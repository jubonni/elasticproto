{
    "meta": {
        "size": 6166,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-boxplot-aggregation.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "search-aggregations-metrics-boxplot-aggregation",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[search-aggregations-metrics-boxplot-aggregation]]\n=== Boxplot aggregation\n++++\n<titleabbrev>Boxplot</titleabbrev>\n++++\n\nA `boxplot` metrics aggregation that computes boxplot of numeric values extracted from the aggregated documents.\nThese values can be generated from specific numeric or <<histogram,histogram fields>> in the documents.\n\nThe `boxplot` aggregation returns essential information for making a {wikipedia}/Box_plot[box plot]: minimum, maximum,\nmedian, first quartile (25th percentile)  and third quartile (75th percentile) values.\n\n==== Syntax\n\nA `boxplot` aggregation looks like this in isolation:\n\n[source,js]\n--------------------------------------------------\n{\n  \"boxplot\": {\n    \"field\": \"load_time\"\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nLet's look at a boxplot representing load time:\n\n[source,console]\n--------------------------------------------------\nGET latency/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"load_time_boxplot\": {\n      \"boxplot\": {\n        \"field\": \"load_time\" <1>\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:latency]\n<1> The field `load_time` must be a numeric field\n\nThe response will look like this:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n\n \"aggregations\": {\n    \"load_time_boxplot\": {\n      \"min\": 0.0,\n      \"max\": 990.0,\n      \"q1\": 167.5,\n      \"q2\": 445.0,\n      \"q3\": 722.5,\n      \"lower\": 0.0,\n      \"upper\": 990.0\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\nIn this case, the lower and upper whisker values are equal to the min and max. In general, these values are the 1.5 *\nIQR range, which is to say the nearest values to `q1 - (1.5 * IQR)` and `q3 + (1.5 * IQR)`. Since this is an approximation, the given values\nmay not actually be observed values from the data, but should be within a reasonable error bound of them. While the Boxplot aggregation\ndoesn't directly return outlier points, you can check if `lower > min` or `upper < max` to see if outliers exist on either side, and then\nquery for them directly.\n\n==== Script\n\nIf you need to create a boxplot for values that aren't indexed exactly you\nshould create a <<runtime,runtime field>> and get the boxplot of that. For\nexample, if your load times are in milliseconds but you want values calculated\nin seconds, use a runtime field to convert them:\n\n[source,console]\n----\nGET latency/_search\n{\n  \"size\": 0,\n  \"runtime_mappings\": {\n    \"load_time.seconds\": {\n      \"type\": \"long\",\n      \"script\": {\n        \"source\": \"emit(doc['load_time'].value / params.timeUnit)\",\n        \"params\": {\n          \"timeUnit\": 1000\n        }\n      }\n    }\n  },\n  \"aggs\": {\n    \"load_time_boxplot\": {\n      \"boxplot\": { \"field\": \"load_time.seconds\" }\n    }\n  }\n}\n----\n// TEST[setup:latency]\n// TEST[s/_search/_search?filter_path=aggregations/]\n// TEST[s/\"timeUnit\": 1000/\"timeUnit\": 10/]\n\n////\n[source,console-result]\n--------------------------------------------------\n{\n \"aggregations\": {\n    \"load_time_boxplot\": {\n      \"min\": 0.0,\n      \"max\": 99.0,\n      \"q1\": 16.75,\n      \"q2\": 44.5,\n      \"q3\": 72.25,\n      \"lower\": 0.0,\n      \"upper\": 99.0\n    }\n  }\n}\n--------------------------------------------------\n////\n\n[[search-aggregations-metrics-boxplot-aggregation-approximation]]\n==== Boxplot values are (usually) approximate\n\nThe algorithm used by the `boxplot` metric is called TDigest (introduced by\nTed Dunning in\nhttps://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf[Computing Accurate Quantiles using T-Digests]).\n\n[WARNING]\n====\nBoxplot as other percentile aggregations are also\n{wikipedia}/Nondeterministic_algorithm[non-deterministic].\nThis means you can get slightly different results using the same data.\n====\n\n[[search-aggregations-metrics-boxplot-aggregation-compression]]\n==== Compression\n\nApproximate algorithms must balance memory utilization with estimation accuracy.\nThis balance can be controlled using a `compression` parameter:\n\n[source,console]\n--------------------------------------------------\nGET latency/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"load_time_boxplot\": {\n      \"boxplot\": {\n        \"field\": \"load_time\",\n        \"compression\": 200    <1>\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:latency]\n\n<1> Compression controls memory usage and approximation error\n\ninclude::percentile-aggregation.asciidoc[tags=t-digest]\n\n==== Execution hint\n\nThe default implementation of TDigest is optimized for performance, scaling to millions or even\nbillions of sample values while maintaining acceptable accuracy levels (close to 1% relative error\nfor millions of samples in some cases). There's an option to use an implementation optimized\nfor accuracy by setting parameter `execution_hint` to value `high_accuracy`:\n\n[source,console]\n--------------------------------------------------\nGET latency/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"load_time_boxplot\": {\n      \"boxplot\": {\n        \"field\": \"load_time\",\n        \"execution_hint\": \"high_accuracy\"    <1>\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:latency]\n\n<1> Optimize TDigest for accuracy, at the expense of performance\n\nThis option can lead to improved accuracy (relative error close to 0.01% for millions of samples in some\ncases) but then percentile queries take 2x-10x longer to complete.\n\n==== Missing value\n\nThe `missing` parameter defines how documents that are missing a value should be treated.\nBy default they will be ignored but it is also possible to treat them as if they\nhad a value.\n\n[source,console]\n--------------------------------------------------\nGET latency/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"grade_boxplot\": {\n      \"boxplot\": {\n        \"field\": \"grade\",\n        \"missing\": 10     <1>\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:latency]\n\n<1> Documents without a value in the `grade` field will fall into the same bucket as documents that have the value `10`.\n"
}