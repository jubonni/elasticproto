{
    "meta": {
        "timestamp": "2024-11-01T03:07:10.127290",
        "size": 52268,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/runtime.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "runtime",
        "version": "8.15"
    },
    "doc": "[[runtime]]\n== Runtime fields\nA _runtime field_ is a field that is evaluated at query time. Runtime fields\nenable you to:\n\n* Add fields to existing documents without reindexing your data\n* Start working with your data without understanding how it\u2019s structured\n* Override the value returned from an indexed field at query time\n* Define fields for a specific use without modifying the underlying schema\n\nYou access runtime fields from the search API like any other field, and {es}\nsees runtime fields no differently. You can define runtime fields in the\n<<runtime-mapping-fields,index mapping>> or in the\n<<runtime-search-request,search request>>. Your choice, which is part of the\ninherent flexibility of runtime fields.\n\nUse the <<search-fields,`fields`>> parameter on the `_search` API to\n<<runtime-retrieving-fields,retrieve the values of runtime fields>>. Runtime\nfields won't display in `_source`, but the `fields` API works for all fields,\neven those that were not sent as part of the original `_source`.\n\nRuntime fields are useful when working with log data\n(see <<runtime-examples,examples>>), especially when you're unsure about the\ndata structure. Your search speed decreases, but your index size is much\nsmaller and you can more quickly process logs without having to index them.\n\n[discrete]\n[[runtime-benefits]]\n=== Benefits\nBecause runtime fields aren't indexed, adding a runtime field doesn't increase\nthe index size. You define runtime fields directly in the index mapping, saving\nstorage costs and increasing ingestion speed. You can more quickly ingest\ndata into the Elastic Stack and access it right away. When you define a runtime\nfield, you can immediately use it in search requests, aggregations, filtering,\nand sorting.\n\nIf you change a runtime field into an indexed field, you don't need to modify\nany queries that refer to the runtime field. Better yet, you can refer to some\nindices where the field is a runtime field, and other indices where the field\nis an indexed field. You have the flexibility to choose which fields to index\nand which ones to keep as runtime fields.\n\nAt its core, the most important benefit of runtime fields is the ability to\nadd fields to documents after you've ingested them. This capability simplifies\nmapping decisions because you don't have to decide how to parse your data up\nfront, and can use runtime fields to amend the mapping at any time. Using\nruntime fields allows for a smaller index and faster ingest time, which\ncombined use less resources and reduce your operating costs.\n\n[discrete]\n[[runtime-incentives]]\n=== Incentives\nRuntime fields can replace many of the ways you can use scripting with the\n`_search` API. How you use a runtime field is impacted by the number of\ndocuments that the included script runs against. For example, if you're using\nthe `fields` parameter on the `_search` API to\n<<runtime-retrieving-fields,retrieve the values of a runtime field>>, the script\nruns only against the top hits just like script fields do.\n\nYou can use <<script-fields,script fields>> to access values in `_source` and\nreturn calculated values based on a script valuation. Runtime fields have the\nsame capabilities, but provide greater flexibility because you can query and\naggregate on runtime fields in a search request. Script fields can only fetch\nvalues.\n\nSimilarly, you could write a <<query-dsl-script-query,script query>> that\nfilters documents in a search request based on a script. Runtime fields provide\na very similar feature that is more flexible. You write a script to create\nfield values and they are available everywhere, such as\n<<search-fields,`fields`>>, <<query-dsl, all queries>>, and\n<<search-aggregations, aggregations>>.\n\nYou can also use scripts to <<script-based-sorting,sort search results>>, but\nthat same script works exactly the same in a runtime field.\n\nIf you move a script from any of these sections in a search request to a\nruntime field that is computing values from the same number of documents, the\nperformance should be about the same. The performance for these features is\nlargely dependent upon the calculations that the included script is running and\nhow many documents the script runs against.\n\n[discrete]\n[[runtime-compromises]]\n=== Compromises\nRuntime fields use less disk space and provide flexibility in how you access\nyour data, but can impact search performance based on the computation defined in\nthe runtime script.\n\nTo balance search performance and flexibility, index fields that you'll\nfrequently search for and filter on, such as a timestamp. {es} automatically\nuses these indexed fields first when running a query, resulting in a fast\nresponse time. You can then use runtime fields to limit the number of fields\nthat {es} needs to calculate values for. Using indexed fields in tandem with\nruntime fields provides flexibility in the data that you index and how you\ndefine queries for other fields.\n\nUse the <<async-search,asynchronous search API>> to run searches that include\nruntime fields. This method of search helps to offset the performance impacts\nof computing values for runtime fields in each document containing that field.\nIf the query can't return the result set synchronously, you'll get results\nasynchronously as they become available.\n\nIMPORTANT: Queries against runtime fields are considered expensive. If\n<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\nto `false`, expensive queries are not allowed and {es} will reject any queries\nagainst runtime fields.\n\n[[runtime-mapping-fields]]\n=== Map a runtime field\nYou map runtime fields by adding a `runtime` section under the mapping\ndefinition and defining\n<<modules-scripting-using,a Painless script>>. This script has access to the\nentire context of a document, including the original `_source` via `params._source`\nand any mapped fields plus their values. At query time, the script runs and\ngenerates values for each scripted field that is required for the query.\n\n.Emitting runtime field values\n****\nWhen defining a Painless script to use with runtime fields, you must include\nthe {painless}/painless-runtime-fields-context.html[`emit` method] to emit\ncalculated values.\n****\n\nFor example, the script in the following request calculates the day of the week\nfrom the `@timestamp` field, which is defined as a `date` type. The script\ncalculates the day of the week based on the value of `timestamp`, and uses\n`emit` to return the calculated value.\n\n[source,console]\n----\nPUT my-index-000001/\n{\n  \"mappings\": {\n    \"runtime\": {\n      \"day_of_week\": {\n        \"type\": \"keyword\",\n        \"script\": {\n          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ENGLISH))\"\n        }\n      }\n    },\n    \"properties\": {\n      \"@timestamp\": {\"type\": \"date\"}\n    }\n  }\n}\n----\n\nThe `runtime` section can be any of these data types:\n\n// tag::runtime-data-types[]\n* `boolean`\n* `composite`\n* `date`\n* `double`\n* `geo_point`\n* `ip`\n* `keyword`\n* `long`\n* <<lookup-runtime-fields, `lookup`>>\n// end::runtime-data-types[]\n\nRuntime fields with a `type` of `date` can accept the\n<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n\nRuntime fields with a `type` of `lookup` allow retrieving fields from\nrelated indices. See <<lookup-runtime-fields, `retrieve fields from related indices`>>.\n\n\nIf <<dynamic-field-mapping,dynamic field mapping>> is enabled where the\n`dynamic` parameter is set to `runtime`, new fields are automatically added to\nthe index mapping as runtime fields:\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic\": \"runtime\",\n    \"properties\": {\n      \"@timestamp\": {\n        \"type\": \"date\"\n      }\n    }\n  }\n}\n----\n\n[[runtime-fields-scriptless]]\n==== Define runtime fields without a script\nRuntime fields typically include a Painless script that manipulates data in some\nway. However, there are instances where you might define a runtime field\n_without_ a script. For example, if you want to retrieve a single field from `_source` without making changes, you don't need a script. You can just create\na runtime field without a script, such as `day_of_week`:\n\n[source,console]\n----\nPUT my-index-000001/\n{\n  \"mappings\": {\n    \"runtime\": {\n      \"day_of_week\": {\n        \"type\": \"keyword\"\n      }\n    }\n  }\n}\n----\n\nWhen no script is provided, {es} implicitly looks in `_source` at query time\nfor a field with the same name as the runtime field, and returns a value if one\nexists. If a field with the same name doesn\u2019t exist, the response doesn't\ninclude any values for that runtime field.\n\nIn most cases, retrieve field values through\n<<doc-values,`doc_values`>> whenever possible. Accessing `doc_values` with a\nruntime field is faster than retrieving values from `_source` because of how\ndata is loaded from Lucene.\n\nHowever, there are cases where retrieving fields from `_source` is necessary.\nFor example, `text` fields do not have `doc_values` available by default, so you\nhave to retrieve values from `_source`. In other instances, you might choose to\ndisable `doc_values` on a specific field.\n\nNOTE: You can alternatively prefix the field you want to retrieve values for\nwith `params._source` (such as `params._source.day_of_week`). For simplicity,\ndefining a runtime field in the mapping definition without a script is the\nrecommended option, whenever possible.\n\n[[runtime-errorhandling]]\n==== Ignoring script errors on runtime fields\n\nScripts can throw errors at runtime, e.g. on accessing missing or invalid values\nin documents or because of performing invalid operations. The `on_script_error`\nparameter can be used to control error behaviour when this happens. Setting this\nparameter to `continue` will have the effect of silently ignoring all errors on\nthis runtime field. The default `fail` value will cause a shard failure which\ngets reported in the search response.\n\n[[runtime-updating-scripts]]\n==== Updating and removing runtime fields\n\nYou can update or remove runtime fields at any time. To replace an existing\nruntime field, add a new runtime field to the mappings with the same name. To\nremove a runtime field from the mappings, set the value of the runtime field to\n`null`:\n\n[source,console]\n----\nPUT my-index-000001/_mapping\n{\n \"runtime\": {\n   \"day_of_week\": null\n }\n}\n----\n//TEST[continued]\n\n.Downstream impacts\n****\nUpdating or removing a runtime field while a dependent query is running can return\ninconsistent results. Each shard might have access to different versions of the\nscript, depending on when the mapping change takes effect.\n\nWARNING: Existing queries or visualizations in {kib} that rely on runtime fields can\nfail if you remove or update the field. For example, a bar chart visualization\nthat uses a runtime field of type `ip` will fail if the type is changed\nto `boolean`, or if the runtime field is removed.\n****\n\n[[runtime-search-request]]\n=== Define runtime fields in a search request\nYou can specify a `runtime_mappings` section in a search request to create\nruntime fields that exist only as part of the query. You specify a script\nas part of the `runtime_mappings` section, just as you would if\n<<runtime-mapping-fields,adding a runtime field to the mappings>>.\n\nDefining a runtime field in a search request uses the same format as defining\na runtime field in the index mapping. Just copy the field definition from\nthe `runtime` in the index mapping to the `runtime_mappings` section of the search request.\n\nThe following search request adds a `day_of_week` field to the\n`runtime_mappings` section. The field values will be calculated dynamically,\nand only within the context of this search request:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"runtime_mappings\": {\n    \"day_of_week\": {\n      \"type\": \"keyword\",\n      \"script\": {\n        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ENGLISH))\"\n      }\n    }\n  },\n  \"aggs\": {\n    \"day_of_week\": {\n      \"terms\": {\n        \"field\": \"day_of_week\"\n      }\n    }\n  }\n}\n----\n//TEST[continued]\n\n[[runtime-search-request-examples]]\n[discrete]\n=== Create runtime fields that use other runtime fields\nYou can even define runtime fields in a search request that return values from\nother runtime fields. For example, let's say you bulk index some sensor data:\n\n[source,console]\n----\nPOST my-index-000001/_bulk?refresh=true\n{\"index\":{}}\n{\"@timestamp\":1516729294000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":\"5.2\",\"start\": \"300\",\"end\":\"8675309\"}}\n{\"index\":{}}\n{\"@timestamp\":1516642894000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":\"5.8\",\"start\": \"300\",\"end\":\"8675309\"}}\n{\"index\":{}}\n{\"@timestamp\":1516556494000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":\"5.1\",\"start\": \"300\",\"end\":\"8675309\"}}\n{\"index\":{}}\n{\"@timestamp\":1516470094000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":\"5.6\",\"start\": \"300\",\"end\":\"8675309\"}}\n{\"index\":{}}\n{\"@timestamp\":1516383694000,\"model_number\":\"HG537PU\",\"measures\":{\"voltage\":\"4.2\",\"start\": \"400\",\"end\":\"8625309\"}}\n{\"index\":{}}\n{\"@timestamp\":1516297294000,\"model_number\":\"HG537PU\",\"measures\":{\"voltage\":\"4.0\",\"start\": \"400\",\"end\":\"8625309\"}}\n----\n\nYou realize after indexing that your numeric data was mapped as type `text`.\nYou want to aggregate on the `measures.start` and `measures.end` fields, but\nthe aggregation fails because you can't aggregate on fields of type `text`.\nRuntime fields to the rescue! You can add runtime fields with the same name as\nyour indexed fields and modify the data type:\n\n[source,console]\n----\nPUT my-index-000001/_mapping\n{\n  \"runtime\": {\n    \"measures.start\": {\n      \"type\": \"long\"\n    },\n    \"measures.end\": {\n      \"type\": \"long\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nRuntime fields take precedence over fields defined with the same name in the\nindex mappings. This flexibility allows you to shadow existing fields and\ncalculate a different value, without modifying the field itself. If you made a\nmistake in your index mapping, you can use runtime fields to calculate values\nthat <<runtime-override-values,override values>> in the mapping during the\nsearch request.\n\nNow, you can easily run an\n<<search-aggregations-metrics-avg-aggregation,average aggregation>> on the\n`measures.start` and `measures.end` fields:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"aggs\": {\n    \"avg_start\": {\n      \"avg\": {\n        \"field\": \"measures.start\"\n      }\n    },\n    \"avg_end\": {\n      \"avg\": {\n        \"field\": \"measures.end\"\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nThe response includes the aggregation results without changing the values for\nthe underlying data:\n\n[source,console-result]\n----\n{\n  \"aggregations\" : {\n    \"avg_start\" : {\n      \"value\" : 333.3333333333333\n    },\n    \"avg_end\" : {\n      \"value\" : 8658642.333333334\n    }\n  }\n}\n----\n\nFurther, you can define a runtime field as part of a search query that\ncalculates a value, and then run a\n<<search-aggregations-metrics-stats-aggregation,stats aggregation>> on that\nfield _in the same query_.\n\nThe `duration` runtime field doesn't exist in the index mapping, but we can\nstill search and aggregate on that field. The following query returns the\ncalculated value for the `duration` field and runs a stats aggregation to\ncompute statistics over numeric values extracted from the aggregated documents.\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"runtime_mappings\": {\n    \"duration\": {\n      \"type\": \"long\",\n      \"script\": {\n        \"source\": \"\"\"\n          emit(doc['measures.end'].value - doc['measures.start'].value);\n          \"\"\"\n      }\n    }\n  },\n  \"aggs\": {\n    \"duration_stats\": {\n      \"stats\": {\n        \"field\": \"duration\"\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nEven though the `duration` runtime field only exists in the context of a search\nquery, you can search and aggregate on that field. This flexibility is\nincredibly powerful, enabling you to rectify mistakes in your index mappings\nand dynamically complete calculations all within a single search request.\n\n[source,console-result]\n----\n{\n  \"aggregations\" : {\n    \"duration_stats\" : {\n      \"count\" : 6,\n      \"min\" : 8624909.0,\n      \"max\" : 8675009.0,\n      \"avg\" : 8658309.0,\n      \"sum\" : 5.1949854E7\n    }\n  }\n}\n----\n\n[[runtime-override-values]]\n=== Override field values at query time\nIf you create a runtime field with the same name as a field that\nalready exists in the mapping, the runtime field shadows the mapped field. At\nquery time, {es} evaluates the runtime field, calculates a value based on the\nscript, and returns the value as part of the query. Because the runtime field\nshadows the mapped field, you can override the value returned in search without\nmodifying the mapped field.\n\nFor example, let's say you indexed the following documents into `my-index-000001`:\n\n[source,console]\n----\nPOST my-index-000001/_bulk?refresh=true\n{\"index\":{}}\n{\"@timestamp\":1516729294000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":5.2}}\n{\"index\":{}}\n{\"@timestamp\":1516642894000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":5.8}}\n{\"index\":{}}\n{\"@timestamp\":1516556494000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":5.1}}\n{\"index\":{}}\n{\"@timestamp\":1516470094000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":5.6}}\n{\"index\":{}}\n{\"@timestamp\":1516383694000,\"model_number\":\"HG537PU\",\"measures\":{\"voltage\":4.2}}\n{\"index\":{}}\n{\"@timestamp\":1516297294000,\"model_number\":\"HG537PU\",\"measures\":{\"voltage\":4.0}}\n----\n\nYou later realize that the `HG537PU` sensors aren't reporting their true\nvoltage. The indexed values are supposed to be 1.7 times higher than\nthe reported values! Instead of reindexing your data, you can define a script in\nthe `runtime_mappings` section of the `_search` request to shadow the `voltage`\nfield and calculate a new value at query time.\n\nIf you search for documents where the model number matches `HG537PU`:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"match\": {\n      \"model_number\": \"HG537PU\"\n    }\n  }\n}\n----\n//TEST[continued]\n\nThe response includes indexed values for documents matching model number\n`HG537PU`:\n\n[source,console-result]\n----\n{\n  ...\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0296195,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"F1BeSXYBg_szTodcYCmk\",\n        \"_score\" : 1.0296195,\n        \"_source\" : {\n          \"@timestamp\" : 1516383694000,\n          \"model_number\" : \"HG537PU\",\n          \"measures\" : {\n            \"voltage\" : 4.2\n          }\n        }\n      },\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"l02aSXYBkpNf6QRDO62Q\",\n        \"_score\" : 1.0296195,\n        \"_source\" : {\n          \"@timestamp\" : 1516297294000,\n          \"model_number\" : \"HG537PU\",\n          \"measures\" : {\n            \"voltage\" : 4.0\n          }\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n// TESTRESPONSE[s/\"_id\" : \"F1BeSXYBg_szTodcYCmk\"/\"_id\": $body.hits.hits.0._id/]\n// TESTRESPONSE[s/\"_id\" : \"l02aSXYBkpNf6QRDO62Q\"/\"_id\": $body.hits.hits.1._id/]\n\nThe following request defines a runtime field where the script evaluates the\n`model_number` field where the value is `HG537PU`. For each match, the script\nmultiplies the value for the `voltage` field by `1.7`.\n\nUsing the <<search-fields,`fields`>> parameter on the `_search` API, you can\nretrieve the value that the script calculates for the `measures.voltage` field\nfor documents matching the search request:\n\n[source,console]\n----\nPOST my-index-000001/_search\n{\n  \"runtime_mappings\": {\n    \"measures.voltage\": {\n      \"type\": \"double\",\n      \"script\": {\n        \"source\":\n        \"\"\"if (doc['model_number.keyword'].value.equals('HG537PU'))\n        {emit(1.7 * params._source['measures']['voltage']);}\n        else{emit(params._source['measures']['voltage']);}\"\"\"\n      }\n    }\n  },\n  \"query\": {\n    \"match\": {\n      \"model_number\": \"HG537PU\"\n    }\n  },\n  \"fields\": [\"measures.voltage\"]\n}\n----\n//TEST[continued]\n\nLooking at the response, the calculated values for `measures.voltage` on each\nresult are `7.14` and `6.8`. That's more like it! The runtime field calculated\nthis value as part of the search request without modifying the mapped value,\nwhich still returns in the response:\n\n[source,console-result]\n----\n{\n  ...\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0296195,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"F1BeSXYBg_szTodcYCmk\",\n        \"_score\" : 1.0296195,\n        \"_source\" : {\n          \"@timestamp\" : 1516383694000,\n          \"model_number\" : \"HG537PU\",\n          \"measures\" : {\n            \"voltage\" : 4.2\n          }\n        },\n        \"fields\" : {\n          \"measures.voltage\" : [\n            7.14\n          ]\n        }\n      },\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"l02aSXYBkpNf6QRDO62Q\",\n        \"_score\" : 1.0296195,\n        \"_source\" : {\n          \"@timestamp\" : 1516297294000,\n          \"model_number\" : \"HG537PU\",\n          \"measures\" : {\n            \"voltage\" : 4.0\n          }\n        },\n        \"fields\" : {\n          \"measures.voltage\" : [\n            6.8\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n// TESTRESPONSE[s/\"_id\" : \"F1BeSXYBg_szTodcYCmk\"/\"_id\": $body.hits.hits.0._id/]\n// TESTRESPONSE[s/\"_id\" : \"l02aSXYBkpNf6QRDO62Q\"/\"_id\": $body.hits.hits.1._id/]\n\n[[runtime-retrieving-fields]]\n=== Retrieve a runtime field\n\nUse the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\nthe values of runtime fields. Runtime fields won't display in `_source`, but\nthe `fields` API works for all fields, even those that were not sent as part of\nthe original `_source`.\n\n[[runtime-define-field-dayofweek]]\n==== Define a runtime field to calculate the day of week\nFor example, the following request adds a runtime field called `day_of_week`.\nThe runtime field includes a script that calculates the day of the week based\non the value of the `@timestamp` field. We'll include `\"dynamic\":\"runtime\"` in\nthe request so that new fields are added to the mapping as runtime fields.\n\n[source,console]\n----\nPUT my-index-000001/\n{\n  \"mappings\": {\n    \"dynamic\": \"runtime\",\n    \"runtime\": {\n      \"day_of_week\": {\n        \"type\": \"keyword\",\n        \"script\": {\n          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ENGLISH))\"\n        }\n      }\n    },\n    \"properties\": {\n      \"@timestamp\": {\"type\": \"date\"}\n    }\n  }\n}\n----\n\n[[runtime-ingest-data]]\n==== Ingest some data\nLet's ingest some sample data, which will result in two indexed fields:\n`@timestamp` and `message`.\n\n[source,console]\n----\nPOST /my-index-000001/_bulk?refresh\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-04-30T14:30:17-05:00\", \"message\" : \"40.135.0.0 - - [2020-04-30T14:30:17-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-04-30T14:30:53-05:00\", \"message\" : \"232.0.0.0 - - [2020-04-30T14:30:53-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-04-30T14:31:12-05:00\", \"message\" : \"26.1.0.0 - - [2020-04-30T14:31:12-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-04-30T14:31:19-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:19-05:00] \\\"GET /french/splash_inet.html HTTP/1.0\\\" 200 3781\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-04-30T14:31:27-05:00\", \"message\" : \"252.0.0.0 - - [2020-04-30T14:31:27-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_brdl.gif HTTP/1.0\\\" 304 0\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_arw.gif HTTP/1.0\\\" 304 0\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-04-30T14:31:32-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:32-05:00] \\\"GET /images/nav_bg_top.gif HTTP/1.0\\\" 200 929\"}\n{ \"index\": {}}\n{ \"@timestamp\": \"2020-04-30T14:31:43-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:43-05:00] \\\"GET /french/images/nav_venue_off.gif HTTP/1.0\\\" 304 0\"}\n----\n//TEST[continued]\n\n[[runtime-search-dayofweek]]\n==== Search for the calculated day of week\nThe following request uses the search API to retrieve the `day_of_week` field\nthat the original request defined as a runtime field in the mapping. The value\nfor this field is calculated dynamically at query time without reindexing\ndocuments or indexing the `day_of_week` field. This flexibility allows you to\nmodify the mapping without changing any field values.\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"fields\": [\n    \"@timestamp\",\n    \"day_of_week\"\n  ],\n  \"_source\": false\n}\n----\n// TEST[continued]\n\nThe previous request returns the `day_of_week` field for all matching documents.\nWe can define another runtime field called `client_ip` that also operates on\nthe `message` field and will further refine the query:\n\n[source,console]\n----\nPUT /my-index-000001/_mapping\n{\n  \"runtime\": {\n    \"client_ip\": {\n      \"type\": \"ip\",\n      \"script\" : {\n      \"source\" : \"String m = doc[\\\"message\\\"].value; int end = m.indexOf(\\\" \\\"); emit(m.substring(0, end));\"\n      }\n    }\n  }\n}\n----\n//TEST[continued]\n\nRun another query, but search for a specific IP address using the `client_ip`\nruntime field:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"size\": 1,\n  \"query\": {\n    \"match\": {\n      \"client_ip\": \"211.11.9.0\"\n    }\n  },\n  \"fields\" : [\"*\"]\n}\n----\n//TEST[continued]\n\nThis time, the response includes only two hits. The value for `day_of_week`\n(`Sunday`) was calculated at query time using the runtime script defined in the\nmapping, and the result includes only documents matching the `211.11.9.0` IP\naddress.\n\n[source,console-result]\n----\n{\n  ...\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"oWs5KXYB-XyJbifr9mrz\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"@timestamp\" : \"2020-06-21T15:00:01-05:00\",\n          \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n        },\n        \"fields\" : {\n          \"@timestamp\" : [\n            \"2020-06-21T20:00:01.000Z\"\n          ],\n          \"client_ip\" : [\n            \"211.11.9.0\"\n          ],\n          \"message\" : [\n            \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n          ],\n          \"day_of_week\" : [\n            \"Sunday\"\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n// TESTRESPONSE[s/\"_id\" : \"oWs5KXYB-XyJbifr9mrz\"/\"_id\": $body.hits.hits.0._id/]\n// TESTRESPONSE[s/\"day_of_week\" : \\[\\n\\s+\"Sunday\"\\n\\s\\]/\"day_of_week\": $body.hits.hits.0.fields.day_of_week/]\n\n\n[[lookup-runtime-fields]]\n==== Retrieve fields from related indices\n\nThe <<search-fields,`fields`>> parameter on the `_search` API can also be used to retrieve fields from\nthe related indices via runtime fields with a type of `lookup`.\n\nNOTE: Fields that are retrieved by runtime fields of type `lookup` can be used\nto enrich the hits in a search response. It's not possible to query or aggregate\non these fields.\n\n[source,console]\n----\nPOST ip_location/_doc?refresh\n{\n  \"ip\": \"192.168.1.1\",\n  \"country\": \"Canada\",\n  \"city\": \"Montreal\"\n}\n\nPUT logs/_doc/1?refresh\n{\n  \"host\": \"192.168.1.1\",\n  \"message\": \"the first message\"\n}\n\nPUT logs/_doc/2?refresh\n{\n  \"host\": \"192.168.1.2\",\n  \"message\": \"the second message\"\n}\n\nPOST logs/_search\n{\n  \"runtime_mappings\": {\n    \"location\": {\n        \"type\": \"lookup\", <1>\n        \"target_index\": \"ip_location\", <2>\n        \"input_field\": \"host\", <3>\n        \"target_field\": \"ip\", <4>\n        \"fetch_fields\": [\"country\", \"city\"] <5>\n    }\n  },\n  \"fields\": [\n    \"host\",\n    \"message\",\n    \"location\"\n  ],\n  \"_source\": false\n}\n----\n<1> Define a runtime field in the main search request with a type of `lookup` that retrieves fields from the target index using the <<query-dsl-term-query, `term`>> queries.\n<2> The target index where the lookup query executes against\n<3> A field on the main index whose values are used as the input values of the lookup term query\n<4> A field on the lookup index which the lookup query searches against\n<5> A list of fields to retrieve from the lookup index. See the <<search-fields, `fields`>> parameter of a search request.\n\nThe above search returns the country and city from the `ip_location` index\nfor each ip address of the returned search hits.\n\n[source,console-result]\n----\n{\n  \"took\": 3,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 2,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.0,\n    \"hits\": [\n      {\n        \"_index\": \"logs\",\n        \"_id\": \"1\",\n        \"_score\": 1.0,\n        \"fields\": {\n          \"host\": [ \"192.168.1.1\" ],\n          \"location\": [\n            {\n              \"city\": [ \"Montreal\" ],\n              \"country\": [ \"Canada\" ]\n            }\n          ],\n          \"message\": [ \"the first message\" ]\n        }\n      },\n      {\n        \"_index\": \"logs\",\n        \"_id\": \"2\",\n        \"_score\": 1.0,\n        \"fields\": {\n          \"host\": [ \"192.168.1.2\" ],\n          \"message\": [ \"the second message\" ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 3/\"took\": $body.took/]\n\nThe response of lookup fields are grouped to maintain the independence\nof each document from the lookup index. The lookup query for each input\nvalue is expected to match at most one document on the lookup index.\nIf the lookup query matches more than one documents, then a random document\nwill be selected.\n\n[[runtime-indexed]]\n=== Index a runtime field\nRuntime fields are defined by the context where they run. For example, you\ncan define runtime fields in the\n<<runtime-search-request,context of a search query>> or within the\n<<runtime-mapping-fields,`runtime` section>> of an index mapping. If you\ndecide to index a runtime field for greater performance, just move the full\nruntime field definition (including the script) to the context of an index\nmapping. {es} automatically uses these indexed fields to drive queries,\nresulting in a fast response time. This capability means you can write a\nscript only once, and apply it to any context that supports runtime fields.\n\nNOTE: Indexing a `composite` runtime field is currently not supported.\n\nYou can then use runtime fields to limit the number of fields that {es} needs\nto calculate values for. Using indexed fields in tandem with runtime fields\nprovides flexibility in the data that you index and how you define queries for\nother fields.\n\nIMPORTANT: After indexing a runtime field, you cannot update the included\nscript. If you need to change the script, create a new field with the updated\nscript.\n\nFor example, let's say your company wants to replace some old pressure\nvalves. The connected sensors are only capable of reporting a fraction of\nthe true readings. Rather than outfit the pressure valves with new sensors,\nyou decide to calculate the values based on reported readings. Based on the\nreported data, you define the following fields in your mapping for\n`my-index-000001`:\n\n[source,console]\n----\nPUT my-index-000001/\n{\n  \"mappings\": {\n    \"properties\": {\n      \"timestamp\": {\n        \"type\": \"date\"\n      },\n      \"temperature\": {\n        \"type\": \"long\"\n      },\n      \"voltage\": {\n        \"type\": \"double\"\n      },\n      \"node\": {\n        \"type\": \"keyword\"\n      }\n    }\n  }\n}\n----\n\nYou then bulk index some sample data from your sensors. This data includes\n`voltage` readings for each sensor:\n\n[source,console]\n----\nPOST my-index-000001/_bulk?refresh=true\n{\"index\":{}}\n{\"timestamp\": 1516729294000, \"temperature\": 200, \"voltage\": 5.2, \"node\": \"a\"}\n{\"index\":{}}\n{\"timestamp\": 1516642894000, \"temperature\": 201, \"voltage\": 5.8, \"node\": \"b\"}\n{\"index\":{}}\n{\"timestamp\": 1516556494000, \"temperature\": 202, \"voltage\": 5.1, \"node\": \"a\"}\n{\"index\":{}}\n{\"timestamp\": 1516470094000, \"temperature\": 198, \"voltage\": 5.6, \"node\": \"b\"}\n{\"index\":{}}\n{\"timestamp\": 1516383694000, \"temperature\": 200, \"voltage\": 4.2, \"node\": \"c\"}\n{\"index\":{}}\n{\"timestamp\": 1516297294000, \"temperature\": 202, \"voltage\": 4.0, \"node\": \"c\"}\n----\n// TEST[continued]\n\nAfter talking to a few site engineers, you realize that the sensors should\nbe reporting at least _double_ the current values, but potentially higher.\nYou create a runtime field named `voltage_corrected` that retrieves the current\nvoltage and multiplies it by `2`:\n\n[source,console]\n----\nPUT my-index-000001/_mapping\n{\n  \"runtime\": {\n    \"voltage_corrected\": {\n      \"type\": \"double\",\n      \"script\": {\n        \"source\": \"\"\"\n        emit(doc['voltage'].value * params['multiplier'])\n        \"\"\",\n        \"params\": {\n          \"multiplier\": 2\n        }\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nYou retrieve the calculated values using the <<search-fields,`fields`>>\nparameter on the `_search` API:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"fields\": [\n    \"voltage_corrected\",\n    \"node\"\n  ],\n  \"size\": 2\n}\n----\n// TEST[continued]\n// TEST[s/_search/_search\\?filter_path=hits/]\n\n//\n////\n[source,console-result]\n----\n{\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 6,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"z4TCrHgBdg9xpPrU6z9k\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : 1516729294000,\n          \"temperature\" : 200,\n          \"voltage\" : 5.2,\n          \"node\" : \"a\"\n        },\n        \"fields\" : {\n          \"voltage_corrected\" : [\n            10.4\n          ],\n          \"node\" : [\n            \"a\"\n          ]\n        }\n      },\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"0ITCrHgBdg9xpPrU6z9k\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : 1516642894000,\n          \"temperature\" : 201,\n          \"voltage\" : 5.8,\n          \"node\" : \"b\"\n        },\n        \"fields\" : {\n          \"voltage_corrected\" : [\n            11.6\n          ],\n          \"node\" : [\n            \"b\"\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"_id\" : \"z4TCrHgBdg9xpPrU6z9k\"/\"_id\": $body.hits.hits.0._id/]\n// TESTRESPONSE[s/\"_id\" : \"0ITCrHgBdg9xpPrU6z9k\"/\"_id\": $body.hits.hits.1._id/]\n////\n//\n\nAfter reviewing the sensor data and running some tests, you determine that the\nmultiplier for reported sensor data should be `4`. To gain greater performance,\nyou decide to index the `voltage_corrected` runtime field with the new\n`multiplier` parameter.\n\nIn a new index named `my-index-000001`, copy the `voltage_corrected` runtime\nfield definition into the mappings of the new index. It's that simple! You can\nadd an optional parameter named `on_script_error` that determines whether to\nreject the entire document if the script throws an error at index time\n(default).\n\n[source,console]\n----\nPUT my-index-000001/\n{\n  \"mappings\": {\n    \"properties\": {\n      \"timestamp\": {\n        \"type\": \"date\"\n      },\n      \"temperature\": {\n        \"type\": \"long\"\n      },\n      \"voltage\": {\n        \"type\": \"double\"\n      },\n      \"node\": {\n        \"type\": \"keyword\"\n      },\n      \"voltage_corrected\": {\n        \"type\": \"double\",\n        \"on_script_error\": \"fail\", <1>\n        \"script\": {\n          \"source\": \"\"\"\n        emit(doc['voltage'].value * params['multiplier'])\n        \"\"\",\n          \"params\": {\n            \"multiplier\": 4\n          }\n        }\n      }\n    }\n  }\n}\n----\n<1> Causes the entire document to be rejected if the script throws an error at\nindex time. Setting the value to `ignore` will register the field in the\ndocument\u2019s `_ignored` metadata field and continue indexing.\n\nBulk index some sample data from your sensors into the `my-index-000001` index:\n\n[source,console]\n----\nPOST my-index-000001/_bulk?refresh=true\n{ \"index\": {}}\n{ \"timestamp\": 1516729294000, \"temperature\": 200, \"voltage\": 5.2, \"node\": \"a\"}\n{ \"index\": {}}\n{ \"timestamp\": 1516642894000, \"temperature\": 201, \"voltage\": 5.8, \"node\": \"b\"}\n{ \"index\": {}}\n{ \"timestamp\": 1516556494000, \"temperature\": 202, \"voltage\": 5.1, \"node\": \"a\"}\n{ \"index\": {}}\n{ \"timestamp\": 1516470094000, \"temperature\": 198, \"voltage\": 5.6, \"node\": \"b\"}\n{ \"index\": {}}\n{ \"timestamp\": 1516383694000, \"temperature\": 200, \"voltage\": 4.2, \"node\": \"c\"}\n{ \"index\": {}}\n{ \"timestamp\": 1516297294000, \"temperature\": 202, \"voltage\": 4.0, \"node\": \"c\"}\n----\n// TEST[continued]\n\nYou can now retrieve calculated values in a search query, and find documents\nbased on precise values. The following range query returns all documents where\nthe calculated `voltage_corrected` is greater than or equal to `16`, but less\nthan or equal to `20`. Again, use the <<search-fields,`fields`>> parameter on\nthe `_search` API to retrieve the fields you want:\n\n[source,console]\n----\nPOST my-index-000001/_search\n{\n  \"query\": {\n    \"range\": {\n      \"voltage_corrected\": {\n        \"gte\": 16,\n        \"lte\": 20,\n        \"boost\": 1.0\n      }\n    }\n  },\n  \"fields\": [\"voltage_corrected\", \"node\"]\n}\n----\n// TEST[continued]\n// TEST[s/_search/_search\\?filter_path=hits/]\n\nThe response includes the `voltage_corrected` field for the documents that\nmatch the range query, based on the calculated value of the included script:\n\n[source,console-result]\n----\n{\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"yoSLrHgBdg9xpPrUZz_P\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : 1516383694000,\n          \"temperature\" : 200,\n          \"voltage\" : 4.2,\n          \"node\" : \"c\"\n        },\n        \"fields\" : {\n          \"voltage_corrected\" : [\n            16.8\n          ],\n          \"node\" : [\n            \"c\"\n          ]\n        }\n      },\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"y4SLrHgBdg9xpPrUZz_P\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : 1516297294000,\n          \"temperature\" : 202,\n          \"voltage\" : 4.0,\n          \"node\" : \"c\"\n        },\n        \"fields\" : {\n          \"voltage_corrected\" : [\n            16.0\n          ],\n          \"node\" : [\n            \"c\"\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"_id\" : \"yoSLrHgBdg9xpPrUZz_P\"/\"_id\": $body.hits.hits.0._id/]\n// TESTRESPONSE[s/\"_id\" : \"y4SLrHgBdg9xpPrUZz_P\"/\"_id\": $body.hits.hits.1._id/]\n\n[[runtime-examples]]\n=== Explore your data with runtime fields\nConsider a large set of log data that you want to extract fields from.\nIndexing the data is time consuming and uses a lot of disk space, and you just\nwant to explore the data structure without committing to a schema up front.\n\nYou know that your log data contains specific fields that you want to extract.\nIn this case, we want to focus on the `@timestamp` and `message` fields. By\nusing runtime fields, you can define scripts to calculate values at search\ntime for these fields.\n\n[[runtime-examples-define-fields]]\n==== Define indexed fields as a starting point\n\nYou can start with a simple example by adding the `@timestamp` and `message`\nfields to the `my-index-000001` mapping as indexed fields. To remain flexible, use\n`wildcard` as the field type for `message`:\n\n[source,console]\n----\nPUT /my-index-000001/\n{\n  \"mappings\": {\n    \"properties\": {\n      \"@timestamp\": {\n        \"format\": \"strict_date_optional_time||epoch_second\",\n        \"type\": \"date\"\n      },\n      \"message\": {\n        \"type\": \"wildcard\"\n      }\n    }\n  }\n}\n----\n\n[[runtime-examples-ingest-data]]\n==== Ingest some data\nAfter mapping the fields you want to retrieve, index a few records from\nyour log data into {es}. The following request uses the <<docs-bulk,bulk API>>\nto index raw log data into `my-index-000001`. Instead of indexing all of your log\ndata, you can use a small sample to experiment with runtime fields.\n\nThe final document is not a valid Apache log format, but we can account for\nthat scenario in our script.\n\n[source,console]\n----\nPOST /my-index-000001/_bulk?refresh\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:30:17-05:00\",\"message\":\"40.135.0.0 - - [30/Apr/2020:14:30:17 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:30:53-05:00\",\"message\":\"232.0.0.0 - - [30/Apr/2020:14:30:53 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:12-05:00\",\"message\":\"26.1.0.0 - - [30/Apr/2020:14:31:12 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:19-05:00\",\"message\":\"247.37.0.0 - - [30/Apr/2020:14:31:19 -0500] \\\"GET /french/splash_inet.html HTTP/1.0\\\" 200 3781\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:22-05:00\",\"message\":\"247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] \\\"GET /images/hm_nbg.jpg HTTP/1.0\\\" 304 0\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:27-05:00\",\"message\":\"252.0.0.0 - - [30/Apr/2020:14:31:27 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:28-05:00\",\"message\":\"not a valid apache log\"}\n----\n// TEST[continued]\n\nAt this point, you can view how {es} stores your raw data.\n\n[source,console]\n----\nGET /my-index-000001\n----\n// TEST[continued]\n\nThe mapping contains two fields: `@timestamp` and `message`.\n\n[source,console-result]\n----\n{\n  \"my-index-000001\" : {\n    \"aliases\" : { },\n    \"mappings\" : {\n      \"properties\" : {\n        \"@timestamp\" : {\n          \"type\" : \"date\",\n          \"format\" : \"strict_date_optional_time||epoch_second\"\n        },\n        \"message\" : {\n          \"type\" : \"wildcard\"\n        },\n        \"timestamp\" : {\n          \"type\" : \"date\"\n        }\n      }\n    },\n    ...\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"settings\": $body.my-index-000001.settings/]\n\n[[runtime-examples-grok]]\n==== Define a runtime field with a grok pattern\nIf you want to retrieve results that include `clientip`, you can add that\nfield as a runtime field in the mapping. The following runtime script defines a\n<<grok,grok pattern>> that extracts structured fields out of a single text\nfield within a document. A grok pattern is like a regular expression that\nsupports aliased expressions that you can reuse.\n\nThe script matches on the `%{COMMONAPACHELOG}` log pattern, which understands\nthe structure of Apache logs. If the pattern matches (`clientip != null`),\nthe script emits the value of the matching IP address. If the pattern doesn't\nmatch, the script just returns the field value without crashing.\n\n[source,console]\n----\nPUT my-index-000001/_mappings\n{\n  \"runtime\": {\n    \"http.client_ip\": {\n      \"type\": \"ip\",\n      \"script\": \"\"\"\n        String clientip=grok('%{COMMONAPACHELOG}').extract(doc[\"message\"].value)?.clientip;\n        if (clientip != null) emit(clientip); <1>\n      \"\"\"\n    }\n  }\n}\n----\n// TEST[continued]\n<1> This condition ensures that the script doesn't crash even if the pattern of\nthe message doesn't match.\n\nAlternatively, you can define the same runtime field but in the context of a\nsearch request. The runtime definition and the script are exactly the same as\nthe one defined previously in the index mapping. Just copy that definition into\nthe search request under the `runtime_mappings` section and include a query\nthat matches on the runtime field. This query returns the same results as if\nyou defined a search query for the `http.clientip` runtime field in your index\nmappings, but only in the context of this specific search:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"runtime_mappings\": {\n    \"http.clientip\": {\n      \"type\": \"ip\",\n      \"script\": \"\"\"\n        String clientip=grok('%{COMMONAPACHELOG}').extract(doc[\"message\"].value)?.clientip;\n        if (clientip != null) emit(clientip);\n      \"\"\"\n    }\n  },\n  \"query\": {\n    \"match\": {\n      \"http.clientip\": \"40.135.0.0\"\n    }\n  },\n  \"fields\" : [\"http.clientip\"]\n}\n----\n// TEST[continued]\n\n[[runtime-examples-grok-composite]]\n==== Define a composite runtime field\nYou can also define a _composite_ runtime field to emit multiple fields from a\nsingle script. You can define a set of typed subfields and emit a map of\nvalues. At search time, each subfield retrieves the value associated with\ntheir name in the map. This means that you only need to specify your grok\npattern one time and can return multiple values:\n\n[source,console]\n----\nPUT my-index-000001/_mappings\n{\n  \"runtime\": {\n    \"http\": {\n      \"type\": \"composite\",\n      \"script\": \"emit(grok(\\\"%{COMMONAPACHELOG}\\\").extract(doc[\\\"message\\\"].value))\",\n      \"fields\": {\n        \"clientip\": {\n          \"type\": \"ip\"\n        },\n        \"verb\": {\n          \"type\": \"keyword\"\n        },\n        \"response\": {\n          \"type\": \"long\"\n        }\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\n[[runtime-examples-grok-ip]]\n===== Search for a specific IP address\nUsing the `http.clientip` runtime field, you can define a simple query to run a\nsearch for a specific IP address and return all related fields.\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"match\": {\n      \"http.clientip\": \"40.135.0.0\"\n    }\n  },\n  \"fields\" : [\"*\"]\n}\n----\n// TEST[continued]\n\nThe API returns the following result. Because `http` is a `composite` runtime\nfield, the response includes each of the sub-fields under `fields`, including\nany associated values that match the query. Without building your data structure\nin advance, you can search and explore your data in meaningful ways to\nexperiment and determine which fields to index.\n\n[source,console-result]\n----\n{\n  ...\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"sRVHBnwBB-qjgFni7h_O\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : \"2020-04-30T14:30:17-05:00\",\n          \"message\" : \"40.135.0.0 - - [30/Apr/2020:14:30:17 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"\n        },\n        \"fields\" : {\n          \"http.verb\" : [\n            \"GET\"\n          ],\n          \"http.clientip\" : [\n            \"40.135.0.0\"\n          ],\n          \"http.response\" : [\n            200\n          ],\n          \"message\" : [\n            \"40.135.0.0 - - [30/Apr/2020:14:30:17 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"\n          ],\n          \"http.client_ip\" : [\n            \"40.135.0.0\"\n          ],\n          \"timestamp\" : [\n            \"2020-04-30T19:30:17.000Z\"\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n// TESTRESPONSE[s/\"_id\" : \"sRVHBnwBB-qjgFni7h_O\"/\"_id\": $body.hits.hits.0._id/]\n\nAlso, remember that `if` statement in the script?\n\n[source,painless]\n----\nif (clientip != null) emit(clientip);\n----\n\nIf the script didn't include this condition, the query would fail on any shard\nthat doesn't match the pattern. By including this condition, the query skips\ndata that doesn't match the grok pattern.\n\n[[runtime-examples-grok-range]]\n===== Search for documents in a specific range\nYou can also run a <<query-dsl-range-query,range query>> that operates on the\n`timestamp` field. The following query returns any documents where the\n`timestamp` is greater than or equal to `2020-04-30T14:31:27-05:00`:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"range\": {\n      \"timestamp\": {\n        \"gte\": \"2020-04-30T14:31:27-05:00\"\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nThe response includes the document where the log format doesn't match, but the\ntimestamp falls within the defined range.\n\n[source,console-result]\n----\n{\n  ...\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"hdEhyncBRSB6iD-PoBqe\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : \"2020-04-30T14:31:27-05:00\",\n          \"message\" : \"252.0.0.0 - - [30/Apr/2020:14:31:27 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"\n        }\n      },\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"htEhyncBRSB6iD-PoBqe\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : \"2020-04-30T14:31:28-05:00\",\n          \"message\" : \"not a valid apache log\"\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n// TESTRESPONSE[s/\"_id\" : \"hdEhyncBRSB6iD-PoBqe\"/\"_id\": $body.hits.hits.0._id/]\n// TESTRESPONSE[s/\"_id\" : \"htEhyncBRSB6iD-PoBqe\"/\"_id\": $body.hits.hits.1._id/]\n\n[[runtime-examples-dissect]]\n==== Define a runtime field with a dissect pattern\nIf you don't need the power of regular expressions, you can use\n<<dissect-processor,dissect patterns>> instead of grok patterns. Dissect\npatterns match on fixed delimiters but are typically faster than grok.\n\nYou can use dissect to achieve the same results as parsing the Apache logs with\na <<runtime-examples-grok,grok pattern>>. Instead of matching on a log\npattern, you include the parts of the string that you want to discard. Paying\nspecial attention to the parts of the string you want to discard will help build\nsuccessful dissect patterns.\n\n[source,console]\n----\nPUT my-index-000001/_mappings\n{\n  \"runtime\": {\n    \"http.client.ip\": {\n      \"type\": \"ip\",\n      \"script\": \"\"\"\n        String clientip=dissect('%{clientip} %{ident} %{auth} [%{@timestamp}] \"%{verb} %{request} HTTP/%{httpversion}\" %{status} %{size}').extract(doc[\"message\"].value)?.clientip;\n        if (clientip != null) emit(clientip);\n      \"\"\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nSimilarly, you can define a dissect pattern to extract the https://developer.mozilla.org/en-US/docs/Web/HTTP/Status[HTTP response code]:\n\n[source,console]\n----\nPUT my-index-000001/_mappings\n{\n  \"runtime\": {\n    \"http.responses\": {\n      \"type\": \"long\",\n      \"script\": \"\"\"\n        String response=dissect('%{clientip} %{ident} %{auth} [%{@timestamp}] \"%{verb} %{request} HTTP/%{httpversion}\" %{response} %{size}').extract(doc[\"message\"].value)?.response;\n        if (response != null) emit(Integer.parseInt(response));\n      \"\"\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nYou can then run a query to retrieve a specific HTTP response using the\n`http.responses` runtime field. Use the `fields` parameter of the `_search`\nrequest to indicate which fields you want to retrieve:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"match\": {\n      \"http.responses\": \"304\"\n    }\n  },\n  \"fields\" : [\"http.client_ip\",\"timestamp\",\"http.verb\"]\n}\n----\n// TEST[continued]\n\nThe response includes a single document where the HTTP response is `304`:\n\n[source,console-result]\n----\n{\n  ...\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"A2qDy3cBWRMvVAuI7F8M\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : \"2020-04-30T14:31:22-05:00\",\n          \"message\" : \"247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] \\\"GET /images/hm_nbg.jpg HTTP/1.0\\\" 304 0\"\n        },\n        \"fields\" : {\n          \"http.verb\" : [\n            \"GET\"\n          ],\n          \"http.client_ip\" : [\n            \"247.37.0.0\"\n          ],\n          \"timestamp\" : [\n            \"2020-04-30T19:31:22.000Z\"\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n// TESTRESPONSE[s/\"_id\" : \"A2qDy3cBWRMvVAuI7F8M\"/\"_id\": $body.hits.hits.0._id/]\n"
}