{
    "meta": {
        "size": 7524,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "nested",
        "version": "8.15"
    },
    "doc": "[[nested]]\n=== Nested field type\n++++\n<titleabbrev>Nested</titleabbrev>\n++++\n\nThe `nested` type is a specialised version of the <<object,`object`>> data type\nthat allows arrays of objects to be indexed in a way that they can be queried\nindependently of each other.\n\nTIP: When ingesting key-value pairs with a large, arbitrary set of keys, you might consider modeling each key-value pair as its own nested document with `key` and `value` fields. Instead, consider using the <<flattened,flattened>> data type, which maps an entire object as a single field and allows for simple searches over its contents.\nNested documents and queries are typically expensive, so using the `flattened` data type for this use case is a better option.\n\nWARNING: Nested fields have incomplete support in Kibana. While they are visible and searchable in Discover, they cannot be used to build visualizations in Lens.\n\n[[nested-arrays-flattening-objects]]\n==== How arrays of objects are flattened\n\nElasticsearch has no concept of inner objects. Therefore, it flattens object\nhierarchies into a simple list of field names and values. For instance, consider the\nfollowing document:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001/_doc/1\n{\n  \"group\" : \"fans\",\n  \"user\" : [ <1>\n    {\n      \"first\" : \"John\",\n      \"last\" :  \"Smith\"\n    },\n    {\n      \"first\" : \"Alice\",\n      \"last\" :  \"White\"\n    }\n  ]\n}\n--------------------------------------------------\n\n<1> The `user` field is dynamically added as a field of type `object`.\n\nThe previous document would be transformed internally into a document that looks more like this:\n\n[source,js]\n--------------------------------------------------\n{\n  \"group\" :        \"fans\",\n  \"user.first\" : [ \"alice\", \"john\" ],\n  \"user.last\" :  [ \"smith\", \"white\" ]\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nThe `user.first` and `user.last` fields are flattened into multi-value fields,\nand the association between `alice` and `white` is lost. This document would\nincorrectly match a query for `alice AND smith`:\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        { \"match\": { \"user.first\": \"Alice\" }},\n        { \"match\": { \"user.last\":  \"Smith\" }}\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[[nested-fields-array-objects]]\n==== Using `nested` fields for arrays of objects\n\nIf you need to index arrays of objects and to maintain the independence of\neach object in the array, use the `nested` data type instead of the\n<<object,`object`>> data type.\n\nInternally, nested objects index each object in\nthe array as a separate hidden document, meaning that each nested object can be\nqueried independently of the others with the <<query-dsl-nested-query,`nested` query>>:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"user\": {\n        \"type\": \"nested\" <1>\n      }\n    }\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  \"group\" : \"fans\",\n  \"user\" : [\n    {\n      \"first\" : \"John\",\n      \"last\" :  \"Smith\"\n    },\n    {\n      \"first\" : \"Alice\",\n      \"last\" :  \"White\"\n    }\n  ]\n}\n\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"nested\": {\n      \"path\": \"user\",\n      \"query\": {\n        \"bool\": {\n          \"must\": [\n            { \"match\": { \"user.first\": \"Alice\" }},\n            { \"match\": { \"user.last\":  \"Smith\" }} <2>\n          ]\n        }\n      }\n    }\n  }\n}\n\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"nested\": {\n      \"path\": \"user\",\n      \"query\": {\n        \"bool\": {\n          \"must\": [\n            { \"match\": { \"user.first\": \"Alice\" }},\n            { \"match\": { \"user.last\":  \"White\" }} <3>\n          ]\n        }\n      },\n      \"inner_hits\": { <4>\n        \"highlight\": {\n          \"fields\": {\n            \"user.first\": {}\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> The `user` field is mapped as type `nested` instead of type `object`.\n<2> This query doesn't match because `Alice` and `Smith` are not in the same nested object.\n<3> This query matches because `Alice` and `White` are in the same nested object.\n<4> `inner_hits` allow us to highlight the matching nested documents.\n\n\n[[nested-accessing-documents]]\n==== Interacting with `nested` documents\nNested documents can be:\n\n* queried with the <<query-dsl-nested-query,`nested`>> query.\n* analyzed with the <<search-aggregations-bucket-nested-aggregation,`nested`>>\n  and <<search-aggregations-bucket-reverse-nested-aggregation, `reverse_nested`>>\n  aggregations.\n* sorted with <<nested-sorting,nested sorting>>.\n* retrieved and highlighted with <<nested-inner-hits,nested inner hits>>.\n\n[IMPORTANT]\n=============================================\n\nBecause nested documents are indexed as separate documents, they can only be\naccessed within the scope of the `nested` query, the\n`nested`/`reverse_nested` aggregations, or <<nested-inner-hits,nested inner hits>>.\n\nFor instance, if a string field within a nested document has\n<<index-options,`index_options`>> set to `offsets` to allow use of the postings\nduring the highlighting, these offsets will not be available during the main highlighting\nphase. Instead, highlighting needs to be performed via\n<<nested-inner-hits,nested inner hits>>. The same consideration applies when loading\nfields during a search through <<docvalue-fields,\n`docvalue_fields`>> or <<stored-fields, `stored_fields`>>.\n\n=============================================\n\n[[nested-params]]\n==== Parameters for `nested` fields\n\nThe following parameters are accepted by `nested` fields:\n\n<<dynamic,`dynamic`>>::\n(Optional, string)\nWhether or not new `properties` should be added dynamically to an existing\nnested object. Accepts `true` (default), `false` and `strict`.\n\n<<properties,`properties`>>::\n(Optional, object)\nThe fields within the nested object, which can be of any\n<<mapping-types,data type>>, including `nested`. New properties\nmay be added to an existing nested object.\n\n`include_in_parent`::\n(Optional, Boolean)\nIf `true`, all fields in the nested object are also added to the parent document\nas standard (flat) fields. Defaults to `false`.\n\n`include_in_root`::\n(Optional, Boolean)\nIf `true`, all fields in the nested object are also added to the root\ndocument as standard (flat) fields. Defaults to `false`.\n\n[discrete]\n=== Limits on `nested` mappings and objects\n\nAs described earlier, each nested object is indexed as a separate Lucene document.\nContinuing with the previous example, if we indexed a single document containing 100 `user` objects,\nthen 101 Lucene documents would be created: one for the parent document, and one for each\nnested object. Because of the expense associated with `nested` mappings, Elasticsearch puts\nsettings in place to guard against performance problems:\n\ninclude::{es-ref-dir}/mapping/mapping-settings-limit.asciidoc[tag=nested-fields-limit]\n\nIn the previous example, the `user` mapping would count as only 1 towards this limit.\n\ninclude::{es-ref-dir}/mapping/mapping-settings-limit.asciidoc[tag=nested-objects-limit]\n\nTo illustrate how this setting works, consider adding another `nested` type called `comments`\nto the previous example mapping. For each document, the combined number of `user` and `comment`\nobjects it contains must be below the limit.\n\nSee <<mapping-limit-settings>> regarding additional settings for preventing mappings explosion.\n"
}