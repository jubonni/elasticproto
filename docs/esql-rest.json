{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.188271",
        "size": 11096,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/esql-rest.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "esql-rest",
        "version": "8.15"
    },
    "doc": "[[esql-rest]]\n=== {esql} REST API\n\n++++\n<titleabbrev>REST API</titleabbrev>\n++++\n\n[discrete]\n[[esql-rest-overview]]\n=== Overview\n\nThe <<esql-query-api,{esql} query API>> accepts an {esql} query string in the\n`query` parameter, runs it, and returns the results. For example:\n\n[source,console]\n----\nPOST /_query?format=txt\n{\n  \"query\": \"FROM library | KEEP author, name, page_count, release_date | SORT page_count DESC | LIMIT 5\"\n}\n----\n// TEST[setup:library]\n\nWhich returns:\n\n[source,text]\n----\n     author      |        name        |  page_count   | release_date\n-----------------+--------------------+---------------+------------------------\nPeter F. Hamilton|Pandora's Star      |768            |2004-03-02T00:00:00.000Z\nVernor Vinge     |A Fire Upon the Deep|613            |1992-06-01T00:00:00.000Z\nFrank Herbert    |Dune                |604            |1965-06-01T00:00:00.000Z\nAlastair Reynolds|Revelation Space    |585            |2000-03-15T00:00:00.000Z\nJames S.A. Corey |Leviathan Wakes     |561            |2011-06-02T00:00:00.000Z\n----\n// TESTRESPONSE[s/\\|/\\\\|/ s/\\+/\\\\+/]\n// TESTRESPONSE[non_json]\n\n[discrete]\n[[esql-kibana-console]]\n==== Kibana Console\n\nIf you are using {kibana-ref}/console-kibana.html[Kibana Console] (which is\nhighly recommended), take advantage of the triple quotes `\"\"\"` when creating the\nquery. This not only automatically escapes double quotes (`\"`) inside the query\nstring but also supports multi-line requests:\n\n// tag::esql-query-api[]\n[source,console]\n----\nPOST /_query?format=txt\n{\n  \"query\": \"\"\"\n    FROM library\n    | KEEP author, name, page_count, release_date\n    | SORT page_count DESC\n    | LIMIT 5\n  \"\"\"\n}\n----\n// TEST[setup:library]\n\n[discrete]\n[[esql-rest-format]]\n==== Response formats\n\n{esql} can return the data in the following human readable and binary formats.\nYou can set the format by specifying the `format` parameter in the URL or by\nsetting the `Accept` or `Content-Type` HTTP header.\n\nNOTE: The URL parameter takes precedence over the HTTP headers. If neither is\nspecified then the response is returned in the same format as the request.\n\n[cols=\"m,4m,8\"]\n\n|===\ns|`format`\ns|HTTP header\ns|Description\n\n3+h| Human readable\n\n|csv\n|text/csv\n|{wikipedia}/Comma-separated_values[Comma-separated values]\n\n|json\n|application/json\n|https://www.json.org/[JSON] (JavaScript Object Notation) human-readable format\n\n|tsv\n|text/tab-separated-values\n|{wikipedia}/Tab-separated_values[Tab-separated values]\n\n|txt\n|text/plain\n|CLI-like representation\n\n|yaml\n|application/yaml\n|{wikipedia}/YAML[YAML] (YAML Ain't Markup Language) human-readable format\n\n3+h| Binary\n\n|cbor\n|application/cbor\n|https://cbor.io/[Concise Binary Object Representation]\n\n|smile\n|application/smile\n|{wikipedia}/Smile_(data_interchange_format)[Smile] binary data format similar\nto CBOR\n\n|arrow\n|application/vnd.apache.arrow.stream\n|**Experimental.** https://arrow.apache.org/[Apache Arrow] dataframes, https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format[IPC streaming format]\n|===\n\nThe `csv` format accepts a formatting URL query attribute, `delimiter`, which\nindicates which character should be used to separate the CSV values. It defaults\nto comma (`,`) and cannot take any of the following values: double quote (`\"`),\ncarriage-return (`\\r`) and new-line (`\\n`). The tab (`\\t`) can also not be used.\nUse the `tsv` format instead.\n\n[discrete]\n[[esql-rest-filtering]]\n==== Filtering using {es} Query DSL\n\nSpecify a Query DSL query in the `filter` parameter to filter the set of\ndocuments that an {esql} query runs on.\n\n[source,console]\n----\nPOST /_query?format=txt\n{\n  \"query\": \"\"\"\n    FROM library\n    | KEEP author, name, page_count, release_date\n    | SORT page_count DESC\n    | LIMIT 5\n  \"\"\",\n  \"filter\": {\n    \"range\": {\n      \"page_count\": {\n        \"gte\": 100,\n        \"lte\": 200\n      }\n    }\n  }\n}\n----\n// TEST[setup:library]\n\nWhich returns:\n\n[source,text]\n--------------------------------------------------\n    author     |                name                |  page_count   | release_date\n---------------+------------------------------------+---------------+------------------------\nDouglas Adams  |The Hitchhiker's Guide to the Galaxy|180            |1979-10-12T00:00:00.000Z\n--------------------------------------------------\n// TESTRESPONSE[s/\\|/\\\\|/ s/\\+/\\\\+/]\n// TESTRESPONSE[non_json]\n\n[discrete]\n[[esql-rest-columnar]]\n==== Columnar results\n\nBy default, {esql} returns results as rows. For example, `FROM` returns each\nindividual document as one row. For the `json`, `yaml`, `cbor` and `smile`\n<<esql-rest-format,formats>>, {esql} can return the results in a columnar\nfashion where one row represents all the values of a certain column in the\nresults.\n\n[source,console]\n----\nPOST /_query?format=json\n{\n  \"query\": \"\"\"\n    FROM library\n    | KEEP author, name, page_count, release_date\n    | SORT page_count DESC\n    | LIMIT 5\n  \"\"\",\n  \"columnar\": true\n}\n----\n// TEST[setup:library]\n\nWhich returns:\n\n[source,console-result]\n----\n{\n  \"took\": 28,\n  \"columns\": [\n    {\"name\": \"author\", \"type\": \"text\"},\n    {\"name\": \"name\", \"type\": \"text\"},\n    {\"name\": \"page_count\", \"type\": \"integer\"},\n    {\"name\": \"release_date\", \"type\": \"date\"}\n  ],\n  \"values\": [\n    [\"Peter F. Hamilton\", \"Vernor Vinge\", \"Frank Herbert\", \"Alastair Reynolds\", \"James S.A. Corey\"],\n    [\"Pandora's Star\", \"A Fire Upon the Deep\", \"Dune\", \"Revelation Space\", \"Leviathan Wakes\"],\n    [768, 613, 604, 585, 561],\n    [\"2004-03-02T00:00:00.000Z\", \"1992-06-01T00:00:00.000Z\", \"1965-06-01T00:00:00.000Z\", \"2000-03-15T00:00:00.000Z\", \"2011-06-02T00:00:00.000Z\"]\n  ]\n}\n----\n// TESTRESPONSE[s/\"took\": 28/\"took\": \"$body.took\"/]\n\n[discrete]\n[[esql-locale-param]]\n==== Returning localized results\n\nUse the `locale` parameter in the request body to return results (especially dates) formatted per the conventions of the locale.\nIf `locale` is not specified, defaults to `en-US` (English).\nRefer to https://www.oracle.com/java/technologies/javase/jdk17-suported-locales.html[JDK Supported Locales].\n\nSyntax: the `locale` parameter accepts language tags in the (case-insensitive) format `xy` and `xy-XY`.\n\nFor example, to return a month name in French:\n\n[source,console]\n----\nPOST /_query\n{\n  \"locale\": \"fr-FR\",\n  \"query\": \"\"\"\n          ROW birth_date_string = \"2023-01-15T00:00:00.000Z\"\n          | EVAL birth_date = date_parse(birth_date_string)\n          | EVAL month_of_birth = DATE_FORMAT(\"MMMM\",birth_date)\n          | LIMIT 5\n   \"\"\"\n}\n----\n// TEST[setup:library]\n\n[discrete]\n[[esql-rest-params]]\n==== Passing parameters to a query\n\nValues, for example for a condition, can be passed to a query \"inline\", by\nintegrating the value in the query string itself:\n\n[source,console]\n----\nPOST /_query\n{\n  \"query\": \"\"\"\n    FROM library\n    | EVAL year = DATE_EXTRACT(\"year\", release_date)\n    | WHERE page_count > 300 AND author == \"Frank Herbert\"\n    | STATS count = COUNT(*) by year\n    | WHERE count > 0\n    | LIMIT 5\n  \"\"\"\n}\n----\n// TEST[setup:library]\n\nTo avoid any attempts of hacking or code injection, extract the values in a\nseparate list of parameters. Use question mark placeholders (`?`) in the query\nstring for each of the parameters:\n\n[source,console]\n----\nPOST /_query\n{\n  \"query\": \"\"\"\n    FROM library\n    | EVAL year = DATE_EXTRACT(\"year\", release_date)\n    | WHERE page_count > ? AND author == ?\n    | STATS count = COUNT(*) by year\n    | WHERE count > ?\n    | LIMIT 5\n  \"\"\",\n  \"params\": [300, \"Frank Herbert\", 0]\n}\n----\n// TEST[setup:library]\n\nThe parameters can be named parameters or positional parameters.\n\nNamed parameters use question mark placeholders (`?`) followed by a string.\n\n[source,console]\n----\nPOST /_query\n{\n  \"query\": \"\"\"\n    FROM library\n    | EVAL year = DATE_EXTRACT(\"year\", release_date)\n    | WHERE page_count > ?page_count AND author == ?author\n    | STATS count = COUNT(*) by year\n    | WHERE count > ?count\n    | LIMIT 5\n  \"\"\",\n  \"params\": [{\"page_count\" : 300}, {\"author\" : \"Frank Herbert\"}, {\"count\" : 0}]\n}\n----\n// TEST[setup:library]\n\nPositional parameters use question mark placeholders (`?`) followed by an\ninteger.\n\n[source,console]\n----\nPOST /_query\n{\n  \"query\": \"\"\"\n    FROM library\n    | EVAL year = DATE_EXTRACT(\"year\", release_date)\n    | WHERE page_count > ?1 AND author == ?2\n    | STATS count = COUNT(*) by year\n    | WHERE count > ?3\n    | LIMIT 5\n  \"\"\",\n  \"params\": [300, \"Frank Herbert\", 0]\n}\n----\n// TEST[setup:library]\n\n[discrete]\n[[esql-rest-async-query]]\n==== Running an async {esql} query\n\nThe <<esql-async-query-api,{esql} async query API>> lets you asynchronously\nexecute a query request, monitor its progress, and retrieve results when\nthey become available.\n\nExecuting an {esql} query is commonly quite fast, however queries across\nlarge data sets or frozen data can take some time. To avoid long waits,\nrun an async {esql} query.\n\nQueries initiated by the async query API may return results or not. The\n`wait_for_completion_timeout` property determines how long to wait for\nthe results. If the results are not available by this time, a\n<<esql-async-query-api-response-body-query-id,query id>> is returned which\ncan be later used to retrieve the results. For example:\n\n[source,console]\n----\nPOST /_query/async\n{\n  \"query\": \"\"\"\n    FROM library\n    | EVAL year = DATE_TRUNC(1 YEARS, release_date)\n    | STATS MAX(page_count) BY year\n    | SORT year\n    | LIMIT 5\n  \"\"\",\n  \"wait_for_completion_timeout\": \"2s\"\n}\n----\n// TEST[setup:library]\n// TEST[skip:awaitsfix https://github.com/elastic/elasticsearch/issues/104013]\n\nIf the results are not available within the given timeout period, 2\nseconds in this case, no results are returned but rather a response that\nincludes:\n\n* A query ID\n* An `is_running` value of _true_, indicating the query is ongoing\n\nThe query continues to run in the background without blocking other\nrequests.\n\n[source,console-result]\n----\n{\n  \"id\": \"FmNJRUZ1YWZCU3dHY1BIOUhaenVSRkEaaXFlZ3h4c1RTWFNocDdnY2FSaERnUTozNDE=\",\n  \"is_running\": true\n}\n----\n// TEST[skip: no access to query ID - may return response values]\n\nTo check the progress of an async query, use the <<esql-async-query-get-api,\n{esql} async query get API>> with the query ID. Specify how long you'd like\nto wait for complete results in the `wait_for_completion_timeout` parameter.\n\n[source,console]\n----\nGET /_query/async/FmNJRUZ1YWZCU3dHY1BIOUhaenVSRkEaaXFlZ3h4c1RTWFNocDdnY2FSaERnUTozNDE=?wait_for_completion_timeout=30s\n----\n// TEST[skip: no access to query ID - may return response values]\n\nIf the response's `is_running` value is `false`, the query has finished\nand the results are returned, along with the `took` time for the query.\n\n[source,console-result]\n----\n{\n  \"is_running\": false,\n  \"took\": 48,\n  \"columns\": ...\n}\n----\n// TEST[skip: no access to query ID - may return response values]\n\nUse the <<esql-async-query-delete-api, {esql} async query delete API>> to\ndelete an async query before the `keep_alive` period ends. If the query\nis still running, {es} cancels it.\n\n[source,console]\n----\nDELETE /_query/async/FmdMX2pIang3UWhLRU5QS0lqdlppYncaMUpYQ05oSkpTc3kwZ21EdC1tbFJXQToxOTI=\n----\n// TEST[skip: no access to query ID]\n\n"
}