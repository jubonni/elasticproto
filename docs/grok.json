{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.305067",
        "size": 8765,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/grok.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "grok",
        "version": "8.15"
    },
    "doc": "[[grok]]\n=== Grokking grok\nGrok is a regular expression dialect that supports reusable aliased expressions. Grok works really well with syslog logs, Apache and other webserver\nlogs, mysql logs, and generally any log format that is written for humans and\nnot computer consumption.\n\nGrok sits on top of the https://github.com/kkos/oniguruma/blob/master/doc/RE[Oniguruma] regular expression library, so any regular expressions are\nvalid in grok. Grok uses this regular expression language to allow naming\nexisting patterns and combining them into more complex patterns that match your\nfields.\n\n[[grok-syntax]]\n==== Grok patterns\nThe {stack} ships with numerous https://github.com/elastic/elasticsearch/blob/master/libs/grok/src/main/resources/patterns/legacy/grok-patterns[predefined grok patterns] that simplify working with grok. The syntax for reusing grok patterns\ntakes one of the following forms:\n\n[%autowidth]\n|===\n|`%{SYNTAX}` | `%{SYNTAX:ID}` |`%{SYNTAX:ID:TYPE}`\n|===\n\n`SYNTAX`::\nThe name of the pattern that will match your text. For example, `NUMBER` and\n`IP` are both patterns that are provided within the default patterns set. The\n`NUMBER` pattern matches data like `3.44`, and the `IP` pattern matches data\nlike `55.3.244.1`. \n\n`ID`::\nThe identifier you give to the piece of text being matched. For  example, `3.44`\ncould be the duration of an event, so you might call it `duration`. The string\n`55.3.244.1` might identify the `client` making a request.\n\n`TYPE`::\nThe data type you want to cast your named field. `int`, `long`, `double`,\n`float` and `boolean` are supported types.\n\nFor example, let's say you have message data that looks like this:\n\n[source,txt]\n----\n3.44 55.3.244.1\n----\n\nThe first value is a number, followed by what appears to be an IP address. You\ncan match this text by using the following grok expression:\n\n[source,txt]\n----\n%{NUMBER:duration} %{IP:client}\n----\n\n[[grok-ecs]]\n==== Migrating to Elastic Common Schema (ECS)\n\nTo ease migration to the {ecs-ref}[Elastic Common Schema (ECS)], a new set of \nECS-compliant patterns is available in addition to the existing patterns. The\nnew ECS pattern definitions capture event field names that are compliant with\nthe schema.\n\nThe ECS pattern set has all of the pattern definitions from the legacy set, and\nis a drop-in replacement. Use the \n{logstash-ref}/plugins-filters-grok.html#plugins-filters-grok-ecs_compatibility[`ecs-compatability`]\nsetting to switch modes. \n\nNew features and enhancements will be added to the ECS-compliant files. The\nlegacy patterns may still receive bug fixes which are backwards compatible.\n\n[[grok-patterns]]\n==== Use grok patterns in Painless scripts\nYou can incorporate predefined grok patterns into Painless scripts to extract\ndata. To test your script, use either the {painless}/painless-execute-api.html#painless-execute-runtime-field-context[field contexts] of the Painless\nexecute API or create a runtime field that includes the script. Runtime fields\noffer greater flexibility and accept multiple documents, but the Painless\nexecute API is a great option if you don't have write access on a cluster\nwhere you're testing a script.\n\nTIP: If you need help building grok patterns to match your data, use the \n{kibana-ref}/xpack-grokdebugger.html[Grok Debugger] tool in {kib}.\n\nFor example, if you're working with Apache log data, you can use the\n`%{COMMONAPACHELOG}` syntax, which understands the structure of Apache logs. A\nsample document might look like this:\n\n// Note to contributors that the line break in the following example is\n// intentional to promote better readability in the output\n[source,js]\n----\n\"timestamp\":\"2020-04-30T14:30:17-05:00\",\"message\":\"40.135.0.0 - - \n[30/Apr/2020:14:30:17 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"\n----\n// NOTCONSOLE\n\nTo extract the IP address from the `message` field, you can write a Painless\nscript that incorporates the `%{COMMONAPACHELOG}` syntax. You can test this\nscript using the {painless}/painless-execute-api.html#painless-runtime-ip[`ip` field context] of the Painless execute API, but let's use a runtime field\ninstead.\n\nBased on the sample document, index the `@timestamp` and `message` fields. To \nremain flexible, use `wildcard` as the field type for `message`:\n\n[source,console]\n----\nPUT /my-index/\n{\n  \"mappings\": {\n    \"properties\": {\n      \"@timestamp\": {\n        \"format\": \"strict_date_optional_time||epoch_second\",\n        \"type\": \"date\"\n      },\n      \"message\": {\n        \"type\": \"wildcard\"\n      }\n    }\n  }\n}\n----\n\nNext, use the <<docs-bulk,bulk API>> to index some log data into\n`my-index`.\n\n[source,console]\n----\nPOST /my-index/_bulk?refresh\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:30:17-05:00\",\"message\":\"40.135.0.0 - - [30/Apr/2020:14:30:17 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:30:53-05:00\",\"message\":\"232.0.0.0 - - [30/Apr/2020:14:30:53 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:12-05:00\",\"message\":\"26.1.0.0 - - [30/Apr/2020:14:31:12 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:19-05:00\",\"message\":\"247.37.0.0 - - [30/Apr/2020:14:31:19 -0500] \\\"GET /french/splash_inet.html HTTP/1.0\\\" 200 3781\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:22-05:00\",\"message\":\"247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] \\\"GET /images/hm_nbg.jpg HTTP/1.0\\\" 304 0\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:27-05:00\",\"message\":\"252.0.0.0 - - [30/Apr/2020:14:31:27 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:28-05:00\",\"message\":\"not a valid apache log\"}\n----\n// TEST[continued]\n\n[[grok-patterns-runtime]]\n==== Incorporate grok patterns and scripts in runtime fields\nNow you can define a runtime field in the mappings that includes your Painless\nscript and grok pattern. If the pattern matches, the script emits the value of\nthe matching IP address. If the pattern doesn't match (`clientip != null`), the\nscript just returns the field value without crashing.\n\n[source,console]\n----\nPUT my-index/_mappings\n{\n  \"runtime\": {\n    \"http.clientip\": {\n      \"type\": \"ip\",\n      \"script\": \"\"\"\n        String clientip=grok('%{COMMONAPACHELOG}').extract(doc[\"message\"].value)?.clientip;\n        if (clientip != null) emit(clientip);\n      \"\"\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nAlternatively, you can define the same runtime field but in the context of a\nsearch request. The runtime definition and the script are exactly the same as\nthe one defined previously in the index mapping. Just copy that definition into\nthe search request under the `runtime_mappings` section and include a query\nthat matches on the runtime field. This query returns the same results as if\nyou <<grok-pattern-results,defined a search query>> for the `http.clientip`\nruntime field in your index mappings, but only in the context of this specific\nsearch:\n\n[source,console]\n----\nGET my-index/_search\n{\n  \"runtime_mappings\": {\n    \"http.clientip\": {\n      \"type\": \"ip\",\n      \"script\": \"\"\"\n        String clientip=grok('%{COMMONAPACHELOG}').extract(doc[\"message\"].value)?.clientip;\n        if (clientip != null) emit(clientip);\n      \"\"\"\n    }\n  },\n  \"query\": {\n    \"match\": {\n      \"http.clientip\": \"40.135.0.0\"\n    }\n  },\n  \"fields\" : [\"http.clientip\"]\n}\n----\n// TEST[continued]\n\n[[grok-pattern-results]]\n==== Return calculated results\nUsing the `http.clientip` runtime field, you can define a simple query to run a\nsearch for a specific IP address and return all related fields. The <<search-fields,`fields`>> parameter on the `_search` API works for all fields,\neven those that weren't sent as part of the original `_source`:\n\n[source,console]\n----\nGET my-index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"http.clientip\": \"40.135.0.0\"\n    }\n  },\n  \"fields\" : [\"http.clientip\"]\n}\n----\n// TEST[continued]\n// TEST[s/_search/_search\\?filter_path=hits/]\n\nThe response includes the specific IP address indicated in your search query.\nThe grok pattern within the Painless script extracted this value from the\n`message` field at runtime. \n\n[source,console-result]\n----\n{\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index\",\n        \"_id\" : \"1iN2a3kBw4xTzEDqyYE0\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : \"2020-04-30T14:30:17-05:00\",\n          \"message\" : \"40.135.0.0 - - [30/Apr/2020:14:30:17 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"\n        },\n        \"fields\" : {\n          \"http.clientip\" : [\n            \"40.135.0.0\"\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"_id\" : \"1iN2a3kBw4xTzEDqyYE0\"/\"_id\": $body.hits.hits.0._id/]\n"
}