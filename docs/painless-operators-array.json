{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.857071",
        "size": 9369,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-operators-array.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-operators-array",
        "version": "8.15"
    },
    "doc": "[[painless-operators-array]]\n=== Operators: Array\n\n[[array-initialization-operator]]\n==== Array Initialization\n\nUse the `array initialization operator '[] {}'` to allocate a single-dimensional\n<<array-type, array type>> instance to the heap with a set of pre-defined\nelements. Each value used to initialize an element in the array type instance is\ncast to the specified element type value upon insertion. The order of specified\nvalues is maintained.\n\n*Errors*\n\n* If a value is not castable to the specified type value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\narray_initialization: 'new' TYPE '[' ']' '{' expression_list '}'\n                    | 'new' TYPE '[' ']' '{' '}';\nexpression_list: expression (',' expression);\n----\n\n*Example:*\n\n* Array initialization with static values.\n+\n[source,Painless]\n----\nint[] x = new int[] {1, 2, 3}; <1>\n----\n+\n<1> declare `int[] x`;\n    allocate `1-d int array` instance with `length [3]`\n            -> `1-d int array reference`;\n    store `int 1` to `index [0]` of `1-d int array reference`;\n    store `int 2` to `index [1]` of `1-d int array reference`;\n    store `int 3` to `index [2]` of `1-d int array reference`;\n    store `1-d int array reference` to `x`;\n+\n* Array initialization with non-static values.\n+\n[source,Painless]\n----\nint i = 1;      <1>\nlong l = 2L;    <2>\nfloat f = 3.0F; <3>\ndouble d = 4.0; <4>\nString s = \"5\"; <5>\ndef array = new def[] {i, l, f*d, s}; <6>\n----\n+\n<1> declare `int i`;\n    store `int 1` to `i`\n<2> declare `long l`;\n    store `long 2` to `l`\n<3> declare `float f`;\n    store `float 3.0` to `f`\n<4> declare `double d`;\n    store `double 4.0` to `d`\n<5> declare `String s`;\n    store `String \"5\"` to `s`\n<6> declare `def array`;\n    allocate `1-d def array` instance with `length [4]`\n            -> `1-d def array reference`;\n    load from `i` -> `int 1`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `index [0]` of `1-d def array reference`;\n    load from `l` -> `long 2`;\n    implicit cast `long 2` to `def` -> `def`;\n    store `def` to `index [1]` of `1-d def array reference`;\n    load from `f` -> `float 3.0`;\n    load from `d` -> `double 4.0`;\n    promote `float 3.0` and `double 4.0`: result `double`;\n    implicit cast `float 3.0` to `double 3.0` -> `double 3.0`;\n    multiply `double 3.0` and `double 4.0` -> `double 12.0`;\n    implicit cast `double 12.0` to `def` -> `def`;\n    store `def` to `index [2]` of `1-d def array reference`;\n    load from `s` -> `String \"5\"`;\n    implicit cast `String \"5\"` to `def` -> `def`;\n    store `def` to `index [3]` of `1-d def array reference`;\n    implicit cast `1-d int array reference` to `def` -> `def`;\n    store `def` to `array`\n\n[[array-access-operator]]\n==== Array Access\n\nUse the `array access operator '[]'` to store a value to or load a value from\nan <<array-type, array type>> value. Each element of an array type value is\naccessed with an `int` type value to specify the index to store/load. The range\nof elements within an array that are accessible is `[0, size)` where size is the\nnumber of elements specified at the time of allocation. Use a negative `int`\ntype value as an index to access an element in reverse from the end of an array\ntype value within a range of `[-size, -1]`.\n\n*Errors*\n\n* If a value other than an `int` type value or a value that is castable to an\n  `int` type value is provided as an index.\n* If an element is accessed outside of the valid ranges.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nbrace_access: '[' expression ']'\n----\n\n*Examples*\n\n* Array access with a single-dimensional array.\n+\n[source,Painless]\n----\nint[] x = new int[2]; <1>\nx[0] = 2;             <2>\nx[1] = 5;             <3>\nint y = x[0] + x[1];  <4>\nint z = 1;            <5>\nint i = x[z];         <6>\n----\n+\n<1> declare `int[] x`;\n    allocate `1-d int array` instance with `length [2]`\n            -> `1-d int array reference`;\n    store `1-d int array reference` to `x`\n<2> load from `x` -> `1-d int array reference`;\n    store `int 2` to `index [0]` of `1-d int array reference`;\n<3> load from `x` -> `1-d int array reference`;\n    store `int 5` to `index [1]` of `1-d int array reference`;\n<4> declare `int y`;\n    load from `x` -> `1-d int array reference`;\n    load from `index [0]` of `1-d int array reference` -> `int 2`;\n    load from `x` -> `1-d int array reference`;\n    load from `index [1]` of `1-d int array reference` -> `int 5`;\n    add `int 2` and `int 5` -> `int 7`;\n    store `int 7` to `y`\n<5> declare `int z`;\n    store `int 1` to `z`;\n<6> declare `int i`;\n    load from `x` -> `1-d int array reference`;\n    load from `z` -> `int 1`;\n    load from `index [1]` of `1-d int array reference` -> `int 5`;\n    store `int 5` to `i`;\n+\n* Array access with the `def` type.\n+\n[source,Painless]\n----\ndef d = new int[2];  <1>\nd[0] = 2;            <2>\nd[1] = 5;            <3>\ndef x = d[0] + d[1]; <4>\ndef y = 1;           <5>\ndef z = d[y];        <6>\n----\n+\n<1> declare `def d`;\n    allocate `1-d int array` instance with `length [2]`\n            -> `1-d int array reference`;\n    implicit cast `1-d int array reference` to `def` -> `def`;\n    store `def` to `d`\n<2> load from `d` -> `def`\n    implicit cast `def` to `1-d int array reference`\n            -> `1-d int array reference`;\n    store `int 2` to `index [0]` of `1-d int array reference`;\n<3> load from `d` -> `def`\n    implicit cast `def` to `1-d int array reference`\n            -> `1-d int array reference`;\n    store `int 5` to `index [1]` of `1-d int array reference`;\n<4> declare `int x`;\n    load from `d` -> `def`\n    implicit cast `def` to `1-d int array reference`\n            -> `1-d int array reference`;\n    load from `index [0]` of `1-d int array reference` -> `int 2`;\n    load from `d` -> `def`\n    implicit cast `def` to `1-d int array reference`\n            -> `1-d int array reference`;\n    load from `index [1]` of `1-d int array reference` -> `int 5`;\n    add `int 2` and `int 5` -> `int 7`;\n    implicit cast `int 7` to `def` -> `def`;\n    store `def` to `x`\n<5> declare `def y`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `y`;\n<6> declare `int i`;\n    load from `d` -> `def`\n    implicit cast `def` to `1-d int array reference`\n            -> `1-d int array reference`;\n    load from `y` -> `def`;\n    implicit cast `def` to `int 1` -> `int 1`;\n    load from `index [1]` of `1-d int array reference` -> `int 5`;\n    implicit cast `int 5` to `def`;\n    store `def` to `z`;\n+\n* Array access with a multi-dimensional array.\n+\n[source,Painless]\n----\nint[][][] ia3 = new int[2][3][4]; <1>\nia3[1][2][3] = 99;                <2>\nint i = ia3[1][2][3];             <3>\n----\n+\n<1> declare `int[][][] ia`;\n    allocate `3-d int array` instance with length `[2, 3, 4]`\n            -> `3-d int array reference`;\n    store `3-d int array reference` to `ia3`\n<2> load from `ia3` -> `3-d int array reference`;\n    store `int 99` to `index [1, 2, 3]` of `3-d int array reference`\n<3> declare `int i`;\n    load from `ia3` -> `3-d int array reference`;\n    load from `index [1, 2, 3]` of `3-d int array reference` -> `int 99`;\n    store `int 99` to `i`\n\n[[array-length-operator]]\n==== Array Length\n\nAn array type value contains a read-only member field named `length`. The\n`length` field stores the size of the array as an `int` type value where size is\nthe number of elements specified at the time of allocation. Use the\n<<field-access-operator, field access operator>> to load the field `length`\nfrom an array type value.\n\n*Examples*\n\n* Access the `length` field.\n+\n[source,Painless]\n----\nint[] x = new int[10]; <1>\nint l = x.length;      <2>\n----\n<1> declare `int[] x`;\n    allocate `1-d int array` instance with `length [2]`\n            -> `1-d int array reference`;\n    store `1-d int array reference` to `x`\n<2> declare `int l`;\n    load `x` -> `1-d int array reference`;\n    load `length` from `1-d int array reference` -> `int 10`;\n    store `int 10` to `l`;\n\n[[new-array-operator]]\n==== New Array\n\nUse the `new array operator 'new []'` to allocate an array type instance to\nthe heap. Specify the element type following the `new` token. Specify each\ndimension with the `[` and `]` tokens following the element type name. The size\nof each dimension is specified by an `int` type value in between each set of `[`\nand `]` tokens.\n\n*Errors*\n\n* If a value other than an `int` type value or a value that is castable to an\n  `int` type value is specified for a dimension's size.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nnew_array: 'new' TYPE ('[' expression ']')+;\n----\n\n*Examples*\n\n* Allocation of different array types.\n+\n[source,Painless]\n----\nint[] x = new int[5];    <1>\nx = new int[10];         <2>\nint y = 2;               <3>\ndef z = new def[y][y*2]; <4>\n----\n+\n<1> declare `int[] x`;\n    allocate `1-d int array` instance with `length [5]`\n            -> `1-d int array reference`;\n    store `1-d int array reference` to `x`\n<2> allocate `1-d int array` instance with `length [10]`\n            -> `1-d int array reference`;\n    store `1-d int array reference` to `x`\n<3> declare `int y`;\n    store `int 2` to `y`;\n<4> declare `def z`;\n    load from `y` -> `int 2 @0`;\n    load from `y` -> `int 2 @1`;\n    multiply `int 2 @1` by `int 2 @2` -> `int 4`;\n    allocate `2-d int array` instance with length `[2, 4]`\n            -> `2-d int array reference`;\n    implicit cast `2-d int array reference` to `def` -> `def`;\n    store `def` to `z`;\n"
}