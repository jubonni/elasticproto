{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.813594",
        "size": 13631,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-intervals-query.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "query-dsl-intervals-query",
        "version": "8.15"
    },
    "doc": "[[query-dsl-intervals-query]]\n=== Intervals query\n++++\n<titleabbrev>Intervals</titleabbrev>\n++++\n\nReturns documents based on the order and proximity of matching terms.\n\nThe `intervals` query uses *matching rules*, constructed from a small set of\ndefinitions. These rules are then applied to terms from a specified `field`.\n\nThe definitions produce sequences of minimal intervals that span terms in a\nbody of text. These intervals can be further combined and filtered by\nparent sources.\n\n\n[[intervals-query-ex-request]]\n==== Example request\n\nThe following `intervals` search returns documents containing `my\nfavorite food` without any gap, followed by `hot water` or `cold porridge` in the\n`my_text` field.\n\nThis search would match a `my_text` value of `my favorite food is cold\nporridge` but not `when it's cold my favorite food is porridge`.\n\n[source,console]\n--------------------------------------------------\nPOST _search\n{\n  \"query\": {\n    \"intervals\" : {\n      \"my_text\" : {\n        \"all_of\" : {\n          \"ordered\" : true,\n          \"intervals\" : [\n            {\n              \"match\" : {\n                \"query\" : \"my favorite food\",\n                \"max_gaps\" : 0,\n                \"ordered\" : true\n              }\n            },\n            {\n              \"any_of\" : {\n                \"intervals\" : [\n                  { \"match\" : { \"query\" : \"hot water\" } },\n                  { \"match\" : { \"query\" : \"cold porridge\" } }\n                ]\n              }\n            }\n          ]\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n[[intervals-top-level-params]]\n==== Top-level parameters for `intervals`\n[[intervals-rules]]\n`<field>`::\n+\n--\n(Required, rule object) Field you wish to search.\n\nThe value of this parameter is a rule object used to match documents\nbased on matching terms, order, and proximity.\n\nValid rules include:\n\n* <<intervals-match,`match`>>\n* <<intervals-prefix,`prefix`>>\n* <<intervals-wildcard,`wildcard`>>\n* <<intervals-regexp,`regexp`>>\n* <<intervals-fuzzy,`fuzzy`>>\n* <<intervals-range,`range`>>\n* <<intervals-all_of,`all_of`>>\n* <<intervals-any_of,`any_of`>>\n--\n\n[[intervals-match]]\n==== `match` rule parameters\n\nThe `match` rule matches analyzed text.\n\n`query`::\n(Required, string) Text you wish to find in the provided `<field>`.\n\n`max_gaps`::\n+\n--\n(Optional, integer) Maximum number of positions between the matching terms.\nTerms further apart than this are not considered matches. Defaults to\n`-1`.\n\nIf unspecified or set to `-1`, there is no width restriction on the match. If\nset to `0`, the terms must appear next to each other.\n--\n\n`ordered`::\n(Optional, Boolean)\nIf `true`, matching terms must appear in their specified order. Defaults to\n`false`.\n\n`analyzer`::\n(Optional, string) <<analysis, analyzer>> used to analyze terms in the `query`.\nDefaults to the top-level `<field>`'s analyzer.\n\n`filter`::\n(Optional, <<interval_filter,interval filter>> rule object) An optional interval\nfilter.\n\n`use_field`::\n(Optional, string) If specified, then match intervals from this\nfield rather than the top-level `<field>`. Terms are analyzed using the\nsearch analyzer from this field. This allows you to search across multiple\nfields as if they were all the same field; for example, you could index the same\ntext into stemmed and unstemmed fields, and search for stemmed tokens near\nunstemmed ones.\n\n[[intervals-prefix]]\n==== `prefix` rule parameters\n\nThe `prefix` rule matches terms that start with a specified set of characters.\nThis prefix can expand to match at most `indices.query.bool.max_clause_count`\n<<search-settings,search setting>> terms. If the prefix matches more terms,\n{es} returns an error. You can use the\n<<index-prefixes,`index-prefixes`>> option in the field mapping to avoid this\nlimit.\n\n`prefix`::\n(Required, string) Beginning characters of terms you wish to find in the\ntop-level `<field>`.\n\n`analyzer`::\n(Optional, string) <<analysis, analyzer>> used to normalize the `prefix`.\nDefaults to the top-level `<field>`'s analyzer.\n\n`use_field`::\n+\n--\n(Optional, string) If specified, then match intervals from this field rather\nthan the top-level `<field>`.\n\nThe `prefix` is normalized using the search analyzer from this field, unless a\nseparate `analyzer` is specified.\n--\n\n[[intervals-wildcard]]\n==== `wildcard` rule parameters\n\nThe `wildcard` rule matches terms using a wildcard pattern. This pattern can\nexpand to match at most  `indices.query.bool.max_clause_count`\n<<search-settings,search setting>> terms. If the pattern matches more terms,\n{es} returns an error.\n\n`pattern`::\n(Required, string) Wildcard pattern used to find matching terms.\n+\n--\nThis parameter supports two wildcard operators:\n\n* `?`, which matches any single character\n* `*`, which can match zero or more characters, including an empty one\n\nWARNING: Avoid beginning patterns with `*` or `?`. This can increase\nthe iterations needed to find matching terms and slow search performance.\n--\n`analyzer`::\n(Optional, string) <<analysis, analyzer>> used to normalize the `pattern`.\nDefaults to the top-level `<field>`'s analyzer.\n\n`use_field`::\n+\n--\n(Optional, string) If specified, match intervals from this field rather than the\ntop-level `<field>`.\n\nThe `pattern` is normalized using the search analyzer from this field, unless\n`analyzer` is specified separately.\n--\n\n[[intervals-regexp]]\n==== `regexp` rule parameters\n\nThe `regexp` rule matches terms using a regular expression pattern.\nThis pattern can expand to match at most  `indices.query.bool.max_clause_count`\n<<search-settings,search setting>> terms.\nIf the pattern matches more terms,{es} returns an error.\n\n`pattern`::\n(Required, string) Regexp pattern used to find matching terms.\nFor a list of operators supported by the\n`regexp` pattern, see <<regexp-syntax, Regular expression syntax>>.\n\nWARNING: Avoid using wildcard patterns, such as `.*` or `.*?+``. This can\nincrease the iterations needed to find matching terms and slow search\nperformance.\n--\n`analyzer`::\n(Optional, string) <<analysis, analyzer>> used to normalize the `pattern`.\nDefaults to the top-level `<field>`'s analyzer.\n--\n`use_field`::\n+\n--\n(Optional, string) If specified, match intervals from this field rather than the\ntop-level `<field>`.\n\nThe `pattern` is normalized using the search analyzer from this field, unless\n`analyzer` is specified separately.\n--\n\n[[intervals-fuzzy]]\n==== `fuzzy` rule parameters\n\nThe `fuzzy` rule matches terms that are similar to the provided term, within an\nedit distance defined by <<fuzziness>>. If the fuzzy expansion matches more than\n`indices.query.bool.max_clause_count`\n<<search-settings,search setting>> terms, {es} returns an error.\n\n`term`::\n(Required, string) The term to match\n\n`prefix_length`::\n(Optional, integer) Number of beginning characters left unchanged when creating\nexpansions. Defaults to `0`.\n\n`transpositions`::\n(Optional, Boolean) Indicates whether edits include transpositions of two\nadjacent characters (ab \u2192 ba). Defaults to `true`.\n\n`fuzziness`::\n(Optional, string) Maximum edit distance allowed for matching. See <<fuzziness>>\nfor valid values and more information. Defaults to `auto`.\n\n`analyzer`::\n(Optional, string) <<analysis, analyzer>> used to normalize the `term`.\nDefaults to the top-level `<field>` 's analyzer.\n\n`use_field`::\n+\n--\n(Optional, string) If specified, match intervals from this field rather than the\ntop-level `<field>`.\n\nThe `term` is normalized using the search analyzer from this field, unless\n`analyzer` is specified separately.\n--\n\n[[intervals-range]]\n==== `range` rule parameters\n\nThe `range` rule matches terms contained within a provided range.\nThis range can expand to match at most  `indices.query.bool.max_clause_count`\n<<search-settings,search setting>> terms.\nIf the range matches more terms,{es} returns an error.\n\n`gt`::\n(Optional, string) Greater than: match terms greater than the provided term.\n\n`gte`::\n(Optional, string) Greater than or equal to: match terms greater than or\nequal to the provided term.\n\n`lt`::\n(Optional, string) Less than: match terms less than the provided term.\n\n`lte`::\n(Optional, string) Less than or equal to: match terms less than or\nequal to the provided term.\n\nNOTE: It is required to provide one of `gt` or `gte` params.\nIt is required to provide one of `lt` or `lte` params.\n\n\n`analyzer`::\n(Optional, string) <<analysis, analyzer>> used to normalize the `pattern`.\nDefaults to the top-level `<field>`'s analyzer.\n\n`use_field`::\n(Optional, string) If specified, match intervals from this field rather than the\ntop-level `<field>`.\n\n\n[[intervals-all_of]]\n==== `all_of` rule parameters\n\nThe `all_of` rule returns matches that span a combination of other rules.\n\n`intervals`::\n(Required, array of rule objects) An array of rules to combine. All rules must\nproduce a match in a document for the overall source to match.\n\n`max_gaps`::\n+\n--\n(Optional, integer) Maximum number of positions between the matching terms.\nIntervals produced by the rules further apart than this are not considered\nmatches. Defaults to `-1`.\n\nIf unspecified or set to `-1`, there is no width restriction on the match. If\nset to `0`, the terms must appear next to each other.\n--\n\n`ordered`::\n(Optional, Boolean) If `true`, intervals produced by the rules should appear in\nthe order in which they are specified. Defaults to `false`.\n\n`filter`::\n(Optional, <<interval_filter,interval filter>> rule object) Rule used to filter\nreturned intervals.\n\n[[intervals-any_of]]\n==== `any_of` rule parameters\n\nThe `any_of` rule returns intervals produced by any of its sub-rules.\n\n`intervals`::\n(Required, array of rule objects) An array of rules to match.\n\n`filter`::\n(Optional, <<interval_filter,interval filter>> rule object) Rule used to filter\nreturned intervals.\n\n[[interval_filter]]\n==== `filter` rule parameters\n\nThe `filter` rule returns intervals based on a query. See\n<<interval-filter-rule-ex>> for an example.\n\n`after`::\n(Optional, query object) Query used to return intervals that follow an interval\nfrom the `filter` rule.\n\n`before`::\n(Optional, query object) Query used to return intervals that occur before an\ninterval from the `filter` rule.\n\n`contained_by`::\n(Optional, query object) Query used to return intervals contained by an interval\nfrom the `filter` rule.\n\n`containing`::\n(Optional, query object) Query used to return intervals that contain an interval\nfrom the `filter` rule.\n\n`not_contained_by`::\n(Optional, query object) Query used to return intervals that are *not*\ncontained by an interval from the `filter` rule.\n\n`not_containing`::\n(Optional, query object) Query used to return intervals that do *not* contain\nan interval from the `filter` rule.\n\n`not_overlapping`::\n(Optional, query object) Query used to return intervals that do *not* overlap\nwith an interval from the `filter` rule.\n\n`overlapping`::\n(Optional, query object) Query used to return intervals that overlap with an\ninterval from the `filter` rule.\n\n`script`::\n(Optional, <<modules-scripting-using, script object>>) Script used to return\nmatching documents. This script must return a boolean value, `true` or `false`.\nSee <<interval-script-filter>> for an example.\n\n\n[[intervals-query-note]]\n==== Notes\n\n[[interval-filter-rule-ex]]\n===== Filter example\n\nThe following search includes a `filter` rule. It returns documents that have\nthe words `hot` and `porridge` within 10 positions of each other, without the\nword `salty` in between:\n\n[source,console]\n--------------------------------------------------\nPOST _search\n{\n  \"query\": {\n    \"intervals\" : {\n      \"my_text\" : {\n        \"match\" : {\n          \"query\" : \"hot porridge\",\n          \"max_gaps\" : 10,\n          \"filter\" : {\n            \"not_containing\" : {\n              \"match\" : {\n                \"query\" : \"salty\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n[[interval-script-filter]]\n===== Script filters\n\nYou can use a script to filter intervals based on their start position, end\nposition, and internal gap count. The following `filter` script uses the\n`interval` variable with the `start`, `end`, and `gaps` methods:\n\n[source,console]\n--------------------------------------------------\nPOST _search\n{\n  \"query\": {\n    \"intervals\" : {\n      \"my_text\" : {\n        \"match\" : {\n          \"query\" : \"hot porridge\",\n          \"filter\" : {\n            \"script\" : {\n              \"source\" : \"interval.start > 10 && interval.end < 20 && interval.gaps == 0\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n\n[[interval-minimization]]\n===== Minimization\n\nThe intervals query always minimizes intervals, to ensure that queries can\nrun in linear time. This can sometimes cause surprising results, particularly\nwhen using `max_gaps` restrictions or filters. For example, take the\nfollowing query, searching for `salty` contained within the phrase `hot\nporridge`:\n\n[source,console]\n--------------------------------------------------\nPOST _search\n{\n  \"query\": {\n    \"intervals\" : {\n      \"my_text\" : {\n        \"match\" : {\n          \"query\" : \"salty\",\n          \"filter\" : {\n            \"contained_by\" : {\n              \"match\" : {\n                \"query\" : \"hot porridge\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThis query does *not* match a document containing the phrase `hot porridge is\nsalty porridge`, because the intervals returned by the match query for `hot\nporridge` only cover the initial two terms in this document, and these do not\noverlap the intervals covering `salty`.\n"
}