{
    "meta": {
        "size": 10642,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/synthetic-source.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "synthetic-source",
        "version": "8.15"
    },
    "doc": "[[synthetic-source]]\n==== Synthetic `_source`\n\nIMPORTANT: Synthetic `_source` is Generally Available only for TSDB indices\n(indices that have `index.mode` set to `time_series`). For other indices,\nsynthetic `_source` is in technical preview. Features in technical preview may\nbe changed or removed in a future release. Elastic will work to fix\nany issues, but features in technical preview are not subject to the support SLA\nof official GA features.\n\nThough very handy to have around, the source field takes up a significant amount\nof space on disk. Instead of storing source documents on disk exactly as you\nsend them, Elasticsearch can reconstruct source content on the fly upon retrieval.\nEnable this by using the value `synthetic` for the index setting `index.mapping.source.mode`:\n\n[source,console,id=enable-synthetic-source-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  }\n}\n----\n// TESTSETUP\n\nWhile this on the fly reconstruction is *generally* slower than saving the source\ndocuments verbatim and loading them at query time, it saves a lot of storage\nspace. Additional latency can be avoided by not loading `_source` field in queries when it is not needed.\n\n[[synthetic-source-fields]]\n===== Supported fields\nSynthetic `_source` is supported by all field types. Depending on implementation details, field types have different\nproperties when used with synthetic `_source`.\n\n<<synthetic-source-fields-native-list, Most field types>> construct synthetic `_source` using existing data, most\ncommonly <<doc-values,`doc_values`>> and <<stored-fields, stored fields>>. For these field types, no additional space\nis needed to store the contents of `_source` field. Due to the storage layout of <<doc-values,`doc_values`>>, the\ngenerated `_source` field undergoes <<synthetic-source-modifications, modifications>> compared to the original document.\n\nFor all other field types, the original value of the field is stored as is, in the same way as the `_source` field in\nnon-synthetic mode. In this case there are no modifications and field data in `_source` is the same as in the original\ndocument. Similarly, malformed values of fields that use <<ignore-malformed,`ignore_malformed`>> or\n<<ignore-above,`ignore_above`>> need to be stored as is. This approach is less storage efficient since data needed for\n`_source` reconstruction is stored in addition to other data required to index the field (like `doc_values`).\n\n[[synthetic-source-restrictions]]\n===== Synthetic `_source` restrictions\n\nSome field types have additional restrictions. These restrictions are documented in the **synthetic `_source`** section\nof the field type's <<mapping-types,documentation>>.\n\n[[synthetic-source-modifications]]\n===== Synthetic `_source` modifications\n\nWhen synthetic `_source` is enabled, retrieved documents undergo some\nmodifications compared to the original JSON.\n\n[[synthetic-source-modifications-leaf-arrays]]\n====== Arrays moved to leaf fields\nSynthetic `_source` arrays are moved to leaves. For example:\n\n[source,console,id=synthetic-source-leaf-arrays-example]\n----\nPUT idx/_doc/1\n{\n  \"foo\": [\n    {\n      \"bar\": 1\n    },\n    {\n      \"bar\": 2\n    }\n  ]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"foo\": {\n    \"bar\": [1, 2]\n  }\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\nThis can cause some arrays to vanish:\n\n[source,console,id=synthetic-source-leaf-arrays-example-sneaky]\n----\nPUT idx/_doc/1\n{\n  \"foo\": [\n    {\n      \"bar\": 1\n    },\n    {\n      \"baz\": 2\n    }\n  ]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"foo\": {\n    \"bar\": 1,\n    \"baz\": 2\n  }\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\n[[synthetic-source-modifications-field-names]]\n====== Fields named as they are mapped\nSynthetic source names fields as they are named in the mapping. When used\nwith <<dynamic,dynamic mapping>>, fields with dots (`.`) in their names are, by\ndefault, interpreted as multiple objects, while dots in field names are\npreserved within objects that have <<subobjects>> disabled. For example:\n\n[source,console,id=synthetic-source-objecty-example]\n----\nPUT idx/_doc/1\n{\n  \"foo.bar.baz\": 1\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"foo\": {\n    \"bar\": {\n      \"baz\": 1\n    }\n  }\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\nThis impacts how source contents can be referenced in <<modules-scripting-using,scripts>>. For instance, referencing\na script in its original source form will return null:\n\n[source,js]\n----\n\"script\": { \"source\": \"\"\"  emit(params._source['foo.bar.baz'])  \"\"\" }\n----\n// NOTCONSOLE\n\nInstead, source references need to be in line with the mapping structure:\n\n[source,js]\n----\n\"script\": { \"source\": \"\"\"  emit(params._source['foo']['bar']['baz'])  \"\"\" }\n----\n// NOTCONSOLE\n\nor simply\n\n[source,js]\n----\n\"script\": { \"source\": \"\"\"  emit(params._source.foo.bar.baz)  \"\"\" }\n----\n// NOTCONSOLE\n\nThe following <<modules-scripting-fields, field APIs>> are preferable as, in addition to being agnostic to the\nmapping structure, they make use of docvalues if available and fall back to synthetic source only when needed. This\nreduces source synthesizing, a slow and costly operation.\n\n[source,js]\n----\n\"script\": { \"source\": \"\"\"  emit(field('foo.bar.baz').get(null))   \"\"\" }\n\"script\": { \"source\": \"\"\"  emit($('foo.bar.baz', null))   \"\"\" }\n----\n// NOTCONSOLE\n\n[[synthetic-source-modifications-alphabetical]]\n====== Alphabetical sorting\nSynthetic `_source` fields are sorted alphabetically. The\nhttps://www.rfc-editor.org/rfc/rfc7159.html[JSON RFC] defines objects as\n\"an unordered collection of zero or more name/value pairs\" so applications\nshouldn't care but without synthetic `_source` the original ordering is\npreserved and some applications may, counter to the spec, do something with\nthat ordering.\n\n[[synthetic-source-modifications-ranges]]\n====== Representation of ranges\nRange field values (e.g. `long_range`) are always represented as inclusive on both sides with bounds adjusted\naccordingly. See <<range-synthetic-source-inclusive, examples>>.\n\n[[synthetic-source-precision-loss-for-point-types]]\n====== Reduced precision of `geo_point` values\nValues of `geo_point` fields are represented in synthetic `_source` with reduced precision. See\n<<geo-point-synthetic-source, examples>>.\n\n[[synthetic-source-keep]]\n====== Minimizing source modifications\n\nIt is possible to avoid synthetic source modifications for a particular object or field, at extra storage cost.\nThis is controlled through param `synthetic_source_keep` with the following option:\n\n - `none`: synthetic source diverges from the original source as described above (default).\n - `arrays`: arrays of the corresponding field or object preserve the original element ordering and duplicate elements.\nThe synthetic source fragment for such arrays is not guaranteed to match the original source exactly, e.g. array\n`[1, 2, [5], [[4, [3]]], 5]` may appear as-is or in an equivalent format like `[1, 2, 5, 4, 3, 5]`. The exact format\nmay change in the future, in an effort to reduce the storage overhead of this option.\n- `all`: the source for both singleton instances and arrays of the corresponding field or object gets recorded. When\napplied to objects, the source of all sub-objects and sub-fields gets captured. Furthermore, the original source of\narrays gets captured and appears in synthetic source with no modifications.\n\nFor instance:\n\n[source,console,id=create-index-with-synthetic-source-keep]\n----\nPUT idx_keep\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"path\": {\n        \"type\": \"object\",\n        \"synthetic_source_keep\": \"all\"\n      },\n      \"ids\": {\n        \"type\": \"integer\",\n        \"synthetic_source_keep\": \"arrays\"\n      }\n    }\n  }\n}\n----\n// TEST\n\n[source,console,id=synthetic-source-keep-example]\n----\nPUT idx_keep/_doc/1\n{\n  \"path\": {\n    \"to\": [\n      { \"foo\": [3, 2, 1] },\n      { \"foo\": [30, 20, 10] }\n    ],\n    \"bar\": \"baz\"\n  },\n  \"ids\": [ 200, 100, 300, 100 ]\n}\n----\n// TEST[s/$/\\nGET idx_keep\\/_doc\\/1?filter_path=_source\\n/]\n\nreturns the original source, with no array deduplication and sorting:\n\n[source,console-result]\n----\n{\n  \"path\": {\n    \"to\": [\n      { \"foo\": [3, 2, 1] },\n      { \"foo\": [30, 20, 10] }\n    ],\n    \"bar\": \"baz\"\n  },\n  \"ids\": [ 200, 100, 300, 100 ]\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\nThe option for capturing the source of arrays can be applied at index level, by setting\n`index.mapping.synthetic_source_keep` to `arrays`. This applies to all objects and fields in the index, except for\nthe ones with explicit overrides of `synthetic_source_keep` set to `none`. In this case, the storage overhead grows\nwith the number and sizes of arrays present in source of each document, naturally.\n\n[[synthetic-source-fields-native-list]]\n===== Field types that support synthetic source with no storage overhead\nThe following field types support synthetic source using data from <<doc-values,`doc_values`>> or\n<stored-fields, stored fields>>, and require no additional storage space to construct the `_source` field.\n\nNOTE: If you enable the <<ignore-malformed,`ignore_malformed`>> or <<ignore-above,`ignore_above`>> settings, then\nadditional storage is required to store ignored field values for these types.\n\n** <<aggregate-metric-double-synthetic-source, `aggregate_metric_double`>>\n** {plugins}/mapper-annotated-text-usage.html#annotated-text-synthetic-source[`annotated-text`]\n** <<binary-synthetic-source,`binary`>>\n** <<boolean-synthetic-source,`boolean`>>\n** <<numeric-synthetic-source,`byte`>>\n** <<date-synthetic-source,`date`>>\n** <<date-nanos-synthetic-source,`date_nanos`>>\n** <<dense-vector-synthetic-source,`dense_vector`>>\n** <<numeric-synthetic-source,`double`>>\n** <<flattened-synthetic-source, `flattened`>>\n** <<numeric-synthetic-source,`float`>>\n** <<geo-point-synthetic-source,`geo_point`>>\n** <<numeric-synthetic-source,`half_float`>>\n** <<histogram-synthetic-source,`histogram`>>\n** <<numeric-synthetic-source,`integer`>>\n** <<ip-synthetic-source,`ip`>>\n** <<keyword-synthetic-source,`keyword`>>\n** <<numeric-synthetic-source,`long`>>\n** <<range-synthetic-source,`range` types>>\n** <<numeric-synthetic-source,`scaled_float`>>\n** <<numeric-synthetic-source,`short`>>\n** <<text-synthetic-source,`text`>>\n** <<version-synthetic-source,`version`>>\n** <<wildcard-synthetic-source,`wildcard`>>\n"
}