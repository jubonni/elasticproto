{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.798067",
        "size": 12089,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html",
        "type": "documentation",
        "role": [
            "child_attributes"
        ],
        "has_code": true,
        "title": "number",
        "version": "8.15"
    },
    "doc": "[[number]]\n=== Numeric field types\n++++\n<titleabbrev>Numeric</titleabbrev>\n++++\n\nThe following numeric types are supported:\n\n[horizontal]\n`long`::         A signed 64-bit integer with a minimum value of +-2^63^+ and a maximum value of +2^63^-1+.\n`integer`::      A signed 32-bit integer with a minimum value of +-2^31^+ and a maximum value of +2^31^-1+.\n`short`::        A signed 16-bit integer with a minimum value of +-32,768+ and a maximum value of +32,767+.\n`byte`::         A signed 8-bit integer with a minimum value of +-128+ and a maximum value of +127+.\n`double`::       A double-precision 64-bit IEEE 754 floating point number, restricted to finite values.\n`float`::        A single-precision 32-bit IEEE 754 floating point number, restricted to finite values.\n`half_float`::   A half-precision 16-bit IEEE 754 floating point number, restricted to finite values.\n`scaled_float`:: A floating point number that is backed by a `long`, scaled by a fixed `double` scaling factor.\n`unsigned_long`:: An unsigned 64-bit integer with a minimum value of 0 and a maximum value of +2^64^-1+.\n\nBelow is an example of configuring a mapping with numeric fields:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"number_of_bytes\": {\n        \"type\": \"integer\"\n      },\n      \"time_in_seconds\": {\n        \"type\": \"float\"\n      },\n      \"price\": {\n        \"type\": \"scaled_float\",\n        \"scaling_factor\": 100\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nNOTE: The `double`, `float` and `half_float` types consider that `-0.0` and\n`+0.0` are different values. As a consequence, doing a `term` query on\n`-0.0` will not match `+0.0` and vice-versa. Same is true for range queries:\nif the upper bound is `-0.0` then `+0.0` will not match, and if the lower\nbound is `+0.0` then `-0.0` will not match.\n\n==== Which type should I use?\n\nAs far as integer types (`byte`, `short`, `integer` and `long`) are concerned,\nyou should pick the smallest type which is enough for your use-case. This will\nhelp indexing and searching be more efficient. Note however that storage is\noptimized based on the actual values that are stored, so picking one type over\nanother one will have no impact on storage requirements.\n\nFor floating-point types, it is often more efficient to store floating-point\ndata into an integer using a scaling factor, which is what the `scaled_float`\ntype does under the hood. For instance, a `price` field could be stored in a\n`scaled_float` with a `scaling_factor` of +100+. All APIs would work as if\nthe field was stored as a double, but under the hood Elasticsearch would be\nworking with the number of cents, +price*100+, which is an integer. This is\nmostly helpful to save disk space since integers are way easier to compress\nthan floating points. `scaled_float` is also fine to use in order to trade\naccuracy for disk space. For instance imagine that you are tracking cpu\nutilization as a number between +0+ and +1+. It usually does not matter much\nwhether cpu utilization is +12.7%+ or +13%+, so you could use a `scaled_float`\nwith a `scaling_factor` of +100+ in order to round cpu utilization to the\nclosest percent in order to save space.\n\nIf `scaled_float` is not a good fit, then you should pick the smallest type\nthat is enough for the use-case among the floating-point types: `double`,\n`float` and `half_float`. Here is a table that compares these types in order\nto help make a decision.\n\n[[floating_point]]\n[cols=\"<,<,<,<,<\",options=\"header\",]\n|=======================================================================\n|Type        |Minimum value |Maximum value        |Significant +\n                                                     bits / digits  |Example precision loss\n|`double`    |+2^-1074^+    |+(2-2^-52^)\u00b72^1023^+ |  +53+ / +15.95+ | +1.2345678912345678+-> +\n                                                                      +1.234567891234568+\n|`float`     |+2^-149^+     |+(2-2^-23^)\u00b72^127^+  |  +24+ / +7.22+  | +1.23456789+-> +\n                                                                      +1.2345679+\n|`half_float`|+2^-24^+      |+65504+              |  +11+ / +3.31+  | +1.2345+-> +\n                                                                      +1.234375+\n|=======================================================================\n\n[TIP]\n.Mapping numeric identifiers\n====\n// tag::map-ids-as-keyword[]\nNot all numeric data should be mapped as a <<number,numeric>> field data type.\n{es} optimizes numeric fields, such as `integer` or `long`, for\n<<query-dsl-range-query,`range`>> queries. However, <<keyword,`keyword`>> fields\nare better for <<query-dsl-term-query,`term`>> and other\n<<term-level-queries,term-level>> queries.\n\nIdentifiers, such as an ISBN or a product ID, are rarely used in `range`\nqueries. However, they are often retrieved using term-level queries.\n\nConsider mapping a numeric identifier as a `keyword` if:\n\n* You don't plan to search for the identifier data using\n  <<query-dsl-range-query,`range`>> queries.\n* Fast retrieval is important. `term` query searches on `keyword` fields are\n  often faster than `term` searches on numeric fields.\n\nIf you're unsure which to use, you can use a <<multi-fields,multi-field>> to map\nthe data as both a `keyword` _and_ a numeric data type.\n// end::map-ids-as-keyword[]\n====\n\n[role=\"child_attributes\"]\n[[number-params]]\n==== Parameters for numeric fields\n\nThe following parameters are accepted by numeric types:\n\n<<coerce,`coerce`>>::\n\n    Try to convert strings to numbers and truncate fractions for integers.\n    Accepts `true` (default) and `false`. Not applicable for `unsigned_long`.\n    Note that this cannot be set if the `script` parameter is used.\n\n<<doc-values,`doc_values`>>::\n\n    Should the field be stored on disk in a column-stride fashion, so that it\n    can later be used for sorting, aggregations, or scripting? Accepts `true`\n    (default) or `false`.\n\n<<ignore-malformed,`ignore_malformed`>>::\n\n    If `true`, malformed numbers are ignored. If `false` (default), malformed\n    numbers throw an exception and reject the whole document.  Note that this\n    cannot be set if the `script` parameter is used.\n\n<<mapping-index,`index`>>::\n\n    Should the field be quickly searchable? Accepts `true` (default) and\n    `false`. Numeric fields that only have <<doc-values,`doc_values`>>\n    enabled can also be queried, albeit slower.\n\n<<mapping-field-meta,`meta`>>::\n\n    Metadata about the field.\n\n<<null-value,`null_value`>>::\n\n    Accepts a numeric value of the same `type` as the field which is\n    substituted for any explicit `null` values. Defaults to `null`, which\n    means the field is treated as missing. Note that this cannot be set\n    if the `script` parameter is used.\n\n`on_script_error`::\n\n    Defines what to do if the script defined by the `script` parameter\n    throws an error at indexing time. Accepts `fail` (default), which\n    will cause the entire document to be rejected, and `continue`, which\n    will register the field in the document's\n    <<mapping-ignored-field,`_ignored`>> metadata field and continue\n    indexing. This parameter can only be set if the `script` field is\n    also set.\n\n`script`::\n\n    If this parameter is set, then the field will index values generated\n    by this script, rather than reading the values directly from the\n    source. If a value is set for this field on the input document, then\n    the document will be rejected with an error.\n    Scripts are in the same format as their\n    <<runtime-mapping-fields,runtime equivalent>>. Scripts can only be\n    configured on `long` and `double` field types.\n\n<<mapping-store,`store`>>::\n\n    Whether the field value should be stored and retrievable separately from\n    the <<mapping-source-field,`_source`>> field. Accepts `true` or `false`\n    (default).\n\n`time_series_dimension`::\n(Optional, Boolean)\n+\n--\ninclude::keyword.asciidoc[tag=dimension]\n\nOf the numeric field types, only `byte`, `short`, `integer`, `long`, and\n`unsigned_long` fields support this parameter.\n\nA numeric field can't be both a time series dimension and a time series metric.\n--\n\n`time_series_metric`::\n(Optional, string)\n// tag::time_series_metric[]\nMarks the field as a <<time-series-metric,time series metric>>. The value is the\nmetric type. You can't update this parameter for existing fields.\n// end::time_series_metric[]\n+\n.Valid `time_series_metric` values for numeric fields\n[%collapsible%open]\n====\ninclude::{es-ref-dir}/data-streams/tsds.asciidoc[tag=time-series-metric-counter]\n\ninclude::{es-ref-dir}/data-streams/tsds.asciidoc[tag=time-series-metric-gauge]\n\ninclude::{es-ref-dir}/data-streams/tsds.asciidoc[tag=time-series-metric-null]\n====\n+\nFor a numeric time series metric, the `doc_values` parameter must be `true`. A\nnumeric field can't be both a time series dimension and a time series metric.\n\n[[scaled-float-params]]\n==== Parameters for `scaled_float`\n\n`scaled_float` accepts an additional parameter:\n\n[horizontal]\n\n`scaling_factor`::\n\n    The scaling factor to use when encoding values. Values will be multiplied\n    by this factor at index time and rounded to the closest long value. For\n    instance, a `scaled_float` with a `scaling_factor` of +10+ would internally\n    store +2.34+ as +23+ and all search-time operations (queries, aggregations,\n    sorting) will behave as if the document had a value of +2.3+. High values\n    of `scaling_factor` improve accuracy but also increase space requirements.\n    This parameter is required.\n\n[[scaled-float-saturation]]\n==== `scaled_float` saturation\n\n`scaled_float` is stored as a single `long` value, which is the product of multiplying the original value by the scaling factor. If the multiplication\nresults in a value that is outside the range of a `long`, the value is saturated\nto the minimum or maximum value of a `long`. For example, if the scaling factor\nis +100+ and the value is +92233720368547758.08+, the expected value is +9223372036854775808+.\nHowever, the value that is stored is +9223372036854775807+, the maximum value for a `long`.\n\nThis can lead to unexpected results with <<query-dsl-range-query,range queries>>\nwhen the scaling factor or provided `float` value are exceptionally large.\n\n[[numeric-synthetic-source]]\n==== Synthetic `_source`\n\nIMPORTANT: Synthetic `_source` is Generally Available only for TSDB indices\n(indices that have `index.mode` set to `time_series`). For other indices\nsynthetic `_source` is in technical preview. Features in technical preview may\nbe changed or removed in a future release. Elastic will work to fix\nany issues, but features in technical preview are not subject to the support SLA\nof official GA features.\n\nAll numeric fields support <<synthetic-source,synthetic\n`_source`>> in their default configuration. Synthetic `_source` cannot be used\ntogether with <<copy-to,`copy_to`>>, or\nwith <<doc-values,`doc_values`>> disabled.\n\nSynthetic source may sort numeric field values. For example:\n[source,console,id=synthetic-source-numeric-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"long\": { \"type\": \"long\" }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"long\": [0, 0, -123466, 87612]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n[source,console-result]\n----\n{\n  \"long\": [-123466, 0, 0, 87612]\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\nScaled floats will always apply their scaling factor so:\n[source,console,id=synthetic-source-scaled-float-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"f\": { \"type\": \"scaled_float\", \"scaling_factor\": 0.01 }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"f\": 123\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"f\": 100.0\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n"
}