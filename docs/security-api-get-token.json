{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.671578",
        "size": 11079,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-token.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "security-api-get-token",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[security-api-get-token]]\n=== Get token API\n++++\n<titleabbrev>Get token</titleabbrev>\n++++\n\nCreates a bearer token for access without requiring basic authentication.\n\n[[security-api-get-token-request]]\n==== {api-request-title}\n\n`POST /_security/oauth2/token`\n\n[[security-api-get-token-prereqs]]\n==== {api-prereq-title}\n\n* To use this API, you must have the `manage_token` cluster privilege.\n\n[[security-api-get-token-desc]]\n==== {api-description-title}\n\nThe tokens are created by the {es} Token Service, which is automatically enabled\nwhen you configure TLS on the HTTP interface. See <<encrypt-http-communication>>. Alternatively,\nyou can explicitly enable the `xpack.security.authc.token.enabled` setting. When\nyou are running in production mode, a bootstrap check prevents you from enabling\nthe token service unless you also enable TLS on the HTTP interface.\n\nThe get token API takes the same parameters as a typical OAuth 2.0 token API\nexcept for the use of a JSON request body.\n\nA successful get token API call returns a JSON structure that contains the access\ntoken, the amount of time (seconds) that the token expires in, the type, and the\nscope if available.\n\nThe tokens returned by the get token API have a finite period of time for which\nthey are valid and after that time period, they can no longer be used. That time\nperiod is defined by the `xpack.security.authc.token.timeout` setting. For more\ninformation, see <<token-service-settings>>.\n\nIf you want to invalidate a token immediately, you can do so by using the\n<<security-api-invalidate-token,invalidate token API>>.\n\n[[security-api-get-token-request-body]]\n==== {api-request-body-title}\n\nThe following parameters can be specified in the body of a POST request and\npertain to creating a token:\n\n`grant_type`::\n(Required, string) The type of grant.\nSupported grant types are: `password`, `_kerberos`,\n`client_credentials` and `refresh_token`.\n\n`client_credentials`:::\nThis grant type implements the Client Credentials Grant of OAuth2. It is geared\nfor machine to machine communication and is not suitable or designed for the\nself-service user creation of tokens. It generates only access tokens that\ncannot be refreshed. The premise is that the entity that uses\n`client_credentials` has constant access to a set of (client, not end-user)\ncredentials and can authenticate itself at will.\n\n`_kerberos`:::\nThis grant type is supported internally and implements SPNEGO based Kerberos\nsupport. The `_kerberos` grant type may change from version to version.\n\n`password`:::\nThis grant type implements the Resource Owner Password Credentials Grant of\nOAuth2. In this grant, a trusted client exchanges the end user's credentials\nfor an access token and (possibly) a refresh token. The request needs to be made\nby an authenticated user but happens _on behalf_ of another authenticated user\n(the one whose credentials are passed as request parameters). This grant type is\nnot suitable or designed for the self-service user creation of tokens.\n\n`refresh_token`:::\nThis grant type implements the Refresh Token Grant of OAuth2.\nIn this grant a user exchanges a previously issued refresh token for a new access token and a new refresh token.\n\n`password`::\n(Optional^*^, string) The user's password. If you specify the `password` grant type, this\nparameter is required. This parameter is not valid with any other supported\ngrant type.\n\n`kerberos_ticket`::\n(Optional^*^, string) The base64 encoded kerberos ticket. If you specify the\n`_kerberos` grant type, this parameter is required. This parameter is not valid\nwith any other supported grant type.\n\n`refresh_token`::\n(Optional^*^, string) The string that was returned when you created the token,\nwhich enables you to extend its life. If you specify the `refresh_token` grant\ntype, this parameter is required. This parameter is not valid with any other\nsupported grant type.\n\n`scope`::\n(Optional, string) The scope of the token. Currently tokens are only issued for a scope of\n`FULL` regardless of the value sent with the request.\n\n`username`::\n(Optional^*^, string) The username that identifies the user. If you specify the `password`\ngrant type, this parameter is required. This parameter is not valid with any\nother supported grant type.\n\n[[security-api-get-token-example]]\n==== {api-examples-title}\n\nThe following example obtains a token using the `client_credentials` grant type,\nwhich simply creates a token as the authenticated user:\n\n[source,console]\n--------------------------------------------------\nPOST /_security/oauth2/token\n{\n  \"grant_type\" : \"client_credentials\"\n}\n--------------------------------------------------\n\nThe following example output contains the access token, the amount of time (in\nseconds) that the token expires in, and the type:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"access_token\" : \"dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==\",\n  \"type\" : \"Bearer\",\n  \"expires_in\" : 1200,\n  \"authentication\" : {\n    \"username\" : \"test_admin\",\n    \"roles\" : [\n      \"superuser\"\n    ],\n    \"full_name\" : null,\n    \"email\" : null,\n    \"metadata\" : { },\n    \"enabled\" : true,\n    \"authentication_realm\" : {\n      \"name\" : \"file\",\n      \"type\" : \"file\"\n    },\n    \"lookup_realm\" : {\n      \"name\" : \"file\",\n      \"type\" : \"file\"\n    },\n    \"authentication_type\" : \"realm\"\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==/$body.access_token/]\n// TESTRESPONSE[s/superuser/_es_test_root/]\n\nThe token returned by this API can be used by sending a request with an\n`Authorization` header with a value having the prefix \"Bearer \" followed\nby the value of the `access_token`.\n\n[source,shell]\n--------------------------------------------------\ncurl -H \"Authorization: Bearer dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==\" http://localhost:9200/_cluster/health\n--------------------------------------------------\n// NOTCONSOLE\n\nThe following example obtains a token for the `test_admin` user using the\n`password` grant type. This request needs to be made by an authenticated user with sufficient privileges that may\nor may not be the same as the one whose username is passed in the `username` parameter:\n\n[source,console]\n--------------------------------------------------\nPOST /_security/oauth2/token\n{\n  \"grant_type\" : \"password\",\n  \"username\" : \"test_admin\",\n  \"password\" : \"x-pack-test-password\"\n}\n--------------------------------------------------\n\nThe following example output contains the access token, the amount of time (in\nseconds) that the token expires in, the type, and the refresh token:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"access_token\" : \"dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==\",\n  \"type\" : \"Bearer\",\n  \"expires_in\" : 1200,\n  \"refresh_token\": \"vLBPvmAB6KvwvJZr27cS\",\n  \"authentication\" : {\n    \"username\" : \"test_admin\",\n    \"roles\" : [\n      \"superuser\"\n    ],\n    \"full_name\" : null,\n    \"email\" : null,\n    \"metadata\" : { },\n    \"enabled\" : true,\n    \"authentication_realm\" : {\n      \"name\" : \"file\",\n      \"type\" : \"file\"\n    },\n    \"lookup_realm\" : {\n      \"name\" : \"file\",\n      \"type\" : \"file\"\n    },\n    \"authentication_type\" : \"realm\"\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==/$body.access_token/]\n// TESTRESPONSE[s/vLBPvmAB6KvwvJZr27cS/$body.refresh_token/]\n// TESTRESPONSE[s/superuser/_es_test_root/]\n\n[[security-api-refresh-token]]\nTo extend the life of an existing token obtained using the `password` grant type,\nyou can call the API again with the refresh token within 24 hours of the token's\ncreation. For example:\n\n[source,console]\n--------------------------------------------------\nPOST /_security/oauth2/token\n{\n  \"grant_type\": \"refresh_token\",\n  \"refresh_token\": \"vLBPvmAB6KvwvJZr27cS\"\n}\n--------------------------------------------------\n// TEST[s/vLBPvmAB6KvwvJZr27cS/$body.refresh_token/]\n// TEST[continued]\n\nThe API will return a new token and refresh token. Each refresh token may only\nbe used one time.\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"access_token\" : \"dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==\",\n  \"type\" : \"Bearer\",\n  \"expires_in\" : 1200,\n  \"refresh_token\": \"vLBPvmAB6KvwvJZr27cS\",\n  \"authentication\" : {\n    \"username\" : \"test_admin\",\n    \"roles\" : [\n      \"superuser\"\n    ],\n    \"full_name\" : null,\n    \"email\" : null,\n    \"metadata\" : { },\n    \"enabled\" : true,\n    \"authentication_realm\" : {\n      \"name\" : \"file\",\n      \"type\" : \"file\"\n    },\n    \"lookup_realm\" : {\n      \"name\" : \"file\",\n      \"type\" : \"file\"\n    },\n    \"authentication_type\" : \"token\"\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==/$body.access_token/]\n// TESTRESPONSE[s/vLBPvmAB6KvwvJZr27cS/$body.refresh_token/]\n// TESTRESPONSE[s/superuser/_es_test_root/]\n\nThe following example obtains a access token and refresh token using the `kerberos` grant type,\nwhich simply creates a token in exchange for the base64 encoded kerberos ticket:\n\n[source,js]\n--------------------------------------------------\nPOST /_security/oauth2/token\n{\n  \"grant_type\" : \"_kerberos\",\n  \"kerberos_ticket\" : \"YIIB6wYJKoZIhvcSAQICAQBuggHaMIIB1qADAgEFoQMCAQ6iBtaDcp4cdMODwOsIvmvdX//sye8NDJZ8Gstabor3MOGryBWyaJ1VxI4WBVZaSn1WnzE06Xy2\"\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nThe API will return a new token and refresh token if kerberos authentication is successful.\nEach refresh token may only be used one time. When the mutual authentication is requested in the Spnego GSS context,\n a base64 encoded token will be returned by the server in the `kerberos_authentication_response_token`\n for clients to consume and finalize the authentication.\n\n[source,js]\n--------------------------------------------------\n{\n  \"access_token\" : \"dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==\",\n  \"type\" : \"Bearer\",\n  \"expires_in\" : 1200,\n  \"refresh_token\": \"vLBPvmAB6KvwvJZr27cS\"\n  \"kerberos_authentication_response_token\": \"YIIB6wYJKoZIhvcSAQICAQBuggHaMIIB1qADAg\",\n  \"authentication\" : {\n    \"username\" : \"test_admin\",\n    \"roles\" : [\n      \"superuser\"\n    ],\n    \"full_name\" : null,\n    \"email\" : null,\n    \"metadata\" : { },\n    \"enabled\" : true,\n    \"authentication_realm\" : {\n      \"name\" : \"file\",\n      \"type\" : \"file\"\n    },\n    \"lookup_realm\" : {\n      \"name\" : \"file\",\n      \"type\" : \"file\"\n    },\n    \"authentication_type\" : \"realm\"\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n"
}