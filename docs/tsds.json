{
    "meta": {
        "size": 14360,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/tsds.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "tsds",
        "version": "8.15"
    },
    "doc": "[[tsds]]\n== Time series data stream (TSDS)\n\nA time series data stream (TSDS) models timestamped metrics data as one or\nmore time series.\n\nYou can use a TSDS to store metrics data more efficiently. In our benchmarks,\nmetrics data stored in a TSDS used 70% less disk space than a regular data\nstream. The exact impact will vary per data set.\n\n[discrete]\n[[when-to-use-tsds]]\n=== When to use a TSDS\n\nBoth a <<data-streams,regular data stream>> and a TSDS can store timestamped\nmetrics data. Only use a TSDS if you typically add metrics data to {es} in near\nreal-time and `@timestamp` order.\n\nA TSDS is only intended for metrics data. For other timestamped data, such as\nlogs or traces, use a regular data stream.\n\n[discrete]\n[[differences-from-regular-data-stream]]\n=== Differences from a regular data stream\n\nA TSDS works like a regular data stream with some key differences:\n\n* The matching index template for a TSDS requires a `data_stream` object with\nthe <<time-series-mode,`index.mode: time_series`>> option. This option enables\nmost TSDS-related functionality.\n\n* In addition to a `@timestamp`, each document in a TSDS must contain one or\nmore <<time-series-dimension,dimension fields>>. The matching index template for\na TSDS must contain mappings for at least one `keyword` dimension.\n+\nTSDS documents also typically\ncontain one or more <<time-series-metric,metric fields>>.\n\n* {es} generates a hidden <<tsid,`_tsid`>> metadata field for each document in a\nTSDS.\n\n* A TSDS uses <<time-bound-indices,time-bound backing indices>> to store data\nfrom the same time period in the same backing index.\n\n* The matching index template for a TSDS must contain the `index.routing_path`\nindex setting. A TSDS uses this setting to perform\n<<dimension-based-routing,dimension-based routing>>.\n\n* A TSDS uses internal <<index-modules-index-sorting,index sorting>> to order\nshard segments by `_tsid` and `@timestamp`.\n\n* TSDS documents only support auto-generated document `_id` values. For TSDS\ndocuments, the document `_id` is a hash of the document's dimensions and\n`@timestamp`. A TSDS doesn't support custom document `_id` values.\n\n\n* A TSDS uses <<synthetic-source,synthetic `_source`>>, and as a result is\nsubject to some <<synthetic-source-restrictions,restrictions>> and <<synthetic-source-modifications,modifications>> applied to the `_source` field.\n\nNOTE: A time series index can contain fields other than dimensions or metrics.\n\n[discrete]\n[[time-series]]\n=== What is a time series?\n\nA time series is a sequence of observations for a specific entity. Together,\nthese observations let you track changes to the entity over time. For example, a\ntime series can track:\n\n* CPU and disk usage for a computer\n* The price of a stock\n* Temperature and humidity readings from a weather sensor.\n\n.Time series of weather sensor readings plotted as a graph\nimage::images/data-streams/time-series-chart.svg[align=\"center\"]\n\nIn a TSDS, each {es} document represents an observation, or data point, in a\nspecific time series. Although a TSDS can contain multiple time series, a\ndocument can only belong to one time series. A time series can't span multiple\ndata streams.\n\n[discrete]\n[[time-series-dimension]]\n==== Dimensions\n\nDimensions are field names and values that, in combination, identify a\ndocument's time series. In most cases, a dimension describes some aspect of the\nentity you're measuring. For example, documents related to the same weather\nsensor may always have the same `sensor_id` and `location` values.\n\nA TSDS document is uniquely identified by its time series and timestamp, both of\nwhich are used to generate the document `_id`. So, two documents with the same\ndimensions and the same timestamp are considered to be duplicates. When you use\nthe `_bulk` endpoint to add documents to a TSDS, a second document with the same\ntimestamp and dimensions overwrites the first. When you use the\n`PUT /<target>/_create/<_id>` format to add an individual document and a document\nwith the same `_id` already exists, an error is generated.\n\nYou mark a field as a dimension using the boolean `time_series_dimension`\nmapping parameter. The following field types support the `time_series_dimension`\nparameter:\n\n* <<keyword-field-type,`keyword`>>\n* <<ip,`ip`>>\n* <<number,`byte`>>\n* <<number,`short`>>\n* <<number,`integer`>>\n* <<number,`long`>>\n* <<number,`unsigned_long`>>\n* <<boolean,`boolean`>>\n\nFor a flattened field, use the `time_series_dimensions` parameter to configure an array of fields as dimensions.\nFor details refer to <<flattened-params,`flattened`>>.\n\nDimension definitions can be simplified through <<passthrough-dimensions, pass-through>> fields.\n\n[discrete]\n[[time-series-metric]]\n==== Metrics\n\nMetrics are fields that contain numeric measurements, as well as aggregations\nand/or downsampling values based off of those measurements. While not required,\ndocuments in a TSDS typically contain one or more metric fields.\n\nMetrics differ from dimensions in that while dimensions generally remain\nconstant, metrics are expected to change over time, even if rarely or slowly.\n\nTo mark a field as a metric, you must specify a metric type using the\n`time_series_metric` mapping parameter. The following field types support the\n`time_series_metric` parameter:\n\n* <<aggregate-metric-double,`aggregate_metric_double`>>\n* <<histogram,`histogram`>>\n* All <<number,numeric field types>>\n\nAccepted metric types vary based on the field type:\n\n.Valid values for `time_series_metric`\n[%collapsible%open]\n====\n// tag::time-series-metric-counter[]\n`counter`:: A cumulative metric that only monotonically increases or resets to `0` (zero). For\nexample, a count of errors or completed tasks.\n// end::time-series-metric-counter[]\n+\nA counter field has additional semantic meaning, because it represents a cumulative counter. This works well with\nthe `rate` aggregation, since a rate can be derived from a cumulative monotonically increasing counter. However a number\nof aggregations (for example `sum`) compute results that don't make sense for a counter field, because of its cumulative nature.\n+\nOnly numeric and `aggregate_metric_double` fields support the `counter` metric type.\n\nNOTE: Due to the cumulative nature of counter fields, the following aggregations are supported and expected to provide meaningful results with the `counter` field: `rate`, `histogram`, `range`, `min`, `max`, `top_metrics` and `variable_width_histogram`. In order to prevent issues with existing integrations and custom dashboards, we also allow the following aggregations, even if the result might be meaningless on counters: `avg`, `box plot`, `cardinality`, `extended stats`, `median absolute deviation`, `percentile ranks`, `percentiles`, `stats`, `sum` and `value count`.\n\n// tag::time-series-metric-gauge[]\n`gauge`:: A metric that represents a single numeric that can arbitrarily increase or decrease. For example, a temperature or\navailable disk space.\n// end::time-series-metric-gauge[]\n+\nOnly numeric and `aggregate_metric_double` fields support the `gauge` metric\ntype.\n\n// tag::time-series-metric-null[]\n`null` (Default):: Not a time series metric.\n// end::time-series-metric-null[]\n====\n\n[discrete]\n[[time-series-mode]]\n=== Time series mode\n\nThe matching index template for a TSDS must contain a `data_stream` object with\nthe `index_mode: time_series` option. This option ensures the TSDS creates\nbacking indices with an <<index-mode,`index.mode`>> setting of `time_series`.\nThis setting enables most TSDS-related functionality in the backing indices.\n\nIf you convert an existing data stream to a TSDS, only backing indices created\nafter the conversion have an `index.mode` of `time_series`. You can't\nchange the `index.mode` of an existing backing index.\n\n[discrete]\n[[tsid]]\n==== `_tsid` metadata field\n\nWhen you add a document to a TSDS, {es} automatically generates a `_tsid`\nmetadata field for the document. The `_tsid` is an object containing the\ndocument's dimensions. Documents in the same TSDS with the same `_tsid` are part\nof the same time series.\n\nThe `_tsid` field is not queryable or updatable. You also can't retrieve a\ndocument's `_tsid` using a <<docs-get,get document>> request. However, you can\nuse the `_tsid` field in aggregations and retrieve the `_tsid` value in searches\nusing the <<search-fields-param,`fields` parameter>>.\n\nWARNING: The format of the `_tsid` field shouldn't be relied upon. It may change\nfrom version to version.\n\n[discrete]\n[[time-bound-indices]]\n==== Time-bound indices\n\nIn a TSDS, each backing index, including the most recent backing index, has a\nrange of accepted `@timestamp` values. This range is defined by the\n<<index-time-series-start-time,`index.time_series.start_time`>> and\n<<index-time-series-end-time,`index.time_series.end_time`>> index settings.\n\nWhen you add a document to a TSDS, {es} adds the document to the appropriate\nbacking index based on its `@timestamp` value. As a result, a TSDS can add\ndocuments to any TSDS backing index that can receive writes. This applies even\nif the index isn't the most recent backing index.\n\nimage::images/data-streams/time-bound-indices.svg[align=\"center\"]\n\nTIP: Some {ilm-init} actions mark the source index as read-only, or expect the index\nto not be actively written anymore in order to provide good performance. These actions are:\n- <<ilm-delete>>\n- <<ilm-downsample>>\n- <<ilm-forcemerge>>\n- <<ilm-readonly>>\n- <<ilm-searchable-snapshot>>\n- <<ilm-shrink>>\n{ilm-cap} will **not** proceed with executing these actions until the upper time-bound\nfor accepting writes, represented by the <<index-time-series-end-time,`index.time_series.end_time`>>\nindex setting, has lapsed.\n\nIf no backing index can accept a document's `@timestamp` value, {es} rejects the\ndocument.\n\n\n{es} automatically configures `index.time_series.start_time` and\n`index.time_series.end_time` settings as part of the index creation and rollover\nprocess.\n\n[discrete]\n[[tsds-look-ahead-time]]\n==== Look-ahead time\n\nUse the <<index-look-ahead-time,`index.look_ahead_time`>> index setting to\nconfigure how far into the future you can add documents to an index. When you\ncreate a new write index for a TSDS, {es} calculates the index's\n`index.time_series.end_time` value as:\n\n`now + index.look_ahead_time`\n\nAt the time series poll interval (controlled via `time_series.poll_interval` setting),\n{es} checks if the write index has met the rollover criteria in its index\nlifecycle policy. If not, {es} refreshes the `now` value and updates the write\nindex's `index.time_series.end_time` to:\n\n`now + index.look_ahead_time + time_series.poll_interval`\n\nThis process continues until the write index rolls over. When the index rolls\nover, {es} sets a final `index.time_series.end_time` value for the index. This\nvalue borders the `index.time_series.start_time` for the new write index. This\nensures the `@timestamp` ranges for neighboring backing indices always border\nbut never overlap.\n\n[discrete]\n[[tsds-look-back-time]]\n==== Look-back time\n\nUse the <<index-look-back-time,`index.look_back_time`>> index setting to\nconfigure how far in the past you can add documents to an index. When you\ncreate a data stream for a TSDS, {es} calculates the index's\n`index.time_series.start_time` value as:\n\n`now - index.look_back_time`\n\nThis setting is only used when a data stream gets created and controls\nthe `index.time_series.start_time` index setting of the first backing index.\nConfiguring this index setting can be useful to accept documents with `@timestamp`\nfield values that are older than 2 hours (the `index.look_back_time` default).\n\n[discrete]\n[[tsds-accepted-time-range]]\n==== Accepted time range for adding data\n\nA TSDS is designed to ingest current metrics data. When the TSDS is first\ncreated the initial backing index has:\n\n* an `index.time_series.start_time` value set to `now - index.look_back_time`\n* an `index.time_series.end_time` value set to `now + index.look_ahead_time`\n\nOnly data that falls inside that range can be indexed.\n\nYou can use the <<indices-get-data-stream,get data stream API>> to check the\naccepted time range for writing to any TSDS.\n\n[discrete]\n[[dimension-based-routing]]\n==== Dimension-based routing\n\nWithin each TSDS backing index, {es} uses the\n<<index-routing-path,`index.routing_path`>> index setting to route documents\nwith the same dimensions to the same shards.\n\nWhen you create the matching index template for a TSDS, you must specify one or\nmore dimensions in the `index.routing_path` setting. Each document in a TSDS\nmust contain one or more dimensions that match the `index.routing_path` setting.\n\nThe `index.routing_path` setting accepts wildcard patterns (for example `dim.*`)\nand can dynamically match new fields. However, {es} will reject any mapping\nupdates that add scripted, runtime, or non-dimension fields that\nmatch the `index.routing_path` value.\n\n<<passthrough-dimensions, Pass-through>> fields may be configured\nas dimension containers. In this case, their sub-fields get included to the\nrouting path automatically.\n\nTSDS documents don't support a custom `_routing` value. Similarly, you can't\nrequire a `_routing` value in mappings for a TSDS.\n\n[discrete]\n[[tsds-index-sorting]]\n==== Index sorting\n\n{es} uses <<index-codec,compression algorithms>> to compress repeated values.\nThis compression works best when repeated values are stored near each other \u2014 in\nthe same index, on the same shard, and side-by-side in the same shard segment.\n\nMost time series data contains repeated values. Dimensions are repeated across\ndocuments in the same time series. The metric values of a time series may also\nchange slowly over time.\n\nInternally, each TSDS backing index uses <<index-modules-index-sorting,index\nsorting>> to order its shard segments by `_tsid` and `@timestamp`. This makes it\nmore likely that these repeated values are stored near each other for better\ncompression. A TSDS doesn't support any\n<<index-modules-index-sorting,`index.sort.*`>> index settings.\n\n[discrete]\n[[tsds-whats-next]]\n=== What's next?\n\nNow that you know the basics, you're ready to <<set-up-tsds,create a TSDS>> or\n<<set-up-tsds,convert an existing data stream to a TSDS>>.\n\ninclude::set-up-tsds.asciidoc[]\ninclude::tsds-index-settings.asciidoc[]\ninclude::downsampling.asciidoc[]\ninclude::downsampling-ilm.asciidoc[]\ninclude::downsampling-manual.asciidoc[]\ninclude::tsds-reindex.asciidoc[]\n"
}