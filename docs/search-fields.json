{
    "meta": {
        "timestamp": "2024-11-01T03:07:10.096289",
        "size": 22097,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-fields.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-fields",
        "version": "8.15"
    },
    "doc": "[[search-fields]]\n=== Retrieve selected fields from a search\n++++\n<titleabbrev>Retrieve selected fields</titleabbrev>\n++++\n\nBy default, each hit in the search response includes the document\n<<mapping-source-field,`_source`>>, which is the entire JSON object that was\nprovided when indexing the document. There are two recommended methods to\nretrieve selected fields from a search query:\n\n* Use the <<search-fields-param,`fields` option>> to extract the values of\nfields present in the index mapping\n* Use the <<source-filtering,`_source` option>> if you need to access the original data that was passed at index time\n\nYou can use both of these methods, though the `fields` option is preferred\nbecause it consults both the document data and index mappings. In some\ninstances, you might want to use <<field-retrieval-methods,other methods>> of\nretrieving data.\n\n[discrete]\n[[search-fields-param]]\n==== The `fields` option\nTo retrieve specific fields in the search response, use the `fields` parameter.\n// tag::fields-param-desc[]\nBecause it consults the index mappings, the `fields` parameter provides several\nadvantages over referencing the `_source` directly. Specifically, the `fields`\nparameter:\n\n* Returns each value in a standardized way that matches its mapping type\n* Accepts <<multi-fields,multi-fields>> and <<field-alias,field aliases>>\n* Formats dates and spatial data types\n* Retrieves <<runtime-retrieving-fields,runtime field values>>\n* Returns fields calculated by a script at index time\n* Returns fields from related indices using <<lookup-runtime-fields, lookup runtime fields>>\n// end::fields-param-desc[]\n\nOther mapping options are also respected, including\n<<ignore-above,`ignore_above`>>, <<ignore-malformed,`ignore_malformed`>>, and\n<<null-value,`null_value`>>.\n\nThe `fields` option returns values in the way that matches how {es} indexes\nthem. For standard fields, this means that the `fields` option looks in\n`_source` to find the values, then parses and formats them using the mappings.\nSelected fields that can't be found in `_source` are skipped.\n\n[discrete]\n[[search-fields-request]]\n===== Retrieve specific fields\nThe following search request uses the `fields` parameter to retrieve values\nfor the `user.id` field, all fields starting with `http.response.`, and the\n`@timestamp` field.\n\nUsing object notation, you can pass a <<search-api-fields,`format`>> argument to\ncustomize the format of returned date or geospatial values.\n\n[source,console]\n----\nPOST my-index-000001/_search\n{\n  \"query\": {\n    \"match\": {\n      \"user.id\": \"kimchy\"\n    }\n  },\n  \"fields\": [\n    \"user.id\",\n    \"http.response.*\",         <1>\n    {\n      \"field\": \"@timestamp\",\n      \"format\": \"epoch_millis\" <2>\n    }\n  ],\n  \"_source\": false\n}\n----\n// TEST[setup:my_index]\n// TEST[s/_search/_search\\?filter_path=hits/]\n\n// tag::fields-param-callouts[]\n<1> Both full field names and wildcard patterns are accepted.\n<2> Use the `format` parameter to apply a custom format for the field's values.\n// end::fields-param-callouts[]\n\nNOTE: By default, document metadata fields like `_id` or `_index` are not\nreturned when the requested `fields` option uses wildcard patterns like `*`.\nHowever, when explicitly requested using the field name, the `_id`, `_routing`,\n`_ignored`, `_index` and `_version` metadata fields can be retrieved.\n\n[discrete]\n[[search-fields-response]]\n===== Response always returns an array\n\nThe `fields` response always returns an array of values for each field,\neven when there is a single value in the `_source`. This is because {es} has\nno dedicated array type, and any field could contain multiple values. The\n`fields` parameter also does not guarantee that array values are returned in\na specific order. See the mapping documentation on <<array,arrays>> for more\nbackground.\n\nThe response includes values as a flat list in the `fields` section for each\nhit. Because the `fields` parameter doesn't fetch entire objects, only leaf\nfields are returned.\n\n[source,console-result]\n----\n{\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"0\",\n        \"_score\" : 1.0,\n        \"fields\" : {\n          \"user.id\" : [\n            \"kimchy\"\n          ],\n          \"@timestamp\" : [\n            \"4098435132000\"\n          ],\n          \"http.response.bytes\": [\n            1070000\n          ],\n          \"http.response.status_code\": [\n            200\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"max_score\" : 1.0/\"max_score\" : $body.hits.max_score/]\n// TESTRESPONSE[s/\"_score\" : 1.0/\"_score\" : $body.hits.hits.0._score/]\n\n[discrete]\n[[search-fields-nested]]\n===== Retrieve nested fields\n\n[%collapsible]\n====\nThe `fields` response for <<nested,`nested` fields>> is slightly different from that\nof regular object fields. While leaf values inside regular `object` fields are\nreturned as a flat list, values inside `nested` fields are grouped to maintain the\nindependence of each object inside the original nested array.\nFor each entry inside a nested field array, values are again returned as a flat list\nunless there are other `nested` fields inside the parent nested object, in which case\nthe same procedure is repeated again for the deeper nested fields.\n\nGiven the following mapping where `user` is a nested field, after indexing\nthe following document and retrieving all fields under the `user` field:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"group\" : { \"type\" : \"keyword\" },\n      \"user\": {\n        \"type\": \"nested\",\n        \"properties\": {\n          \"first\" : { \"type\" : \"keyword\" },\n          \"last\" : { \"type\" : \"keyword\" }\n        }\n      }\n    }\n  }\n}\n\nPUT my-index-000001/_doc/1?refresh=true\n{\n  \"group\" : \"fans\",\n  \"user\" : [\n    {\n      \"first\" : \"John\",\n      \"last\" :  \"Smith\"\n    },\n    {\n      \"first\" : \"Alice\",\n      \"last\" :  \"White\"\n    }\n  ]\n}\n\nPOST my-index-000001/_search\n{\n  \"fields\": [\"*\"],\n  \"_source\": false\n}\n--------------------------------------------------\n\nThe response will group `first` and `last` name instead of\nreturning them as a flat list.\n\n[source,console-result]\n----\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.0,\n    \"hits\": [{\n      \"_index\": \"my-index-000001\",\n      \"_id\": \"1\",\n      \"_score\": 1.0,\n      \"fields\": {\n        \"group\" : [\"fans\"],\n        \"user\": [{\n            \"first\": [\"John\"],\n            \"last\": [\"Smith\"]\n          },\n          {\n            \"first\": [\"Alice\"],\n            \"last\": [\"White\"]\n          }\n        ]\n      }\n    }]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 2/\"took\": $body.took/]\n// TESTRESPONSE[s/\"max_score\" : 1.0/\"max_score\" : $body.hits.max_score/]\n// TESTRESPONSE[s/\"_score\" : 1.0/\"_score\" : $body.hits.hits.0._score/]\n\nNested fields will be grouped by their nested paths, no matter the pattern used\nto retrieve them. For example, if you query only for the `user.first` field from\nthe previous example:\n\n[source,console]\n--------------------------------------------------\nPOST my-index-000001/_search\n{\n  \"fields\": [\"user.first\"],\n  \"_source\": false\n}\n--------------------------------------------------\n// TEST[continued]\n\nThe response returns only the user's first name, but still maintains the\nstructure of the nested `user` array:\n\n[source,console-result]\n----\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.0,\n    \"hits\": [{\n      \"_index\": \"my-index-000001\",\n      \"_id\": \"1\",\n      \"_score\": 1.0,\n      \"fields\": {\n        \"user\": [{\n            \"first\": [\"John\"]\n          },\n          {\n            \"first\": [\"Alice\"]\n          }\n        ]\n      }\n    }]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 2/\"took\": $body.took/]\n// TESTRESPONSE[s/\"max_score\" : 1.0/\"max_score\" : $body.hits.max_score/]\n// TESTRESPONSE[s/\"_score\" : 1.0/\"_score\" : $body.hits.hits.0._score/]\n\nHowever, when the `fields` pattern targets the nested `user` field directly, no\nvalues will be returned because the pattern doesn't match any leaf fields.\n====\n\n[discrete]\n[[retrieve-unmapped-fields]]\n===== Retrieve unmapped fields\n\n[%collapsible]\n====\nBy default, the `fields` parameter returns only values of mapped fields.\nHowever, {es} allows storing fields in `_source` that are unmapped, such as\nsetting <<dynamic-field-mapping,dynamic field mapping>> to `false` or by using\nan object field with `enabled: false`. These options disable parsing and\nindexing of the object content.\n\nTo retrieve unmapped fields in an object from `_source`, use the\n`include_unmapped` option in the `fields` section:\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"enabled\": false <1>\n  }\n}\n\nPUT my-index-000001/_doc/1?refresh=true\n{\n  \"user_id\": \"kimchy\",\n  \"session_data\": {\n     \"object\": {\n       \"some_field\": \"some_value\"\n     }\n   }\n}\n\nPOST my-index-000001/_search\n{\n  \"fields\": [\n    \"user_id\",\n    {\n      \"field\": \"session_data.object.*\",\n      \"include_unmapped\" : true <2>\n    }\n  ],\n  \"_source\": false\n}\n----\n\n<1> Disable all mappings.\n<2> Include unmapped fields matching this field pattern.\n\nThe response will contain field results under the  `session_data.object.*` path,\neven if the fields are unmapped. The `user_id` field is also unmapped, but it\nwon't be included in the response because `include_unmapped` isn't set to\n`true` for that field pattern.\n\n[source,console-result]\n----\n{\n  \"took\" : 2,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"1\",\n        \"_score\" : 1.0,\n        \"fields\" : {\n          \"session_data.object.some_field\": [\n            \"some_value\"\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\" : 2/\"took\": $body.took/]\n// TESTRESPONSE[s/\"max_score\" : 1.0/\"max_score\" : $body.hits.max_score/]\n// TESTRESPONSE[s/\"_score\" : 1.0/\"_score\" : $body.hits.hits.0._score/]\n====\n\n[discrete]\n[[ignored-field-values]]\n===== Ignored field values\n\n[%collapsible]\n====\nThe `fields` section of the response only returns values that were valid when indexed.\nIf your search request asks for values from a field that ignored certain values\nbecause they were malformed or too large these values are returned\nseparately in an `ignored_field_values` section.\n\nIn this example we index a document that has a value which is ignored and\nnot added to the index so is shown separately in search results:\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my-small\" : { \"type\" : \"keyword\", \"ignore_above\": 2 }, <1>\n      \"my-large\" : { \"type\" : \"keyword\" }\n    }\n  }\n}\n\nPUT my-index-000001/_doc/1?refresh=true\n{\n  \"my-small\": [\"ok\", \"bad\"], <2>\n  \"my-large\": \"ok content\"\n}\n\nPOST my-index-000001/_search\n{\n  \"fields\": [\"my-*\"],\n  \"_source\": false\n}\n----\n\n<1> This field has a size restriction\n<2> This document field has a value that exceeds the size restriction so is ignored and not indexed\n\nThe response will contain ignored field values under the  `ignored_field_values` path.\nThese values are retrieved from the document's original JSON source and are raw so will\nnot be formatted or treated in any way, unlike the successfully indexed fields which are\nreturned in the `fields` section.\n\n[source,console-result]\n----\n{\n  \"took\" : 2,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index-000001\",\n        \"_id\" : \"1\",\n        \"_score\" : 1.0,\n        \"_ignored\" : [ \"my-small\"],\n        \"fields\" : {\n          \"my-large\": [\n            \"ok content\"\n          ],\n          \"my-small\": [\n            \"ok\"\n          ]\n        },\n        \"ignored_field_values\" : {\n          \"my-small\": [\n            \"bad\"\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\" : 2/\"took\": $body.took/]\n// TESTRESPONSE[s/\"max_score\" : 1.0/\"max_score\" : $body.hits.max_score/]\n// TESTRESPONSE[s/\"_score\" : 1.0/\"_score\" : $body.hits.hits.0._score/]\n====\n\n[discrete]\n[[source-filtering]]\n=== The `_source` option\nYou can use the `_source` parameter to select what fields of the source are\nreturned. This is called _source filtering_.\n\nThe following search API request sets the `_source` request body parameter to\n`false`. The document source is not included in the response.\n\n[source,console]\n----\nGET /_search\n{\n  \"_source\": false,\n  \"query\": {\n    \"match\": {\n      \"user.id\": \"kimchy\"\n    }\n  }\n}\n----\n\nTo return only a subset of source fields, specify a wildcard (`*`) pattern in\nthe `_source` parameter. The following search API request returns the source for\nonly the `obj` field and its properties.\n\n[source,console]\n----\nGET /_search\n{\n  \"_source\": \"obj.*\",\n  \"query\": {\n    \"match\": {\n      \"user.id\": \"kimchy\"\n    }\n  }\n}\n----\n\nYou can also specify an array of wildcard patterns in the `_source` field. The\nfollowing search API request returns the source for only the `obj1` and\n`obj2` fields and their properties.\n\n[source,console]\n----\nGET /_search\n{\n  \"_source\": [ \"obj1.*\", \"obj2.*\" ],\n  \"query\": {\n    \"match\": {\n      \"user.id\": \"kimchy\"\n    }\n  }\n}\n----\n\nFor finer control, you can specify an object containing arrays of `includes` and\n`excludes` patterns in the `_source` parameter.\n\nIf the `includes` property is specified, only source fields that match one of\nits patterns are returned. You can exclude fields from this subset using the\n`excludes` property.\n\nIf the `includes` property is not specified, the entire document source is\nreturned, excluding any fields that match a pattern in the `excludes` property.\n\nThe following search API request returns the source for only the `obj1` and\n`obj2` fields and their properties, excluding any child `description` fields.\n\n[source,console]\n----\nGET /_search\n{\n  \"_source\": {\n    \"includes\": [ \"obj1.*\", \"obj2.*\" ],\n    \"excludes\": [ \"*.description\" ]\n  },\n  \"query\": {\n    \"term\": {\n      \"user.id\": \"kimchy\"\n    }\n  }\n}\n----\n\n[discrete]\n[[field-retrieval-methods]]\n==== Other methods of retrieving data\n\n.Using `fields` is typically better\n****\nThese options are usually not required. Using the `fields` option is typically\nthe better choice, unless you absolutely need to force loading a stored or\n`docvalue_fields`.\n****\n\nA document's `_source` is stored as a single field in Lucene. This structure\nmeans that the whole `_source` object must be loaded and parsed even if you're\nonly requesting part of it. To avoid this limitation, you can try other options\nfor loading fields:\n\n* Use the <<docvalue-fields,`docvalue_fields`>>\nparameter to get values for selected fields. This can be a good\nchoice when returning a fairly small number of fields that support doc values,\nsuch as keywords and dates.\n* Use the <<stored-fields, `stored_fields`>> parameter to\nget the values for specific stored fields (fields that use the\n<<mapping-store,`store`>> mapping option).\n\n{es} always attempts to load values from `_source`. This behavior has the same\nimplications of source filtering where {es} needs to load and parse the entire\n`_source` to retrieve just one field.\n\n[discrete]\n[[docvalue-fields]]\n===== Doc value fields\n\nYou can use the <<docvalue-fields,`docvalue_fields`>> parameter to return\n<<doc-values,doc values>> for one or more fields in the search response.\n\nDoc values store the same values as the `_source` but in an on-disk,\ncolumn-based structure that's optimized for sorting and aggregations. Since each\nfield is stored separately, {es} only reads the field values that were requested\nand can avoid loading the whole document `_source`.\n\nDoc values are stored for supported fields by default. However, doc values are\nnot supported for <<text,`text`>> or\n{plugins}/mapper-annotated-text-usage.html[`text_annotated`] fields.\n\nThe following search request uses the `docvalue_fields` parameter to retrieve\ndoc values for the `user.id` field, all fields starting with `http.response.`, and the\n`@timestamp` field:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"match\": {\n      \"user.id\": \"kimchy\"\n    }\n  },\n  \"docvalue_fields\": [\n    \"user.id\",\n    \"http.response.*\", <1>\n    {\n      \"field\": \"date\",\n      \"format\": \"epoch_millis\" <2>\n    }\n  ]\n}\n----\n// TEST[setup:my_index]\n\n<1> Both full field names and wildcard patterns are accepted.\n<2> Using object notation, you can pass a `format` parameter to apply a custom\n    format for the field's doc values. <<date,Date fields>> support a\n    <<mapping-date-format,date `format`>>. <<number,Numeric fields>> support a\n    https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html[DecimalFormat\n    pattern]. Other field datatypes do not support the `format` parameter.\n\nTIP: You cannot use the `docvalue_fields` parameter to retrieve doc values for\nnested objects. If you specify a nested object, the search returns an empty\narray (`[ ]`) for the field. To access nested fields, use the\n<<inner-hits, `inner_hits`>> parameter's `docvalue_fields`\nproperty.\n\n[discrete]\n[[stored-fields]]\n===== Stored fields\n\nIt's also possible to store an individual field's values by using the\n<<mapping-store,`store`>> mapping option. You can use the\n`stored_fields` parameter to include these stored values in the search response.\n\nWARNING: The `stored_fields` parameter is for fields that are explicitly marked as\nstored in the mapping, which is off by default and generally not recommended.\nUse <<source-filtering,source filtering>> instead to select\nsubsets of the original source document to be returned.\n\nAllows to selectively load specific stored fields for each document represented\nby a search hit.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"stored_fields\" : [\"user\", \"postDate\"],\n  \"query\" : {\n    \"term\" : { \"user\" : \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\n`*` can be used to load all stored fields from the document.\n\nAn empty array will cause only the `_id` and `_type` for each hit to be\nreturned, for example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"stored_fields\" : [],\n  \"query\" : {\n    \"term\" : { \"user\" : \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\nIf the requested fields are not stored (`store` mapping set to `false`), they will be ignored.\n\nStored field values fetched from the document itself are always returned as an array. On the contrary, metadata fields like `_routing` are never returned as an array.\n\nAlso only leaf fields can be returned via the `stored_fields` option. If an object field is specified, it will be ignored.\n\nNOTE: On its own, `stored_fields` cannot be used to load fields in nested\nobjects -- if a field contains a nested object in its path, then no data will\nbe returned for that stored field. To access nested fields, `stored_fields`\nmust be used within an <<inner-hits, `inner_hits`>> block.\n\n[discrete]\n[[disable-stored-fields]]\n====== Disable stored fields\n\nTo disable the stored fields (and metadata fields) entirely use: `_none_`:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"stored_fields\": \"_none_\",\n  \"query\" : {\n    \"term\" : { \"user\" : \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\nNOTE: <<source-filtering,`_source`>> and <<request-body-search-version, `version`>> parameters cannot be activated if `_none_` is used.\n\n[discrete]\n[[script-fields]]\n===== Script fields\n\nYou can use the `script_fields` parameter to retrieve a <<modules-scripting,script\nevaluation>> (based on different fields) for each hit. For example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"script_fields\": {\n    \"test1\": {\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"doc['price'].value * 2\"\n      }\n    },\n    \"test2\": {\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"doc['price'].value * params.factor\",\n        \"params\": {\n          \"factor\": 2.0\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nScript fields can work on fields that are not stored (`price` in\nthe above case), and allow to return custom values to be returned (the\nevaluated value of the script).\n\nScript fields can also access the actual `_source` document and\nextract specific elements to be returned from it by using `params['_source']`.\nHere is an example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"script_fields\": {\n    \"test1\": {\n      \"script\": \"params['_source']['message']\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nNote the `_source` keyword here to navigate the json-like model.\n\nIt's important to understand the difference between\n`doc['my_field'].value` and `params['_source']['my_field']`. The first,\nusing the doc keyword, will cause the terms for that field to be loaded to\nmemory (cached), which will result in faster execution, but more memory\nconsumption. Also, the `doc[...]` notation only allows for simple valued\nfields (you can't return a json object from it) and makes sense only for\nnon-analyzed or single term based fields. However, using `doc` is\nstill the recommended way to access values from the document, if at all\npossible, because `_source` must be loaded and parsed every time it's used.\nUsing `_source` is very slow.\n"
}