{
    "meta": {
        "timestamp": "2024-11-01T02:49:24.562069",
        "size": 6145,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "query-dsl-bool-query",
        "version": "8.15"
    },
    "doc": "[[query-dsl-bool-query]]\n=== Boolean query\n++++\n<titleabbrev>Boolean</titleabbrev>\n++++\n\nA query that matches documents matching boolean combinations of other\nqueries. The bool query maps to Lucene `BooleanQuery`. It is built using\none or more boolean clauses, each clause with a typed occurrence. The\noccurrence types are:\n\n[cols=\"<,<\",options=\"header\",]\n|=======================================================================\n|Occur |Description\n|`must` |The clause (query) must appear in matching documents and will\ncontribute to the score.\n\n|`filter` |The clause (query) must appear in matching documents. However unlike\n`must` the score of the query will be ignored. Filter clauses are executed\nin <<query-filter-context,filter context>>, meaning that scoring is ignored\nand clauses are considered for caching.\n\n|`should` |The clause (query) should appear in the matching document.\n\n|`must_not` |The clause (query) must not appear in the matching\ndocuments. Clauses are executed in <<query-filter-context,filter context>> meaning\nthat scoring is ignored and clauses are considered for caching. Because scoring is\nignored, a score of `0` for all documents is returned.\n|=======================================================================\n\nThe `bool` query takes a _more-matches-is-better_ approach, so the score from\neach matching `must` or `should` clause will be added together to provide the\nfinal `_score` for each document.\n\n[source,console]\n--------------------------------------------------\nPOST _search\n{\n  \"query\": {\n    \"bool\" : {\n      \"must\" : {\n        \"term\" : { \"user.id\" : \"kimchy\" }\n      },\n      \"filter\": {\n        \"term\" : { \"tags\" : \"production\" }\n      },\n      \"must_not\" : {\n        \"range\" : {\n          \"age\" : { \"gte\" : 10, \"lte\" : 20 }\n        }\n      },\n      \"should\" : [\n        { \"term\" : { \"tags\" : \"env1\" } },\n        { \"term\" : { \"tags\" : \"deployed\" } }\n      ],\n      \"minimum_should_match\" : 1,\n      \"boost\" : 1.0\n    }\n  }\n}\n--------------------------------------------------\n\n[[bool-min-should-match]]\n==== Using `minimum_should_match`\n\nYou can use the `minimum_should_match` parameter to specify the number or\npercentage of `should` clauses returned documents _must_ match.\n\nIf the `bool` query includes at least one `should` clause and no `must` or\n`filter` clauses, the default value is `1`.\nOtherwise, the default value is `0`.\n\nFor other valid values, see the\n<<query-dsl-minimum-should-match, `minimum_should_match` parameter>>.\n\n[[score-bool-filter]]\n==== Scoring with `bool.filter`\n\nQueries specified under the `filter` element have no effect on scoring --\nscores are returned as `0`. Scores are only affected by the query that has\nbeen specified. For instance, all three of the following queries return\nall documents where the `status` field contains the term `active`.\n\nThis first query assigns a score of `0` to all documents, as no scoring\nquery has been specified:\n\n[source,console]\n---------------------------------\nGET _search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": {\n        \"term\": {\n          \"status\": \"active\"\n        }\n      }\n    }\n  }\n}\n---------------------------------\n\nThis `bool` query has a `match_all` query, which assigns a score of `1.0` to\nall documents.\n\n[source,console]\n---------------------------------\nGET _search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": {\n        \"match_all\": {}\n      },\n      \"filter\": {\n        \"term\": {\n          \"status\": \"active\"\n        }\n      }\n    }\n  }\n}\n---------------------------------\n\nThis `constant_score` query behaves in exactly the same way as the second example above.\nThe `constant_score` query assigns a score of `1.0` to all documents matched\nby the filter.\n\n[source,console]\n---------------------------------\nGET _search\n{\n  \"query\": {\n    \"constant_score\": {\n      \"filter\": {\n        \"term\": {\n          \"status\": \"active\"\n        }\n      }\n    }\n  }\n}\n---------------------------------\n\n[[named-queries]]\n==== Named queries\n\nEach query accepts a `_name` in its top level definition. You can use named\nqueries to track which queries matched returned documents. If named queries are\nused, the response includes a `matched_queries` property for each hit.\n\nNOTE: Supplying duplicate `_name` values in the same request results in undefined behavior. Queries with duplicate names may overwrite\neach other. Query names are assumed to be unique within a single request.\n\n[source,console]\n----\nGET /_search\n{\n  \"query\": {\n    \"bool\": {\n      \"should\": [\n        { \"match\": { \"name.first\": { \"query\": \"shay\", \"_name\": \"first\" } } },\n        { \"match\": { \"name.last\": { \"query\": \"banon\", \"_name\": \"last\" } } }\n      ],\n      \"filter\": {\n        \"terms\": {\n          \"name.last\": [ \"banon\", \"kimchy\" ],\n          \"_name\": \"test\"\n        }\n      }\n    }\n  }\n}\n----\n\nThe request parameter named `include_named_queries_score` controls whether scores associated\nwith the matched queries are returned or not. When set, the response includes a `matched_queries`\nmap that contains the name of the query that matched as a key and its associated score as the value.\n\nWARNING: Note that the score might not have contributed to the final score of the document, for instance named queries that appear\nin a filter or must_not contexts, or inside a clause that ignores or modifies the score like `constant_score` or `function_score_query`.\n\n[source,console]\n----\nGET /_search?include_named_queries_score\n{\n  \"query\": {\n    \"bool\": {\n      \"should\": [\n        { \"match\": { \"name.first\": { \"query\": \"shay\", \"_name\": \"first\" } } },\n        { \"match\": { \"name.last\": { \"query\": \"banon\", \"_name\": \"last\" } } }\n      ],\n      \"filter\": {\n        \"terms\": {\n          \"name.last\": [ \"banon\", \"kimchy\" ],\n          \"_name\": \"test\"\n        }\n      }\n    }\n  }\n}\n----\n\nNOTE: This functionality reruns each named query on every hit in a search\nresponse. Typically, this adds a small overhead to a request. However, using\ncomputationally expensive named queries on a large number of hits may add\nsignificant overhead. For example, named queries in combination with a\n`top_hits` aggregation on many buckets may lead to longer response times.\n"
}