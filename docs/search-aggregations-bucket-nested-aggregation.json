{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.761068",
        "size": 3210,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-nested-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "search-aggregations-bucket-nested-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-nested-aggregation]]\n=== Nested aggregation\n++++\n<titleabbrev>Nested</titleabbrev>\n++++\n\nA special single bucket aggregation that enables aggregating nested documents.\n\nFor example, lets say we have an index of products, and each product holds the list of resellers - each having its own\nprice for the product. The mapping could look like:\n\n[source,console,id=nested-aggregation-example]\n----\nPUT /products\n{\n  \"mappings\": {\n    \"properties\": {\n      \"resellers\": { <1>\n        \"type\": \"nested\",\n        \"properties\": {\n          \"reseller\": {\n            \"type\": \"keyword\"\n          },\n          \"price\": {\n            \"type\": \"double\"\n          }\n        }\n      }\n    }\n  }\n}\n----\n<1> `resellers` is an array that holds nested documents.\n\nThe following request adds a product with two resellers:\n\n[source,console]\n----\nPUT /products/_doc/0?refresh\n{\n  \"name\": \"LED TV\", <1>\n  \"resellers\": [\n    {\n      \"reseller\": \"companyA\",\n      \"price\": 350\n    },\n    {\n      \"reseller\": \"companyB\",\n      \"price\": 500\n    }\n  ]\n}\n----\n// TEST[continued]\n\n<1> We are using a dynamic mapping for the `name` attribute.\n\n\nThe following request returns the minimum price a product can be purchased for:\n\n[source,console]\n----\nGET /products/_search?size=0\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"led tv\"\n    }\n  },\n  \"aggs\": {\n    \"resellers\": {\n      \"nested\": {\n        \"path\": \"resellers\"\n      },\n      \"aggs\": {\n        \"min_price\": {\n          \"min\": {\n            \"field\": \"resellers.price\"\n          }\n        }\n      }\n    }\n  }\n}\n----\n// TEST[s/size=0/size=0&filter_path=aggregations/]\n// TEST[continued]\n\nAs you can see above, the nested aggregation requires the `path` of the nested documents within the top level documents.\nThen one can define any type of aggregation over these nested documents.\n\nResponse:\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"resellers\": {\n      \"doc_count\": 2,\n      \"min_price\": {\n        \"value\": 350.0\n      }\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\.//]\n\nYou can use a <<search-aggregations-bucket-filter-aggregation,`filter`>>\nsub-aggregation to return results for a specific reseller.\n\n[source,console]\n----\nGET /products/_search?size=0\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"led tv\"\n    }\n  },\n  \"aggs\": {\n    \"resellers\": {\n      \"nested\": {\n        \"path\": \"resellers\"\n      },\n      \"aggs\": {\n        \"filter_reseller\": {\n          \"filter\": {\n            \"bool\": {\n              \"filter\": [\n                {\n                  \"term\": {\n                    \"resellers.reseller\": \"companyB\"\n                  }\n                }\n              ]\n            }\n          },\n          \"aggs\": {\n            \"min_price\": {\n              \"min\": {\n                \"field\": \"resellers.price\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n----\n// TEST[s/size=0/size=0&filter_path=aggregations/]\n// TEST[continued]\n\nThe search returns:\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"resellers\": {\n      \"doc_count\": 2,\n      \"filter_reseller\": {\n        \"doc_count\": 1,\n        \"min_price\": {\n          \"value\": 500.0\n        }\n      }\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\.//]\n"
}