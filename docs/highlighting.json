{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.404272",
        "size": 35465,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/highlighting.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "highlighting",
        "version": "8.15"
    },
    "doc": "[[highlighting]]\n=== Highlighting\n\nHighlighters enable you to get highlighted snippets from one or more fields\nin your search results so you can show users where the query matches are.\nWhen you request highlights, the response contains an additional `highlight`\nelement for each search hit that includes the highlighted fields and the\nhighlighted fragments.\n\nNOTE: Highlighters don't reflect the boolean logic of a query when extracting\n terms to highlight. Thus, for some complex boolean queries (e.g nested boolean\n queries, queries using `minimum_should_match` etc.), parts of documents may be\n highlighted that don't correspond to query matches.\n\nHighlighting requires the actual content of a field. If the field is not\nstored (the mapping does not set `store` to `true`), the actual `_source` is\nloaded and the relevant field is extracted from `_source`.\n\nFor example, to get highlights for the `content` field in each search hit\nusing the default highlighter, include a `highlight` object in\nthe request body that specifies the `content` field:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"match\": { \"content\": \"kimchy\" }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"content\": {}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n{es} supports three highlighters: `unified`, `plain`, and `fvh` (fast vector\nhighlighter). You can specify the highlighter `type` you want to use\nfor each field.\n\n[discrete]\n[[unified-highlighter]]\n==== Unified highlighter\nThe `unified` highlighter uses the Lucene Unified Highlighter. This\nhighlighter breaks the text into sentences and uses the BM25 algorithm to score\nindividual sentences as if they were documents in the corpus. It also supports\naccurate phrase and multi-term (fuzzy, prefix, regex) highlighting. The `unified`\nhighlighter can combine matches from multiple fields into one result (see\n`matched_fields`). This is the default highlighter.\n\n[discrete]\n[[plain-highlighter]]\n==== Plain highlighter\nThe `plain` highlighter uses the standard Lucene highlighter. It attempts to\nreflect the query matching logic in terms of understanding word importance and\nany word positioning criteria in phrase queries.\n\n[WARNING]\nThe `plain` highlighter works best for highlighting simple query matches in a\nsingle field. To accurately reflect query logic, it creates a tiny in-memory\nindex and re-runs the original query criteria through Lucene's query execution\nplanner to get access to low-level match information for the current document.\nThis is repeated for every field and every document that needs to be highlighted.\nIf you want to highlight a lot of fields in a lot of documents with complex\nqueries, we recommend using the `unified` highlighter on `postings` or `term_vector` fields.\n\n[discrete]\n[[fast-vector-highlighter]]\n==== Fast vector highlighter\nThe `fvh` highlighter uses the Lucene Fast Vector highlighter.\nThis highlighter can be used on fields with `term_vector` set to\n`with_positions_offsets` in the mapping. The fast vector highlighter:\n\n* Can be customized with a <<boundary-scanners,`boundary_scanner`>>.\n* Requires setting `term_vector` to `with_positions_offsets` which\n  increases the size of the index\n* Can combine matches from multiple fields into one result. See\n  `matched_fields`\n* Can assign different weights to matches at different positions allowing\n  for things like phrase matches being sorted above term matches when\n  highlighting a Boosting Query that boosts phrase matches over term matches\n\n[WARNING]\nThe `fvh` highlighter does not support span queries. If you need support for\nspan queries, try an alternative highlighter, such as the `unified` highlighter.\n\n[discrete]\n[[offsets-strategy]]\n==== Offsets strategy\nTo create meaningful search snippets from the terms being queried,\nthe highlighter needs to know the start and end character offsets of each word\nin the original text. These offsets can be obtained from:\n\n* The postings list. If `index_options` is set to `offsets` in the mapping,\nthe `unified` highlighter uses this information to highlight documents without\nre-analyzing the text. It re-runs the original query directly on the postings\nand extracts the matching offsets from the index, limiting the collection to\nthe highlighted documents. This is important if you have large fields because\nit doesn't require reanalyzing the text to be highlighted. It also requires less\ndisk space than using `term_vectors`.\n\n* Term vectors. If `term_vector` information is provided by setting\n`term_vector` to `with_positions_offsets` in the mapping, the `unified`\nhighlighter automatically uses the `term_vector` to highlight the field.\nIt's fast especially for large fields (> `1MB`) and for highlighting multi-term queries like\n`prefix` or `wildcard` because it can access the dictionary of terms for each document.\nThe `fvh` highlighter always uses term vectors.\n\n* Plain highlighting. This mode is used by the `unified` when there is no other alternative.\nIt creates a tiny in-memory index and re-runs the original query criteria through\nLucene's query execution planner to get access to low-level match information on\nthe current document. This is repeated for every field and every document that\nneeds highlighting. The `plain` highlighter always uses plain highlighting.\n\n[WARNING]\nPlain highlighting for large texts may require substantial amount of time and memory.\nTo protect against this, the maximum number of text characters that will be analyzed has been\nlimited to 1000000. This default limit can be changed\nfor a particular index with the index setting <<index-max-analyzed-offset,`index.highlight.max_analyzed_offset`>>.\n\n[discrete]\n[[highlighting-settings]]\n==== Highlighting settings\n\nHighlighting settings can be set on a global level and overridden at\nthe field level.\n\nboundary_chars:: A string that contains each boundary character.\nDefaults to `.,!? \\t\\n`.\n\nboundary_max_scan:: How far to scan for boundary characters. Defaults to `20`.\n\n[[boundary-scanners]]\nboundary_scanner:: Specifies how to break the highlighted fragments: `chars`,\n`sentence`, or `word`. Only valid for the `unified` and `fvh` highlighters.\nDefaults to `sentence` for the `unified` highlighter. Defaults to `chars` for\nthe `fvh` highlighter.\n`chars`::: Use the characters specified by `boundary_chars` as highlighting\nboundaries. The `boundary_max_scan` setting controls how far to scan for\nboundary characters. Only valid for the `fvh` highlighter.\n`sentence`::: Break highlighted fragments at the next sentence boundary, as\ndetermined by Java's\nhttps://docs.oracle.com/javase/8/docs/api/java/text/BreakIterator.html[BreakIterator].\nYou can specify the locale to use with `boundary_scanner_locale`.\n+\nNOTE: When used with the `unified` highlighter, the `sentence` scanner splits\nsentences bigger than `fragment_size` at the first word boundary next to\n`fragment_size`. You can set `fragment_size` to 0 to never split any sentence.\n\n`word`::: Break highlighted fragments at the next word boundary, as determined\nby Java's https://docs.oracle.com/javase/8/docs/api/java/text/BreakIterator.html[BreakIterator].\nYou can specify the locale to use with `boundary_scanner_locale`.\n\nboundary_scanner_locale:: Controls which locale is used to search for sentence\nand word boundaries. This parameter takes a form of a language tag,\ne.g. `\"en-US\"`,  `\"fr-FR\"`, `\"ja-JP\"`. More info can be found in the\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#forLanguageTag-java.lang.String-[Locale Language Tag]\ndocumentation. The default value is https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#ROOT[ Locale.ROOT].\n\nencoder:: Indicates if the snippet should be HTML encoded:\n`default` (no encoding) or `html` (HTML-escape the snippet text and then\ninsert the highlighting tags)\n\nfields:: Specifies the fields to retrieve highlights for. You can use wildcards\nto specify fields. For example, you could specify `comment_*` to\nget highlights for all <<text,text>>, <<match-only-text-field-type,match_only_text>>,\nand <<keyword,keyword>> fields that start with `comment_`.\n+\nNOTE: Only text, match_only_text, and keyword fields are highlighted when\nyou use wildcards. If you use a custom mapper and want to highlight on a\nfield anyway, you must explicitly specify that field name.\n\nfragmenter:: Specifies how text should be broken up in highlight\nsnippets: `simple` or `span`. Only valid for the `plain` highlighter.\nDefaults to `span`.\n\nforce_source:: deprecated; this parameter has no effect\n\n`simple`::: Breaks up text into same-sized fragments.\n`span`::: Breaks up text into same-sized fragments, but tries to avoid\nbreaking up text between highlighted terms. This is helpful when you're\nquerying for phrases. Default.\n\nfragment_offset:: Controls the margin from which you want to start\nhighlighting. Only valid when using the `fvh` highlighter.\n\nfragment_size:: The size of the highlighted fragment in characters. Defaults\nto 100.\n\nhighlight_query:: Highlight matches for a query other than the search\nquery. This is especially useful if you use a rescore query because\nthose are not taken into account by highlighting by default.\n+\nIMPORTANT: {es} does not validate that `highlight_query` contains\nthe search query in any way so it is possible to define it so\nlegitimate query results are not highlighted. Generally, you should\ninclude the search query as part of the `highlight_query`.\n\nmatched_fields:: Combine matches on multiple fields to highlight a single field.\nThis is most intuitive for multifields that analyze the same string in different\nways. Valid for the `unified` and fvh` highlighters, but the behavior of this\noption is different for each highlighter.\n\nFor the `unified` highlighter:\n\n- `matched_fields` array should **not** contain the original field that you want to highlight. The\noriginal field will be automatically added to the `matched_fields`, and there is no\nway to exclude its matches when highlighting.\n- `matched_fields` and the original field can be indexed with different strategies (with or\nwithout `offsets`, with or without `term_vectors`).\n- only the original field to which the matches are combined is loaded so only that field\nbenefits from having `store` set to `yes`\n\nFor the `fvh` highlighter:\n\n- `matched_fields` array may or may not contain the original field\ndepending on your needs. If you want to include the original field's matches in\nhighlighting, add it to the `matched_fields` array.\n- all `matched_fields` must have `term_vector` set to `with_positions_offsets`\n- only the original field to which the matches are combined is loaded so only that field\nbenefits from having `store` set to `yes`.\n\nno_match_size:: The amount of text you want to return from the beginning\nof the field if there are no matching fragments to highlight. Defaults\nto 0 (nothing is returned).\n\nnumber_of_fragments:: The maximum number of fragments to return. If the\nnumber of fragments is set to 0, no fragments are returned. Instead,\nthe entire field contents are highlighted and returned. This can be\nhandy when you need to highlight short texts such as a title or\naddress, but fragmentation is not required. If `number_of_fragments`\nis 0, `fragment_size` is ignored. Defaults to 5.\n\norder:: Sorts highlighted fragments by score when set to `score`. By default,\nfragments will be output in the order they appear in the field (order: `none`).\nSetting this option to `score` will output the most relevant fragments first.\nEach highlighter applies its own logic to compute relevancy scores. See\nthe document <<how-es-highlighters-work-internally, How highlighters work internally>>\nfor more details how different highlighters find the best fragments.\n\nphrase_limit:: Controls the number of matching phrases in a document that are\nconsidered. Prevents the `fvh` highlighter from analyzing too many phrases\nand consuming too much memory. When using `matched_fields`, `phrase_limit`\nphrases per matched field are considered. Raising the limit increases query\ntime and consumes more memory. Only supported by the `fvh` highlighter.\nDefaults to 256.\n\npre_tags:: Use in conjunction with `post_tags` to define the HTML tags\nto use for the highlighted text. By default, highlighted text is wrapped\nin `<em>` and `</em>` tags. Specify as an array of strings.\n\npost_tags:: Use in conjunction with `pre_tags` to define the HTML tags\nto use for the highlighted text. By default, highlighted text is wrapped\nin `<em>` and `</em>` tags. Specify as an array of strings.\n\nrequire_field_match:: By default, only fields that contains a query match are\nhighlighted. Set `require_field_match` to `false` to highlight all fields.\nDefaults to `true`.\n\n[[max-analyzed-offset]]\nmax_analyzed_offset:: By default, the maximum number of characters\nanalyzed for a highlight request is bounded by the value defined in the\n<<index-max-analyzed-offset, `index.highlight.max_analyzed_offset`>> setting,\nand when the number of characters exceeds this limit an error is returned. If\nthis setting is set to a non-negative value, the highlighting stops at this defined\nmaximum limit, and the rest of the text is not processed, thus not highlighted and\nno error is returned. The <<max-analyzed-offset, `max_analyzed_offset`>> query setting\ndoes *not* override the <<index-max-analyzed-offset, `index.highlight.max_analyzed_offset`>>\nwhich prevails when it's set to lower value than the query setting.\n\ntags_schema:: Set to `styled` to use the built-in tag schema. The `styled`\nschema defines the following `pre_tags` and defines `post_tags` as\n`</em>`.\n+\n[source,html]\n--------------------------------------------------\n<em class=\"hlt1\">, <em class=\"hlt2\">, <em class=\"hlt3\">,\n<em class=\"hlt4\">, <em class=\"hlt5\">, <em class=\"hlt6\">,\n<em class=\"hlt7\">, <em class=\"hlt8\">, <em class=\"hlt9\">,\n<em class=\"hlt10\">\n--------------------------------------------------\n\n[[highlighter-type]]\ntype:: The highlighter to use: `unified`, `plain`, or `fvh`. Defaults to\n`unified`.\n\n[discrete]\n[[highlighting-examples]]\n==== Highlighting examples\n\n* <<override-global-settings, Override global settings>>\n* <<specify-highlight-query, Specify a highlight query>>\n* <<set-highlighter-type, Set highlighter type>>\n* <<configure-tags, Configure highlighting tags>>\n* <<highlight-all, Highlight all fields>>\n* <<matched-fields, Combine matches on multiple fields>>\n* <<explicit-field-order, Explicitly order highlighted fields>>\n* <<control-highlighted-frags, Control highlighted fragments>>\n* <<highlight-postings-list, Highlight using the postings list>>\n* <<specify-fragmenter, Specify a fragmenter for the plain highlighter>>\n\n[[override-global-settings]]\n[discrete]\n== Override global settings\n\nYou can specify highlighter settings globally and selectively override them for\nindividual fields.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\" : {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\" : {\n    \"number_of_fragments\" : 3,\n    \"fragment_size\" : 150,\n    \"fields\" : {\n      \"body\" : { \"pre_tags\" : [\"<em>\"], \"post_tags\" : [\"</em>\"] },\n      \"blog.title\" : { \"number_of_fragments\" : 0 },\n      \"blog.author\" : { \"number_of_fragments\" : 0 },\n      \"blog.comment\" : { \"number_of_fragments\" : 5, \"order\" : \"score\" }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[discrete]\n[[specify-highlight-query]]\n=== Specify a highlight query\n\nYou can specify a `highlight_query` to take additional information into account\nwhen highlighting. For example, the following query includes both the search\nquery and rescore query in the `highlight_query`. Without the `highlight_query`,\nhighlighting would only take the search query into account.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"match\": {\n      \"comment\": {\n        \"query\": \"foo bar\"\n      }\n    }\n  },\n  \"rescore\": {\n    \"window_size\": 50,\n    \"query\": {\n      \"rescore_query\": {\n        \"match_phrase\": {\n          \"comment\": {\n            \"query\": \"foo bar\",\n            \"slop\": 1\n          }\n        }\n      },\n      \"rescore_query_weight\": 10\n    }\n  },\n  \"_source\": false,\n  \"highlight\": {\n    \"order\": \"score\",\n    \"fields\": {\n      \"comment\": {\n        \"fragment_size\": 150,\n        \"number_of_fragments\": 3,\n        \"highlight_query\": {\n          \"bool\": {\n            \"must\": {\n              \"match\": {\n                \"comment\": {\n                  \"query\": \"foo bar\"\n                }\n              }\n            },\n            \"should\": {\n              \"match_phrase\": {\n                \"comment\": {\n                  \"query\": \"foo bar\",\n                  \"slop\": 1,\n                  \"boost\": 10.0\n                }\n              }\n            },\n            \"minimum_should_match\": 0\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[discrete]\n[[set-highlighter-type]]\n=== Set highlighter type\n\nThe `type` field allows to force a specific highlighter type.\nThe allowed values are: `unified`, `plain` and `fvh`.\nThe following is an example that forces the use of the plain highlighter:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"comment\": { \"type\": \"plain\" }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[[configure-tags]]\n[discrete]\n=== Configure highlighting tags\n\nBy default, the highlighting will wrap highlighted text in `<em>` and\n`</em>`. This can be controlled by setting `pre_tags` and `post_tags`,\nfor example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\" : {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\" : {\n    \"pre_tags\" : [\"<tag1>\"],\n    \"post_tags\" : [\"</tag1>\"],\n    \"fields\" : {\n      \"body\" : {}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nWhen using the fast vector highlighter, you can specify additional tags and the\n\"importance\" is ordered.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\" : {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\" : {\n    \"pre_tags\" : [\"<tag1>\", \"<tag2>\"],\n    \"post_tags\" : [\"</tag1>\", \"</tag2>\"],\n    \"fields\" : {\n      \"body\" : {}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nYou can also use the built-in `styled` tag schema:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\" : {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\" : {\n    \"tags_schema\" : \"styled\",\n    \"fields\" : {\n      \"comment\" : {}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[[highlight-all]]\n[discrete]\n=== Highlight in all fields\n\nBy default, only fields that contains a query match are highlighted. Set\n`require_field_match` to `false` to highlight all fields.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\" : {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\" : {\n    \"require_field_match\": false,\n    \"fields\": {\n      \"body\" : { \"pre_tags\" : [\"<em>\"], \"post_tags\" : [\"</em>\"] }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[[matched-fields]]\n[discrete]\n=== Combine matches on multiple fields\n\nWARNING: Supported by the `unified` and `fvh` highlighters.\n\nThe Unified and Fast Vector Highlighter can combine matches on multiple fields to\nhighlight a single field. This is most intuitive for multifields that\nanalyze the same string in different ways.\n\ninclude::{es-ref-dir}/tab-widgets/highlighting-multi-fields-widget.asciidoc[]\n\n\n[NOTE]\nTechnically it is also fine to add fields to `matched_fields` that\ndon't share the same underlying string as the field to which the matches\nare combined. The results might not make much sense and if one of the\nmatches is off the end of the text then the whole query will fail.\n\n===================================================================\n\n\n[[explicit-field-order]]\n[discrete]\n=== Explicitly order highlighted fields\nElasticsearch highlights the fields in the order that they are sent, but per the\nJSON spec, objects are unordered. If you need to be explicit about the order\nin which fields are highlighted specify the `fields` as an array:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"highlight\": {\n    \"fields\": [\n      { \"title\": {} },\n      { \"text\": {} }\n    ]\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nNone of the highlighters built into Elasticsearch care about the order that the\nfields are highlighted but a plugin might.\n\n\n\n\n[discrete]\n[[control-highlighted-frags]]\n=== Control highlighted fragments\n\nEach field highlighted can control the size of the highlighted fragment\nin characters (defaults to `100`), and the maximum number of fragments\nto return (defaults to `5`).\nFor example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\" : {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\" : {\n    \"fields\" : {\n      \"comment\" : {\"fragment_size\" : 150, \"number_of_fragments\" : 3}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nOn top of this it is possible to specify that highlighted fragments need\nto be sorted by score:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\" : {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\" : {\n    \"order\" : \"score\",\n    \"fields\" : {\n      \"comment\" : {\"fragment_size\" : 150, \"number_of_fragments\" : 3}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nIf the `number_of_fragments` value is set to `0` then no fragments are\nproduced, instead the whole content of the field is returned, and of\ncourse it is highlighted. This can be very handy if short texts (like\ndocument title or address) need to be highlighted but no fragmentation\nis required. Note that `fragment_size` is ignored in this case.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\" : {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\" : {\n    \"fields\" : {\n      \"body\" : {},\n      \"blog.title\" : {\"number_of_fragments\" : 0}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nWhen using `fvh` one can use `fragment_offset`\nparameter to control the margin to start highlighting from.\n\nIn the case where there is no matching fragment to highlight, the default is\nto not return anything. Instead, we can return a snippet of text from the\nbeginning of the field by setting `no_match_size` (default `0`) to the length\nof the text that you want returned. The actual length may be shorter or longer than\nspecified as it tries to break on a word boundary.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"match\": { \"user.id\": \"kimchy\" }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"comment\": {\n        \"fragment_size\": 150,\n        \"number_of_fragments\": 3,\n        \"no_match_size\": 150\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[discrete]\n[[highlight-postings-list]]\n=== Highlight using the postings list\n\nHere is an example of setting the `comment` field in the index mapping to\nallow for highlighting using the postings:\n\n[source,console]\n--------------------------------------------------\nPUT /example\n{\n  \"mappings\": {\n    \"properties\": {\n      \"comment\" : {\n        \"type\": \"text\",\n        \"index_options\" : \"offsets\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nHere is an example of setting the `comment` field to allow for\nhighlighting using the `term_vectors` (this will cause the index to be bigger):\n\n[source,console]\n--------------------------------------------------\nPUT /example\n{\n  \"mappings\": {\n    \"properties\": {\n      \"comment\" : {\n        \"type\": \"text\",\n        \"term_vector\" : \"with_positions_offsets\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n[discrete]\n[[specify-fragmenter]]\n=== Specify a fragmenter for the plain highlighter\n\nWhen using the `plain` highlighter, you can choose between the `simple` and\n`span` fragmenters:\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"match_phrase\": { \"message\": \"number 1\" }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"message\": {\n        \"type\": \"plain\",\n        \"fragment_size\": 15,\n        \"number_of_fragments\": 3,\n        \"fragmenter\": \"simple\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:messages]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"hits\": {\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.6011951,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"1\",\n        \"_score\": 1.6011951,\n        \"_source\": {\n          \"message\": \"some message with the number 1\",\n          \"context\": \"bar\"\n        },\n        \"highlight\": {\n          \"message\": [\n            \" with the <em>number</em>\",\n            \" <em>1</em>\"\n          ]\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,/]\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"match_phrase\": { \"message\": \"number 1\" }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"message\": {\n        \"type\": \"plain\",\n        \"fragment_size\": 15,\n        \"number_of_fragments\": 3,\n        \"fragmenter\": \"span\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:messages]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"hits\": {\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.6011951,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"1\",\n        \"_score\": 1.6011951,\n        \"_source\": {\n          \"message\": \"some message with the number 1\",\n          \"context\": \"bar\"\n        },\n        \"highlight\": {\n          \"message\": [\n            \" with the <em>number</em> <em>1</em>\"\n          ]\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,/]\n\nIf the `number_of_fragments` option is set to `0`,\n`NullFragmenter` is used which does not fragment the text at all.\nThis is useful for highlighting the entire contents of a document or field.\n\n\n[discrete]\n[[how-es-highlighters-work-internally]]\n=== How highlighters work internally\n\nGiven a query and a text (the content of a document field), the goal of a\nhighlighter is to find the best text fragments for the query, and highlight\nthe query terms in the found fragments. For this, a highlighter needs to\naddress several questions:\n\n- How to break a text into fragments?\n- How to find the best fragments among all fragments?\n- How to highlight the query terms in a fragment?\n\n[discrete]\n==== How to break a text into fragments?\nRelevant settings: `fragment_size`, `fragmenter`, `type` of highlighter,\n`boundary_chars`, `boundary_max_scan`, `boundary_scanner`, `boundary_scanner_locale`.\n\nPlain highlighter begins with analyzing the text using the given analyzer,\nand creating a token stream from it. Plain highlighter uses a very simple\nalgorithm to break the token stream into fragments. It loops through terms in the token stream,\nand every time the current term's end_offset exceeds `fragment_size` multiplied by the number of\ncreated fragments, a new fragment is created. A little more computation is done with using `span`\nfragmenter to avoid breaking up text between highlighted terms. But overall, since the breaking is\ndone only by `fragment_size`, some fragments can be quite odd, e.g. beginning\nwith a punctuation mark.\n\nUnified or FVH highlighters do a better job of breaking up a text into\nfragments by utilizing Java's `BreakIterator`. This ensures that a fragment\nis a valid sentence as long as `fragment_size` allows for this.\n\n[discrete]\n==== How to find the best fragments?\nRelevant settings: `number_of_fragments`.\n\nTo find the best, most relevant, fragments, a highlighter needs to score\neach fragment in respect to the given query. The goal is to score only those\nterms that participated in generating the 'hit' on the document.\nFor some complex queries, this is still work in progress.\n\nThe plain highlighter creates an in-memory index from the current token stream,\nand re-runs the original query criteria through Lucene's query execution planner\nto get access to low-level match information for the current text.\nFor more complex queries the original query could be converted to a span query,\nas span queries can handle phrases more accurately. Then this obtained low-level match\ninformation is used to score each individual fragment. The scoring method of the plain\nhighlighter is quite simple. Each fragment is scored by the number of unique\nquery terms found in this fragment. The score of individual term is equal to its boost,\nwhich is by default is 1. Thus, by default, a fragment that contains one unique query term,\nwill get a score of 1; and a fragment that contains two unique query terms,\nwill get a score of 2 and so on. The fragments are then sorted by their scores,\nso the highest scored fragments will be output first.\n\nFVH doesn't need to analyze the text and build an in-memory index, as it uses\npre-indexed document term vectors, and finds among them terms that correspond to the query.\nFVH scores each fragment by the number of query terms found in this fragment.\nSimilarly to plain highlighter, score of individual term is equal to its boost value.\nIn contrast to plain highlighter, all query terms are counted, not only unique terms.\n\nUnified highlighter can use pre-indexed term vectors or pre-indexed terms offsets,\nif they are available. Otherwise, similar to Plain Highlighter, it has to create\nan in-memory index from the text. Unified highlighter uses the BM25 scoring model\nto score fragments.\n\n[discrete]\n==== How to highlight the query terms in a fragment?\nRelevant settings:  `pre-tags`, `post-tags`.\n\nThe goal is to highlight only those terms that participated in generating the 'hit' on the document.\nFor some complex boolean queries, this is still work in progress, as highlighters don't reflect\nthe boolean logic of a query and only extract leaf (terms, phrases, prefix etc) queries.\n\nPlain highlighter given the token stream and the original text, recomposes the original text to\nhighlight only terms from the token stream that are contained in the low-level match information\nstructure from the previous step.\n\nFVH and unified highlighter use intermediate data structures to represent\nfragments in some raw form, and then populate them with actual text.\n\nA highlighter uses `pre-tags`, `post-tags` to encode highlighted terms.\n\n[discrete]\n==== An example of the work of the unified highlighter\n\nLet's look in more details how unified highlighter works.\n\nFirst, we create a index with a text field `content`, that will be indexed\nusing `english` analyzer, and will be indexed without offsets or term vectors.\n\n[source,js]\n--------------------------------------------------\nPUT test_index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"content\": {\n        \"type\": \"text\",\n        \"analyzer\": \"english\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nWe put the following document into the index:\n\n[source,js]\n--------------------------------------------------\nPUT test_index/_doc/doc1\n{\n  \"content\" : \"For you I'm only a fox like a hundred thousand other foxes. But if you tame me, we'll need each other. You'll be the only boy in the world for me. I'll be the only fox in the world for you.\"\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n\nAnd we ran the following query with a highlight request:\n\n[source,js]\n--------------------------------------------------\nGET test_index/_search\n{\n  \"query\": {\n    \"match_phrase\" : {\"content\" : \"only fox\"}\n  },\n  \"highlight\": {\n    \"type\" : \"unified\",\n    \"number_of_fragments\" : 3,\n    \"fields\": {\n      \"content\": {}\n    }\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n\nAfter `doc1` is found as a hit for this query, this hit will be passed to the\nunified highlighter for highlighting the field `content` of the document.\nSince the field `content` was not indexed either with offsets or term vectors,\nits raw field value will be analyzed, and in-memory index will be built from\nthe terms that match the query:\n\n    {\"token\":\"onli\",\"start_offset\":12,\"end_offset\":16,\"position\":3},\n    {\"token\":\"fox\",\"start_offset\":19,\"end_offset\":22,\"position\":5},\n    {\"token\":\"fox\",\"start_offset\":53,\"end_offset\":58,\"position\":11},\n    {\"token\":\"onli\",\"start_offset\":117,\"end_offset\":121,\"position\":24},\n    {\"token\":\"onli\",\"start_offset\":159,\"end_offset\":163,\"position\":34},\n    {\"token\":\"fox\",\"start_offset\":164,\"end_offset\":167,\"position\":35}\n\nOur complex phrase query will be converted to the span query:\n`spanNear([text:onli, text:fox], 0, true)`, meaning that we are looking for\nterms \"onli: and \"fox\" within 0 distance from each other, and in the given\norder. The span query will be run against the created before in-memory index,\nto find the following match:\n\n    {\"term\":\"onli\", \"start_offset\":159, \"end_offset\":163},\n    {\"term\":\"fox\", \"start_offset\":164, \"end_offset\":167}\n\nIn our example, we have got a single match, but there could be several matches.\nGiven the matches, the unified highlighter breaks the text of the field into\nso called \"passages\". Each passage must contain at least one match.\nThe unified highlighter with the use of Java's `BreakIterator` ensures that each\npassage represents a full sentence as long as it doesn't exceed `fragment_size`.\nFor our example, we have got a single passage with the following properties\n(showing only a subset of the properties here):\n\n    Passage:\n        startOffset: 147\n        endOffset: 189\n        score: 3.7158387\n        matchStarts: [159, 164]\n        matchEnds: [163, 167]\n        numMatches: 2\n\nNotice how a passage has a score, calculated using the BM25 scoring formula\nadapted for passages. Scores allow us to choose the best scoring\npassages if there are more passages available than the requested\nby the user `number_of_fragments`. Scores also let us to sort passages by\n`order: \"score\"` if requested by the user.\n\nAs the final step, the unified highlighter will extract from the field's text\na string corresponding to each passage:\n\n    \"I'll be the only fox in the world for you.\"\n\nand will format with the tags <em> and </em> all matches in this string\nusing the passages's `matchStarts` and `matchEnds` information:\n\n    I'll be the <em>only</em> <em>fox</em> in the world for you.\n\nThis kind of formatted strings are the final result of the highlighter returned\nto the user.\n"
}