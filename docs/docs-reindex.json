{
    "meta": {
        "size": 39665,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "docs-reindex",
        "version": "8.15"
    },
    "doc": "[[docs-reindex]]\n=== Reindex API\n++++\n<titleabbrev>Reindex</titleabbrev>\n++++\n\nCopies documents from a source to a destination.\n\nThe source can be any existing index, alias, or data stream. The destination\nmust differ from the source. For example, you cannot reindex a data stream into\nitself.\n\n[IMPORTANT]\n=================================================\nReindex requires <<mapping-source-field,`_source`>> to be enabled for\nall documents in the source.\n\nThe destination should be configured as wanted before calling `_reindex`.\nReindex does not copy the settings from the source or its associated template.\n\nMappings, shard counts, replicas, and so on must be configured ahead of time.\n=================================================\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"my-index-000001\"\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index_big]\n\n////\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\" : 147,\n  \"timed_out\": false,\n  \"created\": 120,\n  \"updated\": 0,\n  \"deleted\": 0,\n  \"batches\": 1,\n  \"version_conflicts\": 0,\n  \"noops\": 0,\n  \"retries\": {\n    \"bulk\": 0,\n    \"search\": 0\n  },\n  \"throttled_millis\": 0,\n  \"requests_per_second\": -1.0,\n  \"throttled_until_millis\": 0,\n  \"total\": 120,\n  \"failures\" : [ ]\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\" : 147/\"took\" : \"$body.took\"/]\n\n////\n\n[[docs-reindex-api-request]]\n==== {api-request-title}\n\n`POST /_reindex`\n\n[[docs-reindex-api-prereqs]]\n==== {api-prereq-title}\n\n* If the {es} {security-features} are enabled, you must have the following\nsecurity privileges:\n\n** The `read` <<privileges-list-indices,index privilege>> for the source data\nstream, index, or alias.\n\n** The `write` index privilege for the destination data stream, index, or index\nalias.\n\n** To automatically create a data stream or index with an reindex API request,\nyou must have the `auto_configure`, `create_index`, or `manage` index\nprivilege for the destination data stream, index, or alias.\n\n** If reindexing from a remote cluster, the `source.remote.user` must have the\n`monitor` <<privileges-list-cluster,cluster privilege>> and the `read` index\nprivilege for the source data stream, index, or alias.\n\n* If reindexing from a remote cluster, you must explicitly allow the remote host\nin the `reindex.remote.whitelist` setting of `elasticsearch.yml`. See\n<<reindex-from-remote>>.\n\n* Automatic data stream creation requires a matching index template with data\nstream enabled. See <<set-up-a-data-stream>>.\n\n[[docs-reindex-api-desc]]\n==== {api-description-title}\n\n// tag::docs-reindex-api-desc-tag[]\nExtracts the <<mapping-source-field,document source>> from the source index and indexes the documents into the destination index.\nYou can copy all documents to the destination index, or reindex a subset of the documents.\n// end::docs-reindex-api-desc-tag[]\n\n\nJust like <<docs-update-by-query,`_update_by_query`>>, `_reindex` gets a\nsnapshot of the source but its destination must be **different** so\nversion conflicts are unlikely. The `dest` element can be configured like the\nindex API to control optimistic concurrency control. Omitting\n`version_type` or setting it to `internal` causes Elasticsearch\nto blindly dump documents into the destination, overwriting any that happen to have\nthe same ID.\n\nSetting `version_type` to `external` causes Elasticsearch to preserve the\n`version` from the source, create any documents that are missing, and update\nany documents that have an older version in the destination than they do\nin the source.\n\nSetting `op_type` to `create` causes `_reindex` to only create missing\ndocuments in the destination. All existing documents will cause a version\nconflict.\n\nIMPORTANT: Because data streams are <<data-streams-append-only,append-only>>,\nany reindex request to a destination data stream must have an `op_type`\nof `create`. A reindex can only add new documents to a destination data stream.\nIt cannot update existing documents in a destination data stream.\n\nBy default, version conflicts abort the `_reindex` process.\nTo continue reindexing if there are conflicts, set the `\"conflicts\"` request body parameter to `proceed`.\nIn this case, the response includes a count of the version conflicts that were encountered.\nNote that the handling of other error types is unaffected by the `\"conflicts\"` parameter.\nAdditionally, if you opt to count version conflicts the operation could attempt to reindex more documents\nfrom the source than `max_docs` until it has successfully indexed `max_docs` documents into the target, or it has gone\nthrough every document in the source query.\n\n[[docs-reindex-task-api]]\n===== Running reindex asynchronously\n\nIf the request contains `wait_for_completion=false`, {es}\nperforms some preflight checks, launches the request, and returns a\n<<tasks,`task`>> you can use to cancel or get the status of the task.\n{es} creates a record of this task as a document at `_tasks/<task_id>`.\n\n[[docs-reindex-from-multiple-sources]]\n===== Reindex from multiple sources\nIf you have many sources to reindex it is generally better to reindex them\none at a time rather than using a glob pattern to pick up multiple sources. That\nway you can resume the process if there are any errors by removing the\npartially completed source and starting over. It also makes\nparallelizing the process fairly simple: split the list of sources to reindex\nand run each list in parallel.\n\nOne-off bash scripts seem to work nicely for this:\n\n[source,bash]\n----------------------------------------------------------------\nfor index in i1 i2 i3 i4 i5; do\n  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{\n    \"source\": {\n      \"index\": \"'$index'\"\n    },\n    \"dest\": {\n      \"index\": \"'$index'-reindexed\"\n    }\n  }'\ndone\n----------------------------------------------------------------\n// NOTCONSOLE\n\n[[docs-reindex-throttle]]\n===== Throttling\n\nSet `requests_per_second` to any positive decimal number (`1.4`, `6`,\n`1000`, etc.) to throttle the rate at which `_reindex` issues batches of index\noperations. Requests are throttled by padding each batch with a wait time.\nTo disable throttling, set `requests_per_second` to `-1`.\n\nThe throttling is done by waiting between batches so that the `scroll` that `_reindex`\nuses internally can be given a timeout that takes into account the padding.\nThe padding time is the difference between the batch size divided by the\n`requests_per_second` and the time spent writing. By default the batch size is\n`1000`, so if `requests_per_second` is set to `500`:\n\n[source,txt]\n--------------------------------------------------\ntarget_time = 1000 / 500 per second = 2 seconds\nwait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds\n--------------------------------------------------\n\nSince the batch is issued as a single `_bulk` request, large batch sizes\ncause Elasticsearch to create many requests and then wait for a while before\nstarting the next set. This is \"bursty\" instead of \"smooth\".\n\n[[docs-reindex-rethrottle]]\n===== Rethrottling\n\nThe value of `requests_per_second` can be changed on a running reindex using\nthe `_rethrottle` API:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1\n--------------------------------------------------\n\nThe task ID can be found using the <<tasks,tasks API>>.\n\nJust like when setting it on the Reindex API, `requests_per_second`\ncan be either `-1` to disable throttling or any decimal number\nlike `1.7` or `12` to throttle to that level. Rethrottling that speeds up the\nquery takes effect immediately, but rethrottling that slows down the query will\ntake effect after completing the current batch. This prevents scroll\ntimeouts.\n\n[[docs-reindex-slice]]\n===== Slicing\n\nReindex supports <<slice-scroll>> to parallelize the reindexing process.\nThis parallelization can improve efficiency and provide a convenient way to\nbreak the request down into smaller parts.\n\n// tag::remote-reindex-slicing[]\nNOTE: Reindexing from remote clusters does not support\n<<docs-reindex-manual-slice, manual>> or <<docs-reindex-automatic-slice,\nautomatic slicing>>.\n// end::remote-reindex-slicing[]\n\n[[docs-reindex-manual-slice]]\n====== Manual slicing\nSlice a reindex request manually by providing a slice id and total number of\nslices to each request:\n\n[source,console]\n----------------------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"my-index-000001\",\n    \"slice\": {\n      \"id\": 0,\n      \"max\": 2\n    }\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"my-index-000001\",\n    \"slice\": {\n      \"id\": 1,\n      \"max\": 2\n    }\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\n----------------------------------------------------------------\n// TEST[setup:my_index_big]\n\nYou can verify this works by:\n\n[source,console]\n----------------------------------------------------------------\nGET _refresh\nPOST my-new-index-000001/_search?size=0&filter_path=hits.total\n----------------------------------------------------------------\n// TEST[continued]\n\nwhich results in a sensible `total` like this one:\n\n[source,console-result]\n----------------------------------------------------------------\n{\n  \"hits\": {\n    \"total\" : {\n        \"value\": 120,\n        \"relation\": \"eq\"\n    }\n  }\n}\n----------------------------------------------------------------\n\n[[docs-reindex-automatic-slice]]\n====== Automatic slicing\n\nYou can also let `_reindex` automatically parallelize using <<slice-scroll>> to\nslice on `_id`. Use `slices` to specify the number of slices to use:\n\n[source,console]\n----------------------------------------------------------------\nPOST _reindex?slices=5&refresh\n{\n  \"source\": {\n    \"index\": \"my-index-000001\"\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\n----------------------------------------------------------------\n// TEST[setup:my_index_big]\n\nYou can also verify this works by:\n\n[source,console]\n----------------------------------------------------------------\nPOST my-new-index-000001/_search?size=0&filter_path=hits.total\n----------------------------------------------------------------\n// TEST[continued]\n\nwhich results in a sensible `total` like this one:\n\n[source,console-result]\n----------------------------------------------------------------\n{\n  \"hits\": {\n    \"total\" : {\n        \"value\": 120,\n        \"relation\": \"eq\"\n    }\n  }\n}\n----------------------------------------------------------------\n\nSetting `slices` to `auto` will let Elasticsearch choose the number of slices to\nuse. This setting will use one slice per shard, up to a certain limit. If there\nare multiple sources, it will choose the number of\nslices based on the index or <<data-streams,backing index>> with the smallest\nnumber of shards.\n\nAdding `slices` to `_reindex` just automates the manual process used in the\nsection above, creating sub-requests which means it has some quirks:\n\n* You can see these requests in the <<docs-reindex-task-api,Tasks APIs>>. These\nsub-requests are \"child\" tasks of the task for the request with `slices`.\n* Fetching the status of the task for the request with `slices` only contains\nthe status of completed slices.\n* These sub-requests are individually addressable for things like cancellation\nand rethrottling.\n* Rethrottling the request with `slices` will rethrottle the unfinished\nsub-request proportionally.\n* Canceling the request with `slices` will cancel each sub-request.\n* Due to the nature of `slices` each sub-request won't get a perfectly even\nportion of the documents. All documents will be addressed, but some slices may\nbe larger than others. Expect larger slices to have a more even distribution.\n* Parameters like `requests_per_second` and `max_docs` on a request with\n`slices` are distributed proportionally to each sub-request. Combine that with\nthe point above about distribution being uneven and you should conclude that\nusing `max_docs` with `slices` might not result in exactly `max_docs` documents\nbeing reindexed.\n* Each sub-request gets a slightly different snapshot of the source,\nthough these are all taken at approximately the same time.\n\n[[docs-reindex-picking-slices]]\n====== Picking the number of slices\n\nIf slicing automatically, setting `slices` to `auto` will choose a reasonable\nnumber for most indices. If slicing manually or otherwise tuning\nautomatic slicing, use these guidelines.\n\nQuery performance is most efficient when the number of `slices` is equal to the\nnumber of shards in the index. If that number is large (e.g. 500),\nchoose a lower number as too many `slices` will hurt performance. Setting\n`slices` higher than the number of shards generally does not improve efficiency\nand adds overhead.\n\nIndexing performance scales linearly across available resources with the\nnumber of slices.\n\nWhether query or indexing performance dominates the runtime depends on the\ndocuments being reindexed and cluster resources.\n\n[[docs-reindex-routing]]\n===== Reindex routing\n\nBy default if `_reindex` sees a document with routing then the routing is\npreserved unless it's changed by the script. You can set `routing` on the\n`dest` request to change this:\n\n`keep`::\n\nSets the routing on the bulk request sent for each match to the routing on\nthe match. This is the default value.\n\n`discard`::\n\nSets the routing on the bulk request sent for each match to `null`.\n\n`=<some text>`::\n\nSets the routing on the bulk request sent for each match to all text after\nthe `=`.\n\nFor example, you can use the following request to copy all documents from\nthe `source` with the company name `cat` into the `dest`  with\nrouting set to `cat`.\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"source\",\n    \"query\": {\n      \"match\": {\n        \"company\": \"cat\"\n      }\n    }\n  },\n  \"dest\": {\n    \"index\": \"dest\",\n    \"routing\": \"=cat\"\n  }\n}\n--------------------------------------------------\n// TEST[s/^/PUT source\\n/]\n\n\n\nBy default `_reindex` uses scroll batches of 1000. You can change the\nbatch size with the `size` field in the `source` element:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"source\",\n    \"size\": 100\n  },\n  \"dest\": {\n    \"index\": \"dest\",\n    \"routing\": \"=cat\"\n  }\n}\n--------------------------------------------------\n// TEST[s/^/PUT source\\n/]\n\n[[reindex-with-an-ingest-pipeline]]\n===== Reindex with an ingest pipeline\n\nReindex can also use the <<ingest>> feature by specifying a\n`pipeline` like this:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"source\"\n  },\n  \"dest\": {\n    \"index\": \"dest\",\n    \"pipeline\": \"some_ingest_pipeline\"\n  }\n}\n--------------------------------------------------\n// TEST[s/^/PUT source\\n/]\n\n[[docs-reindex-api-query-params]]\n==== {api-query-parms-title}\n\n`refresh`::\n(Optional, Boolean) If `true`, the request refreshes affected shards to make\nthis operation visible to search. Defaults to `false`.\n\n`timeout`::\n+\n--\n(Optional, <<time-units, time units>>)\nPeriod each indexing waits for the following operations:\n\n* <<index-creation,Automatic index creation>>\n* <<dynamic-mapping,Dynamic mapping>> updates\n* <<index-wait-for-active-shards,Waiting for active shards>>\n\nDefaults to `1m` (one minute). This guarantees {es} waits for at least the\ntimeout before failing. The actual wait time could be longer, particularly when\nmultiple waits occur.\n--\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=wait_for_active_shards]\n\n`wait_for_completion`::\n(Optional, Boolean) If `true`, the request blocks until the operation is complete.\nDefaults to `true`.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=requests_per_second]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=require-alias]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=scroll]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=slices]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=max_docs]\n\n[[docs-reindex-api-request-body]]\n==== {api-request-body-title}\n\n[[conflicts]]\n`conflicts`::\n(Optional, enum) Set to `proceed` to continue reindexing even if there are conflicts.\nDefaults to `abort`.\n\n`max_docs`::\n(Optional, integer) The maximum number of documents to reindex. If <<conflicts, conflicts>> is equal to\n`proceed`, reindex could attempt to reindex more documents from the source than `max_docs` until it has successfully\nindexed `max_docs` documents into the target, or it has gone through every document in the source query.\n\n`source`::\n`index`:::\n(Required, string) The name of the data stream, index, or alias you are copying\n_from_. Also accepts a comma-separated list to reindex from multiple sources.\n\n`query`:::\n(Optional, <<query-dsl, query object>>) Specifies the documents to reindex using the Query DSL.\n\n`remote`:::\n`host`::::\n(Optional, string) The URL for the remote instance of {es} that you want to index _from_.\nRequired when indexing from remote.\n`username`::::\n(Optional, string) The username to use for authentication with the remote host.\n`password`::::\n(Optional, string) The password to use for authentication with the remote host.\n`socket_timeout`::::\n(Optional, <<time-units, time units>>) The remote socket read timeout. Defaults to 30 seconds.\n`connect_timeout`::::\n(Optional, <<time-units, time units>>) The remote connection timeout. Defaults to 30 seconds.\n`headers`::::\n(Optional, object) An object containing the headers of ther request.\n`size`:::\n{Optional, integer) The number of documents to index per batch.\nUse when indexing from remote to ensure that the batches fit within the on-heap buffer,\nwhich defaults to a maximum size of 100 MB.\n\n`slice`:::\n`id`::::\n(Optional, integer) Slice ID for <<docs-reindex-manual-slice, manual slicing>>.\n`max`::::\n(Optional, integer) Total number of slices.\n\n`sort`:::\n+\n--\n(Optional, list) A comma-separated list of `<field>:<direction>` pairs to sort by before indexing.\nUse in conjunction with `max_docs` to control what documents are reindexed.\n\ndeprecated::[7.6, Sort in reindex is deprecated. Sorting in reindex was never guaranteed to index documents in order and prevents further development of reindex such as resilience and performance improvements. If used in combination with `max_docs`&#44; consider using a query filter instead.]\n--\n\n`_source`:::\n(Optional, string) If `true` reindexes all source fields.\nSet to a list to reindex select fields.\nDefaults to `true`.\n\n`dest`::\n`index`:::\n(Required, string) The name of the data stream, index, or index alias you are copying _to_.\n\n`version_type`:::\n(Optional, enum) The versioning to use for the indexing operation.\nValid values: `internal`, `external`, `external_gt`, `external_gte`.\nSee <<index-version-types>> for more information.\n\n`op_type`:::\n(Optional, enum) Set to create to only index documents that do not already exist (put if absent).\nValid values: `index`, `create`. Defaults to `index`.\n+\nIMPORTANT: To reindex to a data stream destination, this argument must be\n`create`.\n\n`pipeline`:::\n(Optional, string) the name of the <<reindex-with-an-ingest-pipeline,pipeline>> to use.\n\n`script`::\n`source`:::\n(Optional, string) The script to run to update the document source or metadata when reindexing.\n`lang`:::\n(Optional, enum) The script language: `painless`, `expression`, `mustache`, `java`.\nFor more information, see <<modules-scripting>>.\n\n\n[[docs-reindex-api-response-body]]\n==== {api-response-body-title}\n\n`took`::\n\n(integer) The total milliseconds the entire operation took.\n\n`timed_out`::\n\n{Boolean) This flag is set to `true` if any of the requests executed during the\nreindex timed out.\n\n`total`::\n\n(integer) The number of documents that were successfully processed.\n\n`updated`::\n(integer) The number of documents that were successfully updated,\ni.e. a document with same ID already existed prior to reindex updating it.\n\n`created`::\n\n(integer) The number of documents that were successfully created.\n\n`deleted`::\n\n(integer) The number of documents that were successfully deleted.\n\n`batches`::\n\n(integer) The number of scroll responses pulled back by the reindex.\n\n`noops`::\n\n(integer) The number of documents that were ignored because the script used for\nthe reindex returned a `noop` value for `ctx.op`.\n\n`version_conflicts`::\n\n(integer) The number of version conflicts that reindex hits.\n\n`retries`::\n\n(integer) The number of retries attempted by reindex. `bulk` is the number of bulk\nactions retried and `search` is the number of search actions retried.\n\n`throttled_millis`::\n\n(integer) Number of milliseconds the request slept to conform to `requests_per_second`.\n\n`requests_per_second`::\n\n(integer) The number of requests per second effectively executed during the reindex.\n\n`throttled_until_millis`::\n\n(integer) This field should always be equal to zero in a `_reindex` response. It only\nhas meaning when using the <<docs-reindex-task-api, Task API>>, where it\nindicates the next time (in milliseconds since epoch) a throttled request will be\nexecuted again in order to conform to `requests_per_second`.\n\n`failures`::\n\n(array) Array of failures if there were any unrecoverable errors during the process. If\nthis is non-empty then the request aborted because of those failures. Reindex\nis implemented using batches and any failure causes the entire process to abort\nbut all failures in the current batch are collected into the array. You can use\nthe `conflicts` option to prevent reindex from aborting on version conflicts.\n\n[[docs-reindex-api-example]]\n==== {api-examples-title}\n\n[[docs-reindex-select-query]]\n===== Reindex select documents with a query\n\nYou can limit the documents by adding a query to the `source`.\nFor example, the following request only copies documents with a `user.id` of `kimchy` into `my-new-index-000001`:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"my-index-000001\",\n    \"query\": {\n      \"term\": {\n        \"user.id\": \"kimchy\"\n      }\n    }\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[[docs-reindex-select-max-docs]]\n===== Reindex select documents with `max_docs`\n\nYou can limit the number of processed documents by setting `max_docs`.\nFor example, this request copies a single document from `my-index-000001` to\n`my-new-index-000001`:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"max_docs\": 1,\n  \"source\": {\n    \"index\": \"my-index-000001\"\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[[docs-reindex-multiple-sources]]\n===== Reindex from multiple sources\n\nThe `index` attribute in `source` can be a list, allowing you to copy from lots\nof sources in one request. This will copy documents from the\n`my-index-000001` and `my-index-000002` indices:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": [\"my-index-000001\", \"my-index-000002\"]\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000002\"\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n// TEST[s/^/PUT my-index-000002\\/_doc\\/post1?refresh\\n{\"test\": \"foo\"}\\n/]\n\nNOTE: The Reindex API makes no effort to handle ID collisions so the last\ndocument written will \"win\" but the order isn't usually predictable so it is\nnot a good idea to rely on this behavior. Instead, make sure that IDs are unique\nusing a script.\n\n[[docs-reindex-filter-source]]\n===== Reindex select fields with a source filter\n\nYou can use source filtering to reindex a subset of the fields in the original documents.\nFor example, the following request only reindexes the `user.id` and `_doc` fields of each document:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"my-index-000001\",\n    \"_source\": [\"user.id\", \"_doc\"]\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[[docs-reindex-change-name]]\n===== Reindex to change the name of a field\n\n`_reindex` can be used to build a copy of an index with renamed fields. Say you\ncreate an index containing documents that look like this:\n\n[source,console]\n--------------------------------------------------\nPOST my-index-000001/_doc/1?refresh\n{\n  \"text\": \"words words\",\n  \"flag\": \"foo\"\n}\n--------------------------------------------------\n\nbut you don't like the name `flag` and want to replace it with `tag`.\n`_reindex` can create the other index for you:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"my-index-000001\"\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  },\n  \"script\": {\n    \"source\": \"ctx._source.tag = ctx._source.remove(\\\"flag\\\")\"\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nNow you can get the new document:\n\n[source,console]\n--------------------------------------------------\nGET my-new-index-000001/_doc/1\n--------------------------------------------------\n// TEST[continued]\n\nwhich will return:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"found\": true,\n  \"_id\": \"1\",\n  \"_index\": \"my-new-index-000001\",\n  \"_version\": 1,\n  \"_seq_no\": 44,\n  \"_primary_term\": 1,\n  \"_source\": {\n    \"text\": \"words words\",\n    \"tag\": \"foo\"\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"_seq_no\": \\d+/\"_seq_no\" : $body._seq_no/ s/\"_primary_term\": 1/\"_primary_term\" : $body._primary_term/]\n\n[[docs-reindex-daily-indices]]\n===== Reindex daily indices\n\nYou can use `_reindex` in combination with <<modules-scripting-painless, Painless>> to reindex\ndaily indices to apply a new template to the existing documents.\n\nAssuming you have indices that contain documents like:\n\n[source,console]\n----------------------------------------------------------------\nPUT metricbeat-2016.05.30/_doc/1?refresh\n{\"system.cpu.idle.pct\": 0.908}\nPUT metricbeat-2016.05.31/_doc/1?refresh\n{\"system.cpu.idle.pct\": 0.105}\n----------------------------------------------------------------\n\nThe new template for the `metricbeat-*` indices is already loaded into Elasticsearch,\nbut it applies only to the newly created indices. Painless can be used to reindex\nthe existing documents and apply the new template.\n\nThe script below extracts the date from the index name and creates a new index\nwith `-1` appended. All data from `metricbeat-2016.05.31` will be reindexed\ninto `metricbeat-2016.05.31-1`.\n\n[source,console]\n----------------------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"metricbeat-*\"\n  },\n  \"dest\": {\n    \"index\": \"metricbeat\"\n  },\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"ctx._index = 'metricbeat-' + (ctx._index.substring('metricbeat-'.length(), ctx._index.length())) + '-1'\"\n  }\n}\n----------------------------------------------------------------\n// TEST[continued]\n\nAll documents from the previous metricbeat indices can now be found in the `*-1` indices.\n\n[source,console]\n----------------------------------------------------------------\nGET metricbeat-2016.05.30-1/_doc/1\nGET metricbeat-2016.05.31-1/_doc/1\n----------------------------------------------------------------\n// TEST[continued]\n\nThe previous method can also be used in conjunction with <<docs-reindex-change-name, changing a field name>>\nto load only the existing data into the new index and rename any fields if needed.\n\n[[docs-reindex-api-subset]]\n===== Extract a random subset of the source\n\n`_reindex` can be used to extract a random subset of the source for testing:\n\n[source,console]\n----------------------------------------------------------------\nPOST _reindex\n{\n  \"max_docs\": 10,\n  \"source\": {\n    \"index\": \"my-index-000001\",\n    \"query\": {\n      \"function_score\" : {\n        \"random_score\" : {},\n        \"min_score\" : 0.9    <1>\n      }\n    }\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\n----------------------------------------------------------------\n// TEST[setup:my_index_big]\n\n<1> You may need to adjust the `min_score` depending on the relative amount of\ndata extracted from source.\n\n[[reindex-scripts]]\n===== Modify documents during reindexing\n\nLike `_update_by_query`, `_reindex` supports a script that modifies the\ndocument. Unlike `_update_by_query`, the script is allowed to modify the\ndocument's metadata. This example bumps the version of the source document:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"my-index-000001\"\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\",\n    \"version_type\": \"external\"\n  },\n  \"script\": {\n    \"source\": \"if (ctx._source.foo == 'bar') {ctx._version++; ctx._source.remove('foo')}\",\n    \"lang\": \"painless\"\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nJust as in `_update_by_query`, you can set `ctx.op` to change the\noperation that is executed on the destination:\n\n`noop`::\n\nSet `ctx.op = \"noop\"` if your script decides that the document doesn't have\nto be indexed in the destination. This no operation will be reported\nin the `noop` counter in the <<docs-reindex-api-response-body, response body>>.\n\n`delete`::\n\nSet `ctx.op = \"delete\"` if your script decides that the document must be\n deleted from the destination. The deletion will be reported in the\n `deleted` counter in the <<docs-reindex-api-response-body, response body>>.\n\nSetting `ctx.op` to anything else will return an error, as will setting any\nother field in `ctx`.\n\nThink of the possibilities! Just be careful; you are able to\nchange:\n\n * `_id`\n * `_index`\n * `_version`\n * `_routing`\n\nSetting `_version` to `null` or clearing it from the `ctx` map is just like not\nsending the version in an indexing request; it will cause the document to be\noverwritten in the destination regardless of the version on the target or the\nversion type you use in the `_reindex` request.\n\n[[reindex-from-remote]]\n==== Reindex from remote\n\nReindex supports reindexing from a remote Elasticsearch cluster:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"remote\": {\n      \"host\": \"http://otherhost:9200\",\n      \"username\": \"user\",\n      \"password\": \"pass\"\n    },\n    \"index\": \"my-index-000001\",\n    \"query\": {\n      \"match\": {\n        \"test\": \"data\"\n      }\n    }\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\n--------------------------------------------------\n// TEST[setup:host]\n// TEST[s/^/PUT my-index-000001\\n/]\n// TEST[s/otherhost:9200\",/\\${host}\",/]\n// TEST[s/\"username\": \"user\",/\"username\": \"test_admin\",/]\n// TEST[s/\"password\": \"pass\"/\"password\": \"x-pack-test-password\"/]\n\nThe `host` parameter must contain a scheme, host, port (e.g.\n`https://otherhost:9200`), and optional path (e.g. `https://otherhost:9200/proxy`).\nThe `username` and `password` parameters are optional, and when they are present `_reindex`\nwill connect to the remote Elasticsearch node using basic auth. Be sure to use `https` when\nusing basic auth or the password will be sent in plain text.\nThere are a range of <<reindex-ssl,settings>> available to configure the behaviour of the\n `https` connection.\n\nWhen using {ecloud}, it is also possible to authenticate against the remote cluster\nthrough the use of a valid API key:\n\n[source,console]\n----\nPOST _reindex\n{\n  \"source\": {\n    \"remote\": {\n      \"host\": \"http://otherhost:9200\",\n      \"headers\": {\n        \"Authorization\": \"ApiKey API_KEY_VALUE\"\n      }\n    },\n    \"index\": \"my-index-000001\",\n    \"query\": {\n      \"match\": {\n        \"test\": \"data\"\n      }\n    }\n  },\n  \"dest\": {\n    \"index\": \"my-new-index-000001\"\n  }\n}\n----\n// TEST[setup:host]\n// TEST[s/^/PUT my-index-000001\\n/]\n// TEST[s/otherhost:9200\",/\\${host}\",/]\n// TEST[s/\"headers\": \\{[^}]*\\}/\"username\": \"test_admin\", \"password\": \"x-pack-test-password\"/]\n\nRemote hosts have to be explicitly allowed in `elasticsearch.yml` using the\n`reindex.remote.whitelist` property. It can be set to a comma delimited list\nof allowed remote `host` and `port` combinations. Scheme is\nignored, only the host and port are used. For example:\n\n\n[source,yaml]\n--------------------------------------------------\nreindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*\"]\n--------------------------------------------------\n\nThe list of allowed hosts must be configured on any nodes that will coordinate the reindex.\n\nThis feature should work with remote clusters of any version of Elasticsearch\nyou are likely to find. This should allow you to upgrade from any version of\nElasticsearch to the current version by reindexing from a cluster of the old\nversion.\n\nWARNING: {es} does not support forward compatibility across major versions. For\nexample, you cannot reindex from a 7.x cluster into a 6.x cluster.\n\nTo enable queries sent to older versions of Elasticsearch the `query` parameter\nis sent directly to the remote host without validation or modification.\n\ninclude::{es-ref-dir}/docs/reindex.asciidoc[tag=remote-reindex-slicing]\n\nReindexing from a remote server uses an on-heap buffer that defaults to a\nmaximum size of 100mb. If the remote index includes very large documents you'll\nneed to use a smaller batch size. The example below sets the batch size to `10`\nwhich is very, very small.\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"remote\": {\n      \"host\": \"http://otherhost:9200\",\n      ...\n    },\n    \"index\": \"source\",\n    \"size\": 10,\n    \"query\": {\n      \"match\": {\n        \"test\": \"data\"\n      }\n    }\n  },\n  \"dest\": {\n    \"index\": \"dest\"\n  }\n}\n--------------------------------------------------\n// TEST[setup:host]\n// TEST[s/^/PUT source\\n/]\n// TEST[s/otherhost:9200/\\${host}/]\n// TEST[s/\\.\\.\\./\"username\": \"test_admin\", \"password\": \"x-pack-test-password\"/]\n\nIt is also possible to set the socket read timeout on the remote connection\nwith the `socket_timeout` field and the connection timeout with the\n`connect_timeout` field. Both default to 30 seconds. This example\nsets the socket read timeout to one minute and the connection timeout to 10\nseconds:\n\n[source,console]\n--------------------------------------------------\nPOST _reindex\n{\n  \"source\": {\n    \"remote\": {\n      \"host\": \"http://otherhost:9200\",\n      ...,\n      \"socket_timeout\": \"1m\",\n      \"connect_timeout\": \"10s\"\n    },\n    \"index\": \"source\",\n    \"query\": {\n      \"match\": {\n        \"test\": \"data\"\n      }\n    }\n  },\n  \"dest\": {\n    \"index\": \"dest\"\n  }\n}\n--------------------------------------------------\n// TEST[setup:host]\n// TEST[s/^/PUT source\\n/]\n// TEST[s/otherhost:9200/\\${host}/]\n// TEST[s/\\.\\.\\.,/\"username\": \"test_admin\", \"password\": \"x-pack-test-password\",/]\n\n[[reindex-ssl]]\n===== Configuring SSL parameters\n\nReindex from remote supports configurable SSL settings. These must be\nspecified in the `elasticsearch.yml` file, with the exception of the\nsecure settings, which you add in the Elasticsearch keystore.\nIt is not possible to configure SSL in the body of the `_reindex` request.\n\nThe following settings are supported:\n\n`reindex.ssl.certificate_authorities`::\nList of paths to PEM encoded certificate files that should be trusted.\nYou cannot specify both `reindex.ssl.certificate_authorities` and\n`reindex.ssl.truststore.path`.\n\n`reindex.ssl.truststore.path`::\nThe path to the Java Keystore file that contains the certificates to trust.\nThis keystore can be in \"JKS\" or \"PKCS#12\" format.\nYou cannot specify both `reindex.ssl.certificate_authorities` and\n`reindex.ssl.truststore.path`.\n\n`reindex.ssl.truststore.password`::\nThe password to the truststore (`reindex.ssl.truststore.path`).\ndeprecated:[7.17.0] Prefer `reindex.ssl.truststore.secure_password` instead.\nThis setting cannot be used with `reindex.ssl.truststore.secure_password`.\n\n`reindex.ssl.truststore.secure_password` (<<secure-settings,Secure>>)::\nThe password to the truststore (`reindex.ssl.truststore.path`).\nThis setting cannot be used with `reindex.ssl.truststore.password`.\n\n`reindex.ssl.truststore.type`::\nThe type of the truststore (`reindex.ssl.truststore.path`).\nMust be either `jks` or `PKCS12`. If the truststore path ends in \".p12\", \".pfx\"\nor \"pkcs12\", this setting defaults to `PKCS12`. Otherwise, it defaults to `jks`.\n\n`reindex.ssl.verification_mode`::\nIndicates the type of verification to protect against man in the middle attacks\nand certificate forgery.\nOne of `full` (verify the hostname and the certificate path), `certificate`\n(verify the certificate path, but not the hostname) or `none` (perform no\nverification - this is strongly discouraged in production environments).\nDefaults to `full`.\n\n`reindex.ssl.certificate`::\nSpecifies the path to the PEM encoded certificate (or certificate chain) to be\nused for HTTP client authentication (if required by the remote cluster)\nThis setting requires that `reindex.ssl.key` also be set.\nYou cannot specify both `reindex.ssl.certificate` and `reindex.ssl.keystore.path`.\n\n`reindex.ssl.key`::\nSpecifies the path to the PEM encoded private key associated with the\ncertificate used for client authentication (`reindex.ssl.certificate`).\nYou cannot specify both `reindex.ssl.key` and `reindex.ssl.keystore.path`.\n\n`reindex.ssl.key_passphrase`::\nSpecifies the passphrase to decrypt the PEM encoded private key\n(`reindex.ssl.key`) if it is encrypted.\ndeprecated:[7.17.0] Prefer `reindex.ssl.secure_key_passphrase` instead.\nCannot be used with `reindex.ssl.secure_key_passphrase`.\n\n`reindex.ssl.secure_key_passphrase` (<<secure-settings,Secure>>)::\nSpecifies the passphrase to decrypt the PEM encoded private key\n(`reindex.ssl.key`) if it is encrypted.\nCannot be used with `reindex.ssl.key_passphrase`.\n\n`reindex.ssl.keystore.path`::\nSpecifies the path to the keystore that contains a private key and certificate\nto be used for HTTP client authentication (if required by the remote cluster).\nThis keystore can be in \"JKS\" or \"PKCS#12\" format.\nYou cannot specify both `reindex.ssl.key` and `reindex.ssl.keystore.path`.\n\n`reindex.ssl.keystore.type`::\nThe type of the keystore (`reindex.ssl.keystore.path`). Must be either `jks` or `PKCS12`.\nIf the keystore path ends in \".p12\", \".pfx\" or \"pkcs12\", this setting defaults\nto `PKCS12`. Otherwise, it defaults to `jks`.\n\n`reindex.ssl.keystore.password`::\nThe password to the keystore (`reindex.ssl.keystore.path`).\ndeprecated:[7.17.0] Prefer `reindex.ssl.keystore.secure_password` instead.\nThis setting cannot be used with `reindex.ssl.keystore.secure_password`.\n\n`reindex.ssl.keystore.secure_password` (<<secure-settings,Secure>>)::\nThe password to the keystore (`reindex.ssl.keystore.path`).\nThis setting cannot be used with `reindex.ssl.keystore.password`.\n\n`reindex.ssl.keystore.key_password`::\nThe password for the key in the keystore (`reindex.ssl.keystore.path`).\nDefaults to the keystore password.\ndeprecated:[7.17.0] Prefer `reindex.ssl.keystore.secure_key_password` instead.\nThis setting cannot be used with `reindex.ssl.keystore.secure_key_password`.\n\n`reindex.ssl.keystore.secure_key_password` (<<secure-settings,Secure>>)::\nThe password for the key in the keystore (`reindex.ssl.keystore.path`).\nDefaults to the keystore password. This setting cannot be used with\n`reindex.ssl.keystore.key_password`.\n"
}