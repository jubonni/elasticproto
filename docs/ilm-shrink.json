{
    "meta": {
        "size": 5173,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-shrink.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "ilm-shrink",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[ilm-shrink]]\n=== Shrink\n\nPhases allowed: hot, warm.\n\n<<index-blocks-write,Blocks writes>> on a source index and shrinks it into\na new index with fewer primary shards. The name of the resulting index is\n`shrink-<random-uuid>-<original-index-name>`. This action corresponds to the\n<<indices-shrink-index,shrink API>>.\n\nAfter the `shrink` action, any aliases that pointed to the source index point to\nthe new shrunken index. If {ilm-init} performs the `shrink` action on a backing\nindex for a data stream, the shrunken index replaces the source index in the\nstream. You cannot perform the `shrink` action on a write index.\n\nTo use the `shrink` action in the `hot` phase, the `rollover` action *must* be\npresent. If no rollover action is configured, {ilm-init} will reject the policy.\n\nThe shrink action will unset the index's `index.routing.allocation.total_shards_per_node`\nsetting, meaning that there will be no limit. This is to ensure that all shards of the\nindex can be copied to a single node. This setting change will persist on the index\neven after the step completes.\n\n[IMPORTANT]\nIf the shrink action is used on a <<ccr-put-follow,follower index>>, policy\nexecution waits until the leader index rolls over (or is <<skipping-rollover,\notherwise marked complete>>), then converts the follower index into a regular\nindex with the <<ilm-unfollow,unfollow>> action before performing the shrink\noperation.\n\n[[ilm-shrink-options]]\n==== Shrink options\n\n`number_of_shards`::\n(Optional, integer)\nNumber of shards to shrink to.\nMust be a factor of the number of shards in the source index. This parameter conflicts with\n`max_primary_shard_size`, only one of them may be set.\n\n`max_primary_shard_size`::\n(Optional, <<byte-units, byte units>>)\nThe max primary shard size for the target index. Used to find the optimum number of shards for the target index.\nWhen this parameter is set, each shard's storage in the target index will not be greater than the parameter.\nThe shards count of the target index will still be a factor of the source index's shards count, but if the parameter\nis less than the single shard size in the source index, the shards count for the target index will be equal to the source index's shards count.\nFor example, when this parameter is set to 50gb, if the source index has 60 primary shards with totaling 100gb, then the\ntarget index will have 2 primary shards, with each shard size of 50gb; if the source index has 60 primary shards\nwith totaling 1000gb, then the target index will have 20 primary shards; if the source index has 60 primary shards\nwith totaling 4000gb, then the target index will still have 60 primary shards. This parameter conflicts\nwith `number_of_shards` in the `settings`, only one of them may be set.\n\n`allow_write_after_shrink`::\n(Optional, boolean)\nIf true, the shrunken index is made writable by removing the <<index-blocks-write,write block>>. Defaults to false.\n\n\n[[ilm-shrink-ex]]\n==== Example\n\n[[ilm-shrink-shards-ex]]\n===== Set the number of shards of the new shrunken index explicitly\n\n[source,console]\n--------------------------------------------------\nPUT _ilm/policy/my_policy\n{\n  \"policy\": {\n    \"phases\": {\n      \"warm\": {\n        \"actions\": {\n          \"shrink\" : {\n            \"number_of_shards\": 1\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n[[ilm-shrink-size-ex]]\n===== Calculate the optimal number of primary shards for a shrunken index\n\nThe following policy uses the `max_primary_shard_size` parameter to\nautomatically calculate the new shrunken index's primary shard count based on\nthe source index's storage size.\n\n[source,console]\n--------------------------------------------------\nPUT _ilm/policy/my_policy\n{\n  \"policy\": {\n    \"phases\": {\n      \"warm\": {\n        \"actions\": {\n          \"shrink\" : {\n            \"max_primary_shard_size\": \"50gb\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n[[ilm-shrink-shard-allocation]]\n==== Shard allocation for shrink\n\nDuring a `shrink` action, {ilm-init} allocates the source index's primary shards\nto one node. After shrinking the index, {ilm-init} reallocates the shrunken\nindex's shards to the appropriate nodes based on your allocation rules.\n\nThese allocation steps can fail for several reasons, including:\n\n* A node is removed during the `shrink` action.\n* No node has enough disk space to host the source index's shards.\n* {es} cannot reallocate the shrunken index due to conflicting allocation rules.\n\nWhen one of the allocation steps fails, {ilm-init} waits for the period set in\n<<index-lifecycle-step-wait-time-threshold,`index.lifecycle.step.wait_time_threshold`>>,\nwhich defaults to 12 hours. This threshold period lets the cluster resolve any\nissues causing the allocation failure.\n\nIf the threshold period passes and {ilm-init} has not yet shrunk the index,\n{ilm-init} attempts to allocate the source index's primary shards to another\nnode. If {ilm-init} shrunk the index but could not reallocate the shrunken\nindex's shards during the threshold period, {ilm-init} deletes the shrunken\nindex and re-attempts the entire `shrink` action.\n"
}