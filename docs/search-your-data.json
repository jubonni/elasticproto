{
    "meta": {
        "size": 17432,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-your-data.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-your-data",
        "version": "8.15"
    },
    "doc": "[[search-your-data]]\n== The search API\n\nA _search_ consists of one or more queries that are combined and sent to {es}.\nDocuments that match a search's queries are returned in the _hits_, or\n_search results_, of the response.\n\nA search may also contain additional information used to better process its\nqueries. For example, a search may be limited to a specific index or only return\na specific number of results.\n\nYou can use the <<search-search,search API>> to search and\n<<search-aggregations,aggregate>> data stored in {es} data streams or indices.\nThe API's `query` request body parameter accepts queries written in\n<<query-dsl,Query DSL>>.\n\n[discrete]\n[[run-an-es-search]]\n=== Run a search\n\nThe following request searches `my-index-000001` using a\n<<query-dsl-match-query,`match`>> query. This query matches documents with a\n`user.id` value of `kimchy`.\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"match\": {\n      \"user.id\": \"kimchy\"\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n\nThe API response returns the top 10 documents matching the query in the\n`hits.hits` property.\n\n[source,console-result]\n----\n{\n  \"took\": 5,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.3862942,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"kxWFcnMByiguvud1Z8vC\",\n        \"_score\": 1.3862942,\n        \"_source\": {\n          \"@timestamp\": \"2099-11-15T14:12:12\",\n          \"http\": {\n            \"request\": {\n              \"method\": \"get\"\n            },\n            \"response\": {\n              \"bytes\": 1070000,\n              \"status_code\": 200\n            },\n            \"version\": \"1.1\"\n          },\n          \"message\": \"GET /search HTTP/1.1 200 1070000\",\n          \"source\": {\n            \"ip\": \"127.0.0.1\"\n          },\n          \"user\": {\n            \"id\": \"kimchy\"\n          }\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 5/\"took\": \"$body.took\"/]\n// TESTRESPONSE[s/\"_id\": \"kxWFcnMByiguvud1Z8vC\"/\"_id\": \"$body.hits.hits.0._id\"/]\n\n[discrete]\n[[common-search-options]]\n=== Common search options\n\nYou can use the following options to customize your searches.\n\n*Query DSL* +\n<<query-dsl,Query DSL>> supports a variety of query types you can mix and match\nto get the results you want. Query types include:\n\n* <<query-dsl-bool-query,Boolean>> and other <<compound-queries,compound\nqueries>>, which let you combine queries and match results based on multiple\ncriteria\n* <<term-level-queries,Term-level queries>> for filtering and finding exact matches\n* <<full-text-queries,Full text queries>>, which are commonly used in search\nengines\n* <<geo-queries,Geo>> and <<shape-queries,spatial queries>>\n\n*Aggregations* +\nYou can use <<search-aggregations,search aggregations>> to get statistics and\nother analytics for your search results. Aggregations help you answer questions\nlike:\n\n* What's the average response time for my servers?\n* What are the top IP addresses hit by users on my network?\n* What is the total transaction revenue by customer?\n\n*Search multiple data streams and indices* +\nYou can use comma-separated values and grep-like index patterns to search\nseveral data streams and indices in the same request. You can even boost search\nresults from specific indices. See <<search-multiple-indices>>.\n\n*Paginate search results* +\nBy default, searches return only the top 10 matching hits. To retrieve\nmore or fewer documents, see <<paginate-search-results>>.\n\n*Retrieve selected fields* +\nThe search response's `hits.hits` property includes the full document\n<<mapping-source-field,`_source`>> for each hit. To retrieve only a subset of\nthe `_source` or other fields, see <<search-fields>>.\n\n*Sort search results* +\nBy default, search hits are sorted by `_score`, a <<relevance-scores,relevance\nscore>> that measures how well each document matches the query. To customize the\ncalculation of these scores, use the\n<<query-dsl-script-score-query,`script_score`>> query. To sort search hits by\nother field values, see <<sort-search-results>>.\n\n*Run an async search* +\n{es} searches are designed to run on large volumes of data quickly, often\nreturning results in milliseconds. For this reason, searches are\n_synchronous_ by default. The search request waits for complete results before\nreturning a response.\n\nHowever, complete results can take longer for searches across\nlarge data sets or <<modules-cross-cluster-search,multiple clusters>>.\n\nTo avoid long waits, you can run an _asynchronous_, or _async_, search\ninstead. An <<async-search-intro,async search>> lets you retrieve partial\nresults for a long-running search now and get complete results later.\n\n[discrete]\n[[run-search-runtime-fields]]\n=== Define fields that exist only in a query\nInstead of indexing your data and then searching it, you can define\n<<runtime-search-request,runtime fields>> that only exist as part of your\nsearch query. You specify a `runtime_mappings` section in your search request\nto define the runtime field, which can optionally include a Painless script.\n\nFor example, the following query defines a runtime field called `day_of_week`.\nThe included script calculates the day of the week based on the value of the\n`@timestamp` field, and uses `emit` to return the calculated value.\n\nThe query also includes a <<search-aggregations-bucket-terms-aggregation,terms aggregation>> that operates on `day_of_week`.\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"runtime_mappings\": {\n    \"day_of_week\": {\n      \"type\": \"keyword\",\n      \"script\": {\n        \"source\":\n        \"\"\"emit(doc['@timestamp'].value.dayOfWeekEnum\n        .getDisplayName(TextStyle.FULL, Locale.ENGLISH))\"\"\"\n      }\n    }\n  },\n  \"aggs\": {\n    \"day_of_week\": {\n      \"terms\": {\n        \"field\": \"day_of_week\"\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n\nThe response includes an aggregation based on the `day_of_week` runtime field.\nUnder `buckets` is a `key` with a value of `Sunday`. The query dynamically\ncalculated this value based on the script defined in the `day_of_week` runtime\nfield without ever indexing the field.\n\n[source,console-result]\n----\n{\n  ...\n  ***\n  \"aggregations\" : {\n    \"day_of_week\" : {\n      \"doc_count_error_upper_bound\" : 0,\n      \"sum_other_doc_count\" : 0,\n      \"buckets\" : [\n        {\n          \"key\" : \"Sunday\",\n          \"doc_count\" : 5\n        }\n      ]\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n// TESTRESPONSE[s/\\*\\*\\*/\"hits\" : $body.hits,/]\n\n[discrete]\n[[search-timeout]]\n=== Search timeout\n\nBy default, search requests don't time out. The request waits for complete\nresults from each shard before returning a response.\n\nWhile <<async-search-intro,async search>> is designed for long-running\nsearches, you can also use the `timeout` parameter to specify a duration you'd\nlike to wait on each shard to complete. Each shard collects hits within the\nspecified time period. If collection isn't finished when the period ends, {es}\nuses only the hits accumulated up to that point. The overall latency of a search\nrequest depends on the number of shards needed for the search and the number of\nconcurrent shard requests.\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"timeout\": \"2s\",\n  \"query\": {\n    \"match\": {\n      \"user.id\": \"kimchy\"\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n\nTo set a cluster-wide default timeout for all search requests, configure\n`search.default_search_timeout` using the <<cluster-update-settings,cluster\nsettings API>>. This global timeout duration is used if no `timeout` argument is\npassed in the request. If the global search timeout expires before the search\nrequest finishes, the request is cancelled using <<task-cancellation,task\ncancellation>>. The `search.default_search_timeout` setting defaults to `-1` (no\ntimeout).\n\n[discrete]\n[[global-search-cancellation]]\n=== Search cancellation\n\nYou can cancel a search request using the <<task-cancellation,task management\nAPI>>. {es} also automatically cancels a search request when your client's HTTP\nconnection closes. We recommend you set up your client to close HTTP connections\nwhen a search request is aborted or times out.\n\n[discrete]\n[[track-total-hits]]\n=== Track total hits\n\nGenerally the total hit count can't be computed accurately without visiting all\nmatches, which is costly for queries that match lots of documents. The\n`track_total_hits` parameter allows you to control how the total number of hits\nshould be tracked.\nGiven that it is often enough to have a lower bound of the number of hits,\nsuch as \"there are at least 10000 hits\", the default is set to `10,000`.\nThis means that requests will count the total hit accurately up to `10,000` hits.\nIt is a good trade off to speed up searches if you don't need the accurate number\nof hits after a certain threshold.\n\nWhen set to `true` the search response will always track the number of hits that\nmatch the query accurately (e.g. `total.relation` will always be equal to `\"eq\"`\nwhen `track_total_hits` is set to true). Otherwise the `\"total.relation\"` returned\nin the `\"total\"` object in the search response determines how the `\"total.value\"`\nshould be interpreted. A value of `\"gte\"` means that the `\"total.value\"` is a\nlower bound of the total hits that match the query and a value of `\"eq\"` indicates\nthat `\"total.value\"` is the accurate count.\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"track_total_hits\": true,\n  \"query\": {\n    \"match\" : {\n      \"user.id\" : \"elkbee\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n\\... returns:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"_shards\": ...\n  \"timed_out\": false,\n  \"took\": 100,\n  \"hits\": {\n    \"max_score\": 1.0,\n    \"total\" : {\n      \"value\": 2048,    <1>\n      \"relation\": \"eq\"  <2>\n    },\n    \"hits\": ...\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"_shards\": \\.\\.\\./\"_shards\": \"$body._shards\",/]\n// TESTRESPONSE[s/\"took\": 100/\"took\": $body.took/]\n// TESTRESPONSE[s/\"max_score\": 1\\.0/\"max_score\": $body.hits.max_score/]\n// TESTRESPONSE[s/\"value\": 2048/\"value\": $body.hits.total.value/]\n// TESTRESPONSE[s/\"hits\": \\.\\.\\./\"hits\": \"$body.hits.hits\"/]\n\n<1> The total number of hits that match the query.\n<2> The count is accurate (e.g. `\"eq\"` means equals).\n\nIt is also possible to set `track_total_hits` to an integer.\nFor instance the following query will accurately track the total hit count that match\nthe query up to 100 documents:\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"track_total_hits\": 100,\n  \"query\": {\n    \"match\": {\n      \"user.id\": \"elkbee\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nThe `hits.total.relation` in the response will indicate if the\nvalue returned in `hits.total.value` is accurate (`\"eq\"`) or a lower\nbound of the total (`\"gte\"`).\n\nFor instance the following response:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"_shards\": ...\n  \"timed_out\": false,\n  \"took\": 30,\n  \"hits\": {\n    \"max_score\": 1.0,\n    \"total\": {\n      \"value\": 42,         <1>\n      \"relation\": \"eq\"     <2>\n    },\n    \"hits\": ...\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"_shards\": \\.\\.\\./\"_shards\": \"$body._shards\",/]\n// TESTRESPONSE[s/\"took\": 30/\"took\": $body.took/]\n// TESTRESPONSE[s/\"max_score\": 1\\.0/\"max_score\": $body.hits.max_score/]\n// TESTRESPONSE[s/\"value\": 42/\"value\": $body.hits.total.value/]\n// TESTRESPONSE[s/\"hits\": \\.\\.\\./\"hits\": \"$body.hits.hits\"/]\n\n<1> 42 documents match the query\n<2> and the count is accurate (`\"eq\"`)\n\n\\... indicates that the number of hits returned in the `total`\nis accurate.\n\nIf the total number of hits that match the query is greater than the\nvalue set in `track_total_hits`, the total hits in the response\nwill indicate that the returned value is a lower bound:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"_shards\": ...\n  \"hits\": {\n    \"max_score\": 1.0,\n    \"total\": {\n      \"value\": 100,         <1>\n      \"relation\": \"gte\"     <2>\n    },\n    \"hits\": ...\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[skip:response is already tested in the previous snippet]\n\n<1> There are at least 100 documents that match the query\n<2> This is a lower bound (`\"gte\"`).\n\nIf you don't need to track the total number of hits at all you can improve query\ntimes by setting this option to `false`:\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"track_total_hits\": false,\n  \"query\": {\n    \"match\": {\n      \"user.id\": \"elkbee\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n\\... returns:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"_shards\": ...\n  \"timed_out\": false,\n  \"took\": 10,\n  \"hits\": {             <1>\n    \"max_score\": 1.0,\n    \"hits\": ...\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"_shards\": \\.\\.\\./\"_shards\": \"$body._shards\",/]\n// TESTRESPONSE[s/\"took\": 10/\"took\": $body.took/]\n// TESTRESPONSE[s/\"max_score\": 1\\.0/\"max_score\": $body.hits.max_score/]\n// TESTRESPONSE[s/\"hits\": \\.\\.\\./\"hits\": \"$body.hits.hits\"/]\n\n<1> The total number of hits is unknown.\n\nFinally you can force an accurate count by setting `\"track_total_hits\"`\nto `true` in the request.\n\n[TIP]\n=========================================\nThe `track_total_hits` parameter allows you to trade hit count accuracy for performance.\nIn general the lower the value of `track_total_hits` the faster the query will be,\nwith `false` returning the fastest results.\nSetting `track_total_hits` to true will cause {es} to return exact hit counts, which could\nhurt query performance because it disables the\nhttps://www.elastic.co/blog/faster-retrieval-of-top-hits-in-elasticsearch-with-block-max-wand[Max WAND]\noptimization.\n=========================================\n\n[discrete]\n[[quickly-check-for-matching-docs]]\n=== Quickly check for matching docs\n\nIf you only want to know if there are any documents matching a\nspecific query, you can set the `size` to `0` to indicate that we are not\ninterested in the search results. You can also set `terminate_after` to `1`\nto indicate that the query execution can be terminated whenever the first\nmatching document was found (per shard).\n\n[source,console]\n--------------------------------------------------\nGET /_search?q=user.id:elkbee&size=0&terminate_after=1\n--------------------------------------------------\n// TEST[setup:my_index]\n\nNOTE: `terminate_after` is always applied **after** the\n<<post-filter,`post_filter`>> and stops the query as well as the aggregation\nexecutions when enough hits have been collected on the shard. Though the doc\ncount on aggregations may not reflect the `hits.total` in the response since\naggregations are applied **before** the post filtering.\n\nThe response will not contain any hits as the `size` was set to `0`. The\n`hits.total` will be either equal to `0`, indicating that there were no\nmatching documents, or greater than `0` meaning that there were at least\nas many documents matching the query when it was early terminated.\nAlso if the query was terminated early, the `terminated_early` flag will\nbe set to `true` in the response. Some queries are able to retrieve the hits\ncount directly from the index statistics, which is much faster as it does\nnot require executing the query. In those situations, no documents are\ncollected, the returned `total.hits` will be higher than `terminate_after`,\nand `terminated_early` will be set to `false`.\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 3,\n  \"timed_out\": false,\n  \"terminated_early\": true,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": null,\n    \"hits\": []\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 3/\"took\": $body.took/]\n// TESTRESPONSE[s/\"terminated_early\": true/\"terminated_early\": $body.terminated_early/]\n// TESTRESPONSE[s/\"value\": 1/\"value\": $body.hits.total.value/]\n\nThe `took` time in the response contains the milliseconds that this request\ntook for processing, beginning quickly after the node received the query, up\nuntil all search related work is done and before the above JSON is returned\nto the client. This means it includes the time spent waiting in thread pools,\nexecuting a distributed search across the whole cluster and gathering all the\nresults.\n\ninclude::sort-search-results.asciidoc[]\ninclude::paginate-search-results.asciidoc[]\ninclude::retrieve-selected-fields.asciidoc[]\ninclude::search-multiple-indices.asciidoc[]\ninclude::collapse-search-results.asciidoc[]\ninclude::filter-search-results.asciidoc[]\ninclude::highlighting.asciidoc[]\ninclude::long-running-searches.asciidoc[]\ninclude::near-real-time.asciidoc[]\ninclude::retrieve-inner-hits.asciidoc[]\ninclude::search-shard-routing.asciidoc[]\ninclude::search-using-query-rules.asciidoc[]\ninclude::search-template.asciidoc[]\ninclude::retrievers-overview.asciidoc[]\n\n"
}