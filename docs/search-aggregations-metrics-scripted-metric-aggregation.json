{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.307068",
        "size": 8957,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-scripted-metric-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-metrics-scripted-metric-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-metrics-scripted-metric-aggregation]]\n=== Scripted metric aggregation\n++++\n<titleabbrev>Scripted metric</titleabbrev>\n++++\n\nA metric aggregation that executes using scripts to provide a metric output.\n\nWARNING: `scripted_metric` is not available in {serverless-full}.\n\nWARNING: Using scripts can result in slower search speeds. See\n<<scripts-and-search-speed>>.\n\nExample:\n\n[source,console]\n--------------------------------------------------\nPOST ledger/_search?size=0\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"aggs\": {\n    \"profit\": {\n      \"scripted_metric\": {\n        \"init_script\": \"state.transactions = []\", <1>\n        \"map_script\": \"state.transactions.add(doc.type.value == 'sale' ? doc.amount.value : -1 * doc.amount.value)\",\n        \"combine_script\": \"double profit = 0; for (t in state.transactions) { profit += t } return profit\",\n        \"reduce_script\": \"double profit = 0; for (a in states) { profit += a } return profit\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:ledger]\n\n<1> `init_script` is an optional parameter, all other scripts are required.\n\nThe above aggregation demonstrates how one would use the script aggregation compute the total profit from sale and cost transactions.\n\nThe response for the above aggregation:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 218,\n  ...\n  \"aggregations\": {\n    \"profit\": {\n      \"value\": 240.0\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 218/\"took\": $body.took/]\n// TESTRESPONSE[s/\\.\\.\\./\"_shards\": $body._shards, \"hits\": $body.hits, \"timed_out\": false,/]\n\nThe above example can also be specified using stored scripts as follows:\n\n[source,console]\n--------------------------------------------------\nPOST ledger/_search?size=0\n{\n  \"aggs\": {\n    \"profit\": {\n      \"scripted_metric\": {\n        \"init_script\": {\n          \"id\": \"my_init_script\"\n        },\n        \"map_script\": {\n          \"id\": \"my_map_script\"\n        },\n        \"combine_script\": {\n          \"id\": \"my_combine_script\"\n        },\n        \"params\": {\n          \"field\": \"amount\"           <1>\n        },\n        \"reduce_script\": {\n          \"id\": \"my_reduce_script\"\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:ledger,stored_scripted_metric_script]\n\n<1> script parameters for `init`, `map` and `combine` scripts must be specified\nin a global `params` object so that it can be shared between the scripts.\n\n////\nVerify this response as well but in a hidden block.\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 218,\n  ...\n  \"aggregations\": {\n    \"profit\": {\n      \"value\": 240.0\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 218/\"took\": $body.took/]\n// TESTRESPONSE[s/\\.\\.\\./\"_shards\": $body._shards, \"hits\": $body.hits, \"timed_out\": false,/]\n////\n\nFor more details on specifying scripts see <<modules-scripting, script documentation>>.\n\n[[scripted-metric-aggregation-return-types]]\n==== Allowed return types\n\nWhilst any valid script object can be used within a single script, the scripts must return or store in the `state` object only the following types:\n\n* primitive types\n* String\n* Map (containing only keys and values of the types listed here)\n* Array (containing elements of only the types listed here)\n\n[[scripted-metric-aggregation-scope]]\n==== Scope of scripts\n\nThe scripted metric aggregation uses scripts at 4 stages of its execution:\n\ninit_script::       Executed prior to any collection of documents. Allows the aggregation to set up any initial state.\n+\nIn the above example, the `init_script` creates an array `transactions` in the `state` object.\n\nmap_script::        Executed once per document collected. This is a required script.\n+\nIn the above example, the `map_script` checks the value of the type field. If the value is 'sale' the value of the amount field\nis added to the transactions array. If the value of the type field is not 'sale' the negated value of the amount field is added\nto transactions.\n\ncombine_script::    Executed once on each shard after document collection is complete. This is a required script. Allows the aggregation to\n                    consolidate the state returned from each shard.\n+\nIn the above example, the `combine_script` iterates through all the stored transactions, summing the values in the `profit` variable\nand finally returns `profit`.\n\nreduce_script::     Executed once on the coordinating node after all shards have returned their results. This is a required script. The\n                    script is provided with access to a variable `states` which is an array of the result of the combine_script on each\n                    shard.\n+\nIn the above example, the `reduce_script` iterates through the `profit` returned by each shard summing the values before returning the\nfinal combined profit which will be returned in the response of the aggregation.\n\n[[scripted-metric-aggregation-example]]\n==== Worked example\n\nImagine a situation where you index the following documents into an index with 2 shards:\n\n[source,console]\n--------------------------------------------------\nPUT /transactions/_bulk?refresh\n{\"index\":{\"_id\":1}}\n{\"type\": \"sale\",\"amount\": 80}\n{\"index\":{\"_id\":2}}\n{\"type\": \"cost\",\"amount\": 10}\n{\"index\":{\"_id\":3}}\n{\"type\": \"cost\",\"amount\": 30}\n{\"index\":{\"_id\":4}}\n{\"type\": \"sale\",\"amount\": 130}\n--------------------------------------------------\n\nLets say that documents 1 and 3 end up on shard A and documents 2 and 4 end up on shard B. The following is a breakdown of what the aggregation result is\nat each stage of the example above.\n\n===== Before init_script\n\n`state` is initialized as a new empty object.\n\n[source,js]\n--------------------------------------------------\n\"state\" : {}\n--------------------------------------------------\n// NOTCONSOLE\n\n===== After init_script\n\nThis is run once on each shard before any document collection is performed, and so we will have a copy on each shard:\n\nShard A::\n+\n[source,js]\n--------------------------------------------------\n\"state\" : {\n    \"transactions\" : []\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nShard B::\n+\n[source,js]\n--------------------------------------------------\n\"state\" : {\n    \"transactions\" : []\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n===== After map_script\n\nEach shard collects its documents and runs the map_script on each document that is collected:\n\nShard A::\n+\n[source,js]\n--------------------------------------------------\n\"state\" : {\n    \"transactions\" : [ 80, -30 ]\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nShard B::\n+\n[source,js]\n--------------------------------------------------\n\"state\" : {\n    \"transactions\" : [ -10, 130 ]\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n===== After combine_script\n\nThe combine_script is executed on each shard after document collection is complete and reduces all the transactions down to a single profit figure for each\nshard (by summing the values in the transactions array) which is passed back to the coordinating node:\n\nShard A::        50\nShard B::        120\n\n===== After reduce_script\n\nThe reduce_script receives a `states` array containing the result of the combine script for each shard:\n\n[source,js]\n--------------------------------------------------\n\"states\" : [\n    50,\n    120\n]\n--------------------------------------------------\n// NOTCONSOLE\n\nIt reduces the responses for the shards down to a final overall profit figure (by summing the values) and returns this as the result of the aggregation to\nproduce the response:\n\n[source,js]\n--------------------------------------------------\n{\n  ...\n\n  \"aggregations\": {\n    \"profit\": {\n      \"value\": 170\n    }\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n[[scripted-metric-aggregation-parameters]]\n==== Other parameters\n\n[horizontal]\nparams::           Optional. An object whose contents will be passed as variables to the  `init_script`, `map_script` and `combine_script`. This can be\n                   useful to allow the user to control the behavior of the aggregation and for storing state between the scripts. If this is not specified,\n                   the default is the equivalent of providing:\n+\n[source,js]\n--------------------------------------------------\n\"params\" : {}\n--------------------------------------------------\n// NOTCONSOLE\n\n[[scripted-metric-aggregation-empty-buckets]]\n==== Empty buckets\n\nIf a parent bucket of the scripted metric aggregation does not collect any documents an empty aggregation response will be returned from the\nshard with a `null` value. In this case the `reduce_script`'s `states` variable will contain `null` as a response from that shard.\n`reduce_script`'s should therefore expect and deal with `null` responses from shards.\n"
}