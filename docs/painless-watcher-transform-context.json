{
    "meta": {
        "size": 9500,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-watcher-transform-context.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-watcher-transform-context",
        "version": "8.15"
    },
    "doc": "[[painless-watcher-transform-context]]\n=== Watcher transform context\n\nUse a Painless script as a {ref}/transform-script.html[watch transform]\nto transform a payload into a new payload for further use in the watch.\nTransform scripts return an Object value of the new payload.\n\ninclude::painless-watcher-context-variables.asciidoc[]\n\n*Return*\n\n`Object`::\n        The new payload.\n\n*API*\n\nThe standard <<painless-api-reference-shared, Painless API>> is available.\n\n*Example*\n\nTo run the examples, first follow the steps in\n<<painless-context-examples, context examples>>.\n\n[source,console]\n----\nPOST _watcher/watch/_execute\n{\n  \"watch\" : {\n    \"trigger\" : { \"schedule\" : { \"interval\" : \"24h\" } },\n    \"input\" : {\n      \"search\" : {\n        \"request\" : {\n          \"indices\" : [ \"seats\" ],\n          \"body\" : {\n            \"query\" : { \"term\": { \"sold\": \"true\"} },\n            \"aggs\" : {\n              \"theatres\" : {\n                \"terms\" : { \"field\" : \"play\" },\n                \"aggs\" : {\n                  \"money\" : {\n                    \"sum\": { \"field\" : \"cost\" }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"transform\" : {\n      \"script\":\n      \"\"\"\n        return [\n          'money_makers': ctx.payload.aggregations.theatres.buckets.stream()  <1>\n            .filter(t -> {                                                    <2>\n                return t.money.value > 50000\n            })\n            .map(t -> {                                                       <3>\n                return ['play': t.key, 'total_value': t.money.value ]\n            }).collect(Collectors.toList()),                                  <4>\n          'duds' : ctx.payload.aggregations.theatres.buckets.stream()         <5>\n            .filter(t -> {\n                return t.money.value < 15000\n            })\n            .map(t -> {\n                return ['play': t.key, 'total_value': t.money.value ]\n            }).collect(Collectors.toList())\n          ]\n      \"\"\"\n    },\n    \"actions\" : {\n      \"my_log\" : {\n        \"logging\" : {\n          \"text\" : \"The output of the payload was transformed to {{ctx.payload}}\"\n        }\n      }\n    }\n  }\n}\n----\n// TEST[setup:seats]\n\n<1> The Java Stream API is used in the transform. This API allows manipulation of\nthe elements of the list in a pipeline.\n<2> The stream filter removes items that do not meet the filter criteria.\n<3> The stream map transforms each element into a new object.\n<4> The collector reduces the stream to a `java.util.List`.\n<5> This is done again for the second set of values in the transform.\n\nThe following action transform changes each value in the mod_log action into a `String`.\nThis transform does not change the values in the unmod_log action.\n\n[source,console]\n----\nPOST _watcher/watch/_execute\n{\n  \"watch\" : {\n    \"trigger\" : { \"schedule\" : { \"interval\" : \"24h\" } },\n    \"input\" : {\n      \"search\" : {\n        \"request\" : {\n          \"indices\" : [ \"seats\" ],\n          \"body\" : {\n            \"query\" : {\n              \"term\": { \"sold\": \"true\"}\n            },\n            \"aggs\" : {\n              \"theatres\" : {\n                \"terms\" : { \"field\" : \"play\" },\n                \"aggs\" : {\n                  \"money\" : {\n                    \"sum\": { \"field\" : \"cost\" }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"actions\" : {\n      \"mod_log\" : {\n        \"transform\": {                                                                <1>\n          \"script\" :\n          \"\"\"\n          def formatter = NumberFormat.getCurrencyInstance();\n          return [\n            'msg': ctx.payload.aggregations.theatres.buckets.stream()\n              .map(t-> formatter.format(t.money.value) + ' for the play ' + t.key)\n              .collect(Collectors.joining(\", \"))\n          ]\n          \"\"\"\n        },\n        \"logging\" : {\n          \"text\" : \"The output of the payload was transformed to: {{ctx.payload.msg}}\"\n        }\n      },\n      \"unmod_log\" : {                                                                 <2>\n        \"logging\" : {\n          \"text\" : \"The output of the payload was not transformed and this value should not exist: {{ctx.payload.msg}}\"\n        }\n      }\n    }\n  }\n}\n----\n// TEST[setup:seats]\n\nThis example uses the streaming API in a very similar manner. The differences below are\nsubtle and worth calling out.\n\n<1> The location of the transform is no longer at the top level, but is within\nan individual action.\n<2> A second action that does not transform the payload is given for reference.\n\nThe following example shows scripted watch and action transforms within the\ncontext of a complete watch. This watch also uses a scripted\n<<painless-watcher-condition-context, condition>>.\n\n[source,console]\n----\nPOST _watcher/watch/_execute\n{\n  \"watch\" : {\n    \"metadata\" : { \"high_threshold\": 4000, \"low_threshold\": 1000 },\n    \"trigger\" : { \"schedule\" : { \"interval\" : \"24h\" } },\n    \"input\" : {\n      \"search\" : {\n        \"request\" : {\n          \"indices\" : [ \"seats\" ],\n          \"body\" : {\n            \"query\" : {\n              \"term\": { \"sold\": \"true\"}\n            },\n            \"aggs\" : {\n              \"theatres\" : {\n                \"terms\" : { \"field\" : \"play\" },\n                \"aggs\" : {\n                  \"money\" : {\n                    \"sum\": {\n                      \"field\" : \"cost\",\n                      \"script\": {\n                       \"source\": \"doc.cost.value * doc.number.value\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"condition\" : {\n      \"script\" :\n      \"\"\"\n        return ctx.payload.aggregations.theatres.buckets.stream()\n          .anyMatch(theatre -> theatre.money.value < ctx.metadata.low_threshold ||\n                               theatre.money.value > ctx.metadata.high_threshold)\n      \"\"\"\n    },\n    \"transform\" : {\n      \"script\":\n      \"\"\"\n        return [\n          'money_makers': ctx.payload.aggregations.theatres.buckets.stream()\n            .filter(t -> {\n                return t.money.value > ctx.metadata.high_threshold\n            })\n            .map(t -> {\n                return ['play': t.key, 'total_value': t.money.value ]\n            }).collect(Collectors.toList()),\n          'duds' : ctx.payload.aggregations.theatres.buckets.stream()\n            .filter(t -> {\n                return t.money.value < ctx.metadata.low_threshold\n            })\n            .map(t -> {\n                return ['play': t.key, 'total_value': t.money.value ]\n            }).collect(Collectors.toList())\n          ]\n      \"\"\"\n    },\n    \"actions\" : {\n      \"log_money_makers\" : {\n        \"condition\": {\n          \"script\" : \"return ctx.payload.money_makers.size() > 0\"\n        },\n        \"transform\": {\n          \"script\" :\n          \"\"\"\n          def formatter = NumberFormat.getCurrencyInstance();\n          return [\n            'plays_value': ctx.payload.money_makers.stream()\n              .map(t-> formatter.format(t.total_value) + ' for the play ' + t.play)\n              .collect(Collectors.joining(\", \"))\n          ]\n          \"\"\"\n        },\n        \"logging\" : {\n          \"text\" : \"The following plays contain the highest grossing total income: {{ctx.payload.plays_value}}\"\n        }\n      },\n      \"log_duds\" : {\n        \"condition\": {\n          \"script\" : \"return ctx.payload.duds.size() > 0\"\n        },\n        \"transform\": {\n          \"script\" :\n          \"\"\"\n          def formatter = NumberFormat.getCurrencyInstance();\n          return [\n            'plays_value': ctx.payload.duds.stream()\n              .map(t-> formatter.format(t.total_value) + ' for the play ' + t.play)\n              .collect(Collectors.joining(\", \"))\n          ]\n          \"\"\"\n        },\n        \"logging\" : {\n          \"text\" : \"The following plays need more advertising due to their low total income: {{ctx.payload.plays_value}}\"\n        }\n      }\n    }\n  }\n}\n----\n// TEST[setup:seats]\n\nThe following example shows the use of metadata and transforming dates into a readable format.\n\n[source,console]\n----\nPOST _watcher/watch/_execute\n{\n  \"watch\" : {\n    \"metadata\" : { \"min_hits\": 10 },\n    \"trigger\" : { \"schedule\" : { \"interval\" : \"24h\" } },\n    \"input\" : {\n      \"search\" : {\n        \"request\" : {\n          \"indices\" : [ \"seats\" ],\n          \"body\" : {\n            \"query\" : {\n              \"term\": { \"sold\": \"true\"}\n            },\n            \"aggs\" : {\n              \"theatres\" : {\n                \"terms\" : { \"field\" : \"play\" },\n                \"aggs\" : {\n                  \"money\" : {\n                    \"sum\": { \"field\" : \"cost\" }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"condition\" : {\n      \"script\" :\n      \"\"\"\n        return ctx.payload.hits.total > ctx.metadata.min_hits\n      \"\"\"\n    },\n    \"transform\" : {\n      \"script\" :\n      \"\"\"\n        def theDate = ZonedDateTime.ofInstant(ctx.execution_time.toInstant(), ctx.execution_time.getZone());\n        return ['human_date': DateTimeFormatter.RFC_1123_DATE_TIME.format(theDate),\n                'aggregations': ctx.payload.aggregations]\n      \"\"\"\n    },\n    \"actions\" : {\n      \"my_log\" : {\n        \"logging\" : {\n          \"text\" : \"The watch was successfully executed on {{ctx.payload.human_date}} and contained {{ctx.payload.aggregations.theatres.buckets.size}} buckets\"\n        }\n      }\n    }\n  }\n}\n----\n// TEST[setup:seats]\n"
}