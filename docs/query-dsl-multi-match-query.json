{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.997579",
        "size": 17623,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "query-dsl-multi-match-query",
        "version": "8.15"
    },
    "doc": "[[query-dsl-multi-match-query]]\n=== Multi-match query\n++++\n<titleabbrev>Multi-match</titleabbrev>\n++++\n\nThe `multi_match` query builds on the <<query-dsl-match-query,`match` query>>\nto allow multi-field queries:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\":    \"this is a test\", <1>\n      \"fields\": [ \"subject\", \"message\" ] <2>\n    }\n  }\n}\n--------------------------------------------------\n\n<1> The query string.\n<2> The fields to be queried.\n\n[discrete]\n[[field-boost]]\n==== `fields` and per-field boosting\n\nFields can be specified with wildcards, eg:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\":    \"Will Smith\",\n      \"fields\": [ \"title\", \"*_name\" ] <1>\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Query the `title`, `first_name` and `last_name` fields.\n\nIndividual fields can be boosted with the caret (`^`) notation:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\" : \"this is a test\",\n      \"fields\" : [ \"subject^3\", \"message\" ] <1>\n    }\n  }\n}\n--------------------------------------------------\n\n<1> The query multiplies the `subject` field's score by three but leaves the\n`message` field's score unchanged.\n\nIf no `fields` are provided, the `multi_match` query defaults to the `index.query.default_field`\nindex settings, which in turn defaults to `*`. `*` extracts all fields in the mapping that\nare eligible to term queries and filters the metadata fields. All extracted fields are then\ncombined to build a query.\n\n:query-type: multi-match\ninclude::combined-fields-query.asciidoc[tag=max-clause-limit]\n:query-type!:\n\n[[multi-match-types]]\n[discrete]\n==== Types of `multi_match` query:\n\nThe way the `multi_match` query is executed internally depends on the `type`\nparameter, which can be set to:\n\n[horizontal]\n`best_fields`::     (*default*) Finds documents which match any field, but\n                    uses the  `_score` from the best field. See <<type-best-fields>>.\n\n`most_fields`::     Finds documents which match any field and combines\n                    the `_score` from each field. See <<type-most-fields>>.\n\n`cross_fields`::    Treats fields with the same `analyzer` as though they\n                    were one big field. Looks for each word in *any*\n                    field. See <<type-cross-fields>>.\n\n`phrase`::          Runs a `match_phrase` query on each field and uses the `_score`\n                    from the best field. See <<type-phrase>>.\n\n`phrase_prefix`::   Runs a `match_phrase_prefix` query on each field and uses\n                    the `_score` from the best field. See <<type-phrase>>.\n\n`bool_prefix`::     Creates a `match_bool_prefix` query on each field and\n                    combines the `_score` from each field. See\n                    <<type-bool-prefix>>.\n\n[[type-best-fields]]\n==== `best_fields`\n\nThe `best_fields` type is most useful when you are searching for multiple\nwords best found in the same field. For instance ``brown fox'' in a single\nfield is more meaningful than ``brown'' in one field and ``fox'' in the other.\n\nThe `best_fields` type generates a <<query-dsl-match-query,`match` query>> for\neach field and wraps them in a <<query-dsl-dis-max-query,`dis_max`>> query, to\nfind the single best matching field. For instance, this query:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\":      \"brown fox\",\n      \"type\":       \"best_fields\",\n      \"fields\":     [ \"subject\", \"message\" ],\n      \"tie_breaker\": 0.3\n    }\n  }\n}\n--------------------------------------------------\n\nwould be executed as:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"dis_max\": {\n      \"queries\": [\n        { \"match\": { \"subject\": \"brown fox\" }},\n        { \"match\": { \"message\": \"brown fox\" }}\n      ],\n      \"tie_breaker\": 0.3\n    }\n  }\n}\n--------------------------------------------------\n\nNormally the `best_fields` type uses the score of the *single* best matching\nfield, but if `tie_breaker` is specified, then it calculates the score as\nfollows:\n\n  * the score from the best matching field\n  * plus `tie_breaker * _score` for all other matching fields\n\nAlso, accepts `analyzer`, `boost`, `operator`, `minimum_should_match`,\n`fuzziness`, `lenient`, `prefix_length`, `max_expansions`, `fuzzy_rewrite`, `zero_terms_query`,\n`auto_generate_synonyms_phrase_query` and `fuzzy_transpositions`,\nas explained in <<query-dsl-match-query, match query>>.\n\n[IMPORTANT]\n[[operator-min]]\n.`operator` and `minimum_should_match`\n===================================================\n\nThe `best_fields` and `most_fields` types are _field-centric_ -- they generate\na `match` query *per field*. This means that the `operator` and\n`minimum_should_match` parameters are applied to each field individually,\nwhich is probably not what you want.\n\nTake this query for example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\":      \"Will Smith\",\n      \"type\":       \"best_fields\",\n      \"fields\":     [ \"first_name\", \"last_name\" ],\n      \"operator\":   \"and\" <1>\n    }\n  }\n}\n--------------------------------------------------\n\n<1> All terms must be present.\n\nThis query is executed as:\n\n      (+first_name:will +first_name:smith)\n    | (+last_name:will  +last_name:smith)\n\nIn other words, *all terms* must be present *in a single field* for a document\nto match.\n\nThe <<query-dsl-combined-fields-query, `combined_fields`>> query offers a\nterm-centric approach that handles `operator` and `minimum_should_match` on a\nper-term basis. The other multi-match mode <<type-cross-fields>> also\naddresses this issue.\n\n===================================================\n\n[[type-most-fields]]\n==== `most_fields`\n\nThe `most_fields` type is most useful when querying multiple fields that\ncontain the same text analyzed in different ways. For instance, the main\nfield may contain synonyms, stemming and terms without diacritics. A second\nfield may contain the original terms, and a third field might contain\nshingles. By combining scores from all three fields we can match as many\ndocuments as possible with the main field, but use the second and third fields\nto push the most similar results to the top of the list.\n\nThis query:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\":      \"quick brown fox\",\n      \"type\":       \"most_fields\",\n      \"fields\":     [ \"title\", \"title.original\", \"title.shingles\" ]\n    }\n  }\n}\n--------------------------------------------------\n\nwould be executed as:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"bool\": {\n      \"should\": [\n        { \"match\": { \"title\":          \"quick brown fox\" }},\n        { \"match\": { \"title.original\": \"quick brown fox\" }},\n        { \"match\": { \"title.shingles\": \"quick brown fox\" }}\n      ]\n    }\n  }\n}\n--------------------------------------------------\n\nThe score from each `match` clause is added together, just like a `bool` query.\n\nAlso, accepts `analyzer`, `boost`, `operator`, `minimum_should_match`,\n`fuzziness`, `lenient`, `prefix_length`, `max_expansions`, `fuzzy_rewrite`, and `zero_terms_query`.\n\n[[type-phrase]]\n==== `phrase` and `phrase_prefix`\n\nThe `phrase` and `phrase_prefix` types behave just like <<type-best-fields>>,\nbut they use a `match_phrase` or `match_phrase_prefix` query instead of a\n`match` query.\n\nThis query:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\":      \"quick brown f\",\n      \"type\":       \"phrase_prefix\",\n      \"fields\":     [ \"subject\", \"message\" ]\n    }\n  }\n}\n--------------------------------------------------\n\nwould be executed as:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"dis_max\": {\n      \"queries\": [\n        { \"match_phrase_prefix\": { \"subject\": \"quick brown f\" }},\n        { \"match_phrase_prefix\": { \"message\": \"quick brown f\" }}\n      ]\n    }\n  }\n}\n--------------------------------------------------\n\nAlso, accepts `analyzer`, `boost`, `lenient` and `zero_terms_query` as explained\nin <<query-dsl-match-query>>, as well as `slop` which is explained in <<query-dsl-match-query-phrase>>.\nType `phrase_prefix` additionally accepts `max_expansions`.\n\n[IMPORTANT]\n[[phrase-fuzziness]]\n.`phrase`, `phrase_prefix` and `fuzziness`\n===================================================\nThe `fuzziness` parameter cannot be used with the `phrase` or `phrase_prefix` type.\n===================================================\n\n[[type-cross-fields]]\n==== `cross_fields`\n\nThe `cross_fields` type is particularly useful with structured documents where\nmultiple fields *should* match. For instance, when querying the `first_name`\nand `last_name` fields for ``Will Smith'', the best match is likely to have\n``Will'' in one field and ``Smith'' in the other.\n\n****\n\nThis sounds like a job for <<type-most-fields>> but there are two problems\nwith that approach. The first problem is that `operator` and\n`minimum_should_match` are applied per-field, instead of per-term (see\n<<operator-min,explanation above>>).\n\nThe second problem is to do with relevance: the different term frequencies in\nthe `first_name` and `last_name` fields can produce unexpected results.\n\nFor instance, imagine we have two people: ``Will Smith'' and ``Smith Jones''.\n``Smith'' as a last name is very common (and so is of low importance) but\n``Smith'' as a first name is very uncommon (and so is of great importance).\n\nIf we do a search for ``Will Smith'', the ``Smith Jones'' document will\nprobably appear above the better matching ``Will Smith'' because the score of\n`first_name:smith` has trumped the combined scores of `first_name:will` plus\n`last_name:smith`.\n\n****\n\nOne way of dealing with these types of queries is simply to index the\n`first_name` and `last_name` fields into a single `full_name` field. Of\ncourse, this can only be done at index time.\n\nThe `cross_field` type tries to solve these problems at query time by taking a\n_term-centric_ approach. It first analyzes the query string into individual\nterms, then looks for each term in any of the fields, as though they were one\nbig field.\n\nA query like:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\":      \"Will Smith\",\n      \"type\":       \"cross_fields\",\n      \"fields\":     [ \"first_name\", \"last_name\" ],\n      \"operator\":   \"and\"\n    }\n  }\n}\n--------------------------------------------------\n\nis executed as:\n\n    +(first_name:will last_name:will)\n    +(first_name:smith last_name:smith)\n\nIn other words, *all terms* must be present *in at least one field* for a\ndocument to match.  (Compare this to\n<<operator-min,the logic used for `best_fields` and `most_fields`>>.)\n\nThat solves one of the two problems. The problem of differing term frequencies\nis solved by _blending_ the term frequencies for all fields in order to even\nout the differences.\n\nIn practice, `first_name:smith` will be treated as though it has the same\nfrequencies as `last_name:smith`, plus one. This will make matches on\n`first_name` and `last_name` have comparable scores, with a tiny advantage\nfor `last_name` since it is the most likely field that contains `smith`.\n\nNote that `cross_fields` is usually only useful on short string fields\nthat all have a `boost` of `1`. Otherwise boosts, term freqs and length\nnormalization contribute to the score in such a way that the blending of term\nstatistics is not meaningful anymore.\n\nIf you run the above query through the <<search-validate>>, it returns this\nexplanation:\n\n    +blended(\"will\",  fields: [first_name, last_name])\n    +blended(\"smith\", fields: [first_name, last_name])\n\nAlso, accepts `analyzer`, `boost`, `operator`, `minimum_should_match`,\n`lenient` and `zero_terms_query`.\n\nWARNING: The `cross_fields` type blends field statistics in a complex way that\ncan be hard to interpret. The score combination can even be incorrect, in\nparticular when some documents contain some of the search fields, but not all\nof them. You should consider the\n<<query-dsl-combined-fields-query,`combined_fields`>> query as an alternative,\nwhich is also term-centric but combines field statistics in a more robust way.\n\n[[cross-field-analysis]]\n===== `cross_field` and analysis\n\nThe `cross_field` type can only work in term-centric mode on fields that have\nthe same analyzer. Fields with the same analyzer are grouped together as in\nthe example above. If there are multiple groups, the query will use the best\nscore from any group.\n\nFor instance, if we have a `first` and `last` field which have\nthe same analyzer, plus a `first.edge` and `last.edge` which\nboth use an `edge_ngram` analyzer, this query:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\":      \"Jon\",\n      \"type\":       \"cross_fields\",\n      \"fields\":     [\n        \"first\", \"first.edge\",\n        \"last\",  \"last.edge\"\n      ]\n    }\n  }\n}\n--------------------------------------------------\n\nwould be executed as:\n\n        blended(\"jon\", fields: [first, last])\n    | (\n        blended(\"j\",   fields: [first.edge, last.edge])\n        blended(\"jo\",  fields: [first.edge, last.edge])\n        blended(\"jon\", fields: [first.edge, last.edge])\n    )\n\nIn other words, `first` and `last` would be grouped together and\ntreated as a single field, and `first.edge` and `last.edge` would be\ngrouped together and treated as a single field.\n\nHaving multiple groups is fine, but when combined with `operator` or\n`minimum_should_match`, it can suffer from the <<operator-min,same problem>>\nas `most_fields` or `best_fields`.\n\nYou can easily rewrite this query yourself as two separate `cross_fields`\nqueries combined with a `dis_max` query, and apply the `minimum_should_match`\nparameter to just one of them:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"dis_max\": {\n      \"queries\": [\n        {\n          \"multi_match\" : {\n            \"query\":      \"Will Smith\",\n            \"type\":       \"cross_fields\",\n            \"fields\":     [ \"first\", \"last\" ],\n            \"minimum_should_match\": \"50%\" <1>\n          }\n        },\n        {\n          \"multi_match\" : {\n            \"query\":      \"Will Smith\",\n            \"type\":       \"cross_fields\",\n            \"fields\":     [ \"*.edge\" ]\n          }\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Either `will` or `smith` must be present in either of the `first`\n    or `last` fields\n\nYou can force all fields into the same group by specifying the `analyzer`\nparameter in the query.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n   \"multi_match\" : {\n      \"query\":      \"Jon\",\n      \"type\":       \"cross_fields\",\n      \"analyzer\":   \"standard\", <1>\n      \"fields\":     [ \"first\", \"last\", \"*.edge\" ]\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Use the `standard` analyzer for all fields.\n\nwhich will be executed as:\n\n    blended(\"will\",  fields: [first, first.edge, last.edge, last])\n    blended(\"smith\", fields: [first, first.edge, last.edge, last])\n\n[[tie-breaker]]\n===== `tie_breaker`\n\nBy default, each per-term `blended` query will use the best score returned by\nany field in a group. Then when combining scores across groups, the query uses\nthe best score from any group. The `tie_breaker` parameter can change the\nbehavior for both of these steps:\n\n[horizontal]\n`0.0`::             Take the single best score out of (eg) `first_name:will`\n                    and `last_name:will` (default)\n`1.0`::             Add together the scores for (eg) `first_name:will` and\n                    `last_name:will`\n`0.0 < n < 1.0`::   Take the single best score plus +tie_breaker+ multiplied\n                    by each of the scores from other matching fields/ groups\n\n[IMPORTANT]\n[[crossfields-fuzziness]]\n.`cross_fields` and `fuzziness`\n===================================================\nThe `fuzziness` parameter cannot be used with the `cross_fields` type.\n===================================================\n\n[[type-bool-prefix]]\n==== `bool_prefix`\n\nThe `bool_prefix` type's scoring behaves like <<type-most-fields>>, but using a\n<<query-dsl-match-bool-prefix-query,`match_bool_prefix` query>> instead of a\n`match` query.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"multi_match\" : {\n      \"query\":      \"quick brown f\",\n      \"type\":       \"bool_prefix\",\n      \"fields\":     [ \"subject\", \"message\" ]\n    }\n  }\n}\n--------------------------------------------------\n\nThe `analyzer`, `boost`, `operator`, `minimum_should_match`, `lenient`,\n`zero_terms_query`, and `auto_generate_synonyms_phrase_query` parameters as\nexplained in <<query-dsl-match-query, match query>> are supported. The\n`fuzziness`, `prefix_length`, `max_expansions`, `fuzzy_rewrite`, and\n`fuzzy_transpositions` parameters are supported for the terms that are used to\nconstruct term queries, but do not have an effect on the prefix query\nconstructed from the final term.\n\nThe `slop` parameter is not supported by this query type.\n"
}