{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.185271",
        "size": 6732,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/esql-multi-index.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "esql-multi-index",
        "version": "8.15"
    },
    "doc": "[[esql-multi-index]]\n=== Using {esql} to query multiple indices\n++++\n<titleabbrev>Using {esql} to query multiple indices</titleabbrev>\n++++\n\nWith {esql}, you can execute a single query across multiple indices, data streams, or aliases.\nTo do so, use wildcards and date arithmetic. The following example uses a comma-separated list and a wildcard:\n\n[source,esql]\n----\nFROM employees-00001,other-employees-*\n----\n\nUse the format `<remote_cluster_name>:<target>` to <<esql-cross-clusters, query data streams and indices\non remote clusters>>:\n\n[source,esql]\n----\nFROM cluster_one:employees-00001,cluster_two:other-employees-*\n----\n\n[discrete]\n[[esql-multi-index-invalid-mapping]]\n=== Field type mismatches\n\nWhen querying multiple indices, data streams, or aliases, you might find that the same field is mapped to multiple different types.\nFor example, consider the two indices with the following field mappings:\n\n*index: events_ip*\n```\n{\n  \"mappings\": {\n    \"properties\": {\n      \"@timestamp\":     { \"type\": \"date\" },\n      \"client_ip\":      { \"type\": \"ip\" },\n      \"event_duration\": { \"type\": \"long\" },\n      \"message\":        { \"type\": \"keyword\" }\n    }\n  }\n}\n```\n\n*index: events_keyword*\n```\n{\n  \"mappings\": {\n    \"properties\": {\n      \"@timestamp\":     { \"type\": \"date\" },\n      \"client_ip\":      { \"type\": \"keyword\" },\n      \"event_duration\": { \"type\": \"long\" },\n      \"message\":        { \"type\": \"keyword\" }\n    }\n  }\n}\n```\n\nWhen you query each of these individually with a simple query like `FROM events_ip`, the results are provided with type-specific columns:\n\n[source.merge.styled,esql]\n----\nFROM events_ip\n| SORT @timestamp DESC\n----\n[%header.monospaced.styled,format=dsv,separator=|]\n|===\n@timestamp:date | client_ip:ip | event_duration:long | message:keyword\n2023-10-23T13:55:01.543Z | 172.21.3.15  | 1756467 | Connected to 10.1.0.1\n2023-10-23T13:53:55.832Z | 172.21.3.15  | 5033755 | Connection error\n2023-10-23T13:52:55.015Z | 172.21.3.15  | 8268153 | Connection error\n|===\n\nNote how the `client_ip` column is correctly identified as type `ip`, and all values are displayed.\nHowever, if instead the query sources two conflicting indices with `FROM events_*`, the type of the `client_ip` column cannot be determined\nand is reported as `unsupported` with all values returned as `null`.\n\n[[query-unsupported]]\n[source.merge.styled,esql]\n----\nFROM events_*\n| SORT @timestamp DESC\n----\n[%header.monospaced.styled,format=dsv,separator=|]\n|===\n@timestamp:date | client_ip:unsupported | event_duration:long | message:keyword\n2023-10-23T13:55:01.543Z | null  | 1756467 | Connected to 10.1.0.1\n2023-10-23T13:53:55.832Z | null  | 5033755 | Connection error\n2023-10-23T13:52:55.015Z | null  | 8268153 | Connection error\n2023-10-23T13:51:54.732Z | null  | 725448  | Connection error\n2023-10-23T13:33:34.937Z | null  | 1232382 | Disconnected\n2023-10-23T12:27:28.948Z | null  | 2764889 | Connected to 10.1.0.2\n2023-10-23T12:15:03.360Z | null  | 3450233 | Connected to 10.1.0.3\n|===\n\nIn addition, if the query refers to this unsupported field directly, the query fails:\n\n[source.merge.styled,esql]\n----\nFROM events_*\n| SORT client_ip DESC\n----\n\n[source,bash]\n----\nCannot use field [client_ip] due to ambiguities being mapped as\n[2] incompatible types:\n    [ip] in [events_ip],\n    [keyword] in [events_keyword]\n----\n\n[discrete]\n[[esql-multi-index-union-types]]\n=== Union types\n\nexperimental::[]\n\n{esql} has a way to handle <<esql-multi-index-invalid-mapping, field type mismatches>>. When the same field is mapped to multiple types in multiple indices,\nthe type of the field is understood to be a _union_ of the various types in the index mappings.\nAs seen in the preceding examples, this _union type_ cannot be used in the results,\nand cannot be referred to by the query -- except in `KEEP`, `DROP` or when it's passed to a type conversion function that accepts all the types in\nthe _union_ and converts the field to a single type. {esql} offers a suite of <<esql-type-conversion-functions,type conversion functions>> to achieve this.\n\nIn the above examples, the query can use a command like `EVAL client_ip = TO_IP(client_ip)` to resolve\nthe union of `ip` and `keyword` to just `ip`.\nYou can also use the type-conversion syntax `EVAL client_ip = client_ip::IP`.\nAlternatively, the query could use <<esql-to_string,`TO_STRING`>> to convert all supported types into `KEYWORD`.\n\nFor example, the <<query-unsupported,query>> that returned `client_ip:unsupported` with `null` values can be improved using the `TO_IP` function or the equivalent `field::ip` syntax.\nThese changes also resolve the error message.\nAs long as the only reference to the original field is to pass it to a conversion function that resolves the type ambiguity, no error results.\n\n[source.merge.styled,esql]\n----\nFROM events_*\n| EVAL client_ip = TO_IP(client_ip)\n| KEEP @timestamp, client_ip, event_duration, message\n| SORT @timestamp DESC\n----\n[%header.monospaced.styled,format=dsv,separator=|]\n|===\n@timestamp:date | client_ip:ip | event_duration:long | message:keyword\n2023-10-23T13:55:01.543Z | 172.21.3.15  | 1756467 | Connected to 10.1.0.1\n2023-10-23T13:53:55.832Z | 172.21.3.15  | 5033755 | Connection error\n2023-10-23T13:52:55.015Z | 172.21.3.15  | 8268153 | Connection error\n2023-10-23T13:51:54.732Z | 172.21.3.15  | 725448  | Connection error\n2023-10-23T13:33:34.937Z | 172.21.0.5   | 1232382 | Disconnected\n2023-10-23T12:27:28.948Z | 172.21.2.113 | 2764889 | Connected to 10.1.0.2\n2023-10-23T12:15:03.360Z | 172.21.2.162 | 3450233 | Connected to 10.1.0.3\n|===\n\n[discrete]\n[[esql-multi-index-index-metadata]]\n=== Index metadata\n\nIt can be helpful to know the particular index from which each row is sourced.\nTo get this information, use the <<esql-metadata-fields,`METADATA`>> option on the <<esql-from,`FROM`>> command.\n\n[source.merge.styled,esql]\n----\nFROM events_* METADATA _index\n| EVAL client_ip = TO_IP(client_ip)\n| KEEP _index, @timestamp, client_ip, event_duration, message\n| SORT @timestamp DESC\n----\n[%header.monospaced.styled,format=dsv,separator=|]\n|===\n_index:keyword | @timestamp:date | client_ip:ip | event_duration:long | message:keyword\nevents_ip | 2023-10-23T13:55:01.543Z | 172.21.3.15  | 1756467 | Connected to 10.1.0.1\nevents_ip | 2023-10-23T13:53:55.832Z | 172.21.3.15  | 5033755 | Connection error\nevents_ip | 2023-10-23T13:52:55.015Z | 172.21.3.15  | 8268153 | Connection error\nevents_keyword | 2023-10-23T13:51:54.732Z | 172.21.3.15  | 725448  | Connection error\nevents_keyword | 2023-10-23T13:33:34.937Z | 172.21.0.5   | 1232382 | Disconnected\nevents_keyword | 2023-10-23T12:27:28.948Z | 172.21.2.113 | 2764889 | Connected to 10.1.0.2\nevents_keyword | 2023-10-23T12:15:03.360Z | 172.21.2.162 | 3450233 | Connected to 10.1.0.3\n|===\n"
}