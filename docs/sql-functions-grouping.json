{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.689579",
        "size": 4571,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-functions-grouping.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "sql-functions-grouping",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[sql-functions-grouping]]\n=== Grouping Functions\n\nFunctions for creating special __grouping__s (also known as _bucketing_); as such these need to be used\nas part of the <<sql-syntax-group-by, grouping>>.\n\n[[sql-functions-grouping-histogram]]\n==== `HISTOGRAM`\n\n.Synopsis:\n[source, sql]\n----\nHISTOGRAM(\n    numeric_exp,        <1>\n    numeric_interval)   <2>\n\nHISTOGRAM(\n    date_exp,           <3>\n    date_time_interval) <4>\n----\n\n*Input*:\n\n<1> numeric expression (typically a field). If this field contains only `null`\nvalues, the function returns `null`. Otherwise, the function ignores `null`\nvalues in this field.\n<2> numeric interval. If `null`, the function returns `null`.\n<3> date/time expression (typically a field). If this field contains only `null`\nvalues, the function returns `null`. Otherwise, the function ignores `null`\nvalues in this field.\n<4> date/time <<sql-functions-datetime-interval, interval>>. If `null`, the\nfunction returns `null`.\n\n*Output*: non-empty buckets or groups of the given expression divided according to the given interval\n\n*Description*: The histogram function takes all matching values and divides them into buckets with fixed size matching the given interval, using (roughly) the following formula:\n\n[source, sql]\n----\nbucket_key = Math.floor(value / interval) * interval\n----\n\n[NOTE]\nThe histogram in SQL does *NOT* return empty buckets for missing intervals as the traditional <<search-aggregations-bucket-histogram-aggregation, histogram>> and  <<search-aggregations-bucket-datehistogram-aggregation, date histogram>>. Such behavior does not fit conceptually in SQL which treats all missing values as `null`; as such the histogram places all missing values in the `null` group.\n\n`Histogram` can be applied on either numeric fields:\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[histogramNumeric]\n----\n\nor date/time fields:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[histogramDateTime]\n----\n\nExpressions inside the histogram are also supported as long as the\nreturn type is numeric:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[histogramNumericExpression]\n----\n\nDo note that histograms (and grouping functions in general) allow custom expressions but cannot have any functions applied to them in the `GROUP BY`. In other words, the following statement is *NOT* allowed:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[expressionOnHistogramNotAllowed]\n----\n\nas it requires two groupings (one for histogram followed by a second for applying the function on top of the histogram groups).\n\nInstead one can rewrite the query to move the expression on the histogram _inside_ of it:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[histogramDateTimeExpression]\n----\n\n[IMPORTANT]\nWhen the histogram in SQL is applied on **DATE** type instead of **DATETIME**, the interval specified is truncated to\nthe multiple of a day. E.g.: for `HISTOGRAM(CAST(birth_date AS DATE), INTERVAL '2 3:04' DAY TO MINUTE)` the interval\nactually used will be `INTERVAL '2' DAY`. If the interval specified is less than 1 day, e.g.:\n`HISTOGRAM(CAST(birth_date AS DATE), INTERVAL '20' HOUR)` then the interval used will be `INTERVAL '1' DAY`.\n\n[IMPORTANT]\nAll intervals specified for a date/time HISTOGRAM will use a <<search-aggregations-bucket-datehistogram-aggregation,fixed interval>>\nin their `date_histogram` aggregation definition, with the notable exceptions of `INTERVAL '1' YEAR`, `INTERVAL '1' MONTH` and `INTERVAL '1' DAY`  where a calendar interval is used.\nThe choice for a calendar interval was made for having a more intuitive result for YEAR, MONTH and DAY groupings. In the case of YEAR, for example, the calendar intervals consider a one year\nbucket as the one starting on January 1st that specific year, whereas a fixed interval one-year-bucket considers one year as a number\nof milliseconds (for example, `31536000000ms` corresponding to 365 days, 24 hours per day, 60 minutes per hour etc.). With fixed intervals,\nthe day of February 5th, 2019 for example, belongs to a bucket that starts on December 20th, 2018 and {es} (and implicitly {es-sql}) would\nhave returned the year 2018 for a date that's actually in 2019. With calendar interval this behavior is more intuitive, having the day of\nFebruary 5th, 2019 actually belonging to the 2019 year bucket. \n\n[IMPORTANT]\nHistogram in SQL cannot be applied on **TIME** type.\nE.g.: `HISTOGRAM(CAST(birth_date AS TIME), INTERVAL '10' MINUTES)` is currently not supported.\n"
}