{
    "meta": {
        "size": 5244,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/wildcard-field-type.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "wildcard-field-type",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[discrete]\n[[wildcard-field-type]]\n=== Wildcard field type\n\nThe `wildcard` field type is a specialized keyword field for unstructured\nmachine-generated content you plan to search using grep-like\n<<query-dsl-wildcard-query,`wildcard`>> and <<query-dsl-regexp-query,`regexp`>>\nqueries. The `wildcard` type is optimized for fields with large values or high\ncardinality.\n\n[[mapping-unstructured-content]]\n.Mapping unstructured content\n****\nYou can map a field containing unstructured content to either a `text` or\nkeyword family field. The best field type depends on the nature of the content\nand how you plan to search the field.\n\nUse the `text` field type if:\n\n* The content is human-readable, such as an email body or product description.\n* You plan to search the field for individual words or phrases, such as `the\nbrown fox jumped`, using <<full-text-queries,full text queries>>. {es}\n<<analysis,analyzes>> `text` fields to return the most relevant results for\nthese queries.\n\nUse a keyword family field type if:\n\n* The content is machine-generated, such as a log message or HTTP request\ninformation.\n* You plan to search the field for exact full values, such as `org.foo.bar`, or\npartial character sequences, such as `org.foo.*`, using\n<<term-level-queries,term-level queries>>.\n\n**Choosing a keyword family field type**\n\nIf you choose a keyword family field type, you can map the field as a `keyword`\nor `wildcard` field depending on the cardinality and size of the field's values.\nUse the `wildcard` type if you plan to regularly search the field using a\n<<query-dsl-wildcard-query,`wildcard`>> or <<query-dsl-regexp-query,`regexp`>>\nquery and meet one of the following criteria:\n\n* The field contains more than a million unique values. +\nAND +\nYou plan to regularly search the field using a pattern with leading wildcards,\nsuch as `*foo` or `*baz`.\n\n* The field contains values larger than 32KB. +\nAND +\nYou plan to regularly search the field using any wildcard pattern.\n\nOtherwise, use the `keyword` field type for faster searches, faster indexing,\nand lower storage costs. For an in-depth comparison and decision flowchart, see\nour\nhttps://www.elastic.co/blog/find-strings-within-strings-faster-with-the-new-elasticsearch-wildcard-field[related\nblog post].\n\n**Switching from a `text` field to a keyword field**\n\nIf you previously used a `text` field to index unstructured machine-generated\ncontent, you can <<update-mapping,reindex to update the mapping>> to a `keyword`\nor `wildcard` field. We also recommend you update your application or workflow\nto replace any word-based <<full-text-queries,full text queries>> on the field\nto equivalent <<term-level-queries,term-level queries>>.\n****\n\nInternally the `wildcard` field indexes the whole field value using ngrams and stores the full string.\nThe index is used as a rough filter to cut down the number of values that are then checked by retrieving and checking the full values.\nThis field is especially well suited to run grep-like queries on log lines. Storage costs are typically lower than those of `keyword`\nfields but search speeds for exact matches on full terms are slower. If the\nfield values share many prefixes, such as URLs for the same website, storage\ncosts for a `wildcard` field may be higher than an equivalent `keyword` field.\n\n\nYou index and search a wildcard field as follows\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my_wildcard\": {\n        \"type\": \"wildcard\"\n      }\n    }\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  \"my_wildcard\" : \"This string can be quite lengthy\"\n}\n\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"wildcard\": {\n      \"my_wildcard\": {\n        \"value\": \"*quite*lengthy\"\n      }\n    }\n  }\n}\n\n\n--------------------------------------------------\n\n\n[discrete]\n[[wildcard-params]]\n==== Parameters for wildcard fields\n\nThe following parameters are accepted by `wildcard` fields:\n\n[horizontal]\n\n<<null-value,`null_value`>>::\n\n    Accepts a string value which is substituted for any explicit `null`\n    values. Defaults to `null`, which means the field is treated as missing.\n\n<<ignore-above,`ignore_above`>>::\n\n    Do not index any string longer than this value. Defaults to `2147483647`\n    so that all values would be accepted.\n\n[discrete]\n==== Limitations\n\n* `wildcard` fields are untokenized like keyword fields, so do not support queries that rely on word positions such as phrase queries.\n* When running `wildcard` queries any `rewrite` parameter is ignored. The scoring is always a constant score.\n\n[[wildcard-synthetic-source]]\n==== Synthetic `_source`\n\nSynthetic source may sort `wildcard` field values. For example:\n[source,console,id=synthetic-source-wildcard-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"card\": { \"type\": \"wildcard\" }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"card\": [\"king\", \"ace\", \"ace\", \"jack\"]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"card\": [\"ace\", \"jack\", \"king\"]\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n"
}