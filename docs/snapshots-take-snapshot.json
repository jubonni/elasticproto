{
    "meta": {
        "size": 18810,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-take-snapshot.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "snapshots-take-snapshot",
        "version": "8.15"
    },
    "doc": "[[snapshots-take-snapshot]]\n== Create a snapshot\n\n////\n[source,console]\n----\nPUT _slm/policy/nightly-snapshots\n{\n  \"schedule\": \"0 30 1 * * ?\",\n  \"name\": \"<nightly-snap-{now/d}>\",\n  \"repository\": \"my_repository\",\n  \"config\": {\n    \"indices\": \"*\",\n    \"include_global_state\": true\n  },\n  \"retention\": {\n    \"expire_after\": \"30d\",\n    \"min_count\": 5,\n    \"max_count\": 50\n  }\n}\n----\n// TEST[setup:setup-repository]\n// TESTSETUP\n////\n\nThis guide shows you how to take snapshots of a running cluster. You can later\n<<snapshots-restore-snapshot,restore a snapshot>> to recover or transfer its\ndata.\n\nIn this guide, you\u2019ll learn how to:\n\n* Automate snapshot creation and retention with {slm} ({slm-init})\n* Manually take a snapshot\n* Monitor a snapshot's progress\n* Delete or cancel a snapshot\n* Back up cluster configuration files\n\nThe guide also provides tips for creating dedicated cluster state snapshots and\ntaking snapshots at different time intervals.\n\n[discrete]\n[[create-snapshot-prereqs]]\n=== Prerequisites\n\ninclude::register-repository.asciidoc[tag=kib-snapshot-prereqs]\n\n* You can only take a snapshot from a running cluster with an elected\n<<master-node,master node>>.\n\n* A snapshot repository must be <<snapshots-register-repository,registered>> and\navailable to the cluster.\n\n* The cluster's global metadata must be readable. To include an index in a\nsnapshot, the index and its metadata must also be readable. Ensure there aren't\nany <<cluster-read-only,cluster blocks>> or <<index-modules-blocks,index\nblocks>> that prevent read access.\n\n[discrete]\n[[create-snapshot-considerations]]\n=== Considerations\n\n* Each snapshot must have a unique name within its repository. Attempts to\ncreate a snapshot with the same name as an existing snapshot will fail.\n\n* Snapshots are automatically deduplicated. You can take frequent snapshots with\nlittle impact to your storage overhead.\n\n* Each snapshot is logically independent. You can delete a snapshot without\naffecting other snapshots.\n\n* Taking a snapshot can temporarily pause shard allocations.\nSee <<snapshots-shard-allocation>>.\n\n* Taking a snapshot doesn't block indexing or other requests. However, the\nsnapshot won't include changes made after the snapshot process starts.\n\n* You can take multiple snapshots at the same time. The\n<<snapshot-max-concurrent-ops,`snapshot.max_concurrent_operations`>> cluster\nsetting limits the maximum number of concurrent snapshot operations.\n\n* If you include a data stream in a snapshot, the snapshot also includes the\nstream\u2019s backing indices and metadata.\n+\nYou can also include only specific backing indices in a snapshot. However, the\nsnapshot won't include the data stream\u2019s metadata or its other backing indices.\n\n* A snapshot can include a data stream but exclude specific backing indices.\nWhen you restore such a data stream, it will contain only backing indices in the\nsnapshot. If the stream\u2019s original write index is not in the snapshot, the most\nrecent backing index from the snapshot becomes the stream\u2019s write index.\n\n[discrete]\n[[automate-snapshots-slm]]\n=== Automate snapshots with {slm-init}\n\n{slm-cap} ({slm-init}) is the easiest way to regularly back up a cluster. An\n{slm-init} policy automatically takes snapshots on a preset schedule. The policy\ncan also delete snapshots based on retention rules you define.\n\nTIP: {ess} deployments automatically include the `cloud-snapshot-policy`\n{slm-init} policy. {ess} uses this policy to take periodic snapshots of your\ncluster. For more information, see the {cloud}/ec-snapshot-restore.html[{ess}\nsnapshot documentation].\n\n[discrete]\n[[slm-security]]\n==== {slm-init} security\n\nThe following <<privileges-list-cluster,cluster privileges>> control access to\nthe {slm-init} actions when {es} {security-features} are enabled:\n\n`manage_slm`::\nAllows a user to perform all {slm-init} actions, including\ncreating and updating policies and starting and stopping {slm-init}.\n\n`read_slm`::\nAllows a user to perform all read-only {slm-init} actions, such as getting\npolicies and checking the {slm-init} status.\n\n`cluster:admin/snapshot/*`::\nAllows a user to take and delete snapshots of any index, whether or not they\nhave access to that index.\n\nYou can create and manage roles to assign these privileges through {kib}\nManagement.\n\nTo grant the privileges necessary to create and manage {slm-init} policies and\nsnapshots, you can set up a role with the `manage_slm` and\n`cluster:admin/snapshot/*` cluster privileges and full access to the {slm-init}\nhistory indices.\n\nFor example, the following request creates an `slm-admin` role:\n\n[source,console]\n----\nPOST _security/role/slm-admin\n{\n  \"cluster\": [ \"manage_slm\", \"cluster:admin/snapshot/*\" ],\n  \"indices\": [\n    {\n      \"names\": [ \".slm-history-*\" ],\n      \"privileges\": [ \"all\" ]\n    }\n  ]\n}\n----\n// TEST[skip:security is not enabled here]\n\nTo grant read-only access to {slm-init} policies and the snapshot history,\nyou can set up a role with the `read_slm` cluster privilege and read access\nto the {slm} history indices.\n\nFor example, the following request creates a `slm-read-only` role:\n\n[source,console]\n----\nPOST _security/role/slm-read-only\n{\n  \"cluster\": [ \"read_slm\" ],\n  \"indices\": [\n    {\n      \"names\": [ \".slm-history-*\" ],\n      \"privileges\": [ \"read\" ]\n    }\n  ]\n}\n----\n// TEST[skip:security is not enabled here]\n\n[discrete]\n[[create-slm-policy]]\n==== Create an {slm-init} policy\n\nTo manage {slm-init} in {kib}, go to the main menu and click **Stack\nManagement** > **Snapshot and Restore** > **Policies**. To create a policy,\nclick **Create policy**.\n\nYou can also manage {slm-init} using the\n<<snapshot-lifecycle-management-api,{slm-init} APIs>>. To create a policy, use\nthe <<slm-api-put-policy,create {slm-init} policy API>>.\n\nThe following request creates a policy that backs up the cluster state, all data\nstreams, and all indices daily at 1:30 a.m. UTC.\n\n[source,console]\n----\nPUT _slm/policy/nightly-snapshots\n{\n  \"schedule\": \"0 30 1 * * ?\",       <1>\n  \"name\": \"<nightly-snap-{now/d}>\", <2>\n  \"repository\": \"my_repository\",    <3>\n  \"config\": {\n    \"indices\": \"*\",                 <4>\n    \"include_global_state\": true    <5>\n  },\n  \"retention\": {                    <6>\n    \"expire_after\": \"30d\",\n    \"min_count\": 5,\n    \"max_count\": 50\n  }\n}\n----\n\n<1> When to take snapshots, written in <<schedule-cron,Cron syntax>>.\n<2> Snapshot name. Supports <<api-date-math-index-names,date math>>. To prevent\n    naming conflicts, the policy also appends a UUID to each snapshot name.\n<3> <<snapshots-register-repository,Registered snapshot repository>> used to\n    store the policy's snapshots.\n<4> Data streams and indices to include in the policy's snapshots.\n<5> If `true`, the policy's snapshots include the cluster state. This also\n    includes all feature states by default. To only include specific feature\n    states, see <<back-up-specific-feature-state>>.\n<6> Optional retention rules. This configuration keeps snapshots for 30 days,\n    retaining at least 5 and no more than 50 snapshots regardless of age. See\n    <<slm-retention-task>> and <<snapshot-retention-limits>>.\n\n[discrete]\n[[manually-run-slm-policy]]\n==== Manually run an {slm-init} policy\n\nYou can manually run an {slm-init} policy to immediately create a snapshot. This\nis useful for testing a new policy or taking a snapshot before an upgrade.\nManually running a policy doesn't affect its snapshot schedule.\n\nTo run a policy in {kib}, go to the **Policies** page and click the run icon\nunder the **Actions** column. You can also use the\n<<slm-api-execute-lifecycle,execute {slm-init} policy API>>.\n\n[source,console]\n----\nPOST _slm/policy/nightly-snapshots/_execute\n----\n// TEST[skip:we can't easily handle snapshots from docs tests]\n\nThe snapshot process runs in the background. To monitor its progress, see\n<<monitor-snapshot>>.\n\n[discrete]\n[[slm-retention-task]]\n==== {slm-init} retention\n\n{slm-init} snapshot retention is a cluster-level task that runs separately from\na policy's snapshot schedule. To control when the {slm-init} retention task\nruns, configure the <<slm-retention-schedule,`slm.retention_schedule`>> cluster\nsetting.\n\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\" : {\n    \"slm.retention_schedule\" : \"0 30 1 * * ?\"\n  }\n}\n----\n\nTo immediately run the retention task, use the\n<<slm-api-execute-retention,execute {slm-init} retention policy API>>.\n\n[source,console]\n----\nPOST _slm/_execute_retention\n----\n\nAn {slm-init} policy's retention rules only apply to snapshots created using the\npolicy. Other snapshots don't count toward the policy's retention limits.\n\n[discrete]\n[[snapshot-retention-limits]]\n==== Snapshot retention limits\n\nWe recommend you include retention rules in your {slm-init} policy to delete\nsnapshots you no longer need.\n\nA snapshot repository can safely scale to thousands of snapshots. However, to\nmanage its metadata, a large repository requires more memory on the master node.\nRetention rules ensure a repository's metadata doesn't grow to a size that could\ndestabilize the master node.\n\n[discrete]\n[[manually-create-snapshot]]\n=== Manually create a snapshot\n\nTo take a snapshot without an {slm-init} policy, use the\n<<create-snapshot-api,create snapshot API>>. The snapshot name supports\n<<api-date-math-index-names,date math>>.\n\n[source,console]\n----\n# PUT _snapshot/my_repository/<my_snapshot_{now/d}>\nPUT _snapshot/my_repository/%3Cmy_snapshot_%7Bnow%2Fd%7D%3E\n----\n// TEST[s/3E/3E?wait_for_completion=true/]\n\nDepending on its size, a snapshot can take a while to complete. By default,\nthe create snapshot API only initiates the snapshot process, which runs in the\nbackground. To block the client until the snapshot finishes, set the\n`wait_for_completion` query parameter to `true`.\n\n[source,console]\n----\nPUT _snapshot/my_repository/my_snapshot?wait_for_completion=true\n----\n\nYou can also clone an existing snapshot using <<clone-snapshot-api,clone\nsnapshot API>>.\n\n[discrete]\n[[monitor-snapshot]]\n=== Monitor a snapshot\n\nTo monitor any currently running snapshots, use the <<get-snapshot-api,get\nsnapshot API>> with the `_current` request path parameter.\n\n[source,console]\n----\nGET _snapshot/my_repository/_current\n----\n\nTo get a complete breakdown of each shard participating in any currently running\nsnapshots, use the <<get-snapshot-api,get snapshot status API>>.\n\n[source,console]\n----\nGET _snapshot/_status\n----\n\n[discrete]\n[[check-slm-history]]\n==== Check {slm-init} history\n\nTo get more information about a cluster's {slm-init} execution history,\nincluding stats for each {slm-init} policy, use the <<slm-api-get-stats,get\n{slm-init} stats API>>. The API also returns information about the cluster's\nsnapshot retention task history.\n\n[source,console]\n----\nGET _slm/stats\n----\n\nTo get information about a specific {slm-init} policy's execution history, use\nthe <<slm-api-get-policy,get {slm-init} policy API>>. The response includes:\n\n* The next scheduled policy execution.\n* The last time the policy successfully started the snapshot process, if\n  applicable. A successful start doesn't guarantee the snapshot completed.\n* The last time policy execution failed, if applicable, and the associated\n  error.\n\n[source,console]\n----\nGET _slm/policy/nightly-snapshots\n----\n\n[discrete]\n[[delete-snapshot]]\n=== Delete or cancel a snapshot\n\nTo delete a snapshot in {kib}, go to the **Snapshots** page and click the trash\nicon under the **Actions** column. You can also use the\n<<delete-snapshot-api,delete snapshot API>>.\n\n[source,console]\n----\nDELETE _snapshot/my_repository/my_snapshot_2099.05.06\n----\n// TEST[setup:setup-snapshots]\n\nIf you delete a snapshot that's in progress, {es} cancels it. The snapshot\nprocess halts and deletes any files created for the snapshot. Deleting a\nsnapshot doesn't delete files used by other snapshots.\n\n[discrete]\n[[back-up-config-files]]\n=== Back up configuration files\n\nIf you run {es} on your own hardware, we recommend that, in addition to backups,\nyou take regular backups of the files in each node's\n<<config-files-location,`$ES_PATH_CONF` directory>> using the file backup software\nof your choice. Snapshots don't back up these files. Also note that these files will\ndiffer on each node, so each node's files should be backed up individually.\n\nIMPORTANT: The `elasticsearch.keystore`, TLS keys, and <<ref-saml-settings, SAML>>,\n<<ref-oidc-settings, OIDC>>, and <<ref-kerberos-settings, Kerberos>>\nrealms private key files contain sensitive information. Consider encrypting\nyour backups of these files.\n\n[discrete]\n[[back-up-specific-feature-state]]\n=== Back up a specific feature state\n\nBy default, a snapshot that includes the cluster state also includes all\n<<feature-state,feature states>>. Similarly, a snapshot that excludes the\ncluster state excludes all feature states by default.\n\nYou can also configure a snapshot to only include specific feature states,\nregardless of the cluster state.\n\nTo get a list of available features, use the <<get-features-api,get features\nAPI>>.\n\n[source,console]\n----\nGET _features\n----\n\nThe API returns:\n\n[source,console-result]\n----\n{\n  \"features\": [\n    {\n      \"name\": \"tasks\",\n      \"description\": \"Manages task results\"\n    },\n    {\n      \"name\": \"kibana\",\n      \"description\": \"Manages Kibana configuration and reports\"\n    },\n    {\n      \"name\": \"security\",\n      \"description\": \"Manages configuration for Security features, such as users and roles\"\n    },\n    ...\n  ]\n}\n----\n// TESTRESPONSE[skip:response may vary based on features in test cluster]\n\nTo include a specific feature state in a snapshot, specify the feature `name` in\nthe `feature_states` array.\n\nFor example, the following {slm-init} policy only includes feature states for\nthe {kib} and {es} security features in its snapshots.\n\n[source,console]\n----\nPUT _slm/policy/nightly-snapshots\n{\n  \"schedule\": \"0 30 2 * * ?\",\n  \"name\": \"<nightly-snap-{now/d}>\",\n  \"repository\": \"my_repository\",\n  \"config\": {\n    \"indices\": \"*\",\n    \"include_global_state\": true,\n    \"feature_states\": [\n      \"kibana\",\n      \"security\"\n    ]\n  },\n  \"retention\": {\n    \"expire_after\": \"30d\",\n    \"min_count\": 5,\n    \"max_count\": 50\n  }\n}\n----\n\nAny index or data stream that's part of the feature state will display in a\nsnapshot's contents. For example, if you back up the `security` feature state,\nthe `security-*` system indices display in the <<get-snapshot-api,get snapshot\nAPI>>'s response under both `indices` and `feature_states`.\n\n[discrete]\n[[cluster-state-snapshots]]\n=== Dedicated cluster state snapshots\n\nSome feature states contain sensitive data. For example, the `security` feature\nstate includes system indices that may contain user names and encrypted password\nhashes. Because passwords are stored using <<hashing-settings, cryptographic hashes>>,\nthe disclosure of a snapshot would not automatically enable a third party to\nauthenticate as one of your users or use API keys. However, it would disclose\nconfidential information, and if a third party can modify snapshots, they could\ninstall a back door.\n\nTo better protect this data, consider creating a dedicated repository and\n{slm-init} policy for snapshots of the cluster state. This lets you strictly\nlimit and audit access to the repository.\n\nFor example, the following {slm-init} policy only backs up the cluster state.\nThe policy stores these snapshots in a dedicated repository.\n\n[source,console]\n----\nPUT _slm/policy/nightly-cluster-state-snapshots\n{\n  \"schedule\": \"0 30 2 * * ?\",\n  \"name\": \"<nightly-cluster-state-snap-{now/d}>\",\n  \"repository\": \"my_secure_repository\",\n  \"config\": {\n    \"include_global_state\": true,                 <1>\n    \"indices\": \"-*\"                               <2>\n  },\n  \"retention\": {\n    \"expire_after\": \"30d\",\n    \"min_count\": 5,\n    \"max_count\": 50\n  }\n}\n----\n// TEST[s/my_secure_repository/my_repository/]\n\n<1> Includes the cluster state. This also includes all feature states by\n    default.\n<2> Excludes regular data streams and indices.\n\nIf you take dedicated snapshots of the cluster state, you'll need to exclude the\ncluster state from your other snapshots. For example:\n\n[source,console]\n----\nPUT _slm/policy/nightly-snapshots\n{\n  \"schedule\": \"0 30 2 * * ?\",\n  \"name\": \"<nightly-snap-{now/d}>\",\n  \"repository\": \"my_repository\",\n  \"config\": {\n    \"include_global_state\": false,    <1>\n    \"indices\": \"*\"                    <2>\n  },\n  \"retention\": {\n    \"expire_after\": \"30d\",\n    \"min_count\": 5,\n    \"max_count\": 50\n  }\n}\n----\n\n<1> Excludes the cluster state. This also excludes all feature states by\n    default.\n<2> Includes all regular data streams and indices.\n\n[discrete]\n[[create-snapshots-different-time-intervals]]\n=== Create snapshots at different time intervals\n\nIf you only use a single {slm-init} policy, it can be difficult to take frequent\nsnapshots and retain snapshots with longer time intervals.\n\nFor example, a policy that takes snapshots every 30 minutes with a maximum of\n100 snapshots will only keep snapshots for approximately two days. While this\nsetup is great for backing up recent changes, it doesn't let you restore data\nfrom a previous week or month.\n\nTo fix this, you can create multiple {slm-init} policies with the same snapshot\nrepository that run on different schedules. Since a policy's retention rules\nonly apply to its snapshots, a policy won't delete a snapshot created by another\npolicy.\n\nFor example, the following {slm-init} policy takes hourly snapshots with a\nmaximum of 24 snapshots. The policy keeps its snapshots for one day.\n\n[source,console]\n----\nPUT _slm/policy/hourly-snapshots\n{\n  \"name\": \"<hourly-snapshot-{now/d}>\",\n  \"schedule\": \"0 0 * * * ?\",\n  \"repository\": \"my_repository\",\n  \"config\": {\n    \"indices\": \"*\",\n    \"include_global_state\": true\n  },\n  \"retention\": {\n    \"expire_after\": \"1d\",\n    \"min_count\": 1,\n    \"max_count\": 24\n  }\n}\n----\n\nThe following policy takes nightly snapshots in the same snapshot repository.\nThe policy keeps its snapshots for one month.\n\n[source,console]\n----\nPUT _slm/policy/daily-snapshots\n{\n  \"name\": \"<daily-snapshot-{now/d}>\",\n  \"schedule\": \"0 45 23 * * ?\",          <1>\n  \"repository\": \"my_repository\",\n  \"config\": {\n    \"indices\": \"*\",\n    \"include_global_state\": true\n  },\n  \"retention\": {\n    \"expire_after\": \"30d\",\n    \"min_count\": 1,\n    \"max_count\": 31\n  }\n}\n----\n\n<1> Runs at 11:45 p.m. UTC every day.\n\nThe following policy creates monthly snapshots in the same repository. The\npolicy keeps its snapshots for one year.\n\n[source,console]\n----\nPUT _slm/policy/monthly-snapshots\n{\n  \"name\": \"<monthly-snapshot-{now/d}>\",\n  \"schedule\": \"0 56 23 1 * ?\",            <1>\n  \"repository\": \"my_repository\",\n  \"config\": {\n    \"indices\": \"*\",\n    \"include_global_state\": true\n  },\n  \"retention\": {\n    \"expire_after\": \"366d\",\n    \"min_count\": 1,\n    \"max_count\": 12\n  }\n}\n----\n\n<1> Runs on the first of the month at 11:56 p.m. UTC.\n"
}