{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.763068",
        "size": 9135,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "query-dsl-nested-query",
        "version": "8.15"
    },
    "doc": "[[query-dsl-nested-query]]\n=== Nested query\n++++\n<titleabbrev>Nested</titleabbrev>\n++++\n\nWraps another query to search <<nested,nested>> fields.\n\nThe `nested` query searches nested field objects as if they were indexed as\nseparate documents. If an object matches the search, the `nested` query returns\nthe root parent document.\n\n[[nested-query-ex-request]]\n==== Example request\n\n[[nested-query-index-setup]]\n===== Index setup\n\nTo use the `nested` query, your index must include a <<nested,nested>> field\nmapping. For example:\n\n[source,console]\n----\nPUT /my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"obj1\": {\n        \"type\": \"nested\"\n      }\n    }\n  }\n}\n\n----\n\n[[nested-query-ex-query]]\n===== Example query\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"nested\": {\n      \"path\": \"obj1\",\n      \"query\": {\n        \"bool\": {\n          \"must\": [\n            { \"match\": { \"obj1.name\": \"blue\" } },\n            { \"range\": { \"obj1.count\": { \"gt\": 5 } } }\n          ]\n        }\n      },\n      \"score_mode\": \"avg\"\n    }\n  }\n}\n----\n// TEST[continued]\n\n[[nested-top-level-params]]\n==== Top-level parameters for `nested`\n\n`path`::\n(Required, string) Path to the nested object you wish to search.\n\n`query`::\n+\n--\n(Required, query object) Query you wish to run on nested objects in the `path`.\nIf an object matches the search, the `nested` query returns the root parent\ndocument.\n\nYou can search nested fields using dot notation that includes the complete path,\nsuch as `obj1.name`.\n\nMulti-level nesting is automatically supported, and detected, resulting in an\ninner nested query to automatically match the relevant nesting level, rather\nthan root, if it exists within another nested query.\n\nSee <<multi-level-nested-query-ex>> for an example.\n--\n\n`score_mode`::\n+\n--\n(Optional, string) Indicates how scores for matching child objects affect the\nroot parent document's <<relevance-scores,relevance score>>. Valid values\nare:\n\n`avg` (Default)::\nUse the mean relevance score of all matching child objects.\n\n`max`::\nUses the highest relevance score of all matching child objects.\n\n`min`::\nUses the lowest relevance score of all matching child objects.\n\n`none`::\nDo not use the relevance scores of matching child objects. The query assigns\nparent documents a score of `0`.\n\n`sum`::\nAdd together the relevance scores of all matching child objects.\n--\n\n`ignore_unmapped`::\n+\n--\n(Optional, Boolean) Indicates whether to ignore an unmapped `path` and not\nreturn any documents instead of an error. Defaults to `false`.\n\nIf `false`, {es} returns an error if the `path` is an unmapped field.\n\nYou can use this parameter to query multiple indices that may not contain the\nfield `path`.\n--\n\n[[nested-query-notes]]\n==== Notes\n\n[[nested-query-script-notes]]\n===== Context of script queries\nIf you run a <<query-dsl-script-query,`script` query>> within a nested query,\nyou can only access doc values from the nested document, not the parent\nor root document.\n\n[[multi-level-nested-query-ex]]\n===== Multi-level nested queries\n\nTo see how multi-level nested queries work,\nfirst you need an index that has nested fields.\nThe following request defines mappings for the `drivers` index\nwith nested `make` and `model` fields.\n\n[source,console]\n----\nPUT /drivers\n{\n  \"mappings\": {\n    \"properties\": {\n      \"driver\": {\n        \"type\": \"nested\",\n        \"properties\": {\n          \"last_name\": {\n            \"type\": \"text\"\n          },\n          \"vehicle\": {\n            \"type\": \"nested\",\n            \"properties\": {\n              \"make\": {\n                \"type\": \"text\"\n              },\n              \"model\": {\n                \"type\": \"text\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n----\n\nNext, index some documents to the `drivers` index.\n\n[source,console]\n----\nPUT /drivers/_doc/1\n{\n  \"driver\" : {\n        \"last_name\" : \"McQueen\",\n        \"vehicle\" : [\n            {\n                \"make\" : \"Powell Motors\",\n                \"model\" : \"Canyonero\"\n            },\n            {\n                \"make\" : \"Miller-Meteor\",\n                \"model\" : \"Ecto-1\"\n            }\n        ]\n    }\n}\n\nPUT /drivers/_doc/2?refresh\n{\n  \"driver\" : {\n        \"last_name\" : \"Hudson\",\n        \"vehicle\" : [\n            {\n                \"make\" : \"Mifune\",\n                \"model\" : \"Mach Five\"\n            },\n            {\n                \"make\" : \"Miller-Meteor\",\n                \"model\" : \"Ecto-1\"\n            }\n        ]\n    }\n}\n----\n// TEST[continued]\n\nYou can now use a multi-level nested query\nto match documents based on the `make` and `model` fields.\n\n[source,console]\n----\nGET /drivers/_search\n{\n  \"query\": {\n    \"nested\": {\n      \"path\": \"driver\",\n      \"query\": {\n        \"nested\": {\n          \"path\": \"driver.vehicle\",\n          \"query\": {\n            \"bool\": {\n              \"must\": [\n                { \"match\": { \"driver.vehicle.make\": \"Powell Motors\" } },\n                { \"match\": { \"driver.vehicle.model\": \"Canyonero\" } }\n              ]\n            }\n          }\n        }\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nThe search request returns the following response:\n\n[source,console-result]\n----\n{\n  \"took\" : 5,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 3.7349272,\n    \"hits\" : [\n      {\n        \"_index\" : \"drivers\",\n        \"_id\" : \"1\",\n        \"_score\" : 3.7349272,\n        \"_source\" : {\n          \"driver\" : {\n            \"last_name\" : \"McQueen\",\n            \"vehicle\" : [\n              {\n                \"make\" : \"Powell Motors\",\n                \"model\" : \"Canyonero\"\n              },\n              {\n                \"make\" : \"Miller-Meteor\",\n                \"model\" : \"Ecto-1\"\n              }\n            ]\n          }\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\" : 5/\"took\": $body.took/]\n\n[[must-not-clauses-and-nested-queries]]\n===== `must_not` clauses and `nested` queries\n\nIf a `nested` query matches one or more nested objects in a document, it returns\nthe document as a hit. This applies even if other nested objects in the document\ndon't match the query. Keep this in mind when using a `nested` query that\ncontains an inner <<query-dsl-bool-query,`must_not` clause>>.\n\nTIP: Use the <<inner-hits,`inner_hits`>> parameter to see which nested objects\nmatched a `nested` query.\n\nFor example, the following search uses an outer `nested` query with an inner\n`must_not` clause.\n\n[source,console]\n----\nPUT my-index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"comments\": {\n        \"type\": \"nested\"\n      }\n    }\n  }\n}\n\nPUT my-index/_doc/1?refresh\n{\n  \"comments\": [\n    {\n      \"author\": \"kimchy\"\n    }\n  ]\n}\n\nPUT my-index/_doc/2?refresh\n{\n  \"comments\": [\n    {\n      \"author\": \"kimchy\"\n    },\n    {\n      \"author\": \"nik9000\"\n    }\n  ]\n}\n\nPUT my-index/_doc/3?refresh\n{\n  \"comments\": [\n    {\n      \"author\": \"nik9000\"\n    }\n  ]\n}\n\nPOST my-index/_search\n{\n  \"query\": {\n    \"nested\": {\n      \"path\": \"comments\",\n      \"query\": {\n        \"bool\": {\n          \"must_not\": [\n            {\n              \"term\": {\n                \"comments.author\": \"nik9000\"\n              }\n            }\n          ]\n        }\n      }\n    }\n  }\n}\n----\n// TEST[s/_search/_search?filter_path=hits.hits/]\n\nThe search returns:\n\n[source,console]\n----\n{\n  ...\n  \"hits\" : {\n    ...\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index\",\n        \"_id\" : \"1\",\n        \"_score\" : 0.0,\n        \"_source\" : {\n          \"comments\" : [\n            {\n              \"author\" : \"kimchy\"\n            }\n          ]\n        }\n      },\n      {\n        \"_index\" : \"my-index\",\n        \"_id\" : \"2\",\n        \"_score\" : 0.0,\n        \"_source\" : {\n          \"comments\" : [\n            {\n              \"author\" : \"kimchy\"              <1>\n            },\n            {\n              \"author\" : \"nik9000\"             <2>\n            }\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n<1> This nested object matches the query. As a result, the search returns the\nobject's parent document as a hit.\n\n<2> This nested object doesn't match the query. Since another nested object in\nthe same document does match the query, the search still returns the parent\ndocument as a hit.\n\nTo exclude documents with any nested objects that match the `nested` query,\nuse an outer `must_not` clause.\n\n[source,console]\n----\nPOST my-index/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must_not\": [\n        {\n          \"nested\": {\n            \"path\": \"comments\",\n            \"query\": {\n              \"term\": {\n                \"comments.author\": \"nik9000\"\n              }\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n----\n// TEST[continued]\n// TEST[s/_search/_search?filter_path=hits.hits/]\n\nThe search returns:\n\n[source,console]\n----\n{\n  ...\n  \"hits\" : {\n    ...\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index\",\n        \"_id\" : \"1\",\n        \"_score\" : 0.0,\n        \"_source\" : {\n          \"comments\" : [\n            {\n              \"author\" : \"kimchy\"\n            }\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\.//]\n"
}