{
    "meta": {
        "size": 23679,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/size-your-shards.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "size-your-shards",
        "version": "8.15"
    },
    "doc": "[[size-your-shards]]\n== Size your shards\n\nEach index in {es} is divided into one or more shards, each of which may be\nreplicated across multiple nodes to protect against hardware failures. If you\nare using <<data-streams>> then each data stream is backed by a sequence of\nindices. There is a limit to the amount of data you can store on a single node\nso you can increase the capacity of your cluster by adding nodes and increasing\nthe number of indices and shards to match. However, each index and shard has\nsome overhead and if you divide your data across too many shards then the\noverhead can become overwhelming. A cluster with too many indices or shards is\nsaid to suffer from _oversharding_. An oversharded cluster will be less\nefficient at responding to searches and in extreme cases it may even become\nunstable.\n\n[discrete]\n[[create-a-sharding-strategy]]\n=== Create a sharding strategy\n\nThe best way to prevent oversharding and other shard-related issues is to\ncreate a sharding strategy. A sharding strategy helps you determine and\nmaintain the optimal number of shards for your cluster while limiting the size\nof those shards.\n\nUnfortunately, there is no one-size-fits-all sharding strategy. A strategy that\nworks in one environment may not scale in another. A good sharding strategy\nmust account for your infrastructure, use case, and performance expectations.\n\nThe best way to create a sharding strategy is to benchmark your production data\non production hardware using the same queries and indexing loads you'd see in\nproduction. For our recommended methodology, watch the\nhttps://www.elastic.co/elasticon/conf/2016/sf/quantitative-cluster-sizing[quantitative\ncluster sizing video]. As you test different shard configurations, use {kib}'s\n{kibana-ref}/elasticsearch-metrics.html[{es} monitoring tools] to track your\ncluster's stability and performance.\n\nThe performance of an {es} node is often limited by the performance of the underlying storage. \nReview our recommendations for optimizing your storage for <<indexing-use-faster-hardware,indexing>> and <<search-use-faster-hardware,search>>.\n\nThe following sections provide some reminders and guidelines you should\nconsider when designing your sharding strategy. If your cluster is already\noversharded, see <<reduce-cluster-shard-count>>.\n\n[discrete]\n[[shard-sizing-considerations]]\n=== Sizing considerations\n\nKeep the following things in mind when building your sharding strategy.\n\n[discrete]\n[[single-thread-per-shard]]\n==== Searches run on a single thread per shard\n\nMost searches hit multiple shards. Each shard runs the search on a single\nCPU thread. While a shard can run multiple concurrent searches, searches across a\nlarge number of shards can deplete a node's <<modules-threadpool,search\nthread pool>>. This can result in low throughput and slow search speeds.\n\n[discrete]\n[[each-shard-has-overhead]]\n==== Each index, shard, segment and field has overhead\n\nEvery index and every shard requires some memory and CPU resources. In most\ncases, a small set of large shards uses fewer resources than many small shards.\n\nSegments play a big role in a shard's resource usage. Most shards contain\nseveral segments, which store its index data. {es} keeps some segment metadata\nin heap memory so it can be quickly retrieved for searches. As a shard grows,\nits segments are <<index-modules-merge,merged>> into fewer, larger segments.\nThis decreases the number of segments, which means less metadata is kept in\nheap memory.\n\nEvery mapped field also carries some overhead in terms of memory usage and disk\nspace. By default {es} will automatically create a mapping for every field in\nevery document it indexes, but you can switch off this behaviour to\n<<explicit-mapping,take control of your mappings>>.\n\nMoreover every segment requires a small amount of heap memory for each mapped\nfield. This per-segment-per-field heap overhead includes a copy of the field\nname, encoded using ISO-8859-1 if applicable or UTF-16 otherwise. Usually this\nis not noticeable, but you may need to account for this overhead if your shards\nhave high segment counts and the corresponding mappings contain high field\ncounts and/or very long field names.\n\n[discrete]\n[[shard-auto-balance]]\n==== {es} automatically balances shards within a data tier\n\nA cluster's nodes are grouped into <<data-tiers,data tiers>>. Within each tier,\n{es} attempts to spread an index's shards across as many nodes as possible. When\nyou add a new node or a node fails, {es} automatically rebalances the index's\nshards across the tier's remaining nodes.\n\n[discrete]\n[[shard-size-best-practices]]\n=== Best practices\n\nWhere applicable, use the following best practices as starting points for your\nsharding strategy.\n\n[discrete]\n[[delete-indices-not-documents]]\n==== Delete indices, not documents\n\nDeleted documents aren't immediately removed from {es}'s file system.\nInstead, {es} marks the document as deleted on each related shard. The marked\ndocument will continue to use resources until it's removed during a periodic\n<<index-modules-merge,segment merge>>.\n\nWhen possible, delete entire indices instead. {es} can immediately remove\ndeleted indices directly from the file system and free up resources.\n\n[discrete]\n[[use-ds-ilm-for-time-series]]\n==== Use data streams and {ilm-init} for time series data\n\n<<data-streams,Data streams>> let you store time series data across multiple,\ntime-based backing indices. You can use <<index-lifecycle-management,{ilm}\n({ilm-init})>> to automatically manage these backing indices.\n\nOne advantage of this setup is\n<<getting-started-index-lifecycle-management,automatic rollover>>, which creates\na new write index when the current one meets a defined `max_primary_shard_size`,\n`max_age`, `max_docs`, or `max_size` threshold. When an index is no longer\nneeded, you can use {ilm-init} to automatically delete it and free up resources.\n\n{ilm-init} also makes it easy to change your sharding strategy over time:\n\n* *Want to decrease the shard count for new indices?* +\nChange the <<index-number-of-shards,`index.number_of_shards`>> setting in the\ndata stream's <<data-streams-change-mappings-and-settings,matching index\ntemplate>>.\n\n* *Want larger shards or fewer backing indices?* +\nIncrease your {ilm-init} policy's <<ilm-rollover,rollover threshold>>.\n\n* *Need indices that span shorter intervals?* +\nOffset the increased shard count by deleting older indices sooner. You can do\nthis by lowering the `min_age` threshold for your policy's\n<<ilm-index-lifecycle,delete phase>>.\n\nEvery new backing index is an opportunity to further tune your strategy.\n\n[discrete]\n[[shard-size-recommendation]]\n==== Aim for shards of up to 200M documents, or with sizes between 10GB and 50GB\n\nThere is some overhead associated with each shard, both in terms of cluster\nmanagement and search performance. Searching a thousand 50MB shards will be\nsubstantially more expensive than searching a single 50GB shard containing the\nsame data. However, very large shards can also cause slower searches and will\ntake longer to recover after a failure.\n\nThere is no hard limit on the physical size of a shard, and each shard can in\ntheory contain up to <<troubleshooting-max-docs-limit,just over two billion \ndocuments>>. However, experience shows that shards between 10GB and 50GB \ntypically work well for many use cases, as long as the per-shard document count \nis kept below 200 million.\n\nYou may be able to use larger shards depending on your network and use case,\nand smaller shards may be appropriate for\n{enterprise-search-ref}/index.html[Enterprise Search] and similar use cases.\n\nIf you use {ilm-init}, set the <<ilm-rollover,rollover action>>'s\n`max_primary_shard_size` threshold to `50gb` to avoid shards larger than 50GB \nand `min_primary_shard_size` threshold to `10gb` to avoid shards smaller than 10GB.\n\nTo see the current size of your shards, use the <<cat-shards,cat shards API>>.\n\n[source,console]\n----\nGET _cat/shards?v=true&h=index,prirep,shard,store&s=prirep,store&bytes=gb\n----\n// TEST[setup:my_index]\n\nThe `pri.store.size` value shows the combined size of all primary shards for\nthe index.\n\n[source,txt]\n----\nindex                                 prirep shard store\n.ds-my-data-stream-2099.05.06-000001  p      0      50gb\n...\n----\n// TESTRESPONSE[non_json]\n// TESTRESPONSE[s/\\.ds-my-data-stream-2099\\.05\\.06-000001/my-index-000001/]\n// TESTRESPONSE[s/50gb/.*/]\n\nIf an index's shard is experiencing degraded performance from surpassing the \nrecommended 50GB size, you may consider fixing the index's shards' sizing. \nShards are immutable and therefore their size is fixed in place, \nso indices must be copied with corrected settings. This requires first ensuring \nsufficient disk to copy the data. Afterwards, you can copy the index's data \nwith corrected settings via one of the following options:\n\n* running <<indices-split-index,Split Index>> to increase number of primary \nshards \n\n* creating a destination index with corrected settings and then running \n<<docs-reindex,Reindex>> \n\nKindly note performing a <<restore-snapshot-api,Restore Snapshot>> and/or \n<<indices-clone-index,Clone Index>> would be insufficient to resolve shards' \nsizing. \n\nOnce a source index's data is copied into its destination index, the source \nindex can be <<indices-delete-index,removed>>. You may then consider setting \n<<indices-add-alias,Create Alias>> against the destination index for the source \nindex's name to point to it for continuity. \n\nSee this https://www.youtube.com/watch?v=sHyNYnwbYro[fixing shard sizes video] for an example troubleshooting walkthrough.\n\n[discrete]\n[[shard-count-recommendation]]\n==== Master-eligible nodes should have at least 1GB of heap per 3000 indices\n\nThe number of indices a master node can manage is proportional to its heap\nsize. The exact amount of heap memory needed for each index depends on various\nfactors such as the size of the mapping and the number of shards per index.\n\nAs a general rule of thumb, you should have fewer than 3000 indices per GB of\nheap on master nodes. For example, if your cluster has dedicated master nodes\nwith 4GB of heap each then you should have fewer than 12000 indices. If your\nmaster nodes are not dedicated master nodes then the same sizing guidance\napplies: you should reserve at least 1GB of heap on each master-eligible node\nfor every 3000 indices in your cluster.\n\nNote that this rule defines the absolute maximum number of indices that a\nmaster node can manage, but does not guarantee the performance of searches or\nindexing involving this many indices. You must also ensure that your data nodes\nhave adequate resources for your workload and that your overall sharding\nstrategy meets all your performance requirements. See also\n<<single-thread-per-shard>> and <<each-shard-has-overhead>>.\n\nTo check the configured size of each node's heap, use the <<cat-nodes,cat nodes\nAPI>>.\n\n[source,console]\n----\nGET _cat/nodes?v=true&h=heap.max\n----\n// TEST[setup:my_index]\n\nYou can use the <<cat-shards,cat shards API>> to check the number of shards per\nnode.\n\n[source,console]\n----\nGET _cat/shards?v=true\n----\n// TEST[setup:my_index]\n\n[discrete]\n[[shard-count-per-node-recommendation]]\n==== Add enough nodes to stay within the cluster shard limits\n\ninclude::./shard-limits.asciidoc[]\n\n[discrete]\n[[field-count-recommendation]]\n==== Allow enough heap for field mappers and overheads\n\nMapped fields consume some heap memory on each node, and require extra\nheap on data nodes.\nEnsure each node has enough heap for mappings, and also allow\nextra space for overheads associated with its workload. The following sections\nshow how to determine these heap requirements.\n\n[discrete]\n===== Mapping metadata in the cluster state\n\nEach node in the cluster has a copy of the <<cluster-state-api-desc,cluster state>>.\nThe cluster state includes information about the field mappings for\neach index. This information has heap overhead. You can use the\n<<cluster-stats,Cluster stats API>> to get the heap overhead of the total size of\nall mappings after deduplication and compression.\n\n[source,console]\n----\nGET _cluster/stats?human&filter_path=indices.mappings.total_deduplicated_mapping_size*\n----\n// TEST[setup:node]\n\nThis will show you information like in this example output:\n\n[source,console-result]\n----\n{\n  \"indices\": {\n    \"mappings\": {\n      \"total_deduplicated_mapping_size\": \"1gb\",\n      \"total_deduplicated_mapping_size_in_bytes\": 1073741824\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\"total_deduplicated_mapping_size\": \"1gb\"/\"total_deduplicated_mapping_size\": $body.$_path/]\n// TESTRESPONSE[s/\"total_deduplicated_mapping_size_in_bytes\": 1073741824/\"total_deduplicated_mapping_size_in_bytes\": $body.$_path/]\n\n[discrete]\n===== Retrieving heap size and field mapper overheads\n\nYou can use the <<cluster-nodes-stats,Nodes stats API>> to get two relevant metrics\nfor each node:\n\n* The size of the heap on each node.\n\n* Any additional estimated heap overhead for the fields per node. This is specific to\ndata nodes, where apart from the cluster state field information mentioned above,\nthere is additional heap overhead for each mapped field of an index held by the data\nnode. For nodes which are not data nodes, this field may be zero.\n\n[source,console]\n----\nGET _nodes/stats?human&filter_path=nodes.*.name,nodes.*.indices.mappings.total_estimated_overhead*,nodes.*.jvm.mem.heap_max*\n----\n// TEST[setup:node]\n\nFor each node, this will show you information like in this example output:\n\n[source,console-result]\n----\n{\n  \"nodes\": {\n    \"USpTGYaBSIKbgSUJR2Z9lg\": {\n      \"name\": \"node-0\",\n      \"indices\": {\n        \"mappings\": {\n          \"total_estimated_overhead\": \"1gb\",\n          \"total_estimated_overhead_in_bytes\": 1073741824\n        }\n      },\n      \"jvm\": {\n        \"mem\": {\n          \"heap_max\": \"4gb\",\n          \"heap_max_in_bytes\": 4294967296\n        }\n      }\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\"USpTGYaBSIKbgSUJR2Z9lg\"/\\$node_name/]\n// TESTRESPONSE[s/\"name\": \"node-0\"/\"name\": $body.$_path/]\n// TESTRESPONSE[s/\"total_estimated_overhead\": \"1gb\"/\"total_estimated_overhead\": $body.$_path/]\n// TESTRESPONSE[s/\"total_estimated_overhead_in_bytes\": 1073741824/\"total_estimated_overhead_in_bytes\": $body.$_path/]\n// TESTRESPONSE[s/\"heap_max\": \"4gb\"/\"heap_max\": $body.$_path/]\n// TESTRESPONSE[s/\"heap_max_in_bytes\": 4294967296/\"heap_max_in_bytes\": $body.$_path/]\n\n[discrete]\n===== Consider additional heap overheads\n\nApart from the two field overhead metrics above, you must additionally allow\nenough heap for {es}'s baseline usage as well as your workload such as indexing,\nsearches and aggregations. 0.5GB of extra heap will suffice for many reasonable\nworkloads, and you may need even less if your workload is very light while heavy\nworkloads may require more.\n\n[discrete]\n===== Example\n\nAs an example, consider the outputs above for a data node. The heap of the node\nwill need at least:\n\n* 1 GB for the cluster state field information.\n\n* 1 GB for the additional estimated heap overhead for the fields of the data node.\n\n* 0.5 GB of extra heap for other overheads.\n\nSince the node has a 4GB heap max size in the example, it is thus sufficient\nfor the total required heap of 2.5GB.\n\nIf the heap max size for a node is not sufficient, consider\n<<avoid-unnecessary-fields,avoiding unnecessary fields>>,\nor scaling up the cluster, or redistributing index shards.\n\nNote that the above rules do not necessarily guarantee the performance of\nsearches or indexing involving a very high number of indices. You must also\nensure that your data nodes have adequate resources for your workload and\nthat your overall sharding strategy meets all your performance requirements.\nSee also <<single-thread-per-shard>> and <<each-shard-has-overhead>>.\n\n[discrete]\n[[avoid-node-hotspots]]\n==== Avoid node hotspots\n\nIf too many shards are allocated to a specific node, the node can become a\nhotspot. For example, if a single node contains too many shards for an index\nwith a high indexing volume, the node is likely to have issues.\n\nTo prevent hotspots, use the\n<<total-shards-per-node,`index.routing.allocation.total_shards_per_node`>> index\nsetting to explicitly limit the number of shards on a single node. You can\nconfigure `index.routing.allocation.total_shards_per_node` using the\n<<indices-update-settings,update index settings API>>.\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001/_settings\n{\n  \"index\" : {\n    \"routing.allocation.total_shards_per_node\" : 5\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[discrete]\n[[avoid-unnecessary-fields]]\n==== Avoid unnecessary mapped fields\n\nBy default {es} <<dynamic-mapping,automatically creates a mapping>> for every\nfield in every document it indexes. Every mapped field corresponds to some data\nstructures on disk which are needed for efficient search, retrieval, and\naggregations on this field. Details about each mapped field are also held in\nmemory. In many cases this overhead is unnecessary because a field is not used\nin any searches or aggregations. Use <<explicit-mapping>> instead of dynamic\nmapping to avoid creating fields that are never used. If a collection of fields\nare typically used together, consider using <<copy-to>> to consolidate them at\nindex time. If a field is only rarely used, it may be better to make it a\n<<runtime,Runtime field>> instead.\n\nYou can get information about which fields are being used with the\n<<field-usage-stats>> API, and you can analyze the disk usage of mapped fields\nusing the <<indices-disk-usage>> API. Note however that unnecessary mapped\nfields also carry some memory overhead as well as their disk usage.\n\n[discrete]\n[[reduce-cluster-shard-count]]\n=== Reduce a cluster's shard count\n\nIf your cluster is already oversharded, you can use one or more of the following\nmethods to reduce its shard count.\n\n[discrete]\n[[create-indices-that-cover-longer-time-periods]]\n==== Create indices that cover longer time periods\n\nIf you use {ilm-init} and your retention policy allows it, avoid using a\n`max_age` threshold for the rollover action. Instead, use\n`max_primary_shard_size` to avoid creating empty indices or many small shards.\n\nIf your retention policy requires a `max_age` threshold, increase it to create\nindices that cover longer time intervals. For example, instead of creating daily\nindices, you can create indices on a weekly or monthly basis.\n\n[discrete]\n[[delete-empty-indices]]\n==== Delete empty or unneeded indices\n\nIf you're using {ilm-init} and roll over indices based on a `max_age` threshold,\nyou can inadvertently create indices with no documents. These empty indices\nprovide no benefit but still consume resources.\n\nYou can find these empty indices using the <<cat-count,cat count API>>.\n\n[source,console]\n----\nGET _cat/count/my-index-000001?v=true\n----\n// TEST[setup:my_index]\n\nOnce you have a list of empty indices, you can delete them using the\n<<indices-delete-index,delete index API>>. You can also delete any other\nunneeded indices.\n\n[source,console]\n----\nDELETE my-index-000001\n----\n// TEST[setup:my_index]\n\n[discrete]\n[[force-merge-during-off-peak-hours]]\n==== Force merge during off-peak hours\n\nIf you no longer write to an index, you can use the <<indices-forcemerge,force\nmerge API>> to <<index-modules-merge,merge>> smaller segments into larger ones.\nThis can reduce shard overhead and improve search speeds. However, force merges\nare resource-intensive. If possible, run the force merge during off-peak hours.\n\n[source,console]\n----\nPOST my-index-000001/_forcemerge\n----\n// TEST[setup:my_index]\n\n[discrete]\n[[shrink-existing-index-to-fewer-shards]]\n==== Shrink an existing index to fewer shards\n\nIf you no longer write to an index, you can use the\n<<indices-shrink-index,shrink index API>> to reduce its shard count.\n\n{ilm-init} also has a <<ilm-shrink,shrink action>> for indices in the\nwarm phase.\n\n[discrete]\n[[combine-smaller-indices]]\n==== Combine smaller indices\n\nYou can also use the <<docs-reindex,reindex API>> to combine indices\nwith similar mappings into a single large index. For time series data, you could\nreindex indices for short time periods into a new index covering a\nlonger period. For example, you could reindex daily indices from October with a\nshared index pattern, such as `my-index-2099.10.11`, into a monthly\n`my-index-2099.10` index. After the reindex, delete the smaller indices.\n\n[source,console]\n----\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"my-index-2099.10.*\"\n  },\n  \"dest\": {\n    \"index\": \"my-index-2099.10\"\n  }\n}\n----\n\n[discrete]\n[[troubleshoot-shard-related-errors]]\n=== Troubleshoot shard-related errors\n\nHere\u2019s how to resolve common shard-related errors.\n\n[discrete]\n[[troubleshooting-max-shards-open]]\n==== this action would add [x] total shards, but this cluster currently has [y]/[z] maximum shards open;\n\nThe <<cluster-max-shards-per-node,`cluster.max_shards_per_node`>> cluster\nsetting limits the maximum number of open shards for a cluster. This error\nindicates an action would exceed this limit.\n\nIf you're confident your changes won't destabilize the cluster, you can\ntemporarily increase the limit using the <<cluster-update-settings,cluster\nupdate settings API>> and retry the action.\n\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\" : {\n    \"cluster.max_shards_per_node\": 1200\n  }\n}\n----\n\nThis increase should only be temporary. As a long-term solution, we recommend\nyou add nodes to the oversharded data tier or\n<<reduce-cluster-shard-count,reduce your cluster's shard count>>. To get a\ncluster's current shard count after making changes, use the\n<<cluster-stats,cluster stats API>>.\n\n[source,console]\n----\nGET _cluster/stats?filter_path=indices.shards.total\n----\n\nWhen a long-term solution is in place, we recommend you reset the\n`cluster.max_shards_per_node` limit.\n\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\" : {\n    \"cluster.max_shards_per_node\": null\n  }\n}\n----\n\nSee this https://www.youtube.com/watch?v=tZKbDegt4-M[fixing \"max shards open\" video] for an example troubleshooting walkthrough. For more information, see <<troubleshooting-shards-capacity-issues,Troubleshooting shards capacity>>.\n\n[discrete]\n[[troubleshooting-max-docs-limit]]\n==== Number of documents in the shard cannot exceed [2147483519]\n\nEach {es} shard is a separate Lucene index, so it shares Lucene's\nhttps://github.com/apache/lucene/issues/5176[`MAX_DOC` limit] of having at most\n2,147,483,519 (`(2^31)-129`) documents. This per-shard limit applies to the sum\nof `docs.count` plus `docs.deleted` as reported by the <<indices-stats,Index\nstats API>>. Exceeding this limit will result in errors like the following:\n\n[source,txt]\n----\nElasticsearch exception [type=illegal_argument_exception, reason=Number of documents in the shard cannot exceed [2147483519]]\n----\n\nTIP: This calculation may differ from the <<search-count,Count API's>>\ncalculation, because the Count API does not include nested documents and does\nnot count deleted documents.\n\nThis limit is much higher than the <<shard-size-recommendation,recommended\nmaximum document count>> of approximately 200M documents per shard.\n\nIf you encounter this problem, try to mitigate it by using the\n<<indices-forcemerge,Force Merge API>> to merge away some deleted docs. For\nexample:\n\n[source,console]\n----\nPOST my-index-000001/_forcemerge?only_expunge_deletes=true\n----\n// TEST[setup:my_index]\n\nThis will launch an asynchronous task which can be monitored via the\n<<tasks,Task Management API>>.\n\nIt may also be helpful to <<docs-delete-by-query,delete unneeded documents>>,\nor to <<indices-split-index,split>> or <<docs-reindex,reindex>> the index into\none with a larger number of shards.\n"
}