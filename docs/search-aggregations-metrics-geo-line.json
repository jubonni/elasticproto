{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.282271",
        "size": 19389,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-geo-line.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "search-aggregations-metrics-geo-line",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[search-aggregations-metrics-geo-line]]\n=== Geo-line aggregation\n++++\n<titleabbrev>Geo-line</titleabbrev>\n++++\n\nThe `geo_line` aggregation aggregates all `geo_point` values within a bucket into a `LineString` ordered\nby the chosen `sort` field. This `sort` can be a date field, for example. The bucket returned is a valid\nhttps://tools.ietf.org/html/rfc7946#section-3.2[GeoJSON Feature] representing the line geometry.\n\n[source,console,id=search-aggregations-metrics-geo-line-simple]\n----\nPUT test\n{\n    \"mappings\": {\n        \"properties\": {\n            \"my_location\": { \"type\": \"geo_point\" },\n            \"group\":       { \"type\": \"keyword\" },\n            \"@timestamp\":  { \"type\": \"date\" }\n        }\n    }\n}\n\nPOST /test/_bulk?refresh\n{\"index\":{}}\n{\"my_location\": {\"lat\":52.373184, \"lon\":4.889187}, \"@timestamp\": \"2023-01-02T09:00:00Z\"}\n{\"index\":{}}\n{\"my_location\": {\"lat\":52.370159, \"lon\":4.885057}, \"@timestamp\": \"2023-01-02T10:00:00Z\"}\n{\"index\":{}}\n{\"my_location\": {\"lat\":52.369219, \"lon\":4.901618}, \"@timestamp\": \"2023-01-02T13:00:00Z\"}\n{\"index\":{}}\n{\"my_location\": {\"lat\":52.374081, \"lon\":4.912350}, \"@timestamp\": \"2023-01-02T16:00:00Z\"}\n{\"index\":{}}\n{\"my_location\": {\"lat\":52.371667, \"lon\":4.914722}, \"@timestamp\": \"2023-01-03T12:00:00Z\"}\n\nPOST /test/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"line\": {\n      \"geo_line\": {\n        \"point\": {\"field\": \"my_location\"},\n        \"sort\":  {\"field\": \"@timestamp\"}\n      }\n    }\n  }\n}\n----\n\nWhich returns:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"line\": {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"LineString\",\n        \"coordinates\": [\n            [ 4.889187, 52.373184 ],\n            [ 4.885057, 52.370159 ],\n            [ 4.901618, 52.369219 ],\n            [ 4.912350, 52.374081 ],\n            [ 4.914722, 52.371667 ]\n        ]\n      },\n      \"properties\": {\n        \"complete\": true\n      }\n    }\n  }\n}\n----\n// TESTRESPONSE\n\nThe resulting https://tools.ietf.org/html/rfc7946#section-3.2[GeoJSON Feature] contains both a `LineString` geometry\nfor the path generated by the aggregation, as well as a map of `properties`.\nThe property `complete` informs of whether all documents matched were used to generate the geometry.\nThe <<search-aggregations-metrics-geo-line-size,`size` option>> can be used to limit the number of documents included in the aggregation,\nleading to results  with `complete: false`.\nExactly which documents are dropped from results <<search-aggregations-metrics-geo-line-grouping-time-series-advantages,depends on whether the aggregation is based\non `time_series` or not>>.\n\nThis result could be displayed in a map user interface:\n\nimage:images/spatial/geo_line.png[Kibana map with museum tour of Amsterdam]\n\n[[search-aggregations-metrics-geo-line-options]]\n==== Options\n\n`point`::\n(Required)\n\nThis option specifies the name of the `geo_point` field\n\nExample usage configuring `my_location` as the point field:\n\n[source,js]\n----\n\"point\": {\n  \"field\": \"my_location\"\n}\n----\n// NOTCONSOLE\n\n`sort`::\n(Required outside <<search-aggregations-metrics-geo-line-grouping-time-series,`time_series`>> aggregations)\n\nThis option specifies the name of the numeric field to use as the sort key for ordering the points.\nWhen the `geo_line` aggregation is nested inside a\n<<search-aggregations-metrics-geo-line-grouping-time-series,`time_series`>>\naggregation, this field defaults to `@timestamp`, and any other value will result in error.\n\nExample usage configuring `@timestamp` as the sort key:\n\n[source,js]\n----\n\"sort\": {\n  \"field\": \"@timestamp\"\n}\n----\n// NOTCONSOLE\n\n`include_sort`::\n(Optional, boolean, default: `false`) This option includes, when true, an additional array of the sort values in the\nfeature properties.\n\n`sort_order`::\n(Optional, string, default: `\"ASC\"`) This option accepts one of two values: \"ASC\", \"DESC\".\nThe line is sorted in ascending order by the sort key when set to \"ASC\", and in descending\nwith \"DESC\".\n\n[[search-aggregations-metrics-geo-line-size]]\n`size`::\n(Optional, integer, default: `10000`) The maximum length of the line represented in the aggregation.\nValid sizes are between one and 10000.\nWithin <<search-aggregations-metrics-geo-line-grouping-time-series,`time_series`>>\nthe aggregation uses line simplification to constrain the size, otherwise it uses truncation.\nRefer to <<search-aggregations-metrics-geo-line-grouping-time-series-advantages>>\nfor a discussion on the subtleties involved.\n\n[[search-aggregations-metrics-geo-line-grouping]]\n==== Grouping\n\nThis simple example produces a single track for all the data selected by the query. However, it is far more\ncommon to need to group the data into multiple tracks. For example, grouping flight transponder measurements by\nflight call-sign before sorting each flight by timestamp and producing a separate track for each.\n\nIn the following examples we will group the locations of points of interest in the cities of\nAmsterdam, Antwerp and Paris.\nThe tracks will be ordered by the planned visit sequence for a walking tour of the museums and others attractions.\n\nIn order to demonstrate the difference between a time-series grouping and a non-time-series grouping, we will\nfirst create an index with <<tsds-index-settings,time-series enabled>>,\nand then give examples of grouping the same data without time-series and with time-series.\n\n[source,console,id=search-aggregations-metrics-geo-line-grouping-setup]\n----\nPUT tour\n{\n    \"mappings\": {\n        \"properties\": {\n            \"city\": {\n                \"type\": \"keyword\",\n                \"time_series_dimension\": true\n            },\n            \"category\":   { \"type\": \"keyword\" },\n            \"route\":      { \"type\": \"long\" },\n            \"name\":       { \"type\": \"keyword\" },\n            \"location\":   { \"type\": \"geo_point\" },\n            \"@timestamp\": { \"type\": \"date\" }\n        }\n    },\n    \"settings\": {\n        \"index\": {\n            \"mode\": \"time_series\",\n            \"routing_path\": [ \"city\" ],\n            \"time_series\": {\n                \"start_time\": \"2023-01-01T00:00:00Z\",\n                \"end_time\": \"2024-01-01T00:00:00Z\"\n            }\n        }\n    }\n}\n\nPOST /tour/_bulk?refresh\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-02T09:00:00Z\", \"route\": 0, \"location\": \"POINT(4.889187 52.373184)\", \"city\": \"Amsterdam\", \"category\": \"Attraction\", \"name\": \"Royal Palace Amsterdam\"}\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-02T10:00:00Z\", \"route\": 1, \"location\": \"POINT(4.885057 52.370159)\", \"city\": \"Amsterdam\", \"category\": \"Attraction\", \"name\": \"The Amsterdam Dungeon\"}\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-02T13:00:00Z\", \"route\": 2, \"location\": \"POINT(4.901618 52.369219)\", \"city\": \"Amsterdam\", \"category\": \"Museum\", \"name\": \"Museum Het Rembrandthuis\"}\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-02T16:00:00Z\", \"route\": 3, \"location\": \"POINT(4.912350 52.374081)\", \"city\": \"Amsterdam\", \"category\": \"Museum\", \"name\": \"NEMO Science Museum\"}\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-03T12:00:00Z\", \"route\": 4, \"location\": \"POINT(4.914722 52.371667)\", \"city\": \"Amsterdam\", \"category\": \"Museum\", \"name\": \"Nederlands Scheepvaartmuseum\"}\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-04T09:00:00Z\", \"route\": 5, \"location\": \"POINT(4.401384 51.220292)\", \"city\": \"Antwerp\", \"category\": \"Attraction\", \"name\": \"Cathedral of Our Lady\"}\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-04T12:00:00Z\", \"route\": 6, \"location\": \"POINT(4.405819 51.221758)\", \"city\": \"Antwerp\", \"category\": \"Museum\", \"name\": \"Snijders&Rockoxhuis\"}\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-04T15:00:00Z\", \"route\": 7, \"location\": \"POINT(4.405200 51.222900)\", \"city\": \"Antwerp\", \"category\": \"Museum\", \"name\": \"Letterenhuis\"}\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-05T10:00:00Z\", \"route\": 8, \"location\": \"POINT(2.336389 48.861111)\", \"city\": \"Paris\", \"category\": \"Museum\", \"name\": \"Mus\u00e9e du Louvre\"}\n{\"index\":{}}\n{\"@timestamp\": \"2023-01-05T14:00:00Z\", \"route\": 9, \"location\": \"POINT(2.327000 48.860000)\", \"city\": \"Paris\", \"category\": \"Museum\", \"name\": \"Mus\u00e9e dOrsay\"}\n----\n\n[[search-aggregations-metrics-geo-line-grouping-terms]]\n==== Grouping with terms\n\nUsing this data, for a non-time-series use case, the grouping can be done using a\n<<search-aggregations-bucket-terms-aggregation,terms aggregation>> based on city name.\nThis would work whether or not we had defined the `tour` index as a time series index.\n\n[source,console,id=search-aggregations-metrics-geo-line-terms]\n----\nPOST /tour/_search?filter_path=aggregations\n{\n  \"aggregations\": {\n    \"path\": {\n      \"terms\": {\"field\": \"city\"},\n      \"aggregations\": {\n        \"museum_tour\": {\n          \"geo_line\": {\n            \"point\": {\"field\": \"location\"},\n            \"sort\": {\"field\": \"@timestamp\"}\n          }\n        }\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nWhich returns:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"path\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"Amsterdam\",\n          \"doc_count\": 5,\n          \"museum_tour\": {\n            \"type\": \"Feature\",\n            \"geometry\": {\n              \"coordinates\": [ [ 4.889187, 52.373184 ], [ 4.885057, 52.370159 ], [ 4.901618, 52.369219 ], [ 4.91235, 52.374081 ], [ 4.914722, 52.371667 ] ],\n              \"type\": \"LineString\"\n            },\n            \"properties\": {\n              \"complete\": true\n            }\n          }\n        },\n        {\n          \"key\": \"Antwerp\",\n          \"doc_count\": 3,\n          \"museum_tour\": {\n            \"type\": \"Feature\",\n            \"geometry\": {\n              \"coordinates\": [ [ 4.401384, 51.220292 ], [ 4.405819, 51.221758 ], [ 4.4052, 51.2229 ] ],\n              \"type\": \"LineString\"\n            },\n            \"properties\": {\n              \"complete\": true\n            }\n          }\n        },\n        {\n          \"key\": \"Paris\",\n          \"doc_count\": 2,\n          \"museum_tour\": {\n            \"type\": \"Feature\",\n            \"geometry\": {\n              \"coordinates\": [ [ 2.336389, 48.861111 ], [ 2.327, 48.86 ] ],\n              \"type\": \"LineString\"\n            },\n            \"properties\": {\n              \"complete\": true\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n----\n// TESTRESPONSE\n\nThese results contain an array of buckets, where each bucket is a JSON object with the `key` showing the name\nof the `city` field, and an inner aggregation result called `museum_tour` containing a\nhttps://tools.ietf.org/html/rfc7946#section-3.2[GeoJSON Feature] describing the\nactual route between the various attractions in that city.\nEach result also includes a `properties` object with a `complete` value which will be `false` if the geometry\nwas truncated to the limits specified in the `size` parameter.\nNote that when we use `time_series` in the next example, we will get the same results structured a little differently.\n\n[[search-aggregations-metrics-geo-line-grouping-time-series]]\n==== Grouping with time-series\n\npreview::[]\n\nUsing the same data as before, we can also perform the grouping with a\n<<search-aggregations-bucket-time-series-aggregation,`time_series` aggregation>>.\nThis will group by TSID, which is defined as the combinations of all fields with `time_series_dimension: true`,\nin this case the same `city` field used in the previous\n<<search-aggregations-bucket-terms-aggregation,terms aggregation>>.\nThis example will only work if we defined the `tour` index as a time series index using  `index.mode=\"time_series\"`.\n\n[source,console,id=search-aggregations-metrics-geo-line-time-series]\n----\nPOST /tour/_search?filter_path=aggregations\n{\n  \"aggregations\": {\n    \"path\": {\n      \"time_series\": {},\n      \"aggregations\": {\n        \"museum_tour\": {\n          \"geo_line\": {\n            \"point\": {\"field\": \"location\"}\n          }\n        }\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nNOTE: The `geo_line` aggregation no longer requires the `sort` field when nested within a\n<<search-aggregations-bucket-time-series-aggregation,`time_series` aggregation>>.\nThis is because the sort field is set to `@timestamp`, which all time-series indexes are pre-sorted by.\nIf you do set this parameter, and set it to something other than `@timestamp` you will get an error.\n\nThis query will result in:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"path\": {\n      \"buckets\": {\n        \"{city=Paris}\": {\n          \"key\": {\n            \"city\": \"Paris\"\n          },\n          \"doc_count\": 2,\n          \"museum_tour\": {\n            \"type\": \"Feature\",\n            \"geometry\": {\n              \"coordinates\": [ [ 2.336389, 48.861111 ], [ 2.327, 48.86 ] ],\n              \"type\": \"LineString\"\n            },\n            \"properties\": {\n              \"complete\": true\n            }\n          }\n        },\n        \"{city=Antwerp}\": {\n          \"key\": {\n            \"city\": \"Antwerp\"\n          },\n          \"doc_count\": 3,\n          \"museum_tour\": {\n            \"type\": \"Feature\",\n            \"geometry\": {\n              \"coordinates\": [ [ 4.401384, 51.220292 ], [ 4.405819, 51.221758 ], [ 4.4052, 51.2229 ] ],\n              \"type\": \"LineString\"\n            },\n            \"properties\": {\n              \"complete\": true\n            }\n          }\n        },\n        \"{city=Amsterdam}\": {\n          \"key\": {\n            \"city\": \"Amsterdam\"\n          },\n          \"doc_count\": 5,\n          \"museum_tour\": {\n            \"type\": \"Feature\",\n            \"geometry\": {\n              \"coordinates\": [ [ 4.889187, 52.373184 ], [ 4.885057, 52.370159 ], [ 4.901618, 52.369219 ], [ 4.91235, 52.374081 ], [ 4.914722, 52.371667 ] ],\n              \"type\": \"LineString\"\n            },\n            \"properties\": {\n              \"complete\": true\n            }\n          }\n        }\n      }\n    }\n  }\n}\n----\n// TESTRESPONSE\n\nThese results are essentially the same as with the previous `terms` aggregation example, but structured differently.\nHere we see the buckets returned as a map, where the key is an internal description of the TSID.\nThis TSID is unique for each unique combination of fields with `time_series_dimension: true`.\nEach bucket contains a `key` field which is also a map of all dimension values for the TSID, in this case only the city\nname is used for grouping.\nIn addition, there is an inner aggregation result called `museum_tour` containing a\nhttps://tools.ietf.org/html/rfc7946#section-3.2[GeoJSON Feature] describing the\nactual route between the various attractions in that city.\nEach result also includes a `properties` object with a `complete` value which will be false if the geometry\nwas simplified to the limits specified in the `size` parameter.\n\n[[search-aggregations-metrics-geo-line-grouping-time-series-advantages]]\n==== Why group with time-series?\n\nWhen reviewing these examples, you might think that there is little difference between using\n<<search-aggregations-bucket-terms-aggregation,`terms`>> or\n<<search-aggregations-bucket-time-series-aggregation,`time_series`>>\nto group the geo-lines. However, there are some important differences in behaviour between the two cases.\nTime series indexes are stored in a very specific order on disk.\nThey are pre-grouped by the time-series dimension fields, and pre-sorted by the `@timestamp` field.\nThis allows the `geo_line` aggregation to be considerably optimized:\n\n* The same memory allocated for the first bucket can be re-used over and over for all subsequent buckets.\n  This is substantially less memory than required for non-time-series cases where all buckets are collected\n  concurrently.\n* No sorting needs to be done, since the data is pre-sorted by `@timestamp`.\n  The time-series data will naturally arrive at the aggregation collector in `DESC` order.\n  This means that if we specify `sort_order:ASC` (the default), we still collect in `DESC` order,\n  but perform an efficient in-memory reverse order before generating the final `LineString` geometry.\n* The `size` parameter can be used for a streaming line-simplification algorithm.\n  Without time-series, we are forced to truncate data, by default after 10000 documents per bucket, in order to\n  prevent memory usage from being unbounded.\n  This can result in geo-lines being truncated, and therefor loosing important data.\n  With time-series we can run a streaming line-simplification algorithm, retaining control over memory usage,\n  while also maintaining the overall geometry shape.\n  In fact, for most use cases it would work to set this `size` parameter to a much lower bound, and save even more\n  memory. For example, if the `geo_line` is to be drawn on a display map with a specific resolution, it might look\n  just as good to simplify to as few as 100 or 200 points. This will save memory on the server, on the network and\n  in the client.\n\nNote: There are other significant advantages to working with time-series data and using `time_series` index mode.\nThese are discussed in the documentation on <<tsds,time series data streams>>.\n\n[[search-aggregations-metrics-geo-line-simplification]]\n==== Streaming line simplification\n\nLine simplification is a great way to reduce the size of the final results sent to the client, and displayed in a map\nuser interface. However, normally these algorithms use a lot of memory to perform the simplification, requiring the\nentire geometry to be maintained in memory together with supporting data for the simplification itself.\nThe use of a streaming line simplification algorithm allows for minimal memory usage during the simplification\nprocess by constraining memory to the bounds defined for the simplified geometry. This is only possible if no sorting\nis required, which is the case when grouping is done by the\n<<search-aggregations-bucket-time-series-aggregation,`time_series` aggregation>>,\nrunning on an index with the `time_series` index mode.\n\nUnder these conditions the `geo_line` aggregation allocates memory to the `size` specified, and then fills that\nmemory with the incoming documents.\nOnce the memory is completely filled, documents from within the line are removed as new documents are added.\nThe choice of document to remove is made to minimize the visual impact on the geometry.\nThis process makes use of the\nhttps://en.wikipedia.org/wiki/Visvalingam%E2%80%93Whyatt_algorithm[Visvalingam\u2013Whyatt algorithm].\nEssentially this means points are removed if they have the minimum triangle area, with the triangle defined\nby the point under consideration and the two points before and after it in the line.\nIn addition, we calculate the area using spherical coordinates so that no planar distortions affect the choice.\n\nIn order to demonstrate how much better line simplification is to line truncation, consider this example of the north\nshore of Kodiak Island.\nThe data for this is only 209 points, but if we want to set `size` to `100` we get dramatic truncation.\n\nimage:images/spatial/kodiak_geo_line_truncated.png[North short of Kodiak Island truncated to 100 points]\n\nThe grey line is the entire geometry of 209 points, while the blue line is the first 100 points, a very different\ngeometry than the original.\n\nNow consider the same geometry simplified to 100 points.\n\nimage:images/spatial/kodiak_geo_line_simplified.png[North short of Kodiak Island simplified to 100 points]\n\nFor comparison we have shown the original in grey, the truncated in blue and the new simplified geometry\nin magenta. It is possible to see where the new simplified line deviates from the original, but the overall\ngeometry appears almost identical and is still clearly recognizable as the north shore of Kodiak Island.\n"
}