{
    "meta": {
        "timestamp": "2024-11-01T02:49:24.245820",
        "size": 9957,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "search-aggregations",
        "version": "8.15"
    },
    "doc": "[[search-aggregations]]\n= Aggregations\n\n[partintro]\n--\nAn aggregation summarizes your data as metrics, statistics, or other analytics.\nAggregations help you answer questions like:\n\n* What's the average load time for my website?\n* Who are my most valuable customers based on transaction volume?\n* What would be considered a large file on my network?\n* How many products are in each product category?\n\n{es} organizes aggregations into three categories:\n\n* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\nsuch as a sum or average, from field values.\n\n* <<search-aggregations-bucket,Bucket>> aggregations that\ngroup documents into buckets, also called bins, based on field values, ranges,\nor other criteria.\n\n* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\nother aggregations instead of documents or fields.\n\n[discrete]\n[[run-an-agg]]\n=== Run an aggregation\n\nYou can run aggregations as part of a <<search-your-data,search>> by specifying the <<search-search,search API>>'s `aggs` parameter. The\nfollowing search runs a\n<<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n`my-field`:\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"aggs\": {\n    \"my-agg-name\": {\n      \"terms\": {\n        \"field\": \"my-field\"\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n// TEST[s/my-field/http.request.method/]\n\nAggregation results are in the response's `aggregations` object:\n\n[source,console-result]\n----\n{\n  \"took\": 78,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 5,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.0,\n    \"hits\": [...]\n  },\n  \"aggregations\": {\n    \"my-agg-name\": {                           <1>\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": []\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 78/\"took\": \"$body.took\"/]\n// TESTRESPONSE[s/\\.\\.\\.$/\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", /]\n// TESTRESPONSE[s/\"hits\": \\[\\.\\.\\.\\]/\"hits\": \"$body.hits.hits\"/]\n// TESTRESPONSE[s/\"buckets\": \\[\\]/\"buckets\":\\[\\{\"key\":\"get\",\"doc_count\":5\\}\\]/]\n\n<1> Results for the `my-agg-name` aggregation.\n\n[discrete]\n[[change-agg-scope]]\n=== Change an aggregation's scope\n\nUse the `query` parameter to limit the documents on which an aggregation runs:\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"range\": {\n      \"@timestamp\": {\n        \"gte\": \"now-1d/d\",\n        \"lt\": \"now/d\"\n      }\n    }\n  },\n  \"aggs\": {\n    \"my-agg-name\": {\n      \"terms\": {\n        \"field\": \"my-field\"\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n// TEST[s/my-field/http.request.method/]\n\n[discrete]\n[[return-only-agg-results]]\n=== Return only aggregation results\n\nBy default, searches containing an aggregation return both search hits and\naggregation results. To return only aggregation results, set `size` to `0`:\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my-agg-name\": {\n      \"terms\": {\n        \"field\": \"my-field\"\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n// TEST[s/my-field/http.request.method/]\n\n[discrete]\n[[run-multiple-aggs]]\n=== Run multiple aggregations\n\nYou can specify multiple aggregations in the same request:\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"aggs\": {\n    \"my-first-agg-name\": {\n      \"terms\": {\n        \"field\": \"my-field\"\n      }\n    },\n    \"my-second-agg-name\": {\n      \"avg\": {\n        \"field\": \"my-other-field\"\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n// TEST[s/my-field/http.request.method/]\n// TEST[s/my-other-field/http.response.bytes/]\n\n[discrete]\n[[run-sub-aggs]]\n=== Run sub-aggregations\n\nBucket aggregations support bucket or metric sub-aggregations. For example, a\nterms aggregation with an <<search-aggregations-metrics-avg-aggregation,avg>>\nsub-aggregation calculates an average value for each bucket of documents. There\nis no level or depth limit for nesting sub-aggregations.\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"aggs\": {\n    \"my-agg-name\": {\n      \"terms\": {\n        \"field\": \"my-field\"\n      },\n      \"aggs\": {\n        \"my-sub-agg-name\": {\n          \"avg\": {\n            \"field\": \"my-other-field\"\n          }\n        }\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n// TEST[s/_search/_search?size=0/]\n// TEST[s/my-field/http.request.method/]\n// TEST[s/my-other-field/http.response.bytes/]\n\nThe response nests sub-aggregation results under their parent aggregation:\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"my-agg-name\": {                           <1>\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"foo\",\n          \"doc_count\": 5,\n          \"my-sub-agg-name\": {                 <2>\n            \"value\": 75.0\n          }\n        }\n      ]\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n// TESTRESPONSE[s/\"key\": \"foo\"/\"key\": \"get\"/]\n// TESTRESPONSE[s/\"value\": 75.0/\"value\": $body.aggregations.my-agg-name.buckets.0.my-sub-agg-name.value/]\n\n<1> Results for the parent aggregation, `my-agg-name`.\n<2> Results for `my-agg-name`'s sub-aggregation, `my-sub-agg-name`.\n\n[discrete]\n[[add-metadata-to-an-agg]]\n=== Add custom metadata\n\nUse the `meta` object to associate custom metadata with an aggregation:\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"aggs\": {\n    \"my-agg-name\": {\n      \"terms\": {\n        \"field\": \"my-field\"\n      },\n      \"meta\": {\n        \"my-metadata-field\": \"foo\"\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n// TEST[s/_search/_search?size=0/]\n\nThe response returns the `meta` object in place:\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"my-agg-name\": {\n      \"meta\": {\n        \"my-metadata-field\": \"foo\"\n      },\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": []\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n\n[discrete]\n[[return-agg-type]]\n=== Return the aggregation type\n\nBy default, aggregation results include the aggregation's name but not its type.\nTo return the aggregation type, use the `typed_keys` query parameter.\n\n[source,console]\n----\nGET /my-index-000001/_search?typed_keys\n{\n  \"aggs\": {\n    \"my-agg-name\": {\n      \"histogram\": {\n        \"field\": \"my-field\",\n        \"interval\": 1000\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n// TEST[s/typed_keys/typed_keys&size=0/]\n// TEST[s/my-field/http.response.bytes/]\n\nThe response returns the aggregation type as a prefix to the aggregation's name.\n\nIMPORTANT: Some aggregations return a different aggregation type from the\ntype in the request. For example, the terms,\n<<search-aggregations-bucket-significantterms-aggregation,significant terms>>,\nand <<search-aggregations-metrics-percentile-aggregation,percentiles>>\naggregations return different aggregations types depending on the data type of\nthe aggregated field.\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"histogram#my-agg-name\": {                 <1>\n      \"buckets\": []\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n// TESTRESPONSE[s/\"buckets\": \\[\\]/\"buckets\":\\[\\{\"key\":1070000.0,\"doc_count\":5\\}\\]/]\n\n<1> The aggregation type, `histogram`, followed by a `#` separator and the aggregation's name, `my-agg-name`.\n\n[discrete]\n[[use-scripts-in-an-agg]]\n=== Use scripts in an aggregation\n\nWhen a field doesn't exactly match the aggregation you need, you\nshould aggregate on a <<runtime,runtime field>>:\n\n[source,console]\n----\nGET /my-index-000001/_search?size=0\n{\n  \"runtime_mappings\": {\n    \"message.length\": {\n      \"type\": \"long\",\n      \"script\": \"emit(doc['message.keyword'].value.length())\"\n    }\n  },\n  \"aggs\": {\n    \"message_length\": {\n      \"histogram\": {\n        \"interval\": 10,\n        \"field\": \"message.length\"\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n\n////\n[source,console-result]\n----\n{\n  \"timed_out\": false,\n  \"took\": \"$body.took\",\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"failed\": 0,\n    \"skipped\": 0\n  },\n  \"hits\": \"$body.hits\",\n  \"aggregations\": {\n    \"message_length\": {\n      \"buckets\": [\n        {\n          \"key\": 30.0,\n          \"doc_count\": 5\n        }\n      ]\n    }\n  }\n}\n----\n////\n\nScripts calculate field values dynamically, which adds a little\noverhead to the aggregation. In addition to the time spent calculating,\nsome aggregations like <<search-aggregations-bucket-terms-aggregation,`terms`>>\nand <<search-aggregations-bucket-filters-aggregation,`filters`>> can't use\nsome of their optimizations with runtime fields. In total, performance costs\nfor using a runtime field varies from aggregation to aggregation.\n\n// TODO when we have calculated fields we can link to them here.\n\n[discrete]\n[[agg-caches]]\n=== Aggregation caches\n\nFor faster responses, {es} caches the results of frequently run aggregations in\nthe <<shard-request-cache,shard request cache>>. To get cached results, use the\nsame <<shard-and-node-preference,`preference` string>> for each search. If you\ndon't need search hits, <<return-only-agg-results,set `size` to `0`>> to avoid\nfilling the cache.\n\n{es} routes searches with the same preference string to the same shards. If the\nshards' data doesn\u2019t change between searches, the shards return cached\naggregation results.\n\n[discrete]\n[[limits-for-long-values]]\n=== Limits for `long` values\n\nWhen running aggregations, {es} uses <<number,`double`>> values to hold and\nrepresent numeric data. As a result, aggregations on <<number,`long`>> numbers\ngreater than +2^53^+ are approximate.\n--\n\ninclude::aggregations/bucket.asciidoc[]\n\ninclude::aggregations/metrics.asciidoc[]\n\ninclude::aggregations/pipeline.asciidoc[]\n"
}