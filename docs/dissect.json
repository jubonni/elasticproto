{
    "meta": {
        "timestamp": "2024-11-01T02:49:24.957074",
        "size": 9813,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/dissect.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "dissect",
        "version": "8.15"
    },
    "doc": "[[dissect]]\n=== Dissecting data\nDissect matches a single text field against a defined pattern. A dissect\npattern is defined by the parts of the string you want to discard. Paying\nspecial attention to each part of a string helps to build successful dissect\npatterns.\n\nIf you don't need the power of regular expressions, use dissect patterns instead\nof grok. Dissect uses a much simpler syntax than grok and is typically faster\noverall. The syntax for dissect is transparent: tell dissect what you want and\nit will return those results to you.\n\n[[dissect-syntax]]\n==== Dissect patterns\nDissect patterns are comprised of _variables_ and _separators_. Anything\ndefined by a percent sign and curly braces `%{}` is considered a variable, \nsuch as `%{clientip}`. You can assign variables to any part of data in a field, \nand then return only the parts that you want. Separators are any values between\nvariables, which could be spaces, dashes, or other delimiters.\n\nFor example, let's say you have log data with a `message` field that looks like\nthis:\n\n[source,js]\n----\n\"message\" : \"247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] \\\"GET /images/hm_nbg.jpg HTTP/1.0\\\" 304 0\"\n----\n// NOTCONSOLE\n\nYou assign variables to each part of the data to construct a successful\ndissect pattern. Remember, tell dissect _exactly_ what you want you want to\nmatch on.\n\nThe first part of the data looks like an IP address, so you\ncan assign a variable like `%{clientip}`. The next two characters are dashes\nwith a space on either side. You can assign a variable for each dash, or a\nsingle variable to represent the dashes and spaces. Next are a set of brackets\ncontaining a timestamp. The brackets are a separator, so you include those in\nthe dissect pattern. Thus far, the data and matching dissect pattern look like\nthis:\n\n[source,js]\n----\n247.37.0.0 - - [30/Apr/2020:14:31:22 -0500]  <1>\n\n%{clientip} %{ident} %{auth} [%{@timestamp}] <2>\n----\n// NOTCONSOLE\n<1> The first chunks of data from the `message` field\n<2> Dissect pattern to match on the selected data chunks\n\nUsing that same logic, you can create variables for the remaining chunks of\ndata. Double quotation marks are separators, so include those in your dissect\npattern. The pattern replaces `GET` with a `%{verb}` variable, but keeps `HTTP`\nas part of the pattern. \n\n[source,js]\n----\n\\\"GET /images/hm_nbg.jpg HTTP/1.0\\\" 304 0\n\n\"%{verb} %{request} HTTP/%{httpversion}\" %{response} %{size}\n----\n// NOTCONSOLE\n\nCombining the two patterns results in a dissect pattern that looks like this: \n\n[source,js]\n----\n%{clientip} %{ident} %{auth} [%{@timestamp}] \\\"%{verb} %{request} HTTP/%{httpversion}\\\" %{status} %{size}\n----\n// NOTCONSOLE\n\nNow that you have a dissect pattern, how do you test and use it?\n\n[[dissect-patterns-test]]\n==== Test dissect patterns with Painless\nYou can incorporate dissect patterns into Painless scripts to extract\ndata. To test your script, use either the {painless}/painless-execute-api.html#painless-execute-runtime-field-context[field contexts] of the Painless\nexecute API or create a runtime field that includes the script. Runtime fields\noffer greater flexibility and accept multiple documents, but the Painless execute\nAPI is a great option if you don't have write access on a cluster where you're\ntesting a script.\n\nFor example, test your dissect pattern with the Painless execute API by\nincluding your Painless script and a single document that matches your data.\nStart by indexing the `message` field as a `wildcard` data type:\n\n[source,console]\n----\nPUT my-index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"message\": {\n        \"type\": \"wildcard\"\n      }\n    }\n  }\n}\n----\n\nIf you want to retrieve the HTTP response code, add your dissect pattern to a\nPainless script that extracts the `response` value. To extract values from a\nfield, use this function:\n\n[source,painless]\n----\n`.extract(doc[\"<field_name>\"].value)?.<field_value>`\n----\n\nIn this example, `message` is the `<field_name>` and `response` is the\n`<field_value>`:\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"\"\"\n      String response=dissect('%{clientip} %{ident} %{auth} [%{@timestamp}] \"%{verb} %{request} HTTP/%{httpversion}\" %{response} %{size}').extract(doc[\"message\"].value)?.response;\n        if (response != null) emit(Integer.parseInt(response)); <1>\n    \"\"\"\n  },\n  \"context\": \"long_field\", <2>\n  \"context_setup\": {\n    \"index\": \"my-index\",\n    \"document\": {          <3>\n      \"message\": \"\"\"247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] \"GET /images/hm_nbg.jpg HTTP/1.0\" 304 0\"\"\"\n    }\n  }\n}\n----\n// TEST[continued]\n<1> Runtime fields require the `emit` method to return values.\n<2> Because the response code is an integer, use the `long_field` context.\n<3> Include a sample document that matches your data.\n\nThe result includes the HTTP response code:\n\n[source,console-result]\n----\n{\n  \"result\" : [\n    304\n  ]\n}\n----\n\n[[dissect-patterns-runtime]]\n==== Use dissect patterns and scripts in runtime fields\nIf you have a functional dissect pattern, you can add it to a runtime field to\nmanipulate data. Because runtime fields don't require you to index fields, you\nhave incredible flexibility to modify your script and how it functions. If you\nalready <<dissect-patterns-test,tested your dissect pattern>> using the Painless\nexecute API, you can use that _exact_ Painless script in your runtime field. \n\nTo start, add the `message` field as a `wildcard` type like in the previous\nsection, but also add `@timestamp` as a `date` in case you want to operate on\nthat field for <<common-script-uses,other use cases>>:\n\n[source,console]\n----\nPUT /my-index/\n{\n  \"mappings\": {\n    \"properties\": {\n      \"@timestamp\": {\n        \"format\": \"strict_date_optional_time||epoch_second\",\n        \"type\": \"date\"\n      },\n      \"message\": {\n        \"type\": \"wildcard\"\n      }\n    }\n  }\n}\n----\n\nIf you want to extract the HTTP response code using your dissect pattern, you\ncan create a runtime field like `http.response`:\n\n[source,console]\n----\nPUT my-index/_mappings\n{\n  \"runtime\": {\n    \"http.response\": {\n      \"type\": \"long\",\n      \"script\": \"\"\"\n        String response=dissect('%{clientip} %{ident} %{auth} [%{@timestamp}] \"%{verb} %{request} HTTP/%{httpversion}\" %{response} %{size}').extract(doc[\"message\"].value)?.response;\n        if (response != null) emit(Integer.parseInt(response));\n      \"\"\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nAfter mapping the fields you want to retrieve, index a few records from\nyour log data into {es}. The following request uses the <<docs-bulk,bulk API>>\nto index raw log data into `my-index`:\n\n[source,console]\n----\nPOST /my-index/_bulk?refresh=true\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:30:17-05:00\",\"message\":\"40.135.0.0 - - [30/Apr/2020:14:30:17 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:30:53-05:00\",\"message\":\"232.0.0.0 - - [30/Apr/2020:14:30:53 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:12-05:00\",\"message\":\"26.1.0.0 - - [30/Apr/2020:14:31:12 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:19-05:00\",\"message\":\"247.37.0.0 - - [30/Apr/2020:14:31:19 -0500] \\\"GET /french/splash_inet.html HTTP/1.0\\\" 200 3781\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:22-05:00\",\"message\":\"247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] \\\"GET /images/hm_nbg.jpg HTTP/1.0\\\" 304 0\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:27-05:00\",\"message\":\"252.0.0.0 - - [30/Apr/2020:14:31:27 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n{\"index\":{}}\n{\"timestamp\":\"2020-04-30T14:31:28-05:00\",\"message\":\"not a valid apache log\"}\n----\n// TEST[continued]\n\nYou can define a simple query to run a search for a specific HTTP response and\nreturn all related fields. Use the `fields` parameter of the search API to\nretrieve the `http.response` runtime field.\n\n[source,console]\n----\nGET my-index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"http.response\": \"304\"\n    }\n  },\n  \"fields\" : [\"http.response\"]\n}\n----\n// TEST[continued]\n\nAlternatively, you can define the same runtime field but in the context of a\nsearch request. The runtime definition and the script are exactly the same as\nthe one defined previously in the index mapping. Just copy that definition into\nthe search request under the `runtime_mappings` section and include a query\nthat matches on the runtime field. This query returns the same results as the\nsearch query previously defined for the `http.response` runtime field in your\nindex mappings, but only in the context of this specific search:\n\n[source,console]\n----\nGET my-index/_search\n{\n  \"runtime_mappings\": {\n    \"http.response\": {\n      \"type\": \"long\",\n      \"script\": \"\"\"\n        String response=dissect('%{clientip} %{ident} %{auth} [%{@timestamp}] \"%{verb} %{request} HTTP/%{httpversion}\" %{response} %{size}').extract(doc[\"message\"].value)?.response;\n        if (response != null) emit(Integer.parseInt(response));\n      \"\"\"\n    }\n  },\n  \"query\": {\n    \"match\": {\n      \"http.response\": \"304\"\n    }\n  },\n  \"fields\" : [\"http.response\"]\n}\n----\n// TEST[continued]\n// TEST[s/_search/_search\\?filter_path=hits/]\n\n[source,console-result]\n----\n{\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"my-index\",\n        \"_id\" : \"D47UqXkBByC8cgZrkbOm\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"timestamp\" : \"2020-04-30T14:31:22-05:00\",\n          \"message\" : \"247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] \\\"GET /images/hm_nbg.jpg HTTP/1.0\\\" 304 0\"\n        },\n        \"fields\" : {\n          \"http.response\" : [\n            304\n          ]\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"_id\" : \"D47UqXkBByC8cgZrkbOm\"/\"_id\": $body.hits.hits.0._id/]\n"
}