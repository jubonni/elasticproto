{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.413271",
        "size": 16156,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/how-watcher-works.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "how-watcher-works",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[how-watcher-works]]\n== How {watcher} works\n\nYou <<watch-definition, add watches>> to automatically perform an action when\ncertain conditions are met. The conditions are generally based on data you've\nloaded into the watch, also known as the _Watch Payload_. This payload can be\nloaded from different sources - from Elasticsearch, an external HTTP service, or\neven a combination of the two.\n\nFor example, you could configure a watch to send an email to the sysadmin when a\nsearch in the logs data indicates that there are too many 503 errors in the last\n5 minutes.\n\nThis topic describes the elements of a watch and how watches operate.\n\n[discrete]\n[[watch-definition]]\n=== Watch definition\n\nA watch consists of a _trigger_, _input_, _condition_, and _actions_. The actions\ndefine what needs to be done once the condition is met. In addition, you can\ndefine _conditions_ and _transforms_ to process and prepare the watch payload before\nexecuting the actions.\n\n<<trigger,Trigger>>::\nDetermines when the watch is checked. A watch must have a trigger.\n\n<<input,Input>>::\nLoads data into the watch payload. If no input is specified, an empty payload is\nloaded.\n\n<<condition,Condition>>::\nControls whether the watch actions are executed. If no condition is specified,\nthe condition defaults to `always`.\n\n<<transform,Transform>>::\nProcesses the watch payload to prepare it for the watch actions. You can define\ntransforms at the watch level or define action-specific transforms. Optional.\n\n<<actions,Actions>>::\nSpecify what happens when the watch condition is met.\n\n[[watch-definition-example]]\n\nFor example, the following snippet shows a <<watcher-api-put-watch,create or\nupdate watch>> request that defines a watch that looks for log error events:\n\n[source,console]\n--------------------------------------------------\nPUT _watcher/watch/log_errors\n{\n  \"metadata\" : { <1>\n    \"color\" : \"red\"\n  },\n  \"trigger\" : { <2>\n    \"schedule\" : {\n      \"interval\" : \"5m\"\n    }\n  },\n  \"input\" : { <3>\n    \"search\" : {\n      \"request\" : {\n        \"indices\" : \"log-events\",\n        \"body\" : {\n          \"size\" : 0,\n          \"query\" : { \"match\" : { \"status\" : \"error\" } }\n        }\n      }\n    }\n  },\n  \"condition\" : { <4>\n    \"compare\" : { \"ctx.payload.hits.total\" : { \"gt\" : 5 }}\n  },\n  \"transform\" : { <5>\n    \"search\" : {\n        \"request\" : {\n          \"indices\" : \"log-events\",\n          \"body\" : {\n            \"query\" : { \"match\" : { \"status\" : \"error\" } }\n          }\n        }\n    }\n  },\n  \"actions\" : { <6>\n    \"my_webhook\" : {\n      \"webhook\" : {\n        \"method\" : \"POST\",\n        \"host\" : \"mylisteninghost\",\n        \"port\" : 9200,\n        \"path\" : \"/{{watch_id}}\",\n        \"body\" : \"Encountered {{ctx.payload.hits.total}} errors\"\n      }\n    },\n    \"email_administrator\" : {\n      \"email\" : {\n        \"to\" : \"sys.admino@host.domain\",\n        \"subject\" : \"Encountered {{ctx.payload.hits.total}} errors\",\n        \"body\" : \"Too many error in the system, see attached data\",\n        \"attachments\" : {\n          \"attached_data\" : {\n            \"data\" : {\n              \"format\" : \"json\"\n            }\n          }\n        },\n        \"priority\" : \"high\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Metadata  - You can attach optional static metadata to a watch.\n<2> Trigger   - This schedule trigger executes the watch every 5 minutes.\n<3> Input     - This input searches for errors in the `log-events` index and\n                loads the response into the watch payload.\n<4> Condition - This condition checks to see if there are more than 5 error\n                events (hits in the search response). If there are, execution\n                continues for all `actions`.\n<5> Transform - If the watch condition is met, this transform loads all of the\n                errors into the watch payload by searching for the errors using\n                the default search type, `query_then_fetch`. All of the watch\n                actions have access to this payload.\n<6> Actions   - This watch has two actions. The `my_webhook` action notifies a\n                3rd party system about the problem. The `email_administrator`\n                action sends a high priority email to the system administrator.\n                The watch payload that contains the errors is attached to the\n                email.\n\n[discrete]\n[[watch-execution]]\n=== Watch execution\n\n[[schedule-scheduler]]\nWhen you add a watch, {watcher} immediately registers its trigger with the\nappropriate trigger engine. Watches that have a `schedule` trigger are\nregistered with the `scheduler` trigger engine.\n\nThe scheduler tracks time and triggers watches according to their schedules.\nOn each node, that contains one of the `.watches` shards, a scheduler, that is\nbound to the watcher lifecycle runs. Even though all primaries and replicas are\ntaken into account, when a watch is triggered, watcher also ensures, that each\nwatch is only triggered on one of those shards. The more replica shards you\nadd, the more distributed the watches can be executed. If you add or remove\nreplicas, all watches need to be reloaded. If a shard is relocated, the\nprimary and all replicas of this particular shard will reload.\n\nBecause the watches are executed on the node, where the watch shards are, you\ncan create dedicated watcher nodes by using shard allocation filtering. To do this\n, configure nodes with a dedicated `node.attr.role: watcher` property.\n\nAs the `.watches` index is a system index, you can't use the normal `.watcher/_settings`\nendpoint to modify its routing allocation. Instead, you can use the following dedicated\nendpoint to adjust the allocation of the `.watches` shards to the nodes with the\n`watcher` role attribute:\n\n[source,console]\n------------------------\nPUT _watcher/settings\n{\n  \"index.routing.allocation.include.role\": \"watcher\"\n}\n------------------------\n// TEST[skip:indexes don't assign]\n\nWhen the {watcher} service is stopped, the scheduler stops with it. Trigger\nengines use a separate thread pool from the one used to execute watches.\n\nWhen a watch is triggered, {watcher} queues it up for execution. A `watch_record`\ndocument is created and added to the watch history and the watch's status is set\nto `awaits_execution`.\n\nWhen execution starts, {watcher} creates a watch execution context for the watch.\nThe execution context provides scripts and templates with access to the watch\nmetadata, payload, watch ID, execution time, and trigger information. For more\ninformation, see <<watch-execution-context, Watch Execution Context>>.\n\nDuring the execution process, {watcher}:\n\n. Loads the input data as the payload in the watch execution context. This makes\n  the data available to all subsequent steps in the execution process. This step\n  is controlled by the input of the watch.\n. Evaluates the watch condition to determine whether or not to continue processing\n  the watch. If the condition is met (evaluates to `true`), processing advances\n  to the next step. If it is not met (evaluates to `false`), execution of the watch\n  stops.\n. Applies transforms to the watch payload (if needed).\n. Executes the watch actions granted the condition is met and the watch is not\n  <<watch-acknowledgment-throttling, throttled>>.\n\nWhen the watch execution finishes, the execution result is recorded as a\n_Watch Record_ in the watch history. The watch record includes the execution\ntime and duration, whether the watch condition was met, and the status of each\naction that was executed.\n\nThe following diagram shows the watch execution process:\n\nimage::images/watch-execution.jpg[align=\"center\"]\n\n[discrete]\n[[watch-acknowledgment-throttling]]\n=== Watch acknowledgment and throttling\n\n{watcher} supports both time-based and acknowledgment-based throttling. This\nenables you to prevent actions from being repeatedly executed for the same event.\n\nBy default, {watcher} uses time-based throttling with a throttle period of 5\nseconds. This means that if a watch is executed every second, its actions are\nperformed a maximum of once every 5 seconds, even when the condition is always\nmet. You can configure the throttle period on a per-action basis or at the\nwatch level.\n\nAcknowledgment-based throttling enables you to tell {watcher} not to send any more\nnotifications about a watch as long as its condition is met. Once the condition\nevaluates to `false`, the acknowledgment is cleared and {watcher} resumes executing\nthe watch actions normally.\n\nFor more information, see <<actions-ack-throttle>>.\n\n[discrete]\n[[watch-active-state]]\n=== Watch active state\n\nBy default, when you add a watch it is immediately set to the _active_ state,\nregistered with the appropriate trigger engine, and executed according\nto its configured trigger.\n\nYou can also set a watch to the _inactive_ state. Inactive watches are not\nregistered with a trigger engine and can never be triggered.\n\nTo set a watch to the inactive state when you create it, set the\n<<watcher-api-put-watch,`active`>> parameter to _inactive_. To\ndeactivate an existing watch, use the\n<<watcher-api-deactivate-watch,deactivate watch API>>. To reactivate an\ninactive watch, use the\n<<watcher-api-activate-watch,activate watch API>>.\n\nNOTE:   You can use the <<watcher-api-execute-watch,execute watch API>>\nto force the execution of a watch even when it is inactive.\n\nDeactivating watches is useful in a variety of situations. For example, if you\nhave a watch that monitors an external system and you need to take that system\ndown for maintenance, you can deactivate the watch to prevent it from falsely\nreporting availability issues during the maintenance window.\n\nDeactivating a watch also enables you to keep it around for future use without\ndeleting it from the system.\n\n[discrete]\n[[scripts-templates]]\n=== Scripts and templates\n\nYou can use scripts and templates when defining a watch. Scripts and templates\ncan reference elements in the watch execution context, including the watch payload.\nThe execution context defines variables you can use in a script and parameter\nplaceholders in a template.\n\n{watcher} uses the Elasticsearch script infrastructure, which supports\n<<inline-templates-scripts,inline>> and <<stored-templates-scripts, stored>>.\nScripts and templates are compiled\nand cached by Elasticsearch to optimize recurring execution. Autoloading is also\nsupported. For more information, see <<modules-scripting>> and\n<<modules-scripting-using>>.\n\n[discrete]\n[[watch-execution-context]]\n==== Watch execution context\n\nThe following snippet shows the basic structure of the _Watch Execution Context_:\n\n[source,js]\n----------------------------------------------------------------------\n{\n  \"ctx\" : {\n    \"metadata\" : { ... }, <1>\n    \"payload\" : { ... }, <2>\n    \"watch_id\" : \"<id>\", <3>\n    \"execution_time\" : \"20150220T00:00:10Z\", <4>\n    \"trigger\" : { <5>\n      \"triggered_time\" : \"20150220T00:00:10Z\",\n      \"scheduled_time\" : \"20150220T00:00:00Z\"\n    },\n    \"vars\" : { ... } <6>\n}\n----------------------------------------------------------------------\n// NOTCONSOLE\n<1> Any static metadata specified in the watch definition.\n<2> The current watch payload.\n<3> The id of the executing watch.\n<4> A timestamp that shows when the watch execution started.\n<5> Information about the trigger event. For a `schedule` trigger, this\n    consists of the `triggered_time` (when the watch was triggered)\n    and the `scheduled_time` (when the watch was scheduled to be triggered).\n<6> Dynamic variables that can be set and accessed by different constructs\n    during the execution. These variables are scoped to a single execution\n    (i.e they're not persisted and can't be used between different executions\n    of the same watch)\n\n[discrete]\n[[scripts]]\n==== Using scripts\n\nYou can use scripts to define <<condition-script,conditions>> and\n<<transform-script,transforms>>. The default scripting language is\n<<modules-scripting-painless,Painless>>.\n\nNOTE: Starting with 5.0, Elasticsearch is shipped with the new\n      <<modules-scripting-painless,Painless>> scripting language.\n      Painless was created and designed specifically for use in Elasticsearch.\n      Beyond providing an extensive feature set, its biggest trait is that it's\n      properly sandboxed and safe to use anywhere in the system (including in\n      {watcher}) without the need to enable dynamic scripting.\n\n\nScripts can reference any of the values in the watch execution context or values\nexplicitly passed through script parameters.\n\nFor example, if the watch metadata contains a `color` field\n(e.g. `\"metadata\" : {\"color\": \"red\"}`), you can access its value with the via the\n`ctx.metadata.color` variable. If you pass in a `color`  parameter as part of the\ncondition or transform definition (e.g. `\"params\" : {\"color\": \"red\"}`), you can\naccess its value via the `color` variable.\n\n[discrete]\n[[templates]]\n==== Using templates\n\nYou use templates to define dynamic content for a watch. At execution time,\ntemplates pull in data from the watch execution context. For example, you can use\na template to populate the `subject` field for an `email` action with data stored\nin the watch payload. Templates can also access values explicitly passed through\ntemplate parameters.\n\nYou specify templates using the https://mustache.github.io[Mustache] scripting\nlanguage.\n\nFor example, the following snippet shows how templates enable dynamic subjects\nin sent emails:\n\n[source,js]\n----------------------------------------------------------------------\n{\n  \"actions\" : {\n    \"email_notification\" : {\n      \"email\" : {\n        \"subject\" : \"{{ctx.metadata.color}} alert\"\n      }\n    }\n  }\n}\n----------------------------------------------------------------------\n// NOTCONSOLE\n\n[discrete]\n[[inline-templates-scripts]]\n===== Inline templates and scripts\n\nTo define an inline template or script, you simply specify it directly in the\nvalue of a field. For example, the following snippet configures the subject of\nthe `email` action using an inline template that references the `color` value in\nthe context metadata.\n\n[source,js]\n----------------------------------------------------------------------\n\"actions\" : {\n  \"email_notification\" : {\n     \"email\" : {\n       \"subject\" : \"{{ctx.metadata.color}} alert\"\n     }\n   }\n  }\n}\n----------------------------------------------------------------------\n// NOTCONSOLE\n\nFor a script, you simply specify the inline script as the value of the `script`\nfield. For example:\n\n[source,js]\n----------------------------------------------------------------------\n\"condition\" : {\n  \"script\" : \"return true\"\n}\n----------------------------------------------------------------------\n// NOTCONSOLE\n\nYou can also explicitly specify the inline type by using a formal object\ndefinition as the field value. For example:\n\n[source,js]\n----------------------------------------------------------------------\n\"actions\" : {\n  \"email_notification\" : {\n    \"email\" : {\n      \"subject\" : {\n         \"source\" : \"{{ctx.metadata.color}} alert\"\n      }\n    }\n  }\n}\n----------------------------------------------------------------------\n// NOTCONSOLE\n\nThe formal object definition for a script would be:\n\n[source,js]\n----------------------------------------------------------------------\n\"condition\" : {\n  \"script\" : {\n    \"source\": \"return true\"\n  }\n}\n----------------------------------------------------------------------\n// NOTCONSOLE\n\n[discrete]\n[[stored-templates-scripts]]\n===== Stored templates and scripts\n\nIf you <<modules-scripting-using,store>>\nyour templates and scripts, you can reference them by id.\n\nTo reference a stored script or template, you use the formal object definition\nand specify its id in the `id` field. For example, the following snippet\nreferences the `email_notification_subject` template:\n\n[source,js]\n----------------------------------------------------------------------\n{\n  ...\n  \"actions\" : {\n    \"email_notification\" : {\n      \"email\" : {\n        \"subject\" : {\n          \"id\" : \"email_notification_subject\",\n          \"params\" : {\n            \"color\" : \"red\"\n          }\n        }\n      }\n    }\n  }\n}\n----------------------------------------------------------------------\n// NOTCONSOLE\n"
}