{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.863067",
        "size": 32764,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-operators-numeric.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-operators-numeric",
        "version": "8.15"
    },
    "doc": "[[painless-operators-numeric]]\n=== Operators: Numeric\n\n[[post-increment-operator]]\n==== Post Increment\n\nUse the `post increment operator '++'` to INCREASE the value of a numeric type\nvariable/field by `1`. An extra implicit cast is necessary to return the\npromoted numeric type value to the original numeric type value of the\nvariable/field for the following types: `byte`, `short`, and `char`. If a\nvariable/field is read as part of an expression the value is loaded prior to the\nincrement.\n\n*Errors*\n\n* If the variable/field is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\npost_increment: ( variable | field ) '++';\n----\n\n*Promotion*\n\n[options=\"header\",cols=\"<1,<1,<1\"]\n|====\n| original | promoted | implicit\n| byte     | int      | byte\n| short    | int      | short\n| char     | int      | char\n| int      | int      |\n| long     | long     |\n| float    | float    |\n| double   | double   |\n| def      | def      |\n|====\n\n*Examples*\n\n* Post increment with different numeric types.\n+\n[source,Painless]\n----\nshort i = 0; <1>\ni++;         <2>\nlong j = 1;  <3>\nlong k;      <4>\nk = j++;     <5>\n----\n+\n<1> declare `short i`;\n    store `short 0` to `i`\n<2> load from `i` -> `short 0`;\n    promote `short 0`: result `int`;\n    add `int 0` and `int 1` -> `int 1`;\n    implicit cast `int 1` to `short 1`;\n    store `short 1` to `i`\n<3> declare `long j`;\n    implicit cast `int 1` to `long 1` -> `long 1`;\n    store `long 1` to `j`\n<4> declare `long k`;\n    store default `long 0` to `k`\n<5> load from `j` -> `long 1`;\n    store `long 1` to `k`;\n    add `long 1` and `long 1` -> `long 2`;\n    store `long 2` to `j`\n+\n* Post increment with the `def` type.\n+\n[source,Painless]\n----\ndef x = 1; <1>\nx++;       <2>\n----\n+\n<1> declare `def x`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `x`\n<2> load from `x` -> `def`;\n    implicit cast `def` to `int 1`;\n    add `int 1` and `int 1` -> `int 2`;\n    implicit cast `int 2` to `def`;\n    store `def` to `x`\n\n[[post-decrement-operator]]\n==== Post Decrement\n\nUse the `post decrement operator '--'` to DECREASE the value of a numeric type\nvariable/field by `1`. An extra implicit cast is necessary to return the\npromoted numeric type value to the original numeric type value of the\nvariable/field for the following types: `byte`, `short`, and `char`. If a\nvariable/field is read as part of an expression the value is loaded prior to\nthe decrement.\n\n*Errors*\n\n* If the variable/field is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\npost_decrement: ( variable | field ) '--';\n----\n\n*Promotion*\n\n[options=\"header\",cols=\"<1,<1,<1\"]\n|====\n| original | promoted | implicit\n| byte     | int      | byte\n| short    | int      | short\n| char     | int      | char\n| int      | int      |\n| long     | long     |\n| float    | float    |\n| double   | double   |\n| def      | def      |\n|====\n\n*Examples*\n\n* Post decrement with different numeric types.\n+\n[source,Painless]\n----\nshort i = 0; <1>\ni--;         <2>\nlong j = 1;  <3>\nlong k;      <4>\nk = j--;     <5>\n----\n+\n<1> declare `short i`;\n    store `short 0` to `i`\n<2> load from `i` -> `short 0`;\n    promote `short 0`: result `int`;\n    subtract `int 1` from `int 0` -> `int -1`;\n    implicit cast `int -1` to `short -1`;\n    store `short -1` to `i`\n<3> declare `long j`;\n    implicit cast `int 1` to `long 1` -> `long 1`;\n    store `long 1` to `j`\n<4> declare `long k`;\n    store default `long 0` to `k`\n<5> load from `j` -> `long 1`;\n    store `long 1` to `k`;\n    subtract `long 1` from `long 1` -> `long 0`;\n    store `long 0` to `j`\n+\n* Post decrement with the `def` type.\n+\n[source,Painless]\n----\ndef x = 1; <1>\nx--;       <2>\n----\n+\n<1> declare `def x`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `x`\n<2> load from `x` -> `def`;\n    implicit cast `def` to `int 1`;\n    subtract `int 1` from `int 1` -> `int 0`;\n    implicit cast `int 0` to `def`;\n    store `def` to `x`\n\n[[pre-increment-operator]]\n==== Pre Increment\n\nUse the `pre increment operator '++'` to INCREASE the value of a numeric type\nvariable/field by `1`. An extra implicit cast is necessary to return the\npromoted numeric type value to the original numeric type value of the\nvariable/field for the following types: `byte`, `short`, and `char`. If a\nvariable/field is read as part of an expression the value is loaded after the\nincrement.\n\n*Errors*\n\n* If the variable/field is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\npre_increment: '++' ( variable | field );\n----\n\n*Promotion*\n\n[options=\"header\",cols=\"<1,<1,<1\"]\n|====\n| original | promoted | implicit\n| byte     | int      | byte\n| short    | int      | short\n| char     | int      | char\n| int      | int      |\n| long     | long     |\n| float    | float    |\n| double   | double   |\n| def      | def      |\n|====\n\n*Examples*\n\n* Pre increment with different numeric types.\n+\n[source,Painless]\n----\nshort i = 0; <1>\n++i;         <2>\nlong j = 1;  <3>\nlong k;      <4>\nk = ++j;     <5>\n----\n+\n<1> declare `short i`;\n    store `short 0` to `i`\n<2> load from `i` -> `short 0`;\n    promote `short 0`: result `int`;\n    add `int 0` and `int 1` -> `int 1`;\n    implicit cast `int 1` to `short 1`;\n    store `short 1` to `i`\n<3> declare `long j`;\n    implicit cast `int 1` to `long 1` -> `long 1`;\n    store `long 1` to `j`\n<4> declare `long k`;\n    store default `long 0` to `k`\n<5> load from `j` -> `long 1`;\n    add `long 1` and `long 1` -> `long 2`;\n    store `long 2` to `j`;\n    store `long 2` to `k`\n+\n* Pre increment with the `def` type.\n+\n[source,Painless]\n----\ndef x = 1; <1>\n++x;       <2>\n----\n+\n<1> declare `def x`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `x`\n<2> load from `x` -> `def`;\n    implicit cast `def` to `int 1`;\n    add `int 1` and `int 1` -> `int 2`;\n    implicit cast `int 2` to `def`;\n    store `def` to `x`\n\n[[pre-decrement-operator]]\n==== Pre Decrement\n\nUse the `pre decrement operator '--'` to DECREASE the value of a numeric type\nvariable/field by `1`. An extra implicit cast is necessary to return the\npromoted numeric type value to the original numeric type value of the\nvariable/field for the following types: `byte`, `short`, and `char`. If a\nvariable/field is read as part of an expression the value is loaded after the\ndecrement.\n\n*Errors*\n\n* If the variable/field is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\npre_decrement: '--' ( variable | field );\n----\n\n*Promotion*\n\n[options=\"header\",cols=\"<1,<1,<1\"]\n|====\n| original | promoted | implicit\n| byte     | int      | byte\n| short    | int      | short\n| char     | int      | char\n| int      | int      |\n| long     | long     |\n| float    | float    |\n| double   | double   |\n| def      | def      |\n|====\n\n*Examples*\n\n* Pre decrement with different numeric types.\n+\n[source,Painless]\n----\nshort i = 0; <1>\n--i;         <2>\nlong j = 1;  <3>\nlong k;      <4>\nk = --j;     <5>\n----\n+\n<1> declare `short i`;\n    store `short 0` to `i`\n<2> load from `i` -> `short 0`;\n    promote `short 0`: result `int`;\n    subtract `int 1` from `int 0` -> `int -1`;\n    implicit cast `int -1` to `short -1`;\n    store `short -1` to `i`\n<3> declare `long j`;\n    implicit cast `int 1` to `long 1` -> `long 1`;\n    store `long 1` to `j`\n<4> declare `long k`;\n    store default `long 0` to `k`\n<5> load from `j` -> `long 1`;\n    subtract `long 1` from `long 1` -> `long 0`;\n    store `long 0` to `j`\n    store `long 0` to `k`;\n+\n* Pre decrement operator with the `def` type.\n+\n[source,Painless]\n----\ndef x = 1; <1>\n--x;       <2>\n----\n+\n<1> declare `def x`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `x`\n<2> load from `x` -> `def`;\n    implicit cast `def` to `int 1`;\n    subtract `int 1` from `int 1` -> `int 0`;\n    implicit cast `int 0` to `def`;\n    store `def` to `x`\n\n[[unary-positive-operator]]\n==== Unary Positive\n\nUse the `unary positive operator '+'` to the preserve the IDENTITY of a\nnumeric type value.\n\n*Errors*\n\n* If the value is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nunary_positive: '+' expression;\n----\n\n*Examples*\n\n* Unary positive with different numeric types.\n+\n[source,Painless]\n----\nint x = +1;  <1>\nlong y = +x; <2>\n----\n+\n<1> declare `int x`;\n    identity `int 1` -> `int 1`;\n    store `int 1` to `x`\n<2> declare `long y`;\n    load from `x` -> `int 1`;\n    identity `int 1` -> `int 1`;\n    implicit cast `int 1` to `long 1` -> `long 1`;\n    store `long 1` to `y`\n+\n* Unary positive with the `def` type.\n+\n[source,Painless]\n----\ndef z = +1; <1>\nint i = +z; <2>\n----\n<1> declare `def z`;\n    identity `int 1` -> `int 1`;\n    implicit cast `int 1` to `def`;\n    store `def` to `z`\n<2> declare `int i`;\n    load from `z` -> `def`;\n    implicit cast `def` to `int 1`;\n    identity `int 1` -> `int 1`;\n    store `int 1` to `i`;\n\n[[unary-negative-operator]]\n==== Unary Negative\n\nUse the `unary negative operator '-'` to NEGATE a numeric type value.\n\n*Errors*\n\n* If the value is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nunary_negative: '-' expression;\n----\n\n*Examples*\n\n* Unary negative with different numeric types.\n+\n[source,Painless]\n----\nint x = -1;  <1>\nlong y = -x; <2>\n----\n+\n<1> declare `int x`;\n    negate `int 1` -> `int -1`;\n    store `int -1` to `x`\n<2> declare `long y`;\n    load from `x` -> `int 1`;\n    negate `int -1` -> `int 1`;\n    implicit cast `int 1` to `long 1` -> `long 1`;\n    store `long 1` to `y`\n+\n* Unary negative with the `def` type.\n+\n[source,Painless]\n----\ndef z = -1; <1>\nint i = -z; <2>\n----\n<1> declare `def z`;\n    negate `int 1` -> `int -1`;\n    implicit cast `int -1` to `def`;\n    store `def` to `z`\n<2> declare `int i`;\n    load from `z` -> `def`;\n    implicit cast `def` to `int -1`;\n    negate `int -1` -> `int 1`;\n    store `int 1` to `i`;\n\n[[bitwise-not-operator]]\n==== Bitwise Not\n\nUse the `bitwise not operator '~'` to NOT each bit in an integer type value\nwhere a `1-bit` is flipped to a resultant `0-bit` and a `0-bit` is flipped to a\nresultant `1-bit`.\n\n*Errors*\n\n* If the value is a non-integer type.\n\n*Bits*\n\n[options=\"header\",cols=\"<1,<1\"]\n|====\n| original | result\n| 1        | 0\n| 0        | 1\n|====\n\n*Grammar*\n\n[source,ANTLR4]\n----\nbitwise_not: '~' expression;\n----\n\n*Promotion*\n\n[options=\"header\",cols=\"<1,<1\"]\n|====\n| original | promoted\n| byte     | int\n| short    | int\n| char     | int\n| int      | int\n| long     | long\n| def      | def\n|====\n\n*Examples*\n\n* Bitwise not with different numeric types.\n+\n[source,Painless]\n----\nbyte b = 1;  <1>\nint i = ~b;  <2>\nlong l = ~i; <3>\n----\n+\n<1> declare `byte x`;\n    store `byte 1` to b\n<2> declare `int i`;\n    load from `b` -> `byte 1`;\n    implicit cast `byte 1` to `int 1` -> `int 1`;\n    bitwise not `int 1` -> `int -2`;\n    store `int -2` to `i`\n<3> declare `long l`;\n    load from `i` -> `int -2`;\n    implicit cast `int -2` to `long -2` -> `long -2`;\n    bitwise not `long -2` -> `long 1`;\n    store `long 1` to `l`\n+\n* Bitwise not with the `def` type.\n+\n[source,Painless]\n----\ndef d = 1;  <1>\ndef e = ~d; <2>\n----\n+\n<1> declare `def d`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `d`;\n<2> declare `def e`;\n    load from `d` -> `def`;\n    implicit cast `def` to `int 1` -> `int 1`;\n    bitwise not `int 1` -> `int -2`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `e`\n\n[[multiplication-operator]]\n==== Multiplication\n\nUse the `multiplication operator '*'` to MULTIPLY together two numeric type\nvalues. Rules for resultant overflow and NaN values follow the JVM\nspecification.\n\n*Errors*\n\n* If either of the values is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nmultiplication: expression '*' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | float  | double | def\n| byte   | int    | int    | int    | int    | long   | float  | double | def\n| short  | int    | int    | int    | int    | long   | float  | double | def\n| char   | int    | int    | int    | int    | long   | float  | double | def\n| int    | int    | int    | int    | int    | long   | float  | double | def\n| long   | long   | long   | long   | long   | long   | float  | double | def\n| float  | float  | float  | float  | float  | float  | float  | double | def\n| double | double | double | double | double | double | double | double | def\n| def    | def    | def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Multiplication with different numeric types.\n+\n[source,Painless]\n----\nint i = 5*4;      <1>\ndouble d = i*7.0; <2>\n----\n+\n<1> declare `int i`;\n    multiply `int 4` by `int 5` -> `int 20`;\n    store `int 20` in `i`\n<2> declare `double d`;\n    load from `int i` -> `int 20`;\n    promote `int 20` and `double 7.0`: result `double`;\n    implicit cast `int 20` to `double 20.0` -> `double 20.0`;\n    multiply `double 20.0` by `double 7.0` -> `double 140.0`;\n    store `double 140.0` to `d`\n+\n* Multiplication with the `def` type.\n+\n[source,Painless]\n----\ndef x = 5*4; <1>\ndef y = x*2; <2>\n----\n<1> declare `def x`;\n    multiply `int 5` by `int 4` -> `int 20`;\n    implicit cast `int 20` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 20`;\n    multiply `int 20` by `int 2` -> `int 40`;\n    implicit cast `int 40` to `def` -> `def`;\n    store `def` to `y`\n\n[[division-operator]]\n==== Division\n\nUse the `division operator '/'` to DIVIDE one numeric type value by another.\nRules for NaN values and division by zero follow the JVM specification. Division\nwith integer values drops the remainder of the resultant value.\n\n*Errors*\n\n* If either of the values is a non-numeric type.\n* If a left-hand side integer type value is divided by a right-hand side integer\n  type value of `0`.\n\n*Grammar*\n\n[source,ANTLR4]\n----\ndivision: expression '/' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | float  | double | def\n| byte   | int    | int    | int    | int    | long   | float  | double | def\n| short  | int    | int    | int    | int    | long   | float  | double | def\n| char   | int    | int    | int    | int    | long   | float  | double | def\n| int    | int    | int    | int    | int    | long   | float  | double | def\n| long   | long   | long   | long   | long   | long   | float  | double | def\n| float  | float  | float  | float  | float  | float  | float  | double | def\n| double | double | double | double | double | double | double | double | def\n| def    | def    | def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Division with different numeric types.\n+\n[source,Painless]\n----\nint i = 29/4;     <1>\ndouble d = i/7.0; <2>\n----\n+\n<1> declare `int i`;\n    divide `int 29` by `int 4` -> `int 7`;\n    store `int 7` in `i`\n<2> declare `double d`;\n    load from `int i` -> `int 7`;\n    promote `int 7` and `double 7.0`: result `double`;\n    implicit cast `int 7` to `double 7.0` -> `double 7.0`;\n    divide `double 7.0` by `double 7.0` -> `double 1.0`;\n    store `double 1.0` to `d`\n+\n* Division with the `def` type.\n+\n[source,Painless]\n----\ndef x = 5/4; <1>\ndef y = x/2; <2>\n----\n<1> declare `def x`;\n    divide `int 5` by `int 4` -> `int 1`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 1`;\n    divide `int 1` by `int 2` -> `int 0`;\n    implicit cast `int 0` to `def` -> `def`;\n    store `def` to `y`\n\n[[remainder-operator]]\n==== Remainder\n\nUse the `remainder operator '%'` to calculate the REMAINDER for division\nbetween two numeric type values. Rules for NaN values and division by zero follow the JVM\nspecification.\n\n*Errors*\n\n* If either of the values is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nremainder: expression '%' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | float  | double | def\n| byte   | int    | int    | int    | int    | long   | float  | double | def\n| short  | int    | int    | int    | int    | long   | float  | double | def\n| char   | int    | int    | int    | int    | long   | float  | double | def\n| int    | int    | int    | int    | int    | long   | float  | double | def\n| long   | long   | long   | long   | long   | long   | float  | double | def\n| float  | float  | float  | float  | float  | float  | float  | double | def\n| double | double | double | double | double | double | double | double | def\n| def    | def    | def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Remainder with different numeric types.\n+\n[source,Painless]\n----\nint i = 29%4;     <1>\ndouble d = i%7.0; <2>\n----\n+\n<1> declare `int i`;\n    remainder `int 29` by `int 4` -> `int 1`;\n    store `int 7` in `i`\n<2> declare `double d`;\n    load from `int i` -> `int 1`;\n    promote `int 1` and `double 7.0`: result `double`;\n    implicit cast `int 1` to `double 1.0` -> `double 1.0`;\n    remainder `double 1.0` by `double 7.0` -> `double 1.0`;\n    store `double 1.0` to `d`\n+\n* Remainder with the `def` type.\n+\n[source,Painless]\n----\ndef x = 5%4; <1>\ndef y = x%2; <2>\n----\n<1> declare `def x`;\n    remainder `int 5` by `int 4` -> `int 1`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 1`;\n    remainder `int 1` by `int 2` -> `int 1`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `y`\n\n[[addition-operator]]\n==== Addition\n\nUse the `addition operator '+'` to ADD together two numeric type values. Rules\nfor resultant overflow and NaN values follow the JVM specification.\n\n*Errors*\n\n* If either of the values is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\naddition: expression '+' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | float  | double | def\n| byte   | int    | int    | int    | int    | long   | float  | double | def\n| short  | int    | int    | int    | int    | long   | float  | double | def\n| char   | int    | int    | int    | int    | long   | float  | double | def\n| int    | int    | int    | int    | int    | long   | float  | double | def\n| long   | long   | long   | long   | long   | long   | float  | double | def\n| float  | float  | float  | float  | float  | float  | float  | double | def\n| double | double | double | double | double | double | double | double | def\n| def    | def    | def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Addition operator with different numeric types.\n+\n[source,Painless]\n----\nint i = 29+4;     <1>\ndouble d = i+7.0; <2>\n----\n+\n<1> declare `int i`;\n    add `int 29` and `int 4` -> `int 33`;\n    store `int 33` in `i`\n<2> declare `double d`;\n    load from `int i` -> `int 33`;\n    promote `int 33` and `double 7.0`: result `double`;\n    implicit cast `int 33` to `double 33.0` -> `double 33.0`;\n    add `double 33.0` and `double 7.0` -> `double 40.0`;\n    store `double 40.0` to `d`\n+\n* Addition with the `def` type.\n+\n[source,Painless]\n----\ndef x = 5+4; <1>\ndef y = x+2; <2>\n----\n<1> declare `def x`;\n    add `int 5` and `int 4` -> `int 9`;\n    implicit cast `int 9` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 9`;\n    add `int 9` and `int 2` -> `int 11`;\n    implicit cast `int 11` to `def` -> `def`;\n    store `def` to `y`\n\n[[subtraction-operator]]\n==== Subtraction\n\nUse the `subtraction operator '-'` to SUBTRACT a right-hand side numeric type\nvalue from a left-hand side numeric type value. Rules for resultant overflow\nand NaN values follow the JVM specification.\n\n*Errors*\n\n* If either of the values is a non-numeric type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nsubtraction: expression '-' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | float  | double | def\n| byte   | int    | int    | int    | int    | long   | float  | double | def\n| short  | int    | int    | int    | int    | long   | float  | double | def\n| char   | int    | int    | int    | int    | long   | float  | double | def\n| int    | int    | int    | int    | int    | long   | float  | double | def\n| long   | long   | long   | long   | long   | long   | float  | double | def\n| float  | float  | float  | float  | float  | float  | float  | double | def\n| double | double | double | double | double | double | double | double | def\n| def    | def    | def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Subtraction with different numeric types.\n+\n[source,Painless]\n----\nint i = 29-4;     <1>\ndouble d = i-7.5; <2>\n----\n+\n<1> declare `int i`;\n    subtract `int 4` from `int 29` -> `int 25`;\n    store `int 25` in `i`\n<2> declare `double d`\n    load from `int i` -> `int 25`;\n    promote `int 25` and `double 7.5`: result `double`;\n    implicit cast `int 25` to `double 25.0` -> `double 25.0`;\n    subtract `double 33.0` by `double 7.5` -> `double 25.5`;\n    store `double 25.5` to `d`\n+\n* Subtraction with the `def` type.\n+\n[source,Painless]\n----\ndef x = 5-4; <1>\ndef y = x-2; <2>\n----\n<1> declare `def x`;\n    subtract `int 4` and `int 5` -> `int 1`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 1`;\n    subtract `int 2` from `int 1` -> `int -1`;\n    implicit cast `int -1` to `def` -> `def`;\n    store `def` to `y`\n\n[[left-shift-operator]]\n==== Left Shift\n\nUse the `left shift operator '<<'` to SHIFT lower order bits to higher order\nbits in a left-hand side integer type value by the distance specified in a\nright-hand side integer type value.\n\n*Errors*\n\n* If either of the values is a non-integer type.\n* If the right-hand side value cannot be cast to an int type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nleft_shift: expression '<<' expression;\n----\n\n*Promotion*\n\nThe left-hand side integer type value is promoted as specified in the table\nbelow. The right-hand side integer type value is always implicitly cast to an\n`int` type value and truncated to the number of bits of the promoted type value.\n\n[options=\"header\",cols=\"<1,<1\"]\n|====\n| original | promoted\n| byte     | int\n| short    | int\n| char     | int\n| int      | int\n| long     | long\n| def      | def\n|====\n\n*Examples*\n\n* Left shift with different integer types.\n+\n[source,Painless]\n----\nint i = 4 << 1;   <1>\nlong l = i << 2L; <2>\n----\n+\n<1> declare `int i`;\n    left shift `int 4` by `int 1` -> `int 8`;\n    store `int 8` in `i`\n<2> declare `long l`\n    load from `int i` -> `int 8`;\n    implicit cast `long 2` to `int 2` -> `int 2`;\n    left shift `int 8` by `int 2` -> `int 32`;\n    implicit cast `int 32` to `long 32` -> `long 32`;\n    store `long 32` to `l`\n+\n* Left shift with the `def` type.\n+\n[source,Painless]\n----\ndef x = 4 << 2; <1>\ndef y = x << 1; <2>\n----\n<1> declare `def x`;\n    left shift `int 4` by `int 2` -> `int 16`;\n    implicit cast `int 16` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 16`;\n    left shift `int 16` by `int 1` -> `int 32`;\n    implicit cast `int 32` to `def` -> `def`;\n    store `def` to `y`\n\n[[right-shift-operator]]\n==== Right Shift\n\nUse the `right shift operator '>>'` to SHIFT higher order bits to lower order\nbits in a left-hand side integer type value by the distance specified in a\nright-hand side integer type value. The highest order bit of the left-hand side\ninteger type value is preserved.\n\n*Errors*\n\n* If either of the values is a non-integer type.\n* If the right-hand side value cannot be cast to an int type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nright_shift: expression '>>' expression;\n----\n\n*Promotion*\n\nThe left-hand side integer type value is promoted as specified in the table\nbelow. The right-hand side integer type value is always implicitly cast to an\n`int` type value and truncated to the number of bits of the promoted type value.\n\n[options=\"header\",cols=\"<1,<1\"]\n|====\n| original | promoted\n| byte     | int\n| short    | int\n| char     | int\n| int      | int\n| long     | long\n| def      | def\n|====\n\n*Examples*\n\n* Right shift with different integer types.\n+\n[source,Painless]\n----\nint i = 32 >> 1;  <1>\nlong l = i >> 2L; <2>\n----\n+\n<1> declare `int i`;\n    right shift `int 32` by `int 1` -> `int 16`;\n    store `int 16` in `i`\n<2> declare `long l`\n    load from `int i` -> `int 16`;\n    implicit cast `long 2` to `int 2` -> `int 2`;\n    right shift `int 16` by `int 2` -> `int 4`;\n    implicit cast `int 4` to `long 4` -> `long 4`;\n    store `long 4` to `l`\n+\n* Right shift with the `def` type.\n+\n[source,Painless]\n----\ndef x = 16 >> 2; <1>\ndef y = x >> 1;  <2>\n----\n<1> declare `def x`;\n    right shift `int 16` by `int 2` -> `int 4`;\n    implicit cast `int 4` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 4`;\n    right shift `int 4` by `int 1` -> `int 2`;\n    implicit cast `int 2` to `def` -> `def`;\n    store `def` to `y`\n\n[[unsigned-right-shift-operator]]\n==== Unsigned Right Shift\n\nUse the `unsigned right shift operator '>>>'` to SHIFT higher order bits to\nlower order bits in a left-hand side integer type value by the distance\nspecified in a right-hand side type integer value. The highest order bit of the\nleft-hand side integer type value is *not* preserved.\n\n*Errors*\n\n* If either of the values is a non-integer type.\n* If the right-hand side value cannot be cast to an int type.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nunsigned_right_shift: expression '>>>' expression;\n----\n\n*Promotion*\n\nThe left-hand side integer type value is promoted as specified in the table\nbelow. The right-hand side integer type value is always implicitly cast to an\n`int` type value and truncated to the number of bits of the promoted type value.\n\n[options=\"header\",cols=\"<1,<1\"]\n|====\n| original | promoted\n| byte     | int\n| short    | int\n| char     | int\n| int      | int\n| long     | long\n| def      | def\n|====\n\n*Examples*\n\n* Unsigned right shift with different integer types.\n+\n[source,Painless]\n----\nint i = -1 >>> 29; <1>\nlong l = i >>> 2L; <2>\n----\n+\n<1> declare `int i`;\n    unsigned right shift `int -1` by `int 29` -> `int 7`;\n    store `int 7` in `i`\n<2> declare `long l`\n    load from `int i` -> `int 7`;\n    implicit cast `long 2` to `int 2` -> `int 2`;\n    unsigned right shift `int 7` by `int 2` -> `int 3`;\n    implicit cast `int 3` to `long 3` -> `long 3`;\n    store `long 3` to `l`\n+\n* Unsigned right shift with the `def` type.\n+\n[source,Painless]\n----\ndef x = 16 >>> 2; <1>\ndef y = x >>> 1;  <2>\n----\n<1> declare `def x`;\n    unsigned right shift `int 16` by `int 2` -> `int 4`;\n    implicit cast `int 4` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 4`;\n    unsigned right shift `int 4` by `int 1` -> `int 2`;\n    implicit cast `int 2` to `def` -> `def`;\n    store `def` to `y`\n\n[[bitwise-and-operator]]\n==== Bitwise And\n\nUse the `bitwise and operator '&'` to AND together each bit within two\ninteger type values where if both bits at the same index are `1` the resultant\nbit is `1` and `0` otherwise.\n\n*Errors*\n\n* If either of the values is a non-integer type.\n\n*Bits*\n\n[cols=\"^1,^1,^1\"]\n|====\n|   | 1 | 0\n| 1 | 1 | 0\n| 0 | 0 | 0\n|====\n\n*Grammar*\n\n[source,ANTLR4]\n----\nbitwise_and: expression '&' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | def\n| byte   | int    | int    | int    | int    | long   | def\n| short  | int    | int    | int    | int    | long   | def\n| char   | int    | int    | int    | int    | long   | def\n| int    | int    | int    | int    | int    | long   | def\n| long   | long   | long   | long   | long   | long   | def\n| def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Bitwise and with different integer types.\n+\n[source,Painless]\n----\nint i = 5 & 6;   <1>\nlong l = i & 5L; <2>\n----\n+\n<1> declare `int i`;\n    bitwise and `int 5` and `int 6` -> `int 4`;\n    store `int 4` in `i`\n<2> declare `long l`\n    load from `int i` -> `int 4`;\n    promote `int 4` and `long 5`: result `long`;\n    implicit cast `int 4` to `long 4` -> `long 4`;\n    bitwise and `long 4` and `long 5` -> `long 4`;\n    store `long 4` to `l`\n+\n* Bitwise and with the `def` type.\n+\n[source,Painless]\n----\ndef x = 15 & 6; <1>\ndef y = x & 5;  <2>\n----\n<1> declare `def x`;\n    bitwise and `int 15` and `int 6` -> `int 6`;\n    implicit cast `int 6` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 6`;\n    bitwise and `int 6` and `int 5` -> `int 4`;\n    implicit cast `int 4` to `def` -> `def`;\n    store `def` to `y`\n\n[[bitwise-xor-operator]]\n==== Bitwise Xor\n\nUse the `bitwise xor operator '^'` to XOR together each bit within two integer\ntype values where if one bit is a `1` and the other bit is a `0` at the same\nindex the resultant bit is `1` otherwise the resultant bit is `0`.\n\n*Errors*\n\n* If either of the values is a non-integer type.\n\n*Bits*\n\nThe following table illustrates the resultant bit from the xoring of two bits.\n\n[cols=\"^1,^1,^1\"]\n|====\n|   | 1 | 0\n| 1 | 0 | 1\n| 0 | 1 | 0\n|====\n\n*Grammar*\n\n[source,ANTLR4]\n----\nbitwise_xor: expression '^' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | def\n| byte   | int    | int    | int    | int    | long   | def\n| short  | int    | int    | int    | int    | long   | def\n| char   | int    | int    | int    | int    | long   | def\n| int    | int    | int    | int    | int    | long   | def\n| long   | long   | long   | long   | long   | long   | def\n| def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Bitwise xor with different integer types.\n+\n[source,Painless]\n----\nint i = 5 ^ 6;   <1>\nlong l = i ^ 5L; <2>\n----\n+\n<1> declare `int i`;\n    bitwise xor `int 5` and `int 6` -> `int 3`;\n    store `int 3` in `i`\n<2> declare `long l`\n    load from `int i` -> `int 4`;\n    promote `int 3` and `long 5`: result `long`;\n    implicit cast `int 3` to `long 3` -> `long 3`;\n    bitwise xor `long 3` and `long 5` -> `long 6`;\n    store `long 6` to `l`\n+\n* Bitwise xor with the `def` type.\n+\n[source,Painless]\n----\ndef x = 15 ^ 6; <1>\ndef y = x ^ 5;  <2>\n----\n<1> declare `def x`;\n    bitwise xor `int 15` and `int 6` -> `int 9`;\n    implicit cast `int 9` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 9`;\n    bitwise xor `int 9` and `int 5` -> `int 12`;\n    implicit cast `int 12` to `def` -> `def`;\n    store `def` to `y`\n\n[[bitwise-or-operator]]\n==== Bitwise Or\n\nUse the `bitwise or operator '|'` to OR together each bit within two integer\ntype values where if at least one bit is a `1` at the same index the resultant\nbit is `1` otherwise the resultant bit is `0`.\n\n*Errors*\n\n* If either of the values is a non-integer type.\n\n*Bits*\n\nThe following table illustrates the resultant bit from the oring of two bits.\n\n[cols=\"^1,^1,^1\"]\n|====\n|   | 1 | 0\n| 1 | 1 | 1\n| 0 | 1 | 0\n|====\n\n*Grammar*\n\n[source,ANTLR4]\n----\nbitwise_or: expression '|' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | def\n| byte   | int    | int    | int    | int    | long   | def\n| short  | int    | int    | int    | int    | long   | def\n| char   | int    | int    | int    | int    | long   | def\n| int    | int    | int    | int    | int    | long   | def\n| long   | long   | long   | long   | long   | long   | def\n| def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Bitwise or with different integer types.\n+\n[source,Painless]\n----\nint i = 5 | 6;   <1>\nlong l = i | 8L; <2>\n----\n+\n<1> declare `int i`;\n    bitwise or `int 5` and `int 6` -> `int 7`;\n    store `int 7` in `i`\n<2> declare `long l`\n    load from `int i` -> `int 7`;\n    promote `int 7` and `long 8`: result `long`;\n    implicit cast `int 7` to `long 7` -> `long 7`;\n    bitwise or `long 7` and `long 8` -> `long 15`;\n    store `long 15` to `l`\n+\n* Bitwise or with the `def` type.\n+\n[source,Painless]\n----\ndef x = 5 ^ 6; <1>\ndef y = x ^ 8; <2>\n----\n<1> declare `def x`;\n    bitwise or `int 5` and `int 6` -> `int 7`;\n    implicit cast `int 7` to `def` -> `def`;\n    store `def` in `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 7`;\n    bitwise or `int 7` and `int 8` -> `int 15`;\n    implicit cast `int 15` to `def` -> `def`;\n    store `def` to `y`\n"
}