{
    "meta": {
        "size": 9762,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-string-syntax.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "query-string-syntax",
        "version": "8.15"
    },
    "doc": "[[query-string-syntax]]\n\n===== Query string syntax\n\nThe query string ``mini-language'' is used by the\n<<query-dsl-query-string-query>> and by the\n`q` query string parameter in the <<search-search,`search` API>>.\n\nThe query string is parsed into a series of _terms_ and _operators_. A\nterm can be a single word -- `quick` or `brown` -- or a phrase, surrounded by\ndouble quotes -- `\"quick brown\"` -- which searches for all the words in the\nphrase, in the same order.\n\nOperators allow you to customize the search -- the available options are\nexplained below.\n\n====== Field names\n\nYou can specify fields to search in the query syntax:\n\n* where the `status` field contains `active`\n\n    status:active\n\n* where the `title` field contains `quick` or `brown`\n\n    title:(quick OR brown)\n\n* where the `author` field contains the exact phrase `\"john smith\"`\n\n    author:\"John Smith\"\n\n* where the `first name` field contains `Alice` (note how we need to escape\n  the space with a backslash)\n\n    first\\ name:Alice\n\n* where any of the fields `book.title`, `book.content` or `book.date` contains\n  `quick` or `brown` (note how we need to escape the `*` with a backslash):\n\n    book.\\*:(quick OR brown)\n\n* where the field `title` has any non-null value:\n\n    _exists_:title\n\n[[query-string-wildcard]]\n====== Wildcards\n\nWildcard searches can be run on individual terms, using `?` to replace\na single character, and `*` to replace zero or more characters:\n\n    qu?ck bro*\n\nBe aware that wildcard queries can use an enormous amount of memory and\nperform very badly -- just think how many terms need to be queried to\nmatch the query string `\"a* b* c*\"`.\n\n[WARNING]\n=======\nPure wildcards `\\*` are rewritten to <<query-dsl-exists-query,`exists`>> queries for efficiency.\nAs a consequence, the wildcard `\"field:*\"` would match documents with an empty value\n like the following:\n```\n{\n  \"field\": \"\"\n}\n```\n\\... and would **not** match if the field is missing or set with an explicit null\nvalue like the following:\n```\n{\n  \"field\": null\n}\n```\n=======\n\n[WARNING]\n=======\nAllowing a wildcard at the beginning of a word (eg `\"*ing\"`) is particularly\nheavy, because all terms in the index need to be examined, just in case\nthey match. Leading wildcards can be disabled by setting\n`allow_leading_wildcard` to `false`.\n=======\n\nOnly parts of the analysis chain that operate at the character level are\napplied. So for instance, if the analyzer performs both lowercasing and\nstemming, only the lowercasing will be applied: it would be wrong to perform\nstemming on a word that is missing some of its letters.\n\nBy setting `analyze_wildcard` to true, queries that end with a `*` will be\nanalyzed and a boolean query will be built out of the different tokens, by\nensuring exact matches on the first N-1 tokens, and prefix match on the last\ntoken.\n\n====== Regular expressions\n\nRegular expression patterns can be embedded in the query string by\nwrapping them in forward-slashes (`\"/\"`):\n\n    name:/joh?n(ath[oa]n)/\n\nThe supported regular expression syntax is explained in <<regexp-syntax>>.\n\n[WARNING]\n=======\nThe `allow_leading_wildcard` parameter does not have any control over\nregular expressions. A query string such as the following would force\nElasticsearch to visit every term in the index:\n\n    /.*n/\n\nUse with caution!\n=======\n\n[[query-string-fuzziness]]\n====== Fuzziness\n\nYou can run <<query-dsl-fuzzy-query,`fuzzy` queries>> using the `~` operator:\n\n    quikc~ brwn~ foks~\n\nFor these queries, the query string is <<analysis-normalizers,normalized>>. If\npresent, only certain filters from the analyzer are applied. For a list of\napplicable filters, see <<analysis-normalizers>>.\n\nThe query uses the\n{wikipedia}/Damerau-Levenshtein_distance[Damerau-Levenshtein distance]\nto find all terms with a maximum of\ntwo changes, where a change is the insertion, deletion\nor substitution of a single character, or transposition of two adjacent\ncharacters.\n\nThe default _edit distance_ is `2`, but an edit distance of `1` should be\nsufficient to catch 80% of all human misspellings. It can be specified as:\n\n    quikc~1\n\n[[avoid-widlcards-fuzzy-searches]]\n[WARNING]\n.Avoid mixing fuzziness with wildcards\n====\nMixing <<fuzziness,fuzzy>> and <<query-string-wildcard,wildcard>> operators is\n_not_ supported. When mixed, one of the operators is not applied. For example,\nyou can search for `app~1` (fuzzy) or `app*` (wildcard), but searches for\n`app*~1` do not apply the fuzzy operator (`~1`).\n====\n\n====== Proximity searches\n\nWhile a phrase query (eg `\"john smith\"`) expects all of the terms in exactly\nthe same order, a proximity query allows the specified words to be further\napart or in a different order. In the same way that fuzzy queries can\nspecify a maximum edit distance for characters in a word, a proximity search\nallows us to specify a maximum edit distance of words in a phrase:\n\n    \"fox quick\"~5\n\nThe closer the text in a field is to the original order specified in the\nquery string, the more relevant that document is considered to be. When\ncompared to the above example query, the phrase `\"quick fox\"` would be\nconsidered more relevant than `\"quick brown fox\"`.\n\n====== Ranges\n\nRanges can be specified for date, numeric or string fields. Inclusive ranges\nare specified with square brackets `[min TO max]` and exclusive ranges with\ncurly brackets `{min TO max}`.\n\n* All days in 2012:\n\n    date:[2012-01-01 TO 2012-12-31]\n\n* Numbers 1..5\n\n    count:[1 TO 5]\n\n* Tags between `alpha` and `omega`, excluding `alpha` and `omega`:\n\n    tag:{alpha TO omega}\n\n* Numbers from 10 upwards\n\n    count:[10 TO *]\n\n* Dates before 2012\n\n    date:{* TO 2012-01-01}\n\nCurly and square brackets can be combined:\n\n* Numbers from 1 up to but not including 5\n\n    count:[1 TO 5}\n\n\nRanges with one side unbounded can use the following syntax:\n\n    age:>10\n    age:>=10\n    age:<10\n    age:<=10\n\n[NOTE]\n====================================================================\nTo combine an upper and lower bound with the simplified syntax, you\nwould need to join two clauses with an `AND` operator:\n\n    age:(>=10 AND <20)\n    age:(+>=10 +<20)\n\n====================================================================\n\nThe parsing of ranges in query strings can be complex and error prone. It is\nmuch more reliable to use an explicit <<query-dsl-range-query,`range` query>>.\n\n\n====== Boosting\n\nUse the _boost_ operator `^` to make one term more relevant than another.\nFor instance, if we want to find all documents about foxes, but we are\nespecially interested in quick foxes:\n\n    quick^2 fox\n\nThe default `boost` value is 1, but can be any positive floating point number.\nBoosts between 0 and 1 reduce relevance.\n\nBoosts can also be applied to phrases or to groups:\n\n    \"john smith\"^2   (foo bar)^4\n\n====== Boolean operators\n\nBy default, all terms are optional, as long as one term matches. A search\nfor `foo bar baz` will find any document that contains one or more of\n`foo` or `bar` or `baz`. We have already discussed the `default_operator`\nabove which allows you to force all terms to be required, but there are\nalso _boolean operators_ which can be used in the query string itself\nto provide more control.\n\nThe preferred operators are `+` (this term *must* be present) and `-`\n(this term *must not* be present). All other terms are optional.\nFor example, this query:\n\n    quick brown +fox -news\n\nstates that:\n\n* `fox` must be present\n* `news` must not be present\n* `quick` and `brown` are optional -- their presence increases the relevance\n\nThe familiar boolean operators `AND`, `OR` and `NOT` (also written `&&`, `||`\nand `!`) are also supported but beware that they do not honor the usual\nprecedence rules, so parentheses should be used whenever multiple operators are\nused together. For instance the previous query could be rewritten as:\n\n`((quick AND fox) OR (brown AND fox) OR fox) AND NOT news`::\n\nThis form now replicates the logic from the original query correctly, but\nthe relevance scoring bears little resemblance to the original.\n\nIn contrast, the same query rewritten using the <<query-dsl-match-query,`match` query>>\nwould look like this:\n\n    {\n        \"bool\": {\n            \"must\":     { \"match\": \"fox\"         },\n            \"should\":   { \"match\": \"quick brown\" },\n            \"must_not\": { \"match\": \"news\"        }\n        }\n    }\n\n\n====== Grouping\n\nMultiple terms or clauses can be grouped together with parentheses, to form\nsub-queries:\n\n    (quick OR brown) AND fox\n\nGroups can be used to target a particular field, or to boost the result\nof a sub-query:\n\n    status:(active OR pending) title:(full text search)^2\n\n====== Reserved characters\n\nIf you need to use any of the characters which function as operators in your\nquery itself (and not as operators), then you should escape them with\na leading backslash. For instance, to search for `(1+1)=2`, you would\nneed to write your query as `\\(1\\+1\\)\\=2`. When using JSON for the request body, two preceding backslashes (`\\\\`) are required; the backslash is a reserved escaping character in JSON strings.\n\n[source,console]\n----\nGET /my-index-000001/_search\n{\n  \"query\" : {\n    \"query_string\" : {\n      \"query\" : \"kimchy\\\\!\",\n      \"fields\"  : [\"user.id\"]\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n\nThe reserved characters are:  `+ - = && || > < ! ( ) { } [ ] ^ \" ~ * ? : \\ /`\n\nFailing to escape these special characters correctly could lead to a syntax error which prevents your query from running. \n\nNOTE: `<` and `>` can't be escaped at all. The only way to prevent them from\nattempting to create a range query is to remove them from the query string\nentirely.\n\n====== Whitespaces and empty queries\n\nWhitespace is not considered an operator.\n\nIf the query string is empty or only contains whitespaces the query will\nyield an empty result set.\n"
}