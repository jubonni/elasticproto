{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.445067",
        "size": 19862,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significanttext-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-bucket-significanttext-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-significanttext-aggregation]]\n=== Significant text aggregation\n++++\n<titleabbrev>Significant text</titleabbrev>\n++++\n\nAn aggregation that returns interesting or unusual occurrences of free-text terms in a set.\nIt is like the <<search-aggregations-bucket-significantterms-aggregation,significant terms>> aggregation but differs in that:\n\n* It is specifically designed for use on type `text` fields\n* It does not require field data or doc-values\n* It re-analyzes text content on-the-fly meaning it can also filter duplicate sections of\nnoisy text that otherwise tend to skew statistics.\n\nWARNING: Re-analyzing _large_ result sets will require a lot of time and memory. It is recommended that the significant_text\n         aggregation is used as a child of either the <<search-aggregations-bucket-sampler-aggregation,sampler>> or \n         <<search-aggregations-bucket-diversified-sampler-aggregation,diversified sampler>> aggregation to limit the analysis\n         to a _small_ selection of top-matching documents e.g. 200. This will typically improve speed, memory use and quality of\n         results.\n\n.Example use cases:\n* Suggesting \"H5N1\" when users search for \"bird flu\" to help expand queries\n* Suggesting keywords relating to stock symbol $ATI for use in an automated news classifier\n\nIn these cases the words being selected are not simply the most popular terms in results. The most popular words tend to be\nvery boring (_and, of, the, we, I, they_ ...).\nThe significant words are the ones that have undergone a significant change in popularity measured between a _foreground_ and _background_ set.\nIf the term \"H5N1\" only exists in 5 documents in a 10 million document index and yet is found in 4 of the 100 documents that make up a user's search results\nthat is significant and probably very relevant to their search. 5/10,000,000 vs 4/100 is a big swing in frequency.\n\n==== Basic use\n\nIn the typical use case, the _foreground_ set of interest is a selection of the top-matching search results for a query\nand the _background_ set used for statistical comparisons is the index or indices from which the results were gathered.\n\nExample:\n\n[source,console,id=significanttext-aggregation-example]\n--------------------------------------------------\nGET news/_search\n{\n  \"query\": {\n    \"match\": { \"content\": \"Bird flu\" }\n  },\n  \"aggregations\": {\n    \"my_sample\": {\n      \"sampler\": {\n        \"shard_size\": 100\n      },\n      \"aggregations\": {\n        \"keywords\": {\n          \"significant_text\": { \"field\": \"content\" }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:news]\n\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 9,\n  \"timed_out\": false,\n  \"_shards\": ...,\n  \"hits\": ...,\n    \"aggregations\" : {\n        \"my_sample\": {\n            \"doc_count\": 100,\n            \"keywords\" : {\n                \"doc_count\": 100,\n                \"buckets\" : [\n                    {\n                        \"key\": \"h5n1\",\n                        \"doc_count\": 4,\n                        \"score\": 4.71235374214817,\n                        \"bg_count\": 5\n                    }\n                    ...\n                ]\n            }\n        }\n    }\n}\n--------------------------------------------------\n// TESTRESPONSE[skip:historically skipped]\n\nThe results show that \"h5n1\" is one of several terms strongly associated with bird flu.\nIt only occurs 5 times in our index as a whole (see the `bg_count`) and yet 4 of these \nwere lucky enough to appear in our 100 document sample of \"bird flu\" results. That suggests\na significant word and one which the user can potentially add to their search. \n\n[[filter-duplicate-text-noisy-data]]\n==== Dealing with noisy data using `filter_duplicate_text`\nFree-text fields often contain a mix of original content and mechanical copies of text (cut-and-paste biographies, email reply chains, \nretweets, boilerplate headers/footers, page navigation menus, sidebar news links, copyright notices, standard disclaimers, addresses).\n\nIn real-world data these duplicate sections of text tend to feature heavily in `significant_text` results if they aren't filtered out.\nFiltering near-duplicate text is a difficult task at index-time but we can cleanse the data on-the-fly at query time using the \n`filter_duplicate_text` setting.\n\n\nFirst let's look at an unfiltered real-world example using the https://research.signalmedia.co/newsir16/signal-dataset.html[Signal media dataset] of\na million news articles covering a wide variety of news. Here are the raw significant text results for a search for the articles \nmentioning \"elasticsearch\":\n\n\n[source,js]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"sample\": {\n      \"doc_count\": 35,\n      \"keywords\": {\n        \"doc_count\": 35,\n        \"buckets\": [\n          {\n            \"key\": \"elasticsearch\",\n            \"doc_count\": 35,\n            \"score\": 28570.428571428572,\n            \"bg_count\": 35\n          },\n          ...\n          {\n            \"key\": \"currensee\",\n            \"doc_count\": 8,\n            \"score\": 6530.383673469388,\n            \"bg_count\": 8\n          },\n          ...\n          {\n            \"key\": \"pozmantier\",\n            \"doc_count\": 4,\n            \"score\": 3265.191836734694,\n            \"bg_count\": 4\n          },\n          ...\n\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nThe uncleansed documents have thrown up some odd-looking terms that are, on the face of it, statistically \ncorrelated with appearances of our search term \"elasticsearch\" e.g. \"pozmantier\".\nWe can drill down into examples of these documents to see why pozmantier is connected using this query:\n\n[source,console,id=significanttext-aggregation-pozmantier-example]\n--------------------------------------------------\nGET news/_search\n{\n  \"query\": {\n    \"simple_query_string\": {\n      \"query\": \"+elasticsearch  +pozmantier\"\n    }\n  },\n  \"_source\": [\n    \"title\",\n    \"source\"\n  ],\n  \"highlight\": {\n    \"fields\": {\n      \"content\": {}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:news]\n\nThe results show a series of very similar news articles about a judging panel for a number of tech projects:\n\n[source,js]\n--------------------------------------------------\n{\n  ...\n  \"hits\": {\n    \"hits\": [\n      {\n        ...\n        \"_source\": {\n          \"source\": \"Presentation Master\",\n          \"title\": \"T.E.N. Announces Nominees for the 2015 ISE\u00ae North America Awards\"\n        },\n        \"highlight\": {\n          \"content\": [\n            \"City of San Diego Mike <em>Pozmantier</em>, Program Manager, Cyber Security Division, Department of\",\n            \" Janus, Janus <em>ElasticSearch</em> Security Visualization Engine \"\n          ]\n        }\n      },\n      {\n        ...\n        \"_source\": {\n          \"source\": \"RCL Advisors\",\n          \"title\": \"T.E.N. Announces Nominees for the 2015 ISE(R) North America Awards\"\n        },\n        \"highlight\": {\n          \"content\": [\n            \"Mike <em>Pozmantier</em>, Program Manager, Cyber Security Division, Department of Homeland Security S&T\",\n            \"Janus, Janus <em>ElasticSearch</em> Security Visualization Engine\"\n          ]\n        }\n      },\n      ...\n--------------------------------------------------\n// NOTCONSOLE\nMike Pozmantier was one of many judges on a panel and elasticsearch was used in one of many projects being judged.\n\nAs is typical, this lengthy press release was cut-and-paste by a variety of news sites and consequently any rare names, numbers or \ntypos they contain become statistically correlated with our matching query.\n\nFortunately similar documents tend to rank similarly so as part of examining the stream of top-matching documents the significant_text\naggregation can apply a filter to remove sequences of any 6 or more tokens that have already been seen. Let's try this same query now but\nwith the `filter_duplicate_text` setting turned on:\n\n[source,console,id=significanttext-aggregation-filter-duplicate-text-example]\n--------------------------------------------------\nGET news/_search\n{\n  \"query\": {\n    \"match\": {\n      \"content\": \"elasticsearch\"\n    }\n  },\n  \"aggs\": {\n    \"sample\": {\n      \"sampler\": {\n        \"shard_size\": 100\n      },\n      \"aggs\": {\n        \"keywords\": {\n          \"significant_text\": {\n            \"field\": \"content\",\n            \"filter_duplicate_text\": true\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:news]\n\nThe results from analysing our deduplicated text are obviously of higher quality to anyone familiar with the elastic stack:\n\n[source,js]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"sample\": {\n      \"doc_count\": 35,\n      \"keywords\": {\n        \"doc_count\": 35,\n        \"buckets\": [\n          {\n            \"key\": \"elasticsearch\",\n            \"doc_count\": 22,\n            \"score\": 11288.001166180758,\n            \"bg_count\": 35\n          },\n          {\n            \"key\": \"logstash\",\n            \"doc_count\": 3,\n            \"score\": 1836.648979591837,\n            \"bg_count\": 4\n          },\n          {\n            \"key\": \"kibana\",\n            \"doc_count\": 3,\n            \"score\": 1469.3020408163263,\n            \"bg_count\": 5\n          }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nMr Pozmantier and other one-off associations with elasticsearch no longer appear in the aggregation \nresults as a consequence of copy-and-paste operations or other forms of mechanical repetition. \n\nIf your duplicate or near-duplicate content is identifiable via a single-value indexed field  (perhaps\na hash of the article's `title` text or an `original_press_release_url` field) then it would be more \nefficient to use a parent <<search-aggregations-bucket-diversified-sampler-aggregation,diversified sampler>> aggregation\nto eliminate these documents from the sample set based on that single key. The less duplicate content you can feed into\nthe significant_text aggregation up front the better in terms of performance.\n\n\n.How are the significance scores calculated?\n**********************************\nThe numbers returned for scores are primarily intended for ranking different suggestions sensibly rather than something easily \nunderstood by end users. The scores are derived from the doc frequencies in _foreground_ and _background_ sets. In brief, a \nterm is considered significant if there is a noticeable difference in the frequency in which a term appears in the subset and \nin the background. The way the terms are ranked can be configured, see \"Parameters\" section.\n\n**********************************\n\n.Use the _\"like this but not this\"_ pattern\n**********************************\nYou can spot mis-categorized content by first searching a structured field e.g. `category:adultMovie` and use significant_text on the\ntext \"movie_description\" field. Take the suggested words (I'll leave them to your imagination) and then search for all movies NOT marked as category:adultMovie but containing these keywords.\nYou now have a ranked list of badly-categorized movies that you should reclassify or at least remove from the \"familyFriendly\" category.\n\nThe significance score from each term can also provide a useful `boost` setting to sort matches.\nUsing the `minimum_should_match` setting of the `terms` query with the keywords will help control the balance of precision/recall in the result set i.e\na high setting would have a small number of relevant results packed full of keywords and a setting of \"1\" would produce a more exhaustive results set with all documents containing _any_ keyword.\n\n**********************************\n\n\n\n==== Limitations\n\n\n===== No support for child aggregations\nThe significant_text aggregation intentionally does not support the addition of child aggregations because:\n\n* It would come with a high memory cost\n* It isn't a generally useful feature and there is a workaround for those that need it\n\nThe volume of candidate terms is generally very high and these are pruned heavily before the final\nresults are returned. Supporting child aggregations would generate additional churn and be inefficient.\nClients can always take the heavily-trimmed set of results from a `significant_text` request and \nmake a subsequent follow-up query using a `terms` aggregation with an `include` clause and child\naggregations to perform further analysis of selected keywords in a more efficient fashion.\n\n===== No support for nested objects\n\nThe significant_text aggregation currently also cannot be used with text fields in\nnested objects, because it works with the document JSON source. This makes this\nfeature inefficient when matching nested docs from stored JSON given a matching\nLucene docID.\n\n===== Approximate counts\nThe counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and\nas such may be:\n\n* low if certain shards did not provide figures for a given term in their top sample\n* high when considering the background frequency as it may count occurrences found in deleted documents\n\nLike most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.\nHowever, the `size` and `shard size` settings covered in the next section provide tools to help control the accuracy levels.\n\n[[significanttext-aggregation-parameters]]\n==== Parameters\n\n===== Significance heuristics\n\nThis aggregation supports the same scoring heuristics (JLH, mutual_information, gnd, chi_square etc) as the <<search-aggregations-bucket-significantterms-aggregation,significant terms>> aggregation\n\n[[sig-text-shard-size]]\n===== Size & Shard Size\n\nThe `size` parameter can be set to define how many term buckets should be returned out of the overall terms list. By\ndefault, the node coordinating the search process will request each shard to provide its own top term buckets\nand once all shards respond, it will reduce the results to the final list that will then be returned to the client.\nIf the number of unique terms is greater than `size`, the returned list can be slightly off and not accurate\n(it could be that the term counts are slightly off and it could even be that a term that should have been in the top\nsize buckets was not returned).\n\nTo ensure better accuracy a multiple of the final `size` is used as the number of terms to request from each shard\n(`2 * (size * 1.5 + 10)`). To take manual control of this setting the `shard_size` parameter\ncan be used to control the volumes of candidate terms produced by each shard.\n\nLow-frequency terms can turn out to be the most interesting ones once all results are combined so the\nsignificant_terms aggregation can produce higher-quality results when the `shard_size` parameter is set to\nvalues significantly higher than the `size` setting. This ensures that a bigger volume of promising candidate terms are given\na consolidated review by the reducing node before the final selection. Obviously large candidate term lists\nwill cause extra network traffic and RAM usage so this is quality/cost trade off that needs to be balanced. If `shard_size` is set to -1 (the default) then `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.\n\n\nNOTE:   `shard_size` cannot be smaller than `size` (as it doesn't make much sense). When it is, elasticsearch will\n        override it and reset it to be equal to `size`.\n\n===== Minimum document count\n\nIt is possible to only return terms that match more than a configured number of hits using the `min_doc_count` option.\nThe Default value is 3.\n\nTerms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step. \nHowever, the shard does not have the information about the global term frequencies available. The decision if a term is added to a \ncandidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word.\nThe `min_doc_count` criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the \nterm as a candidate is made without being very _certain_ about if the term will actually reach the required `min_doc_count`. \nThis might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated \nthe candidate lists. To avoid this, the `shard_size` parameter can be increased to allow more candidate terms on the shards. \nHowever, this increases memory consumption and network traffic.\n\n[[search-aggregations-bucket-significanttext-shard-min-doc-count]]\n====== `shard_min_doc_count`\n\ninclude::terms-aggregation.asciidoc[tag=min-doc-count]\n\nWARNING: Setting `min_doc_count` to `1` is generally not advised as it tends to return terms that\n         are typos or other bizarre curiosities. Finding more than one instance of a term helps\n         reinforce that, while still rare, the term was not the result of a one-off accident. The\n         default value of 3 is used to provide a minimum weight-of-evidence.\n         Setting `shard_min_doc_count` too high will cause significant candidate terms to be filtered out on a shard level. \n         This value should be set much lower than `min_doc_count/#shards`.\n\n\n\n===== Custom background context\n\nThe default source of statistical information for background term frequencies is the entire index and this\nscope can be narrowed through the use of a `background_filter` to focus in on significant terms within a narrower\ncontext:\n\n[source,console,id=significanttext-aggregation-custom-background-example]\n--------------------------------------------------\nGET news/_search\n{\n  \"query\": {\n    \"match\": {\n      \"content\": \"madrid\"\n    }\n  },\n  \"aggs\": {\n    \"tags\": {\n      \"significant_text\": {\n        \"field\": \"content\",\n        \"background_filter\": {\n          \"term\": { \"content\": \"spain\" }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:news]\n\nThe above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing\nterms like \"Spanish\" that are unusual in the full index's worldwide context but commonplace in the subset of documents containing the\nword \"Spain\".\n\nWARNING: Use of background filters will slow the query as each term's postings must be filtered to determine a frequency\n\n\n===== Dealing with source and index mappings\n\nOrdinarily the indexed field name and the original JSON field being retrieved share the same name.\nHowever with more complex field mappings using features like `copy_to` the source \nJSON field(s) and the indexed field being aggregated can differ.\nIn these cases it is possible to list the JSON _source fields from which text\nwill be analyzed using the `source_fields` parameter:\n\n[source,console,id=significanttext-aggregation-mappings-example]\n--------------------------------------------------\nGET news/_search\n{\n  \"query\": {\n    \"match\": {\n      \"custom_all\": \"elasticsearch\"\n    }\n  },\n  \"aggs\": {\n    \"tags\": {\n      \"significant_text\": {\n        \"field\": \"custom_all\",\n        \"source_fields\": [ \"content\", \"title\" ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:news]\n\n\n===== Filtering Values\n\nIt is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the `include` and\n`exclude` parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features\ndescribed in the <<search-aggregations-bucket-terms-aggregation,terms aggregation>> documentation.\n\n\n"
}