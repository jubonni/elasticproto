{
    "meta": {
        "size": 28375,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/eql-function-ref.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "eql-function-ref",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[eql-function-ref]]\n== EQL function reference\n++++\n<titleabbrev>Function reference</titleabbrev>\n++++\n\n{es} supports the following <<eql-functions,EQL functions>>.\n\n[discrete]\n[[eql-fn-add]]\n=== `add`\nReturns the sum of two provided addends.\n\n*Example*\n[source,eql]\n----\nadd(4, 5)                                           // returns 9\nadd(4, 0.5)                                         // returns 4.5\nadd(0.5, 0.25)                                      // returns 0.75\nadd(4, -2)                                          // returns 2\nadd(-2, -2)                                         // returns -4\n\n// process.args_count = 4\nadd(process.args_count, 5)                          // returns 9\nadd(process.args_count, 0.5)                        // returns 4.5\n\n// process.parent.args_count = 2\nadd(process.args_count, process.parent.args_count)  // returns 6\n\n// null handling\nadd(null, 4)                                        // returns null\nadd(4. null)                                        // returns null\nadd(null, process.args_count)                       // returns null\nadd(process.args_count null)                        // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nadd(<addend>, <addend>)\n----\n\n*Parameters:*\n\n`<addend>`::\n(Required, integer or float or `null`)\nAddend to add. If `null`, the function returns `null`.\n+\nTwo addends are required. No more than two addends can be provided.\n+\nIf using a field as the argument, this parameter supports only\n<<number,`numeric`>> field data types.\n\n*Returns:* integer, float, or `null`\n\n[discrete]\n[[eql-fn-between]]\n=== `between`\n\nExtracts a substring that's between a provided `left` and `right` text in a\nsource string. Matching is case-sensitive by default.\n\n*Example*\n[source,eql]\n----\n// file.path = \"C:\\\\Windows\\\\System32\\\\cmd.exe\"\nbetween(file.path, \"System32\\\\\\\\\", \".exe\")                // returns \"cmd\"\nbetween(file.path, \"system32\\\\\\\\\", \".exe\")                // returns \"\"\nbetween(file.path, \"workspace\\\\\\\\\", \".exe\")               // returns \"\"\n\n// Make matching case-insensitive\nbetween~(file.path, \"system32\\\\\\\\\", \".exe\")               // returns \"cmd\"\n\n// Greedy matching defaults to false.\nbetween(file.path, \"\\\\\\\\\", \"\\\\\\\\\", false)                 // returns \"Windows\"\n\n// Sets greedy matching to true\nbetween(file.path, \"\\\\\\\\\", \"\\\\\\\\\", true)                  // returns \"Windows\\\\System32\"\n\n// empty source string\nbetween(\"\", \"System32\\\\\\\\\", \".exe\")                       // returns \"\"\nbetween(\"\", \"\", \"\")                                       // returns \"\"\n\n// null handling\nbetween(null, \"System32\\\\\\\\\", \".exe\")                     // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nbetween(<source>, <left>, <right>[, <greedy_matching>])\n----\n\n*Parameters*\n\n`<source>`::\n+\n--\n(Required, string or `null`)\nSource string. Empty strings return an empty string (`\"\"`), regardless of the\n`<left>` or `<right>` parameters. If `null`, the function returns `null`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n`<left>`::\n+\n--\n(Required, string)\nText to the left of the substring to extract. This text should include\nwhitespace.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n`<right>`::\n+\n--\n(Required, string)\nText to the right of the substring to extract. This text should include\nwhitespace.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n`<greedy_matching>`::\n(Optional, Boolean)\nIf `true`, match the longest possible substring, similar to `.*` in regular\nexpressions. If `false`, match the shortest possible substring, similar to `.*?`\nin regular expressions. Defaults to `false`.\n\n*Returns:* string or `null`\n\n[discrete]\n[[eql-fn-cidrmatch]]\n=== `cidrMatch`\n\nReturns `true` if an IP address is contained in one or more provided\n{wikipedia}/Classless_Inter-Domain_Routing[CIDR] blocks.\n\n*Example*\n\n[source,eql]\n----\n// source.address = \"192.168.152.12\"\ncidrMatch(source.address, \"192.168.0.0/16\")               // returns true\ncidrMatch(source.address, \"192.168.0.0/16\", \"10.0.0.0/8\") // returns true\ncidrMatch(source.address, \"10.0.0.0/8\")                   // returns false\ncidrMatch(source.address, \"10.0.0.0/8\", \"10.128.0.0/9\")   // returns false\n\n// null handling\ncidrMatch(null, \"10.0.0.0/8\")                             // returns null\ncidrMatch(source.address, null)                           // returns null\n----\n\n*Syntax*\n[source,txt]\n----\n`cidrMatch(<ip_address>, <cidr_block>[, ...])`\n----\n\n*Parameters*\n\n`<ip_address>`::\n(Required, string or `null`)\nIP address. Supports\n{wikipedia}/IPv4[IPv4] and\n{wikipedia}/IPv6[IPv6] addresses. If `null`, the function\nreturns `null`.\n+\nIf using a field as the argument, this parameter supports only the <<ip,`ip`>>\nfield data type.\n\n`<cidr_block>`::\n(Required{multi-arg}, string or `null`)\nCIDR block you wish to search. If `null`, the function returns `null`.\n\n*Returns:* boolean or `null`\n\n[discrete]\n[[eql-fn-concat]]\n=== `concat`\n\nReturns a concatenated string of provided values.\n\n*Example*\n[source,eql]\n----\nconcat(\"process is \", \"regsvr32.exe\")         // returns \"process is regsvr32.exe\"\nconcat(\"regsvr32.exe\", \" \", 42)               // returns \"regsvr32.exe 42\"\nconcat(\"regsvr32.exe\", \" \", 42.5)             // returns \"regsvr32.exe 42.5\"\nconcat(\"regsvr32.exe\", \" \", true)             // returns \"regsvr32.exe true\"\nconcat(\"regsvr32.exe\")                        // returns \"regsvr32.exe\"\n\n// process.name = \"regsvr32.exe\"\nconcat(process.name, \" \", 42)                 // returns \"regsvr32.exe 42\"\nconcat(process.name, \" \", 42.5)               // returns \"regsvr32.exe 42.5\"\nconcat(\"process is \", process.name)           // returns \"process is regsvr32.exe\"\nconcat(process.name, \" \", true)               // returns \"regsvr32.exe true\"\nconcat(process.name)                          // returns \"regsvr32.exe\"\n\n// process.arg_count = 4\nconcat(process.name, \" \", process.arg_count)  // returns \"regsvr32.exe 4\"\n\n// null handling\nconcat(null, \"regsvr32.exe\")                  // returns null\nconcat(process.name, null)                    // returns null\nconcat(null)                                  // returns null \n----\n\n*Syntax*\n[source,txt]\n----\nconcat(<value>[, <value>])\n----\n\n*Parameters*\n\n`<value>`::\n(Required{multi-arg-ref})\nValue to concatenate. If any of the arguments are `null`, the function returns `null`.\n+\nIf using a field as the argument, this parameter does not support the\n<<text,`text`>> field data type.\n\n*Returns:* string or `null`\n\n[discrete]\n[[eql-fn-divide]]\n=== `divide`\nReturns the quotient of a provided dividend and divisor.\n\n[[eql-divide-fn-float-rounding]]\n[WARNING]\n====\nIf both the dividend and divisor are integers, the `divide` function _rounds\ndown_ any returned floating point numbers to the nearest integer. To avoid\nrounding, convert either the dividend or divisor to a float.\n\n[%collapsible]\n.**Example**\n=====\nThe `process.args_count` field is a <<number,`long`>> integer field containing a\ncount of process arguments.\n\nA user might expect the following EQL query to only match events with a\n`process.args_count` value of `4`.\n\n[source,eql]\n----\nprocess where divide(4, process.args_count) == 1\n----\n\nHowever, the EQL query matches events with a `process.args_count` value of `3`\nor `4`.\n\nFor events with a `process.args_count` value of `3`, the `divide` function\nreturns a floating point number of `1.333...`, which is rounded down to `1`.\n\nTo match only events with a `process.args_count` value of `4`, convert\neither the dividend or divisor to a float.\n\nThe following EQL query changes the integer `4` to the equivalent float `4.0`.\n\n[source,eql]\n----\nprocess where divide(4.0, process.args_count) == 1\n----\n=====\n====\n\n*Example*\n[source,eql]\n----\ndivide(4, 2)                                            // returns 2\ndivide(4, 3)                                            // returns 1\ndivide(4, 3.0)                                          // returns 1.333...\ndivide(4, 0.5)                                          // returns 8\ndivide(0.5, 4)                                          // returns 0.125\ndivide(0.5, 0.25)                                       // returns 2.0\ndivide(4, -2)                                           // returns -2\ndivide(-4, -2)                                          // returns 2\n\n// process.args_count = 4\ndivide(process.args_count, 2)                           // returns 2\ndivide(process.args_count, 3)                           // returns 1\ndivide(process.args_count, 3.0)                         // returns 1.333...\ndivide(12, process.args_count)                          // returns 3\ndivide(process.args_count, 0.5)                         // returns 8\ndivide(0.5, process.args_count)                         // returns 0.125\n\n// process.parent.args_count = 2\ndivide(process.args_count, process.parent.args_count)   // returns 2\n\n// null handling\ndivide(null, 4)                                         // returns null\ndivide(4, null)                                         // returns null\ndivide(null, process.args_count)                        // returns null\ndivide(process.args_count, null)                        // returns null\n----\n\n*Syntax*\n[source,txt]\n----\ndivide(<dividend>, <divisor>)\n----\n\n*Parameters*\n\n`<dividend>`::\n(Required, integer or float or `null`)\nDividend to divide. If `null`, the function returns `null`.\n+\nIf using a field as the argument, this parameter supports only\n<<number,`numeric`>> field data types.\n\n`<divisor>`::\n(Required, integer or float or `null`)\nDivisor to divide by. If `null`, the function returns `null`. This value cannot\nbe zero (`0`).\n+\nIf using a field as the argument, this parameter supports only\n<<number,`numeric`>> field data types.\n\n*Returns:* integer, float, or null\n\n[discrete]\n[[eql-fn-endswith]]\n=== `endsWith`\n\nReturns `true` if a source string ends with a provided substring. Matching is\ncase-sensitive by default.\n\n*Example*\n[source,eql]\n----\nendsWith(\"regsvr32.exe\", \".exe\")          // returns true\nendsWith(\"regsvr32.exe\", \".EXE\")          // returns false\nendsWith(\"regsvr32.exe\", \".dll\")          // returns false\nendsWith(\"\", \"\")                          // returns true\n\n// Make matching case-insensitive\nendsWith~(\"regsvr32.exe\", \".EXE\")         // returns true\n\n// file.name = \"regsvr32.exe\"\nendsWith(file.name, \".exe\")               // returns true\nendsWith(file.name, \".dll\")               // returns false\n\n// file.extension = \".exe\"\nendsWith(\"regsvr32.exe\", file.extension)  // returns true\nendsWith(\"ntdll.dll\", file.name)          // returns false\n\n// null handling\nendsWith(\"regsvr32.exe\", null)            // returns null\nendsWith(\"\", null)                        // returns null\nendsWith(null, \".exe\")                    // returns null\nendsWith(null, null)                      // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nendsWith(<source>, <substring>)\n----\n\n*Parameters*\n\n`<source>`::\n+\n--\n(Required, string or `null`)\nSource string. If `null`, the function returns `null`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n`<substring>`::\n+\n--\n(Required, string or `null`)\nSubstring to search for. If `null`, the function returns `null`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n*Returns:* boolean or `null`\n\n[discrete]\n[[eql-fn-indexof]]\n=== `indexOf`\n\nReturns the first position of a provided substring in a source string. Matching\nis case-sensitive by default.\n\nIf an optional start position is provided, this function returns the first\noccurrence of the substring at or after the start position.\n\n*Example*\n[source,eql]\n----\n// url.domain = \"subdomain.example.com\"\nindexOf(url.domain, \"d\")        // returns 3\nindexOf(url.domain, \"D\")        // returns null\nindexOf(url.domain, \".\")        // returns 9\nindexOf(url.domain, \".\", 9)     // returns 9\nindexOf(url.domain, \".\", 10)    // returns 17\nindexOf(url.domain, \".\", -6)    // returns 9\n\n// Make matching case-insensitive\nindexOf~(url.domain, \"D\")        // returns 4\n\n// empty strings\nindexOf(\"\", \"\")                 // returns 0\nindexOf(url.domain, \"\")         // returns 0\nindexOf(url.domain, \"\", 9)      // returns 9\nindexOf(url.domain, \"\", 10)     // returns 10\nindexOf(url.domain, \"\", -6)     // returns 0\n\n// missing substrings\nindexOf(url.domain, \"z\")        // returns null\nindexOf(url.domain, \"z\", 9)     // returns null\n\n// start position is higher than string length\nindexOf(url.domain, \".\", 30)    // returns null\n\n// null handling\nindexOf(null, \".\", 9)           // returns null\nindexOf(url.domain, null, 9)    // returns null\nindexOf(url.domain, \".\", null)  // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nindexOf(<source>, <substring>[, <start_pos>])\n----\n\n*Parameters*\n\n`<source>`::\n+\n--\n(Required, string or `null`)\nSource string. If `null`, the function returns `null`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n`<substring>`::\n+\n--\n(Required, string or `null`)\nSubstring to search for.\n\nIf this argument is `null` or the `<source>` string does not contain this\nsubstring, the function returns `null`.\n\nIf the `<start_pos>` is positive, empty strings (`\"\"`) return the `<start_pos>`.\nOtherwise, empty strings return `0`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n`<start_pos>`::\n+\n--\n(Optional, integer or `null`)\nStarting position for matching. The function will not return positions before\nthis one. Defaults to `0`.\n\nPositions are zero-indexed. Negative offsets are treated as `0`.\n\nIf this argument is `null` or higher than the length of the `<source>` string,\nthe function returns `null`.\n\nIf using a field as the argument, this parameter supports only the following\n<<number,numeric>> field data types:\n\n* `long`\n* `integer`\n* `short`\n* `byte`\n--\n\n*Returns:* integer or `null`\n\n[discrete]\n[[eql-fn-length]]\n=== `length`\n\nReturns the character length of a provided string, including whitespace and\npunctuation.\n\n*Example*\n[source,eql]\n----\nlength(\"explorer.exe\")         // returns 12\nlength(\"start explorer.exe\")   // returns 18\nlength(\"\")                     // returns 0\nlength(null)                   // returns null\n\n// process.name = \"regsvr32.exe\"\nlength(process.name)           // returns 12\n----\n\n*Syntax*\n[source,txt]\n----\nlength(<string>)\n----\n\n*Parameters*\n\n`<string>`::\n+\n--\n(Required, string or `null`)\nString for which to return the character length. If `null`, the function returns\n`null`. Empty strings return `0`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n*Returns:* integer or `null`\n\n[discrete]\n[[eql-fn-modulo]]\n=== `modulo`\nReturns the remainder of the division of a provided dividend and divisor.\n\n*Example*\n[source,eql]\n----\nmodulo(10, 6)                                       // returns 4\nmodulo(10, 5)                                       // returns 0\nmodulo(10, 0.5)                                     // returns 0\nmodulo(10, -6)                                      // returns 4\nmodulo(-10, -6)                                     // returns -4\n\n// process.args_count = 10\nmodulo(process.args_count, 6)                       // returns 4\nmodulo(process.args_count, 5)                       // returns 0\nmodulo(106, process.args_count)                     // returns 6\nmodulo(process.args_count, -6)                      // returns 4\nmodulo(process.args_count, 0.5)                     // returns 0\n\n// process.parent.args_count = 6\nmodulo(process.args_count, process.parent.args_count)  // returns 4\n\n// null handling\nmodulo(null, 5)                                     // returns null\nmodulo(7, null)                                     // returns null\nmodulo(null, process.args_count)                    // returns null\nmodulo(process.args_count, null)                    // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nmodulo(<dividend>, <divisor>)\n----\n\n*Parameters*\n\n`<dividend>`::\n(Required, integer or float or `null`)\nDividend to divide. If `null`, the function returns `null`. Floating point\nnumbers return `0`.\n+\nIf using a field as the argument, this parameter supports only\n<<number,`numeric`>> field data types.\n\n`<divisor>`::\n(Required, integer or float or `null`)\nDivisor to divide by. If `null`, the function returns `null`. Floating point\nnumbers return `0`. This value cannot be zero (`0`).\n+\nIf using a field as the argument, this parameter supports only\n<<number,`numeric`>> field data types.\n\n*Returns:* integer, float, or `null`\n\n[discrete]\n[[eql-fn-multiply]]\n=== `multiply`\n\nReturns the product of two provided factors.\n\n*Example*\n[source,eql]\n----\nmultiply(2, 2)                                           // returns 4\nmultiply(0.5, 2)                                         // returns 1\nmultiply(0.25, 2)                                        // returns 0.5\nmultiply(-2, 2)                                          // returns -4\nmultiply(-2, -2)                                         // returns 4\n\n// process.args_count = 2\nmultiply(process.args_count, 2)                          // returns 4\nmultiply(0.5, process.args_count)                        // returns 1\nmultiply(0.25, process.args_count)                       // returns 0.5\n\n// process.parent.args_count = 3\nmultiply(process.args_count, process.parent.args_count)  // returns 6\n\n// null handling\nmultiply(null, 2)                                        // returns null\nmultiply(2, null)                                        // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nmultiply(<factor, <factor>)\n----\n\n*Parameters*\n\n`<factor>`::\n+\n--\n(Required, integer or float or `null`)\nFactor to multiply. If `null`, the function returns `null`.\n\nTwo factors are required. No more than two factors can be provided.\n\nIf using a field as the argument, this parameter supports only\n<<number,`numeric`>> field data types.\n--\n\n*Returns:* integer, float, or `null`\n\n[discrete]\n[[eql-fn-number]]\n=== `number`\n\nConverts a string to the corresponding integer or float.\n\n*Example*\n[source,eql]\n----\nnumber(\"1337\")              // returns 1337\nnumber(\"42.5\")              // returns 42.5\nnumber(\"deadbeef\", 16)      // returns 3735928559\n\n// integer literals beginning with \"0x\" are auto-detected as hexadecimal\nnumber(\"0xdeadbeef\")        // returns 3735928559\nnumber(\"0xdeadbeef\", 16)    // returns 3735928559\n\n// \"+\" and \"-\" are supported\nnumber(\"+1337\")             // returns 1337\nnumber(\"-1337\")             // returns -1337\n\n// surrounding whitespace is ignored\nnumber(\"  1337  \")          // returns 1337\n\n// process.pid = \"1337\"\nnumber(process.pid)         // returns 1337\n\n// null handling\nnumber(null)                // returns null\nnumber(null, 16)            // returns null\n\n// strings beginning with \"0x\" are treated as hexadecimal (base 16),\n// even if the <base_num> is explicitly null.\nnumber(\"0xdeadbeef\", null) // returns 3735928559\n\n// otherwise, strings are treated as decimal (base 10)\n// if the <base_num> is explicitly null.\nnumber(\"1337\", null)        // returns 1337\n----\n\n*Syntax*\n[source,txt]\n----\nnumber(<string>[, <base_num>])\n----\n\n*Parameters*\n\n`<string>`::\n+\n--\n(Required, string or `null`)\nString to convert to an integer or float. If this value is a string, it must be\none of the following:\n\n* A string representation of an integer (e.g., `\"42\"`)\n* A string representation of a float (e.g., `\"9.5\"`)\n* If the `<base_num>` parameter is specified, a string containing an integer\n  literal in the base notation (e.g., `\"0xDECAFBAD\"` in hexadecimal or base\n  `16`)\n\nStrings that begin with `0x` are auto-detected as hexadecimal and use a default\n`<base_num>` of `16`.\n\n`-` and `+` are supported with no space between. Surrounding whitespace is\nignored. Empty strings (`\"\"`) are not supported.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n\nIf this argument is `null`, the function returns `null`.\n--\n\n`<base_num>`::\n+\n--\n(Optional, integer or `null`)\nRadix or base used to convert the string. If the `<string>` begins with `0x`,\nthis parameter defaults to `16` (hexadecimal). Otherwise, it defaults to base\n`10`.\n\nIf this argument is explicitly `null`, the default value is used.\n\nFields are not supported as arguments.\n--\n\n*Returns:* integer or float or `null`\n\n[discrete]\n[[eql-fn-startswith]]\n=== `startsWith`\n\nReturns `true` if a source string begins with a provided substring. Matching is\ncase-sensitive by default.\n\n*Example*\n[source,eql]\n----\nstartsWith(\"regsvr32.exe\", \"regsvr32\")  // returns true\nstartsWith(\"regsvr32.exe\", \"Regsvr32\")  // returns false\nstartsWith(\"regsvr32.exe\", \"explorer\")  // returns false\nstartsWith(\"\", \"\")                      // returns true\n\n// Make matching case-insensitive\nstartsWith~(\"regsvr32.exe\", \"Regsvr32\")  // returns true\n\n// process.name = \"regsvr32.exe\"\nstartsWith(process.name, \"regsvr32\")    // returns true\nstartsWith(process.name, \"explorer\")    // returns false\n\n// process.name = \"regsvr32\"\nstartsWith(\"regsvr32.exe\", process.name) // returns true\nstartsWith(\"explorer.exe\", process.name) // returns false\n\n// null handling\nstartsWith(\"regsvr32.exe\", null)        // returns null\nstartsWith(\"\", null)                    // returns null\nstartsWith(null, \"regsvr32\")            // returns null\nstartsWith(null, null)                  // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nstartsWith(<source>, <substring>)\n----\n\n*Parameters*\n\n`<source>`::\n+\n--\n(Required, string or `null`)\nSource string. If `null`, the function returns `null`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n`<substring>`::\n+\n--\n(Required, string or `null`)\nSubstring to search for. If `null`, the function returns `null`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n--\n\n*Returns:* boolean or `null`\n\n[discrete]\n[[eql-fn-string]]\n=== `string`\n\nConverts a value to a string.\n\n*Example*\n[source,eql]\n----\nstring(42)               // returns \"42\"\nstring(42.5)             // returns \"42.5\"\nstring(\"regsvr32.exe\")   // returns \"regsvr32.exe\"\nstring(true)             // returns \"true\"\n\n// null handling\nstring(null)             // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nstring(<value>)\n----\n\n*Parameters*\n\n`<value>`::\n(Required)\nValue to convert to a string. If `null`, the function returns `null`.\n+\nIf using a field as the argument, this parameter does not support the\n<<text,`text`>> field data type.\n\n*Returns:* string or `null`\n\n[discrete]\n[[eql-fn-stringcontains]]\n=== `stringContains`\n\nReturns `true` if a source string contains a provided substring. Matching is\ncase-sensitive by default.\n\n*Example*\n[source,eql]\n----\n// process.command_line = \"start regsvr32.exe\"\nstringContains(process.command_line, \"regsvr32\")  // returns true\nstringContains(process.command_line, \"Regsvr32\")  // returns false\nstringContains(process.command_line, \"start \")    // returns true\nstringContains(process.command_line, \"explorer\")  // returns false\n\n// Make matching case-insensitive\nstringContains~(process.command_line, \"Regsvr32\")  // returns false\n\n// process.name = \"regsvr32.exe\"\nstringContains(command_line, process.name)        // returns true\n\n// empty strings\nstringContains(\"\", \"\")                            // returns false\nstringContains(process.command_line, \"\")          // returns false\n\n// null handling\nstringContains(null, \"regsvr32\")                  // returns null\nstringContains(process.command_line, null)        // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nstringContains(<source>, <substring>)\n----\n\n*Parameters*\n\n`<source>`::\n(Required, string or `null`)\nSource string to search. If `null`, the function returns `null`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n\n`<substring>`::\n(Required, string or `null`)\nSubstring to search for. If `null`, the function returns `null`.\n\nIf using a field as the argument, this parameter supports only the following\nfield data types:\n\n* A type in the <<keyword,`keyword`>> family\n* <<text,`text`>> field with a <<keyword,`keyword`>> sub-field\n\n*Returns:* boolean or `null`\n\n[discrete]\n[[eql-fn-substring]]\n=== `substring`\n\nExtracts a substring from a source string at provided start and end positions.\n\nIf no end position is provided, the function extracts the remaining string.\n\n*Example*\n[source,eql]\n----\nsubstring(\"start regsvr32.exe\", 6)        // returns \"regsvr32.exe\"\nsubstring(\"start regsvr32.exe\", 0, 5)     // returns \"start\"\nsubstring(\"start regsvr32.exe\", 6, 14)    // returns \"regsvr32\"\nsubstring(\"start regsvr32.exe\", -4)       // returns \".exe\"\nsubstring(\"start regsvr32.exe\", -4, -1)   // returns \".ex\"\n----\n\n*Syntax*\n[source,txt]\n----\nsubstring(<source>, <start_pos>[, <end_pos>])\n----\n\n*Parameters*\n\n`<source>`::\n(Required, string)\nSource string.\n\n`<start_pos>`::\n+\n--\n(Required, integer)\nStarting position for extraction.\n\nIf this position is higher than the `<end_pos>` position or the length of the\n`<source>` string, the function returns an empty string.\n\nPositions are zero-indexed. Negative offsets are supported.\n--\n\n`<end_pos>`::\n(Optional, integer)\nExclusive end position for extraction. If this position is not provided, the\nfunction returns the remaining string.\n+\nPositions are zero-indexed. Negative offsets are supported.\n\n*Returns:* string\n\n[discrete]\n[[eql-fn-subtract]]\n=== `subtract`\nReturns the difference between a provided minuend and subtrahend.\n\n*Example*\n[source,eql]\n----\nsubtract(10, 2)                                          // returns 8\nsubtract(10.5, 0.5)                                      // returns 10\nsubtract(1, 0.2)                                         // returns 0.8\nsubtract(-2, 4)                                          // returns -8\nsubtract(-2, -4)                                         // returns 8\n\n// process.args_count = 10\nsubtract(process.args_count, 6)                          // returns 4\nsubtract(process.args_count, 5)                          // returns 5\nsubtract(15, process.args_count)                         // returns 5\nsubtract(process.args_count, 0.5)                        // returns 9.5\n\n// process.parent.args_count = 6\nsubtract(process.args_count, process.parent.args_count)  // returns 4\n\n// null handling\nsubtract(null, 2)                                        // returns null\nsubtract(2, null)                                        // returns null\n----\n\n*Syntax*\n[source,txt]\n----\nsubtract(<minuend>, <subtrahend>)\n----\n\n*Parameters*\n\n`<minuend>`::\n(Required, integer or float or `null`)\nMinuend to subtract from.\n+\nIf using a field as the argument, this parameter supports only\n<<number,`numeric`>> field data types.\n\n`<subtrahend>`::\n(Optional, integer or float or `null`)\nSubtrahend to subtract. If `null`, the function returns `null`.\n+\nIf using a field as the argument, this parameter supports only\n<<number,`numeric`>> field data types.\n\n*Returns:* integer, float, or `null`\n"
}