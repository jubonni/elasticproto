{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.858273",
        "size": 46466,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-operators-boolean.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-operators-boolean",
        "version": "8.15"
    },
    "doc": "[[painless-operators-boolean]]\n=== Operators: Boolean\n\n[[boolean-not-operator]]\n==== Boolean Not\n\nUse the `boolean not operator '!'` to NOT a `boolean` type value where `true` is\nflipped to `false` and `false` is flipped to `true`.\n\n*Errors*\n\n* If a value other than a `boolean` type value or a value that is castable to a\n  `boolean` type value is given.\n\n*Truth*\n\n[options=\"header\",cols=\"<1,<1\"]\n|====\n| original | result\n| true     | false\n| false    | true\n|====\n\n*Grammar*\n\n[source,ANTLR4]\n----\nboolean_not: '!' expression;\n----\n\n*Examples*\n\n* Boolean not with the `boolean` type.\n+\n[source,Painless]\n----\nboolean x = !false; <1>\nboolean y = !x;     <2>\n----\n<1> declare `boolean x`;\n    boolean not `boolean false` -> `boolean true`;\n    store `boolean true` to `x`\n<2> declare `boolean y`;\n    load from `x` -> `boolean true`;\n    boolean not `boolean true` -> `boolean false`;\n    store `boolean false` to `y`\n+\n* Boolean not with the `def` type.\n+\n[source,Painless]\n----\ndef y = true; <1>\ndef z = !y;   <2>\n----\n+\n<1> declare `def y`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `true` to `y`\n<2> declare `def z`;\n    load from `y` -> `def`;\n    implicit cast `def` to `boolean true` -> boolean `true`;\n    boolean not `boolean true` -> `boolean false`;\n    implicit cast `boolean false` to `def` -> `def`;\n    store `def` to `z`\n\n[[greater-than-operator]]\n==== Greater Than\n\nUse the `greater than operator '>'` to COMPARE two numeric type values where a\nresultant `boolean` type value is `true` if the left-hand side value is greater\nthan to the right-hand side value and `false` otherwise.\n\n*Errors*\n\n* If either the evaluated left-hand side or the evaluated right-hand side is a\n  non-numeric value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\ngreater_than: expression '>' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | float  | double | def\n| byte   | int    | int    | int    | int    | long   | float  | double | def\n| short  | int    | int    | int    | int    | long   | float  | double | def\n| char   | int    | int    | int    | int    | long   | float  | double | def\n| int    | int    | int    | int    | int    | long   | float  | double | def\n| long   | long   | long   | long   | long   | long   | float  | double | def\n| float  | float  | float  | float  | float  | float  | float  | double | def\n| double | double | double | double | double | double | double | double | def\n| def    | def    | def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Greater than with different numeric types.\n+\n[source,Painless]\n----\nboolean x = 5 > 4; <1>\ndouble y = 6.0;    <2>\nx = 6 > y;         <3>\n----\n+\n<1> declare `boolean x`;\n    greater than `int 5` and `int 4` -> `boolean true`;\n    store `boolean true` to `x`;\n<2> declare `double y`;\n    store `double 6.0` to `y`;\n<3> load from `y` -> `double 6.0 @0`;\n    promote `int 6` and `double 6.0`: result `double`;\n    implicit cast `int 6` to `double 6.0 @1` -> `double 6.0 @1`;\n    greater than `double 6.0 @1` and `double 6.0 @0` -> `boolean false`;\n    store `boolean false` to `x`\n+\n* Greater than with `def` type.\n+\n[source,Painless]\n----\nint x = 5;       <1>\ndef y = 7.0;     <2>\ndef z = y > 6.5; <3>\ndef a = x > y;   <4>\n----\n+\n<1> declare `int x`;\n    store `int 5` to `x`\n<2> declare `def y`;\n    implicit cast `double 7.0` to `def` -> `def`;\n    store `def` to `y`\n<3> declare `def z`;\n    load from `y` -> `def`;\n    implicit cast `def` to `double 7.0` -> `double 7.0`;\n    greater than `double 7.0` and `double 6.5` -> `boolean true`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `def` to `z`\n<4> declare `def a`;\n    load from `y` -> `def`;\n    implicit cast `def` to `double 7.0` -> `double 7.0`;\n    load from `x` -> `int 5`;\n    promote `int 5` and `double 7.0`: result `double`;\n    implicit cast `int 5` to `double 5.0` -> `double 5.0`;\n    greater than `double 5.0` and `double 7.0` -> `boolean false`;\n    implicit cast `boolean false` to `def` -> `def`;\n    store `def` to `z`\n\n[[greater-than-or-equal-operator]]\n==== Greater Than Or Equal\n\nUse the `greater than or equal operator '>='` to COMPARE two numeric type values\nwhere a resultant `boolean` type value is `true` if the left-hand side value is\ngreater than or equal to the right-hand side value and `false` otherwise.\n\n*Errors*\n\n* If either the evaluated left-hand side or the evaluated right-hand side is a\n  non-numeric value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\ngreater_than_or_equal: expression '>=' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | float  | double | def\n| byte   | int    | int    | int    | int    | long   | float  | double | def\n| short  | int    | int    | int    | int    | long   | float  | double | def\n| char   | int    | int    | int    | int    | long   | float  | double | def\n| int    | int    | int    | int    | int    | long   | float  | double | def\n| long   | long   | long   | long   | long   | long   | float  | double | def\n| float  | float  | float  | float  | float  | float  | float  | double | def\n| double | double | double | double | double | double | double | double | def\n| def    | def    | def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Greater than or equal with different numeric types.\n+\n[source,Painless]\n----\nboolean x = 5 >= 4; <1>\ndouble y = 6.0;     <2>\nx = 6 >= y;         <3>\n----\n+\n<1> declare `boolean x`;\n    greater than or equal `int 5` and `int 4` -> `boolean true`;\n    store `boolean true` to `x`\n<2> declare `double y`;\n    store `double 6.0` to `y`\n<3> load from `y` -> `double 6.0 @0`;\n    promote `int 6` and `double 6.0`: result `double`;\n    implicit cast `int 6` to `double 6.0 @1` -> `double 6.0 @1`;\n    greater than or equal `double 6.0 @1` and `double 6.0 @0` -> `boolean true`;\n    store `boolean true` to `x`\n+\n* Greater than or equal with the `def` type.\n+\n[source,Painless]\n----\nint x = 5;        <1>\ndef y = 7.0;      <2>\ndef z = y >= 7.0; <3>\ndef a = x >= y;   <4>\n----\n+\n<1> declare `int x`;\n    store `int 5` to `x`;\n<2> declare `def y`\n    implicit cast `double 7.0` to `def` -> `def`;\n    store `def` to `y`\n<3> declare `def z`;\n    load from `y` -> `def`;\n    implicit cast `def` to `double 7.0 @0` -> `double 7.0 @0`;\n    greater than or equal `double 7.0 @0` and `double 7.0 @1` -> `boolean true`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `def` to `z`\n<4> declare `def a`;\n    load from `y` -> `def`;\n    implicit cast `def` to `double 7.0` -> `double 7.0`;\n    load from `x` -> `int 5`;\n    promote `int 5` and `double 7.0`: result `double`;\n    implicit cast `int 5` to `double 5.0` -> `double 5.0`;\n    greater than or equal `double 5.0` and `double 7.0` -> `boolean false`;\n    implicit cast `boolean false` to `def` -> `def`;\n    store `def` to `z`\n\n[[less-than-operator]]\n==== Less Than\n\nUse the `less than operator '<'` to COMPARE two numeric type values where a\nresultant `boolean` type value is `true` if the left-hand side value is less\nthan to the right-hand side value and `false` otherwise.\n\n*Errors*\n\n* If either the evaluated left-hand side or the evaluated right-hand side is a\n  non-numeric value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nless_than: expression '<' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | float  | double | def\n| byte   | int    | int    | int    | int    | long   | float  | double | def\n| short  | int    | int    | int    | int    | long   | float  | double | def\n| char   | int    | int    | int    | int    | long   | float  | double | def\n| int    | int    | int    | int    | int    | long   | float  | double | def\n| long   | long   | long   | long   | long   | long   | float  | double | def\n| float  | float  | float  | float  | float  | float  | float  | double | def\n| double | double | double | double | double | double | double | double | def\n| def    | def    | def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Less than with different numeric types.\n+\n[source,Painless]\n----\nboolean x = 5 < 4; <1>\ndouble y = 6.0;    <2>\nx = 6 < y;         <3>\n----\n+\n<1> declare `boolean x`;\n    less than `int 5` and `int 4` -> `boolean false`;\n    store `boolean false` to `x`\n<2> declare `double y`;\n    store `double 6.0` to `y`\n<3> load from `y` -> `double 6.0 @0`;\n    promote `int 6` and `double 6.0`: result `double`;\n    implicit cast `int 6` to `double 6.0 @1` -> `double 6.0 @1`;\n    less than `double 6.0 @1` and `double 6.0 @0` -> `boolean false`;\n    store `boolean false` to `x`\n+\n* Less than with the `def` type.\n+\n[source,Painless]\n----\nint x = 5;       <1>\ndef y = 7.0;     <2>\ndef z = y < 6.5; <3>\ndef a = x < y;   <4>\n----\n+\n<1> declare `int x`;\n    store `int 5` to `x`\n<2> declare `def y`;\n    implicit cast `double 7.0` to `def` -> `def`;\n    store `def` to `y`\n<3> declare `def z`;\n    load from `y` -> `def`;\n    implicit cast `def` to `double 7.0` -> `double 7.0`;\n    less than `double 7.0` and `double 6.5` -> `boolean false`;\n    implicit cast `boolean false` to `def` -> `def`;\n    store `def` to `z`\n<4> declare `def a`;\n    load from `y` -> `def`;\n    implicit cast `def` to `double 7.0` -> `double 7.0`;\n    load from `x` -> `int 5`;\n    promote `int 5` and `double 7.0`: result `double`;\n    implicit cast `int 5` to `double 5.0` -> `double 5.0`;\n    less than `double 5.0` and `double 7.0` -> `boolean true`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `def` to `z`\n\n[[less-than-or-equal-operator]]\n==== Less Than Or Equal\n\nUse the `less than or equal operator '<='` to COMPARE two numeric type values\nwhere a resultant `boolean` type value is `true` if the left-hand side value is\nless than or equal to the right-hand side value and `false` otherwise.\n\n*Errors*\n\n* If either the evaluated left-hand side or the evaluated right-hand side is a\n  non-numeric value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\ngreater_than_or_equal: expression '<=' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|        | byte   | short  | char   | int    | long   | float  | double | def\n| byte   | int    | int    | int    | int    | long   | float  | double | def\n| short  | int    | int    | int    | int    | long   | float  | double | def\n| char   | int    | int    | int    | int    | long   | float  | double | def\n| int    | int    | int    | int    | int    | long   | float  | double | def\n| long   | long   | long   | long   | long   | long   | float  | double | def\n| float  | float  | float  | float  | float  | float  | float  | double | def\n| double | double | double | double | double | double | double | double | def\n| def    | def    | def    | def    | def    | def    | def    | def    | def\n|====\n\n*Examples*\n\n* Less than or equal with different numeric types.\n+\n[source,Painless]\n----\nboolean x = 5 <= 4; <1>\ndouble y = 6.0;     <2>\nx = 6 <= y;         <3>\n----\n+\n<1> declare `boolean x`;\n    less than or equal `int 5` and `int 4` -> `boolean false`;\n    store `boolean true` to `x`\n<2> declare `double y`;\n    store `double 6.0` to `y`\n<3> load from `y` -> `double 6.0 @0`;\n    promote `int 6` and `double 6.0`: result `double`;\n    implicit cast `int 6` to `double 6.0 @1` -> `double 6.0 @1`;\n    less than or equal `double 6.0 @1` and `double 6.0 @0` -> `boolean true`;\n    store `boolean true` to `x`\n+\n* Less than or equal with the `def` type.\n+\n[source,Painless]\n----\nint x = 5;        <1>\ndef y = 7.0;      <2>\ndef z = y <= 7.0; <3>\ndef a = x <= y;   <4>\n----\n+\n<1> declare `int x`;\n    store `int 5` to `x`;\n<2> declare `def y`;\n    implicit cast `double 7.0` to `def` -> `def`;\n    store `def` to `y`;\n<3> declare `def z`;\n    load from `y` -> `def`;\n    implicit cast `def` to `double 7.0 @0` -> `double 7.0 @0`;\n    less than or equal `double 7.0 @0` and `double 7.0 @1` -> `boolean true`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `def` to `z`\n<4> declare `def a`;\n    load from `y` -> `def`;\n    implicit cast `def` to `double 7.0` -> `double 7.0`;\n    load from `x` -> `int 5`;\n    promote `int 5` and `double 7.0`: result `double`;\n    implicit cast `int 5` to `double 5.0` -> `double 5.0`;\n    less than or equal `double 5.0` and `double 7.0` -> `boolean true`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `def` to `z`\n\n[[instanceof-operator]]\n==== Instanceof\n\nUse the `instanceof operator` to COMPARE the variable/field type to a\nspecified reference type using the reference type name where a resultant\n`boolean` type value is `true` if the variable/field type is the same as or a\ndescendant of the specified reference type and false otherwise.\n\n*Errors*\n\n* If the reference type name doesn't exist as specified by the right-hand side.\n\n*Grammar*\n\n[source,ANTLR4]\n----\ninstance_of: ID 'instanceof' TYPE;\n----\n\n*Examples*\n\n* Instance of with different reference types.\n+\n[source,Painless]\n----\nMap m = new HashMap();            <1>\nboolean a = m instanceof HashMap; <2>\nboolean b = m instanceof Map;     <3>\n----\n+\n<1> declare `Map m`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `Map reference`;\n    store `Map reference` to `m`\n<2> declare `boolean a`;\n    load from `m` -> `Map reference`;\n    implicit cast `Map reference` to `HashMap reference` -> `HashMap reference`;\n    instanceof `HashMap reference` and `HashMap` -> `boolean true`;\n    store `boolean true` to `a`\n<3> declare `boolean b`;\n    load from `m` -> `Map reference`;\n    implicit cast `Map reference` to `HashMap reference` -> `HashMap reference`;\n    instanceof `HashMap reference` and `Map` -> `boolean true`;\n    store `true` to `b`;\n    (note `HashMap` is a descendant of `Map`)\n+\n* Instance of with the `def` type.\n+\n[source,Painless]\n----\ndef d = new ArrayList();       <1>\nboolean a = d instanceof List; <2>\nboolean b = d instanceof Map;  <3>\n----\n+\n<1> declare `def d`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `def` -> `def`;\n    store `def` to `d`\n<2> declare `boolean a`;\n    load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    instanceof `ArrayList reference` and `List` -> `boolean true`;\n    store `boolean true` to `a`;\n    (note `ArrayList` is a descendant of `List`)\n<3> declare `boolean b`;\n    load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    instanceof `ArrayList reference` and `Map` -> `boolean false`;\n    store `boolean false` to `a`;\n    (note `ArrayList` is not a descendant of `Map`)\n\n[[equality-equals-operator]]\n==== Equality Equals\n\nUse the `equality equals operator '=='` to COMPARE two values where a resultant\n`boolean` type value is `true` if the two values are equal and `false`\notherwise. The member method, `equals`, is implicitly called when the values are\nreference type values where the first value is the target of the call and the\nsecond value is the argument. This operation is null-safe where if both values\nare `null` the resultant `boolean` type value is `true`, and if only one value\nis `null` the resultant `boolean` type value is `false`. A valid comparison is\nbetween `boolean` type values, numeric type values, or reference type values.\n\n*Errors*\n\n* If a comparison is made between a `boolean` type value and numeric type value.\n* If a comparison is made between a primitive type value and a reference type\n  value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nequality_equals: expression '==' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|           | boolean | byte   | short  | char   | int    | long   | float  | double | Reference | def\n| boolean   | boolean | -      | -      | -      | -      | -      | -      | -      | -         | def\n| byte      | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| short     | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| char      | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| int       | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| long      | -       | long   | long   | long   | long   | long   | float  | double | -         | def\n| float     | -       | float  | float  | float  | float  | float  | float  | double | -         | def\n| double    | -       | double | double | double | double | double | double | double | -         | def\n| Reference | -       | -      | -      | -      | -      | -      | -      | -      | Object    | def\n| def       | def     | def    | def    | def    | def    | def    | def    | def    | def       | def\n|====\n\n*Examples*\n\n* Equality equals with the `boolean` type.\n+\n[source,Painless]\n----\nboolean a = true;  <1>\nboolean b = false; <2>\na = a == false;    <3>\nb = a == b;        <4>\n----\n+\n<1> declare `boolean a`;\n    store `boolean true` to `a`\n<2> declare `boolean b`;\n    store `boolean false` to `b`\n<3> load from `a` -> `boolean true`;\n    equality equals `boolean true` and `boolean false` -> `boolean false`;\n    store `boolean false` to `a`\n<4> load from `a` -> `boolean false @0`;\n    load from `b` -> `boolean false @1`;\n    equality equals `boolean false @0` and `boolean false @1`\n            -> `boolean false`;\n    store `boolean false` to `b`\n+\n* Equality equals with primitive types.\n+\n[source,Painless]\n----\nint a = 1;          <1>\ndouble b = 2.0;     <2>\nboolean c = a == b; <3>\nc = 1 == a;         <4>\n----\n+\n<1> declare `int a`;\n    store `int 1` to `a`\n<2> declare `double b`;\n    store `double 1.0` to `b`\n<3> declare `boolean c`;\n    load from `a` -> `int 1`;\n    load from `b` -> `double 2.0`;\n    promote `int 1` and `double 2.0`: result `double`;\n    implicit cast `int 1` to `double 1.0` -> `double `1.0`;\n    equality equals `double 1.0` and `double 2.0` -> `boolean false`;\n    store `boolean false` to `c`\n<4> load from `a` -> `int 1 @1`;\n    equality equals `int 1 @0` and `int 1 @1` -> `boolean true`;\n    store `boolean true` to `c`\n+\n* Equal equals with reference types.\n+\n[source,Painless]\n----\nList a = new ArrayList(); <1>\nList b = new ArrayList(); <2>\na.add(1);                 <3>\nboolean c = a == b;       <4>\nb.add(1);                 <5>\nc = a == b;               <6>\n----\n+\n<1> declare `List a`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `a`\n<2> declare `List b`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `b`\n<3> load from `a` -> `List reference`;\n    call `add` on `List reference` with arguments (`int 1)`\n<4> declare `boolean c`;\n    load from `a` -> `List reference @0`;\n    load from `b` -> `List reference @1`;\n    call `equals` on `List reference @0` with arguments (`List reference @1`)\n            -> `boolean false`;\n    store `boolean false` to `c`\n<5> load from `b` -> `List reference`;\n    call `add` on `List reference` with arguments (`int 1`)\n<6> load from `a` -> `List reference @0`;\n    load from `b` -> `List reference @1`;\n    call `equals` on `List reference @0` with arguments (`List reference @1`)\n            -> `boolean true`;\n    store `boolean true` to `c`\n+\n* Equality equals with `null`.\n+\n[source,Painless]\n----\nObject a = null;       <1>\nObject b = null;       <2>\nboolean c = a == null; <3>\nc = a == b;            <4>\nb = new Object();      <5>\nc = a == b;            <6>\n----\n+\n<1> declare `Object a`;\n    store `null` to `a`\n<2> declare `Object b`;\n    store `null` to `b`\n<3> declare `boolean c`;\n    load from `a` -> `null @0`;\n    equality equals `null @0` and `null @1` -> `boolean true`;\n    store `boolean true` to `c`\n<4> load from `a` -> `null @0`;\n    load from `b` -> `null @1`;\n    equality equals `null @0` and `null @1` -> `boolean true`;\n    store `boolean true` to `c`\n<5> allocate `Object` instance -> `Object reference`;\n    store `Object reference` to `b`\n<6> load from `a` -> `Object reference`;\n    load from `b` -> `null`;\n    call `equals` on `Object reference` with arguments (`null`)\n            -> `boolean false`;\n    store `boolean false` to `c`\n+\n* Equality equals with the `def` type.\n+\n[source, Painless]\n----\ndef a = 0;               <1>\ndef b = 1;               <2>\nboolean c = a == b;      <3>\ndef d = new HashMap();   <4>\ndef e = new ArrayList(); <5>\nc = d == e;              <6>\n----\n+\n<1> declare `def a`;\n    implicit cast `int 0` to `def` -> `def`;\n    store `def` to `a`;\n<2> declare `def b`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `b`;\n<3> declare `boolean c`;\n    load from `a` -> `def`;\n    implicit cast `a` to `int 0` -> `int 0`;\n    load from `b` -> `def`;\n    implicit cast `b` to `int 1` -> `int 1`;\n    equality equals `int 0` and `int 1` -> `boolean false`;\n    store `boolean false` to `c`\n<4> declare `def d`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `def` -> `def`\n    store `def` to `d`;\n<5> declare `def e`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `def` -> `def`\n    store `def` to `d`;\n<6> load from `d` -> `def`;\n    implicit cast `def` to `HashMap reference` -> `HashMap reference`;\n    load from `e` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `equals` on `HashMap reference` with arguments (`ArrayList reference`)\n            -> `boolean false`;\n    store `boolean false` to `c`\n\n[[equality-not-equals-operator]]\n==== Equality Not Equals\n\nUse the `equality not equals operator '!='` to COMPARE two values where a\nresultant `boolean` type value is `true` if the two values are NOT equal and\n`false` otherwise. The member method, `equals`, is implicitly called when the\nvalues are reference type values where the first value is the target of the call\nand the second value is the argument with the resultant `boolean` type value\nflipped. This operation is `null-safe` where if both values are `null` the\nresultant `boolean` type value is `false`, and if only one value is `null` the\nresultant `boolean` type value is `true`. A valid comparison is between boolean\ntype values, numeric type values, or reference type values.\n\n*Errors*\n\n* If a comparison is made between a `boolean` type value and numeric type value.\n* If a comparison is made between a primitive type value and a reference type\n  value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nequality_not_equals: expression '!=' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|           | boolean | byte   | short  | char   | int    | long   | float  | double | Reference | def\n| boolean   | boolean | -      | -      | -      | -      | -      | -      | -      | -         | def\n| byte      | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| short     | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| char      | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| int       | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| long      | -       | long   | long   | long   | long   | long   | float  | double | -         | def\n| float     | -       | float  | float  | float  | float  | float  | float  | double | -         | def\n| double    | -       | double | double | double | double | double | double | double | -         | def\n| Reference | -       | -      | -      | -      | -      | -      | -      | -      | Object    | def\n| def       | def     | def    | def    | def    | def    | def    | def    | def    | def       | def\n|====\n\n*Examples*\n\n* Equality not equals with the `boolean` type.\n+\n[source,Painless]\n----\nboolean a = true;  <1>\nboolean b = false; <2>\na = a != false;    <3>\nb = a != b;        <4>\n----\n+\n<1> declare `boolean a`;\n    store `boolean true` to `a`\n<2> declare `boolean b`;\n    store `boolean false` to `b`\n<3> load from `a` -> `boolean true`;\n    equality not equals `boolean true` and `boolean false` -> `boolean true`;\n    store `boolean true` to `a`\n<4> load from `a` -> `boolean true`;\n    load from `b` -> `boolean false`;\n    equality not equals `boolean true` and `boolean false` -> `boolean true`;\n    store `boolean true` to `b`\n+\n* Equality not equals with primitive types.\n+\n[source,Painless]\n----\nint a = 1;          <1>\ndouble b = 2.0;     <2>\nboolean c = a != b; <3>\nc = 1 != a;         <4>\n----\n+\n<1> declare `int a`;\n    store `int 1` to `a`\n<2> declare `double b`;\n    store `double 1.0` to `b`\n<3> declare `boolean c`;\n    load from `a` -> `int 1`;\n    load from `b` -> `double 2.0`;\n    promote `int 1` and `double 2.0`: result `double`;\n    implicit cast `int 1` to `double 1.0` -> `double `1.0`;\n    equality not equals `double 1.0` and `double 2.0` -> `boolean true`;\n    store `boolean true` to `c`\n<4> load from `a` -> `int 1 @1`;\n    equality not equals `int 1 @0` and `int 1 @1` -> `boolean false`;\n    store `boolean false` to `c`\n+\n* Equality not equals with reference types.\n+\n[source,Painless]\n----\nList a = new ArrayList(); <1>\nList b = new ArrayList(); <2>\na.add(1);                 <3>\nboolean c = a == b;       <4>\nb.add(1);                 <5>\nc = a == b;               <6>\n----\n+\n<1> declare `List a`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `a`\n<2> declare `List b`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `b`\n<3> load from `a` -> `List reference`;\n    call `add` on `List reference` with arguments (`int 1)`\n<4> declare `boolean c`;\n    load from `a` -> `List reference @0`;\n    load from `b` -> `List reference @1`;\n    call `equals` on `List reference @0` with arguments (`List reference @1`)\n            -> `boolean false`;\n    boolean not `boolean false` -> `boolean true`\n    store `boolean true` to `c`\n<5> load from `b` -> `List reference`;\n    call `add` on `List reference` with arguments (`int 1`)\n<6> load from `a` -> `List reference @0`;\n    load from `b` -> `List reference @1`;\n    call `equals` on `List reference @0` with arguments (`List reference @1`)\n            -> `boolean true`;\n    boolean not `boolean true` -> `boolean false`;\n    store `boolean false` to `c`\n+\n* Equality not equals with `null`.\n+\n[source,Painless]\n----\nObject a = null;       <1>\nObject b = null;       <2>\nboolean c = a == null; <3>\nc = a == b;            <4>\nb = new Object();      <5>\nc = a == b;            <6>\n----\n+\n<1> declare `Object a`;\n    store `null` to `a`\n<2> declare `Object b`;\n    store `null` to `b`\n<3> declare `boolean c`;\n    load from `a` -> `null @0`;\n    equality not equals `null @0` and `null @1` -> `boolean false`;\n    store `boolean false` to `c`\n<4> load from `a` -> `null @0`;\n    load from `b` -> `null @1`;\n    equality not equals `null @0` and `null @1` -> `boolean false`;\n    store `boolean false` to `c`\n<5> allocate `Object` instance -> `Object reference`;\n    store `Object reference` to `b`\n<6> load from `a` -> `Object reference`;\n    load from `b` -> `null`;\n    call `equals` on `Object reference` with arguments (`null`)\n            -> `boolean false`;\n    boolean not `boolean false` -> `boolean true`;\n    store `boolean true` to `c`\n+\n* Equality not equals with the `def` type.\n+\n[source, Painless]\n----\ndef a = 0;               <1>\ndef b = 1;               <2>\nboolean c = a == b;      <3>\ndef d = new HashMap();   <4>\ndef e = new ArrayList(); <5>\nc = d == e;              <6>\n----\n+\n<1> declare `def a`;\n    implicit cast `int 0` to `def` -> `def`;\n    store `def` to `a`;\n<2> declare `def b`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `b`;\n<3> declare `boolean c`;\n    load from `a` -> `def`;\n    implicit cast `a` to `int 0` -> `int 0`;\n    load from `b` -> `def`;\n    implicit cast `b` to `int 1` -> `int 1`;\n    equality equals `int 0` and `int 1` -> `boolean false`;\n    store `boolean false` to `c`\n<4> declare `def d`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `def` -> `def`\n    store `def` to `d`;\n<5> declare `def e`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `def` -> `def`\n    store `def` to `d`;\n<6> load from `d` -> `def`;\n    implicit cast `def` to `HashMap reference` -> `HashMap reference`;\n    load from `e` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `equals` on `HashMap reference` with arguments (`ArrayList reference`)\n            -> `boolean false`;\n    store `boolean false` to `c`\n\n[[identity-equals-operator]]\n==== Identity Equals\n\nUse the `identity equals operator '==='` to COMPARE two values where a resultant\n`boolean` type value is `true` if the two values are equal and `false`\notherwise. A reference type value is equal to another reference type value if\nboth values refer to same instance on the heap or if both values are `null`. A\nvalid comparison is between `boolean` type values, numeric type values, or\nreference type values.\n\n*Errors*\n\n* If a comparison is made between a `boolean` type value and numeric type value.\n* If a comparison is made between a primitive type value and a reference type\n  value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nidentity_equals: expression '===' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|           | boolean | byte   | short  | char   | int    | long   | float  | double | Reference | def\n| boolean   | boolean | -      | -      | -      | -      | -      | -      | -      | -         | def\n| byte      | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| short     | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| char      | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| int       | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| long      | -       | long   | long   | long   | long   | long   | float  | double | -         | def\n| float     | -       | float  | float  | float  | float  | float  | float  | double | -         | def\n| double    | -       | double | double | double | double | double | double | double | -         | def\n| Reference | -       | -      | -      | -      | -      | -      | -      | -      | Object    | def\n| def       | def     | def    | def    | def    | def    | def    | def    | def    | def       | def\n|====\n\n*Examples*\n\n* Identity equals with reference types.\n+\n[source,Painless]\n----\nList a = new ArrayList(); <1>\nList b = new ArrayList(); <2>\nList c = a;               <3>\nboolean c = a === b;      <4>\nc = a === c;              <5>\n----\n+\n<1> declare `List a`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `a`\n<2> declare `List b`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `b`\n<3> load from `a` -> `List reference`;\n    store `List reference` to `c`\n<4> declare `boolean c`;\n    load from `a` -> `List reference @0`;\n    load from `b` -> `List reference @1`;\n    identity equals `List reference @0` and `List reference @1`\n            -> `boolean false`\n    store `boolean false` to `c`\n<5> load from `a` -> `List reference @0`;\n    load from `c` -> `List reference @1`;\n    identity equals `List reference @0` and `List reference @1`\n            -> `boolean true`\n    store `boolean true` to `c`\n    (note `List reference @0` and `List reference @1` refer to the same\n            instance)\n+\n* Identity equals with `null`.\n+\n[source,Painless]\n----\nObject a = null;        <1>\nObject b = null;        <2>\nboolean c = a === null; <3>\nc = a === b;            <4>\nb = new Object();       <5>\nc = a === b;            <6>\n----\n+\n<1> declare `Object a`;\n    store `null` to `a`\n<2> declare `Object b`;\n    store `null` to `b`\n<3> declare `boolean c`;\n    load from `a` -> `null @0`;\n    identity equals `null @0` and `null @1` -> `boolean true`;\n    store `boolean true` to `c`\n<4> load from `a` -> `null @0`;\n    load from `b` -> `null @1`;\n    identity equals `null @0` and `null @1` -> `boolean true`;\n    store `boolean true` to `c`\n<5> allocate `Object` instance -> `Object reference`;\n    store `Object reference` to `b`\n<6> load from `a` -> `Object reference`;\n    load from `b` -> `null`;\n    identity equals `Object reference` and `null` -> `boolean false`;\n    store `boolean false` to `c`\n+\n* Identity equals with the `def` type.\n+\n[source, Painless]\n----\ndef a = new HashMap();   <1>\ndef b = new ArrayList(); <2>\nboolean c = a === b;     <3>\nb = a;                   <4>\nc = a === b;             <5>\n----\n+\n<1> declare `def d`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `def` -> `def`\n    store `def` to `d`\n<2> declare `def e`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `def` -> `def`\n    store `def` to `d`\n<3> declare `boolean c`;\n    load from `a` -> `def`;\n    implicit cast `def` to `HashMap reference` -> `HashMap reference`;\n    load from `b` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    identity equals `HashMap reference` and `ArrayList reference`\n            -> `boolean false`;\n    store `boolean false` to `c`\n<4> load from `a` -> `def`;\n    store `def` to `b`\n<5> load from `a` -> `def`;\n    implicit cast `def` to `HashMap reference @0` -> `HashMap reference @0`;\n    load from `b` -> `def`;\n    implicit cast `def` to `HashMap reference @1` -> `HashMap reference @1`;\n    identity equals `HashMap reference @0` and `HashMap reference @1`\n            -> `boolean true`;\n    store `boolean true` to `b`;\n    (note `HashMap reference @0` and `HashMap reference @1` refer to the same\n            instance)\n\n[[identity-not-equals-operator]]\n==== Identity Not Equals\n\nUse the `identity not equals operator '!=='` to COMPARE two values where a\nresultant `boolean` type value is `true` if the two values are NOT equal and\n`false` otherwise. A reference type value is not equal to another reference type\nvalue if both values refer to different instances on the heap or if one value is\n`null` and the other is not. A valid comparison is between `boolean` type\nvalues, numeric type values, or reference type values.\n\n*Errors*\n\n* If a comparison is made between a `boolean` type value and numeric type value.\n* If a comparison is made between a primitive type value and a reference type\n  value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nidentity_not_equals: expression '!==' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|           | boolean | byte   | short  | char   | int    | long   | float  | double | Reference | def\n| boolean   | boolean | -      | -      | -      | -      | -      | -      | -      | -         | def\n| byte      | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| short     | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| char      | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| int       | -       | int    | int    | int    | int    | long   | float  | double | -         | def\n| long      | -       | long   | long   | long   | long   | long   | float  | double | -         | def\n| float     | -       | float  | float  | float  | float  | float  | float  | double | -         | def\n| double    | -       | double | double | double | double | double | double | double | -         | def\n| Reference | -       | -      | -      | -      | -      | -      | -      | -      | Object    | def\n| def       | def     | def    | def    | def    | def    | def    | def    | def    | def       | def\n|====\n\n*Examples*\n\n* Identity not equals with reference type values.\n+\n[source,Painless]\n----\nList a = new ArrayList(); <1>\nList b = new ArrayList(); <2>\nList c = a;               <3>\nboolean c = a !== b;      <4>\nc = a !== c;              <5>\n----\n+\n<1> declare `List a`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `a`\n<2> declare `List b`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `b`\n<3> load from `a` -> `List reference`;\n    store `List reference` to `c`\n<4> declare `boolean c`;\n    load from `a` -> `List reference @0`;\n    load from `b` -> `List reference @1`;\n    identity not equals `List reference @0` and `List reference @1`\n            -> `boolean true`\n    store `boolean true` to `c`\n<5> load from `a` -> `List reference @0`;\n    load from `c` -> `List reference @1`;\n    identity not equals `List reference @0` and `List reference @1`\n            -> `boolean false`\n    store `boolean false` to `c`\n    (note `List reference @0` and `List reference @1` refer to the same\n            instance)\n+\n* Identity not equals with `null`.\n+\n[source,Painless]\n----\nObject a = null;        <1>\nObject b = null;        <2>\nboolean c = a !== null; <3>\nc = a !== b;            <4>\nb = new Object();       <5>\nc = a !== b;            <6>\n----\n+\n<1> declare `Object a`;\n    store `null` to `a`\n<2> declare `Object b`;\n    store `null` to `b`\n<3> declare `boolean c`;\n    load from `a` -> `null @0`;\n    identity not equals `null @0` and `null @1` -> `boolean false`;\n    store `boolean false` to `c`\n<4> load from `a` -> `null @0`;\n    load from `b` -> `null @1`;\n    identity not equals `null @0` and `null @1` -> `boolean false`;\n    store `boolean false` to `c`\n<5> allocate `Object` instance -> `Object reference`;\n    store `Object reference` to `b`\n<6> load from `a` -> `Object reference`;\n    load from `b` -> `null`;\n    identity not equals `Object reference` and `null` -> `boolean true`;\n    store `boolean true` to `c`\n+\n* Identity not equals with the `def` type.\n+\n[source, Painless]\n----\ndef a = new HashMap();   <1>\ndef b = new ArrayList(); <2>\nboolean c = a !== b;     <3>\nb = a;                   <4>\nc = a !== b;             <5>\n----\n+\n<1> declare `def d`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `def` -> `def`\n    store `def` to `d`\n<2> declare `def e`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `def` -> `def`\n    store `def` to `d`\n<3> declare `boolean c`;\n    load from `a` -> `def`;\n    implicit cast `def` to `HashMap reference` -> `HashMap reference`;\n    load from `b` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    identity not equals `HashMap reference` and `ArrayList reference`\n            -> `boolean true`;\n    store `boolean true` to `c`\n<4> load from `a` -> `def`;\n    store `def` to `b`\n<5> load from `a` -> `def`;\n    implicit cast `def` to `HashMap reference @0` -> `HashMap reference @0`;\n    load from `b` -> `def`;\n    implicit cast `def` to `HashMap reference @1` -> `HashMap reference @1`;\n    identity not equals `HashMap reference @0` and `HashMap reference @1`\n            -> `boolean false`;\n    store `boolean false` to `b`;\n    (note `HashMap reference @0` and `HashMap reference @1` refer to the same\n            instance)\n\n[[boolean-xor-operator]]\n==== Boolean Xor\n\nUse the `boolean xor operator '^'` to XOR together two `boolean` type values\nwhere if one `boolean` type value is `true` and the other is `false` the\nresultant `boolean` type value is `true` and `false` otherwise.\n\n*Errors*\n\n* If either evaluated value is a value other than a `boolean` type value or\n  a value that is castable to a `boolean` type value.\n\n*Truth*\n\n[cols=\"^1,^1,^1\"]\n|====\n|       | true  | false\n| true  | false | true\n| false | true  | false\n|====\n\n*Grammar*\n\n[source,ANTLR4]\n----\nboolean_xor: expression '^' expression;\n----\n\n*Examples*\n\n* Boolean xor with the `boolean` type.\n+\n[source,Painless]\n----\nboolean x = false;    <1>\nboolean y = x ^ true; <2>\ny = y ^ x;            <3>\n----\n+\n<1> declare `boolean x`;\n    store `boolean false` to `x`\n<2> declare `boolean y`;\n    load from `x` -> `boolean false`\n    boolean xor `boolean false` and `boolean true` -> `boolean true`;\n    store `boolean true` to `y`\n<3> load from `y` -> `boolean true @0`;\n    load from `x` -> `boolean true @1`;\n    boolean xor `boolean true @0` and `boolean true @1` -> `boolean false`;\n    store `boolean false` to `y`\n+\n* Boolean xor with the `def` type.\n+\n[source,Painless]\n----\ndef x = false;    <1>\ndef y = x ^ true; <2>\ny = y ^ x;        <3>\n----\n+\n<1> declare `def x`;\n    implicit cast `boolean false` to `def` -> `def`;\n    store `def` to `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `boolean false` -> `boolean false`;\n    boolean xor `boolean false` and `boolean true` -> `boolean true`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `def` to `y`\n<3> load from `y` -> `def`;\n    implicit cast `def` to `boolean true @0` -> `boolean true @0`;\n    load from `x` -> `def`;\n    implicit cast `def` to `boolean true @1` -> `boolean true @1`;\n    boolean xor `boolean true @0` and `boolean true @1` -> `boolean false`;\n    implicit cast `boolean false` -> `def`;\n    store `def` to `y`\n\n[[boolean-and-operator]]\n==== Boolean And\n\nUse the `boolean and operator '&&'` to AND together two `boolean` type values\nwhere if both `boolean` type values are `true` the resultant `boolean` type\nvalue is `true` and `false` otherwise.\n\n*Errors*\n\n* If either evaluated value is a value other than a `boolean` type value or\n  a value that is castable to a `boolean` type value.\n\n*Truth*\n\n[cols=\"^1,^1,^1\"]\n|====\n|       | true  | false\n| true  | true  | false\n| false | false | false\n|====\n\n*Grammar*\n\n[source,ANTLR4]\n----\nboolean_and: expression '&&' expression;\n----\n\n*Examples*\n\n* Boolean and with the `boolean` type.\n+\n[source,Painless]\n----\nboolean x = true;      <1>\nboolean y = x && true; <2>\nx = false;             <3>\ny = y && x;            <4>\n----\n+\n<1> declare `boolean x`;\n    store `boolean true` to `x`\n<2> declare `boolean y`;\n    load from `x` -> `boolean true @0`;\n    boolean and `boolean true @0` and `boolean true @1` -> `boolean true`;\n    store `boolean true` to `y`\n<3> store `boolean false` to `x`\n<4> load from `y` -> `boolean true`;\n    load from `x` -> `boolean false`;\n    boolean and `boolean true` and `boolean false` -> `boolean false`;\n    store `boolean false` to `y`\n+\n* Boolean and with the `def` type.\n+\n[source,Painless]\n----\ndef x = true;      <1>\ndef y = x && true; <2>\nx = false;         <3>\ny = y && x;        <4>\n----\n+\n<1> declare `def x`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `def` to `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `boolean true @0` -> `boolean true @0`;\n    boolean and `boolean true @0` and `boolean true @1` -> `boolean true`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `def` to `y`\n<3> implicit cast `boolean false` to `def` -> `def`;\n    store `def` to `x`;\n<4> load from `y` -> `def`;\n    implicit cast `def` to `boolean true` -> `boolean true`;\n    load from `x` -> `def`;\n    implicit cast `def` to `boolean false` -> `boolean false`;\n    boolean and `boolean true` and `boolean false` -> `boolean false`;\n    implicit cast `boolean false` -> `def`;\n    store `def` to `y`\n\n[[boolean-or-operator]]\n==== Boolean Or\n\nUse the `boolean or operator '||'` to OR together two `boolean` type values\nwhere if either one of the `boolean` type values is `true` the resultant\n`boolean` type value is `true` and `false` otherwise.\n\n*Errors*\n\n* If either evaluated value is a value other than a `boolean` type value or\n  a value that is castable to a `boolean` type value.\n\n*Truth*\n\n[cols=\"^1,^1,^1\"]\n|====\n|       | true | false\n| true  | true | true\n| false | true | false\n|====\n\n*Grammar:*\n[source,ANTLR4]\n----\nboolean_and: expression '||' expression;\n----\n\n*Examples*\n\n* Boolean or with the `boolean` type.\n+\n[source,Painless]\n----\nboolean x = false;     <1>\nboolean y = x || true; <2>\ny = false;             <3>\ny = y || x;            <4>\n----\n+\n<1> declare `boolean x`;\n    store `boolean false` to `x`\n<2> declare `boolean y`;\n    load from `x` -> `boolean false`;\n    boolean or `boolean false` and `boolean true` -> `boolean true`;\n    store `boolean true` to `y`\n<3> store `boolean false` to `y`\n<4> load from `y` -> `boolean false @0`;\n    load from `x` -> `boolean false @1`;\n    boolean or `boolean false @0` and `boolean false @1` -> `boolean false`;\n    store `boolean false` to `y`\n+\n* Boolean or with the `def` type.\n+\n[source,Painless]\n----\ndef x = false;     <1>\ndef y = x || true; <2>\ny = false;         <3>\ny = y || x;        <4>\n----\n+\n<1> declare `def x`;\n    implicit cast `boolean false` to `def` -> `def`;\n    store `def` to `x`\n<2> declare `def y`;\n    load from `x` -> `def`;\n    implicit cast `def` to `boolean false` -> `boolean true`;\n    boolean or `boolean false` and `boolean true` -> `boolean true`;\n    implicit cast `boolean true` to `def` -> `def`;\n    store `def` to `y`\n<3> implicit cast `boolean false` to `def` -> `def`;\n    store `def` to `y`;\n<4> load from `y` -> `def`;\n    implicit cast `def` to `boolean false @0` -> `boolean false @0`;\n    load from `x` -> `def`;\n    implicit cast `def` to `boolean false @1` -> `boolean false @1`;\n    boolean or `boolean false @0` and `boolean false @1` -> `boolean false`;\n    implicit cast `boolean false` -> `def`;\n    store `def` to `y`\n"
}