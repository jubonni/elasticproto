{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.769068",
        "size": 25612,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "docs-update-by-query",
        "version": "8.15"
    },
    "doc": "[[docs-update-by-query]]\n=== Update By Query API\n++++\n<titleabbrev>Update by query</titleabbrev>\n++++\n\nUpdates documents that match the specified query.\nIf no query is specified, performs an update on every document in the data stream or index without\nmodifying the source, which is useful for picking up mapping changes.\n\n[source,console]\n--------------------------------------------------\nPOST my-index-000001/_update_by_query?conflicts=proceed\n--------------------------------------------------\n// TEST[setup:my_index_big]\n\n////\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\" : 147,\n  \"timed_out\": false,\n  \"updated\": 120,\n  \"deleted\": 0,\n  \"batches\": 1,\n  \"version_conflicts\": 0,\n  \"noops\": 0,\n  \"retries\": {\n    \"bulk\": 0,\n    \"search\": 0\n  },\n  \"throttled_millis\": 0,\n  \"requests_per_second\": -1.0,\n  \"throttled_until_millis\": 0,\n  \"total\": 120,\n  \"failures\" : [ ]\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\" : 147/\"took\" : \"$body.took\"/]\n\n////\n\n[[docs-update-by-query-api-request]]\n==== {api-request-title}\n\n`POST /<target>/_update_by_query`\n\n[[docs-update-by-query-api-prereqs]]\n==== {api-prereq-title}\n\n* If the {es} {security-features} are enabled, you must have the following\n<<privileges-list-indices,index privileges>> for the target data stream, index,\nor alias:\n\n** `read`\n** `index` or `write`\n\n[[docs-update-by-query-api-desc]]\n==== {api-description-title}\n\nYou can specify the query criteria in the request URI or the request body\nusing the same syntax as the  <<search-search,Search API>>.\n\nWhen you submit an update by query request, {es} gets a snapshot of the data stream or index\nwhen it begins processing the request and updates matching documents using\n`internal` versioning.\nWhen the versions match, the document is updated and the version number is incremented.\nIf a document changes between the time that the snapshot is taken and\nthe update operation is processed, it results in a version conflict and the operation fails.\nYou can opt to count version conflicts instead of halting and returning by\nsetting `conflicts` to `proceed`. Note that if you opt to count\nversion conflicts the operation could attempt to update more documents from the source than\n`max_docs` until it has successfully updated `max_docs` documents, or it has gone through every document\nin the source query.\n\nNOTE: Documents with a version equal to 0 cannot be updated using update by\nquery because `internal` versioning does not support 0 as a valid\nversion number.\n\nWhile processing an update by query request, {es} performs multiple search\nrequests sequentially to find all of the matching documents.\nA bulk update request is performed for each batch of matching documents.\nAny query or update failures cause the update by query request to fail and\nthe failures are shown in the response.\nAny update requests that completed successfully still stick, they are not rolled back.\n\n===== Refreshing shards\n\nSpecifying the `refresh` parameter refreshes all shards once the request completes.\nThis is different than the update API's `refresh` parameter, which causes just the shard\nthat received the request to be refreshed. Unlike the update API, it does not support\n`wait_for`.\n\n[[docs-update-by-query-task-api]]\n===== Running update by query asynchronously\n\nIf the request contains `wait_for_completion=false`, {es}\nperforms some preflight checks, launches the request, and returns a\n<<tasks,`task`>> you can use to cancel or get the status of the task.\n{es} creates a record of this task as a document at `.tasks/task/${taskId}`.\n\n===== Waiting for active shards\n\n`wait_for_active_shards` controls how many copies of a shard must be active\nbefore proceeding with the request. See <<index-wait-for-active-shards>>\nfor details. `timeout` controls how long each write request waits for unavailable\nshards to become available. Both work exactly the way they work in the\n<<docs-bulk,Bulk API>>. Update by query uses scrolled searches, so you can also\nspecify the `scroll` parameter to control how long it keeps the search context\nalive, for example `?scroll=10m`. The default is 5 minutes.\n\n===== Throttling update requests\n\nTo control the rate at which update by query issues batches of update operations,\nyou can set `requests_per_second` to any positive decimal number. This pads each\nbatch with a wait time to throttle the rate. Set `requests_per_second` to `-1`\nto disable throttling.\n\nThrottling uses a wait time between batches so that the internal scroll requests\ncan be given a timeout that takes the request padding into account. The padding\ntime is the difference between the batch size divided by the\n`requests_per_second` and the time spent writing. By default the batch size is\n`1000`, so if `requests_per_second` is set to `500`:\n\n[source,txt]\n--------------------------------------------------\ntarget_time = 1000 / 500 per second = 2 seconds\nwait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds\n--------------------------------------------------\n\nSince the batch is issued as a single `_bulk` request, large batch sizes\ncause {es} to create many requests and wait before starting the next set.\nThis is \"bursty\" instead of \"smooth\".\n\n[[docs-update-by-query-slice]]\n===== Slicing\n\nUpdate by query supports <<slice-scroll, sliced scroll>> to parallelize the\nupdate process. This can improve efficiency and provide a\nconvenient way to break the request down into smaller parts.\n\nSetting `slices` to `auto` chooses a reasonable number for most data streams and indices.\nIf you're slicing manually or otherwise tuning automatic slicing, keep in mind\nthat:\n\n* Query performance is most efficient when the number of `slices` is equal to\nthe number of shards in the index or backing index. If that number is large (for example,\n500), choose a lower number as too many `slices` hurts performance. Setting\n`slices` higher than the number of shards generally does not improve efficiency\nand adds overhead.\n\n* Update performance scales linearly across available resources with the\nnumber of slices.\n\nWhether query or update performance dominates the runtime depends on the\ndocuments being reindexed and cluster resources.\n\n[[docs-update-by-query-api-path-params]]\n==== {api-path-parms-title}\n\n`<target>`::\n(Optional, string) Comma-separated list of data streams, indices, and aliases to\nsearch. Supports wildcards (`*`). To search all data streams or indices, omit\nthis parameter or use `*` or `_all`.\n\n[[docs-update-by-query-api-query-params]]\n==== {api-query-parms-title}\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=allow-no-indices]\n+\nDefaults to `true`.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=analyzer]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=analyze_wildcard]\n\n`conflicts`::\n  (Optional, string) What to do if update by query hits version conflicts:\n  `abort` or `proceed`. Defaults to `abort`.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=default_operator]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=df]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=expand-wildcards]\n+\nDefaults to `open`.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=index-ignore-unavailable]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=lenient]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=max_docs]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=pipeline]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=preference]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=search-q]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=request_cache]\n\n`refresh`::\n(Optional, Boolean)\nIf `true`, {es} refreshes affected shards to make the operation visible to\nsearch. Defaults to `false`.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=requests_per_second]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=routing]\n\n`scroll`::\n(Optional, <<time-units,time value>>)\nPeriod to retain the <<scroll-search-context,search context>> for scrolling. See\n<<scroll-search-results>>.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=scroll_size]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=search_type]\n\n`search_timeout`::\n(Optional, <<time-units, time units>>)\nExplicit timeout for each search request.\nDefaults to no timeout.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=slices]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=sort]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=stats]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=terminate_after]\n\n`timeout`::\n+\n--\n(Optional, <<time-units, time units>>)\nPeriod each update request waits for the following operations:\n\n* Dynamic mapping updates\n* <<index-wait-for-active-shards,Waiting for active shards>>\n\nDefaults to `1m` (one minute). This guarantees {es} waits for at least the\ntimeout before failing. The actual wait time could be longer, particularly when\nmultiple waits occur.\n--\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=version]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=wait_for_active_shards]\n\n[[docs-update-by-query-api-request-body]]\n==== {api-request-body-title}\n\n`query`::\n  (Optional, <<query-dsl,query object>>) Specifies the documents to update\n  using the  <<query-dsl,Query DSL>>.\n\n\n[[docs-update-by-query-api-response-body]]\n==== Response body\n\n`took`::\nThe number of milliseconds from start to end of the whole operation.\n\n`timed_out`::\nThis flag is set to `true` if any of the requests executed during the\nupdate by query execution has timed out.\n\n`total`::\nThe number of documents that were successfully processed.\n\n`updated`::\nThe number of documents that were successfully updated.\n\n`deleted`::\nThe number of documents that were successfully deleted.\n\n`batches`::\nThe number of scroll responses pulled back by the update by query.\n\n`version_conflicts`::\nThe number of version conflicts that the update by query hit.\n\n`noops`::\nThe number of documents that were ignored because the script used for\nthe update by query returned a `noop` value for `ctx.op`.\n\n`retries`::\nThe number of retries attempted by update by query. `bulk` is the number of bulk\nactions retried, and `search` is the number of search actions retried.\n\n`throttled_millis`::\nNumber of milliseconds the request slept to conform to `requests_per_second`.\n\n`requests_per_second`::\nThe number of requests per second effectively executed during the update by query.\n\n`throttled_until_millis`::\nThis field should always be equal to zero in an `_update_by_query` response. It only\nhas meaning when using the <<docs-update-by-query-task-api, Task API>>, where it\nindicates the next time (in milliseconds since epoch) a throttled request will be\nexecuted again in order to conform to `requests_per_second`.\n\n`failures`::\nArray of failures if there were any unrecoverable errors during the process. If\nthis is non-empty then the request aborted because of those failures.\nUpdate by query is implemented using batches. Any failure causes the entire\nprocess to abort, but all failures in the current batch are collected into the\narray. You can use the `conflicts` option to prevent reindex from aborting on\nversion conflicts.\n\n[[docs-update-by-query-api-example]]\n==== {api-examples-title}\n\nThe simplest usage of `_update_by_query` just performs an update on every\ndocument in the data stream or index without changing the source. This is useful to\n<<picking-up-a-new-property,pick up a new property>> or some other online\nmapping change.\n\nTo update selected documents, specify a query in the request body:\n\n[source,console]\n--------------------------------------------------\nPOST my-index-000001/_update_by_query?conflicts=proceed\n{\n  \"query\": { <1>\n    \"term\": {\n      \"user.id\": \"kimchy\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n<1> The query must be passed as a value to the `query` key, in the same\nway as the <<search-search,Search API>>. You can also use the `q`\nparameter in the same way as the search API.\n\nUpdate documents in multiple data streams or indices:\n\n[source,console]\n--------------------------------------------------\nPOST my-index-000001,my-index-000002/_update_by_query\n--------------------------------------------------\n// TEST[s/^/PUT my-index-000001\\nPUT my-index-000002\\n/]\n\nLimit the update by query operation to shards that a particular routing value:\n\n[source,console]\n--------------------------------------------------\nPOST my-index-000001/_update_by_query?routing=1\n--------------------------------------------------\n// TEST[setup:my_index]\n\nBy default update by query uses scroll batches of 1000.\nYou can change the batch size with the `scroll_size` parameter:\n\n[source,console]\n--------------------------------------------------\nPOST my-index-000001/_update_by_query?scroll_size=100\n--------------------------------------------------\n// TEST[setup:my_index]\n\nUpdate a document using a unique attribute:\n\n[source,console]\n--------------------------------------------------\nPOST my-index-000001/_update_by_query\n{\n  \"query\": {\n    \"term\": {\n      \"user.id\": \"kimchy\"\n    }\n  },\n  \"max_docs\": 1\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[[docs-update-by-query-api-source]]\n===== Update the document source\n\nUpdate by query supports scripts to update the document source.\nFor example, the following request increments the `count` field for all\ndocuments with a `user.id` of `kimchy` in `my-index-000001`:\n\n////\n[source,console]\n----\nPUT my-index-000001/_create/1\n{\n  \"user\": {\n    \"id\": \"kimchy\"\n  },\n  \"count\": 1\n}\n----\n////\n\n[source,console]\n--------------------------------------------------\nPOST my-index-000001/_update_by_query\n{\n  \"script\": {\n    \"source\": \"ctx._source.count++\",\n    \"lang\": \"painless\"\n  },\n  \"query\": {\n    \"term\": {\n      \"user.id\": \"kimchy\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nNote that `conflicts=proceed` is not specified in this example. In this case, a\nversion conflict should halt the process so you can handle the failure.\n\nAs with the <<docs-update,Update API>>, you can set `ctx.op` to change the\noperation that is performed:\n\n[horizontal]\n`noop`::\nSet `ctx.op = \"noop\"` if your script decides that it doesn't have to make any changes.\nThe update by query operation skips updating the document and increments the  `noop` counter.\n\n`delete`::\nSet `ctx.op = \"delete\"` if your script decides that the document should be deleted.\nThe update by query operation deletes the document and increments the  `deleted` counter.\n\nUpdate by query only supports `index`, `noop`, and `delete`.\nSetting `ctx.op` to anything else is an error. Setting any other field in `ctx` is an error.\nThis API only enables you to modify the source of matching documents, you cannot move them.\n\n[[docs-update-by-query-api-ingest-pipeline]]\n===== Update documents using an ingest pipeline\n\nUpdate by query can use the <<ingest>> feature by specifying a `pipeline`:\n\n[source,console]\n--------------------------------------------------\nPUT _ingest/pipeline/set-foo\n{\n  \"description\" : \"sets foo\",\n  \"processors\" : [ {\n      \"set\" : {\n        \"field\": \"foo\",\n        \"value\": \"bar\"\n      }\n  } ]\n}\nPOST my-index-000001/_update_by_query?pipeline=set-foo\n--------------------------------------------------\n// TEST[setup:my_index]\n\n\n[discrete]\n[[docs-update-by-query-fetch-tasks]]\n===== Get the status of update by query operations\n\nYou can fetch the status of all running update by query requests with the\n<<tasks,Task API>>:\n\n[source,console]\n--------------------------------------------------\nGET _tasks?detailed=true&actions=*byquery\n--------------------------------------------------\n// TEST[skip:No tasks to retrieve]\n\nThe responses looks like:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"nodes\" : {\n    \"r1A2WoRbTwKZ516z6NEs5A\" : {\n      \"name\" : \"r1A2WoR\",\n      \"transport_address\" : \"127.0.0.1:9300\",\n      \"host\" : \"127.0.0.1\",\n      \"ip\" : \"127.0.0.1:9300\",\n      \"attributes\" : {\n        \"testattr\" : \"test\",\n        \"portsfile\" : \"true\"\n      },\n      \"tasks\" : {\n        \"r1A2WoRbTwKZ516z6NEs5A:36619\" : {\n          \"node\" : \"r1A2WoRbTwKZ516z6NEs5A\",\n          \"id\" : 36619,\n          \"type\" : \"transport\",\n          \"action\" : \"indices:data/write/update/byquery\",\n          \"status\" : {    <1>\n            \"total\" : 6154,\n            \"updated\" : 3500,\n            \"created\" : 0,\n            \"deleted\" : 0,\n            \"batches\" : 4,\n            \"version_conflicts\" : 0,\n            \"noops\" : 0,\n            \"retries\": {\n              \"bulk\": 0,\n              \"search\": 0\n            },\n            \"throttled_millis\": 0\n          },\n          \"description\" : \"\"\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> This object contains the actual status. It is just like the response JSON\nwith the important addition of the `total` field. `total` is the total number\nof operations that the reindex expects to perform. You can estimate the\nprogress by adding the `updated`, `created`, and `deleted` fields. The request\nwill finish when their sum is equal to the `total` field.\n\nWith the task id you can look up the task directly. The following example\nretrieves information about task `r1A2WoRbTwKZ516z6NEs5A:36619`:\n\n[source,console]\n--------------------------------------------------\nGET /_tasks/r1A2WoRbTwKZ516z6NEs5A:36619\n--------------------------------------------------\n// TEST[catch:missing]\n\nThe advantage of this API is that it integrates with `wait_for_completion=false`\nto transparently return the status of completed tasks. If the task is completed\nand `wait_for_completion=false` was set on it, then it'll come back with a\n`results` or an `error` field. The cost of this feature is the document that\n`wait_for_completion=false` creates at `.tasks/task/${taskId}`. It is up to\nyou to delete that document.\n\n\n[discrete]\n[[docs-update-by-query-cancel-task-api]]\n===== Cancel an update by query operation\n\nAny update by query can be cancelled using the <<tasks,Task Cancel API>>:\n\n[source,console]\n--------------------------------------------------\nPOST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel\n--------------------------------------------------\n\nThe task ID can be found using the <<tasks,tasks API>>.\n\nCancellation should happen quickly but might take a few seconds. The task status\nAPI above will continue to list the update by query task until this task checks\nthat it has been cancelled and terminates itself.\n\n\n[discrete]\n[[docs-update-by-query-rethrottle]]\n===== Change throttling for a request\n\nThe value of `requests_per_second` can be changed on a running update by query\nusing the `_rethrottle` API:\n\n[source,console]\n--------------------------------------------------\nPOST _update_by_query/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1\n--------------------------------------------------\n\nThe task ID can be found using the <<tasks, tasks API>>.\n\nJust like when setting it on the `_update_by_query` API, `requests_per_second`\ncan be either `-1` to disable throttling or any decimal number\nlike `1.7` or `12` to throttle to that level. Rethrottling that speeds up the\nquery takes effect immediately, but rethrotting that slows down the query will\ntake effect after completing the current batch. This prevents scroll\ntimeouts.\n\n[discrete]\n[[docs-update-by-query-manual-slice]]\n===== Slice manually\nSlice an update by query manually by providing a slice id and total number of\nslices to each request:\n\n[source,console]\n----------------------------------------------------------------\nPOST my-index-000001/_update_by_query\n{\n  \"slice\": {\n    \"id\": 0,\n    \"max\": 2\n  },\n  \"script\": {\n    \"source\": \"ctx._source['extra'] = 'test'\"\n  }\n}\nPOST my-index-000001/_update_by_query\n{\n  \"slice\": {\n    \"id\": 1,\n    \"max\": 2\n  },\n  \"script\": {\n    \"source\": \"ctx._source['extra'] = 'test'\"\n  }\n}\n----------------------------------------------------------------\n// TEST[setup:my_index_big]\n\nWhich you can verify works with:\n\n[source,console]\n----------------------------------------------------------------\nGET _refresh\nPOST my-index-000001/_search?size=0&q=extra:test&filter_path=hits.total\n----------------------------------------------------------------\n// TEST[continued]\n\nWhich results in a sensible `total` like this one:\n\n[source,console-result]\n----------------------------------------------------------------\n{\n  \"hits\": {\n    \"total\": {\n        \"value\": 120,\n        \"relation\": \"eq\"\n    }\n  }\n}\n----------------------------------------------------------------\n\n[discrete]\n[[docs-update-by-query-automatic-slice]]\n===== Use automatic slicing\n\nYou can also let update by query automatically parallelize using\n<<slice-scroll>> to slice on `_id`. Use `slices` to specify the number of\nslices to use:\n\n[source,console]\n----------------------------------------------------------------\nPOST my-index-000001/_update_by_query?refresh&slices=5\n{\n  \"script\": {\n    \"source\": \"ctx._source['extra'] = 'test'\"\n  }\n}\n----------------------------------------------------------------\n// TEST[setup:my_index_big]\n\nWhich you also can verify works with:\n\n[source,console]\n----------------------------------------------------------------\nPOST my-index-000001/_search?size=0&q=extra:test&filter_path=hits.total\n----------------------------------------------------------------\n// TEST[continued]\n\nWhich results in a sensible `total` like this one:\n\n[source,console-result]\n----------------------------------------------------------------\n{\n  \"hits\": {\n    \"total\": {\n        \"value\": 120,\n        \"relation\": \"eq\"\n    }\n  }\n}\n----------------------------------------------------------------\n\nSetting `slices` to `auto` will let Elasticsearch choose the number of slices\nto use. This setting will use one slice per shard, up to a certain limit. If\nthere are multiple source data streams or indices, it will choose the number of slices based\non the index or backing index with the smallest number of shards.\n\nAdding `slices` to `_update_by_query` just automates the manual process used in\nthe section above, creating sub-requests which means it has some quirks:\n\n* You can see these requests in the\n<<docs-update-by-query-task-api,Tasks APIs>>. These sub-requests are \"child\"\ntasks of the task for the request with `slices`.\n* Fetching the status of the task for the request with `slices` only contains\nthe status of completed slices.\n* These sub-requests are individually addressable for things like cancellation\nand rethrottling.\n* Rethrottling the request with `slices` will rethrottle the unfinished\nsub-request proportionally.\n* Canceling the request with `slices` will cancel each sub-request.\n* Due to the nature of `slices` each sub-request won't get a perfectly even\nportion of the documents. All documents will be addressed, but some slices may\nbe larger than others. Expect larger slices to have a more even distribution.\n* Parameters like `requests_per_second` and `max_docs` on a request with\n`slices` are distributed proportionally to each sub-request. Combine that with\nthe point above about distribution being uneven and you should conclude that\nusing `max_docs` with `slices` might not result in exactly `max_docs` documents\nbeing updated.\n* Each sub-request gets a slightly different snapshot of the source data stream or index\nthough these are all taken at approximately the same time.\n\n[discrete]\n[[picking-up-a-new-property]]\n===== Pick up a new property\n\nSay you created an index without dynamic mapping, filled it with data, and then\nadded a mapping value to pick up more fields from the data:\n\n[source,console]\n--------------------------------------------------\nPUT test\n{\n  \"mappings\": {\n    \"dynamic\": false,   <1>\n    \"properties\": {\n      \"text\": {\"type\": \"text\"}\n    }\n  }\n}\n\nPOST test/_doc?refresh\n{\n  \"text\": \"words words\",\n  \"flag\": \"bar\"\n}\nPOST test/_doc?refresh\n{\n  \"text\": \"words words\",\n  \"flag\": \"foo\"\n}\nPUT test/_mapping   <2>\n{\n  \"properties\": {\n    \"text\": {\"type\": \"text\"},\n    \"flag\": {\"type\": \"text\", \"analyzer\": \"keyword\"}\n  }\n}\n--------------------------------------------------\n\n<1> This means that new fields won't be indexed, just stored in `_source`.\n\n<2> This updates the mapping to add the new `flag` field. To pick up the new\nfield you have to reindex all documents with it.\n\nSearching for the data won't find anything:\n\n[source,console]\n--------------------------------------------------\nPOST test/_search?filter_path=hits.total\n{\n  \"query\": {\n    \"match\": {\n      \"flag\": \"foo\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"hits\" : {\n    \"total\": {\n        \"value\": 0,\n        \"relation\": \"eq\"\n    }\n  }\n}\n--------------------------------------------------\n\nBut you can issue an `_update_by_query` request to pick up the new mapping:\n\n[source,console]\n--------------------------------------------------\nPOST test/_update_by_query?refresh&conflicts=proceed\nPOST test/_search?filter_path=hits.total\n{\n  \"query\": {\n    \"match\": {\n      \"flag\": \"foo\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"hits\" : {\n    \"total\": {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    }\n  }\n}\n--------------------------------------------------\n\nYou can do the exact same thing when adding a field to a multifield.\n"
}