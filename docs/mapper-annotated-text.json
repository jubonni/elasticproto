{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.582076",
        "size": 12544,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapper-annotated-text.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "mapper-annotated-text",
        "version": "8.15"
    },
    "doc": "[[mapper-annotated-text]]\n=== Mapper annotated text plugin\n\nexperimental[]\n\nThe mapper-annotated-text plugin provides the ability to index text that is a\ncombination of free-text and special markup that is typically used to identify\nitems of interest such as people or organisations (see NER or Named Entity Recognition\ntools).\n\n\nThe elasticsearch markup allows one or more additional tokens to be injected, unchanged, into the token\nstream at the same position as the underlying text it annotates.\n\n:plugin_name: mapper-annotated-text\ninclude::install_remove.asciidoc[]\n\n[[mapper-annotated-text-usage]]\n==== Using the `annotated-text` field\n\nThe `annotated-text` tokenizes text content as per the more common {ref}/text.html[`text`] field (see\n\"limitations\" below) but also injects any marked-up annotation tokens directly into\nthe search index:\n\n[source,console]\n--------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my_field\": {\n        \"type\": \"annotated_text\"\n      }\n    }\n  }\n}\n--------------------------\n\nSuch a mapping would allow marked-up text eg wikipedia articles to be indexed as both text\nand structured tokens. The annotations use a markdown-like syntax using URL encoding of\none or more values separated by the `&` symbol.\n\n\nWe can use the \"_analyze\" api to test how an example annotation would be stored as tokens\nin the search index:\n\n\n[source,js]\n--------------------------\nGET my-index-000001/_analyze\n{\n  \"field\": \"my_field\",\n  \"text\":\"Investors in [Apple](Apple+Inc.) rejoiced.\"\n}\n--------------------------\n// NOTCONSOLE\n\nResponse:\n\n[source,js]\n--------------------------------------------------\n{\n  \"tokens\": [\n    {\n      \"token\": \"investors\",\n      \"start_offset\": 0,\n      \"end_offset\": 9,\n      \"type\": \"<ALPHANUM>\",\n      \"position\": 0\n    },\n    {\n      \"token\": \"in\",\n      \"start_offset\": 10,\n      \"end_offset\": 12,\n      \"type\": \"<ALPHANUM>\",\n      \"position\": 1\n    },\n    {\n      \"token\": \"Apple Inc.\", <1>\n      \"start_offset\": 13,\n      \"end_offset\": 18,\n      \"type\": \"annotation\",\n      \"position\": 2\n    },\n    {\n      \"token\": \"apple\",\n      \"start_offset\": 13,\n      \"end_offset\": 18,\n      \"type\": \"<ALPHANUM>\",\n      \"position\": 2\n    },\n    {\n      \"token\": \"rejoiced\",\n      \"start_offset\": 19,\n      \"end_offset\": 27,\n      \"type\": \"<ALPHANUM>\",\n      \"position\": 3\n    }\n  ]\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n<1> Note the whole annotation token `Apple Inc.` is placed, unchanged as a single token in\nthe token stream and at the same position (position 2) as the text token (`apple`) it annotates.\n\n\nWe can now perform searches for annotations using regular `term` queries that don't tokenize\nthe provided search values. Annotations are a more precise way of matching as can be seen\nin this example where a search for `Beck` will not match `Jeff Beck` :\n\n[source,console]\n--------------------------\n# Example documents\nPUT my-index-000001/_doc/1\n{\n  \"my_field\": \"[Beck](Beck) announced a new tour\"<1>\n}\n\nPUT my-index-000001/_doc/2\n{\n  \"my_field\": \"[Jeff Beck](Jeff+Beck&Guitarist) plays a strat\"<2>\n}\n\n# Example search\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"term\": {\n        \"my_field\": \"Beck\" <3>\n    }\n  }\n}\n--------------------------\n\n<1> As well as tokenising the plain text into single words e.g. `beck`, here we\ninject the single token value `Beck` at the same position as `beck` in the token stream.\n<2> Note annotations can inject multiple tokens at the same position - here we inject both\nthe very specific value `Jeff Beck` and the broader term `Guitarist`. This enables\nbroader positional queries e.g. finding mentions of a `Guitarist` near to `strat`.\n<3> A benefit of searching with these carefully defined annotation tokens is that a query for\n`Beck` will not match document 2 that contains the tokens `jeff`, `beck` and `Jeff Beck`\n\nWARNING: Any use of `=` signs in annotation values eg `[Prince](person=Prince)` will\ncause the document to be rejected with a parse failure. In future we hope to have a use for\nthe equals signs so will actively reject documents that contain this today.\n\n[[annotated-text-synthetic-source]]\n===== Synthetic `_source`\n\nIMPORTANT: Synthetic `_source` is Generally Available only for TSDB indices\n(indices that have `index.mode` set to `time_series`). For other indices\nsynthetic `_source` is in technical preview. Features in technical preview may\nbe changed or removed in a future release. Elastic will work to fix\nany issues, but features in technical preview are not subject to the support SLA\nof official GA features.\n\nIf using a sub-`keyword` field then the values are sorted in the same way as\na `keyword` field's values are sorted. By default, that means sorted with\nduplicates removed. So:\n[source,console,id=synthetic-source-text-example-default]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"text\": {\n        \"type\": \"annotated_text\",\n        \"fields\": {\n          \"raw\": {\n            \"type\": \"keyword\"\n          }\n        }\n      }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"text\": [\n    \"the quick brown fox\",\n    \"the quick brown fox\",\n    \"jumped over the lazy dog\"\n  ]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n[source,console-result]\n----\n{\n  \"text\": [\n    \"jumped over the lazy dog\",\n    \"the quick brown fox\"\n  ]\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\nNOTE: Reordering text fields can have an effect on {ref}/query-dsl-match-query-phrase.html[phrase]\nand {ref}/span-queries.html[span] queries. See the discussion about {ref}/position-increment-gap.html[`position_increment_gap`] for more detail. You\ncan avoid this by making sure the `slop` parameter on the phrase queries\nis lower than the `position_increment_gap`. This is the default.\n\nIf the `annotated_text` field sets `store` to true then order and duplicates\nare preserved.\n[source,console,id=synthetic-source-text-example-stored]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"text\": { \"type\": \"annotated_text\", \"store\": true }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"text\": [\n    \"the quick brown fox\",\n    \"the quick brown fox\",\n    \"jumped over the lazy dog\"\n  ]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n[source,console-result]\n----\n{\n  \"text\": [\n    \"the quick brown fox\",\n    \"the quick brown fox\",\n    \"jumped over the lazy dog\"\n  ]\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\n\n[[mapper-annotated-text-tips]]\n==== Data modelling tips\n===== Use structured and unstructured fields\n\nAnnotations are normally a way of weaving structured information into unstructured text for\nhigher-precision search.\n\n`Entity resolution` is a form of document enrichment undertaken by specialist software or people\nwhere references to entities in a document are disambiguated by attaching a canonical ID.\nThe ID is used to resolve any number of aliases or distinguish between people with the\nsame name. The hyperlinks connecting Wikipedia's articles are a good example of resolved\nentity IDs woven into text.\n\nThese IDs can be embedded as annotations in an annotated_text field but it often makes\nsense to include them in dedicated structured fields to support discovery via aggregations:\n\n[source,console]\n--------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my_unstructured_text_field\": {\n        \"type\": \"annotated_text\"\n      },\n      \"my_structured_people_field\": {\n        \"type\": \"text\",\n        \"fields\": {\n          \"keyword\" : {\n            \"type\": \"keyword\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------\n\nApplications would then typically provide content and discover it as follows:\n\n[source,console]\n--------------------------\n# Example documents\nPUT my-index-000001/_doc/1\n{\n  \"my_unstructured_text_field\": \"[Shay](%40kimchy) created elasticsearch\",\n  \"my_twitter_handles\": [\"@kimchy\"] <1>\n}\n\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"query_string\": {\n        \"query\": \"elasticsearch OR logstash OR kibana\",<2>\n        \"default_field\": \"my_unstructured_text_field\"\n    }\n  },\n  \"aggregations\": {\n  \t\"top_people\" :{\n  \t    \"significant_terms\" : { <3>\n\t       \"field\" : \"my_twitter_handles.keyword\"\n  \t    }\n  \t}\n  }\n}\n--------------------------\n\n<1> Note the `my_twitter_handles` contains a list of the annotation values\nalso used in the unstructured text. (Note the annotated_text syntax requires escaping).\nBy repeating the annotation values in a structured field this application has ensured that\nthe tokens discovered in the structured field can be used for search and highlighting\nin the unstructured field.\n<2> In this example we search for documents that talk about components of the elastic stack\n<3> We use the `my_twitter_handles` field here to discover people who are significantly\nassociated with the elastic stack.\n\n===== Avoiding over-matching annotations\nBy design, the regular text tokens and the annotation tokens co-exist in the same indexed\nfield but in rare cases this can lead to some over-matching.\n\nThe value of an annotation often denotes a _named entity_ (a person, place or company).\nThe tokens for these named entities are inserted untokenized, and differ from typical text\ntokens because they are normally:\n\n* Mixed case e.g. `Madonna`\n* Multiple words e.g. `Jeff Beck`\n* Can have punctuation or numbers e.g. `Apple Inc.` or `@kimchy`\n\nThis means, for the most part, a search for a named entity in the annotated text field will\nnot have any false positives e.g. when selecting `Apple Inc.` from an aggregation result\nyou can drill down to highlight uses in the text without \"over matching\" on any text tokens\nlike the word `apple` in this context:\n\n    the apple was very juicy\n\nHowever, a problem arises if your named entity happens to be a single term and lower-case e.g. the\ncompany `elastic`. In this case, a search on the annotated text field for the token `elastic`\nmay match a text document such as this:\n\n    they fired an elastic band\n\nTo avoid such false matches users should consider prefixing annotation values to ensure\nthey don't name clash with text tokens e.g.\n\n    [elastic](Company_elastic) released version 7.0 of the elastic stack today\n\n\n\n\n[[mapper-annotated-text-highlighter]]\n==== Using the `annotated` highlighter\n\nThe `annotated-text` plugin includes a custom highlighter designed to mark up search hits\nin a way which is respectful of the original markup:\n\n[source,console]\n--------------------------\n# Example documents\nPUT my-index-000001/_doc/1\n{\n  \"my_field\": \"The cat sat on the [mat](sku3578)\"\n}\n\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"query_string\": {\n        \"query\": \"cats\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"my_field\": {\n        \"type\": \"annotated\", <1>\n        \"require_field_match\": false\n      }\n    }\n  }\n}\n--------------------------\n\n<1> The `annotated` highlighter type is designed for use with annotated_text fields\n\nThe annotated highlighter is based on the `unified` highlighter and supports the same\nsettings but does not use the `pre_tags` or `post_tags` parameters. Rather than using\nhtml-like markup such as `<em>cat</em>` the annotated highlighter uses the same\nmarkdown-like syntax used for annotations and injects a key=value annotation where `_hit_term`\nis the key and the matched search term is the value e.g.\n\n    The [cat](_hit_term=cat) sat on the [mat](sku3578)\n\nThe annotated highlighter tries to be respectful of any existing markup in the original\ntext:\n\n* If the search term matches exactly the location of an existing annotation then the\n`_hit_term` key is merged into the url-like syntax used in the `(...)` part of the\nexisting annotation.\n* However, if the search term overlaps the span of an existing annotation it would break\nthe markup formatting so the original annotation is removed in favour of a new annotation\nwith just the search hit information in the results.\n* Any non-overlapping annotations in the original text are preserved in highlighter\nselections\n\n\n[[mapper-annotated-text-limitations]]\n==== Limitations\n\nThe annotated_text field type supports the same mapping settings as the `text` field type\nbut with the following exceptions:\n\n* No support for `fielddata` or `fielddata_frequency_filter`\n* No support for `index_prefixes` or `index_phrases` indexing\n"
}