{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.873273",
        "size": 17427,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-types.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-types",
        "version": "8.15"
    },
    "doc": "[[painless-types]]\n=== Types\n\nA type is a classification of data used to define the properties of a value.\nThese properties specify what data a value represents and the rules for how a\nvalue is evaluated during an <<painless-operators, operation>>. Each type\nbelongs to one of the following categories: <<primitive-types, primitive>>,\n<<reference-types, reference>>, or <<dynamic-types, dynamic>>.\n\n[[primitive-types]]\n==== Primitive Types\n\nA primitive type represents basic data built natively into the JVM and is\nallocated to non-heap memory. Declare a primitive type\n<<painless-variables, variable>> or access a primitive type member field (from\na reference type instance), and assign it a primitive type value for evaluation\nduring later operations. The default value for a newly-declared primitive type\nvariable is listed as part of the definitions below. A primitive type value is\ncopied during an assignment or as an argument for a method/function call.\n\nA primitive type has a corresponding reference type (also known as a boxed\ntype). Use the <<field-access-operator, field access operator>> or\n<<method-call-operator, method call operator>> on a primitive type value to\nforce evaluation as its corresponding reference type value.\n\nThe following primitive types are available. The corresponding reference type\nis listed in parentheses. For example, `Byte` is the reference type for the\n`byte` primitive type:\n\n[[available-primitive-types]]\n.**Available primitive types**\n[%collapsible%open]\n====\n`byte` (`Byte`)::\n    8-bit, signed, two's complement integer. Range: [`-128`, `127`]. Default: `0`.\n\n`short` (`Short`)::\n    16-bit, signed, two's complement integer. Range: [`-32768`, `32767`]. Default: `0`.\n\n`char` (`Character`)::\n    16-bit, unsigned, Unicode character. Range: [`0`, `65535`]. Default: `0` or `\\u0000`.\n\n`int` (`Integer`)::\n    32-bit, signed, two's complement integer. Range: [`-2^31`, `2^31-1`]. Default: `0`.\n\n`long` (`Long`)::\n    64-bit, signed, two's complement integer. Range: [`-2^63`, `2^63-1`]. Default: `0`.\n\n`float (`Float`)`::\n    32-bit, signed, single-precision, IEEE 754 floating point number. Default `0.0`.\n\n`double` (`Double`)::\n    64-bit, signed, double-precision, IEEE 754 floating point number. Default: `0.0`.\n\n`boolean` (`Boolean`)::\n    logical quantity with two possible values of `true` and `false`. Default: `false`.\n====\n\n*Examples*\n\n* Primitive types used in declaration, declaration and assignment.\n+\n[source,Painless]\n----\nint i = 1;        <1>\ndouble d;         <2>\nboolean b = true; <3>\n----\n+\n<1> declare `int i`;\n    store `int 1` to `i`\n<2> declare `double d`;\n    store default `double 0.0` to `d`\n<3> declare `boolean b`;\n    store `boolean true` to `b`\n+\n* Method call on a primitive type using the corresponding reference type.\n+\n[source,Painless]\n----\nint i = 1;    <1>\ni.toString(); <2>\n----\n+\n<1> declare `int i`;\n    store `int 1` to `i`\n<2> load from `i` -> `int 1`;\n    box `int 1` -> `Integer 1 reference`;\n    call `toString` on `Integer 1 reference` -> `String '1'`\n\n[[reference-types]]\n==== Reference Types\n\nA reference type is a named construct (object), potentially representing\nmultiple pieces of data (member fields) and logic to manipulate that data\n(member methods), defined as part of the application programming interface\n(API) for scripts.\n\nA reference type instance is a single set of data for one reference type\nobject allocated to the heap. Use the\n<<new-instance-operator, new instance operator>> to allocate a reference type\ninstance. Use a reference type instance to load from, store to, and manipulate\ncomplex data.\n\nA reference type value refers to a reference type instance, and multiple\nreference type values may refer to the same reference type instance. A change to\na reference type instance will affect all reference type values referring to\nthat specific instance.\n\nDeclare a reference type <<painless-variables, variable>> or access a reference\ntype member field (from a reference type instance), and assign it a reference\ntype value for evaluation during later operations. The default value for a\nnewly-declared reference type variable is `null`. A reference type value is\nshallow-copied during an assignment or as an argument for a method/function\ncall. Assign `null` to a reference type variable to indicate the reference type\nvalue refers to no reference type instance. The JVM will garbage collect a\nreference type instance when it is no longer referred to by any reference type\nvalues. Pass `null` as an argument to a method/function call to indicate the\nargument refers to no reference type instance.\n\nA reference type object defines zero-to-many of each of the following:\n\nstatic member field::\n\nA static member field is a named and typed piece of data. Each reference type\n*object* contains one set of data representative of its static member fields.\nUse the <<field-access-operator, field access operator>> in correspondence with\nthe reference type object name to access a static member field for loading and\nstoring to a specific reference type *object*. No reference type instance\nallocation is necessary to use a static member field.\n\nnon-static member field::\n\nA non-static member field is a named and typed piece of data. Each reference\ntype *instance* contains one set of data representative of its reference type\nobject's non-static member fields. Use the\n<<field-access-operator, field access operator>> for loading and storing to a\nnon-static member field of a specific reference type *instance*. An allocated\nreference type instance is required to use a non-static member field.\n\nstatic member method::\n\nA static member method is a <<painless-functions, function>> called on a\nreference type *object*. Use the <<method-call-operator, method call operator>>\nin correspondence with the reference type object name to call a static member\nmethod. No reference type instance allocation is necessary to use a static\nmember method.\n\nnon-static member method::\n\nA non-static member method is a <<painless-functions, function>> called on a\nreference type *instance*. A non-static member method called on a reference type\ninstance can load from and store to non-static member fields of that specific\nreference type instance. Use the <<method-call-operator, method call operator>>\nin correspondence with a specific reference type instance to call a non-static\nmember method. An allocated reference type instance is required to use a\nnon-static member method.\n\nconstructor::\n\nA constructor is a special type of <<painless-functions, function>> used to\nallocate a reference type *instance* defined by a specific reference type\n*object*. Use the <<new-instance-operator, new instance operator>> to allocate\na reference type instance.\n\nA reference type object follows a basic inheritance model. Consider types A and\nB. Type A is considered to be a parent of B, and B a child of A, if B inherits\n(is able to access as its own) all of A's non-static members. Type B is\nconsidered a descendant of A if there exists a recursive parent-child\nrelationship from B to A with none to many types in between. In this case, B\ninherits all of A's non-static members along with all of the non-static members\nof the types in between. Type B is also considered to be a type A in both\nrelationships.\n\n*Examples*\n\n* Reference types evaluated in several different operations.\n+\n[source,Painless]\n----\nList l = new ArrayList(); <1>\nl.add(1);                 <2>\nint i = l.get(0) + 2;     <3>\n----\n+\n<1> declare `List l`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `l`\n<2> load from `l` -> `List reference`;\n    implicit cast `int 1` to `def` -> `def`\n    call `add` on `List reference` with arguments (`def`)\n<3> declare `int i`;\n    load from `l` -> `List reference`;\n    call `get` on `List reference` with arguments (`int 0`) -> `def`;\n    implicit cast `def` to `int 1` -> `int 1`;\n    add `int 1` and `int 2` -> `int 3`;\n    store `int 3` to `i`\n+\n* Sharing a reference type instance.\n+\n[source,Painless]\n----\nList l0 = new ArrayList();     <1>\nList l1 = l0;                  <2>\nl0.add(1);                     <3>\nl1.add(2);                     <4>\nint i = l1.get(0) + l0.get(1); <5>\n----\n+\n<1> declare `List l0`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `l0`\n<2> declare `List l1`;\n    load from `l0` -> `List reference`;\n    store `List reference` to `l1`\n    (note `l0` and `l1` refer to the same instance known as a shallow-copy)\n<3> load from `l0` -> `List reference`;\n    implicit cast `int 1` to `def` -> `def`\n    call `add` on `List reference` with arguments (`def`)\n<4> load from `l1` -> `List reference`;\n    implicit cast `int 2` to `def` -> `def`\n    call `add` on `List reference` with arguments (`def`)\n<5> declare `int i`;\n    load from `l0` -> `List reference`;\n    call `get` on `List reference` with arguments (`int 0`) -> `def @0`;\n    implicit cast `def @0` to `int 1` -> `int 1`;\n    load from `l1` -> `List reference`;\n    call `get` on `List reference` with arguments (`int 1`) -> `def @1`;\n    implicit cast `def @1` to `int 2` -> `int 2`;\n    add `int 1` and `int 2` -> `int 3`;\n    store `int 3` to `i`;\n+\n* Using the static members of a reference type.\n+\n[source,Painless]\n----\nint i = Integer.MAX_VALUE;       <1>\nlong l = Long.parseLong(\"123L\"); <2>\n----\n+\n<1> declare `int i`;\n    load from `MAX_VALUE` on `Integer` -> `int 2147483647`;\n    store `int 2147483647` to `i`\n<2> declare `long l`;\n    call `parseLong` on `Long` with arguments (`long 123`) -> `long 123`;\n    store `long 123` to `l`\n\n[[dynamic-types]]\n==== Dynamic Types\n\nA dynamic type value can represent the value of any primitive type or\nreference type using a single type name `def`. A `def` type value mimics\nthe behavior of whatever value it represents at run-time and will always\nrepresent the child-most descendant type value of any type value when evaluated\nduring operations.\n\nDeclare a `def` type <<painless-variables, variable>> or access a `def` type\nmember field (from a reference type instance), and assign it any type of value\nfor evaluation during later operations. The default value for a newly-declared\n`def` type variable is `null`. A `def` type variable or method/function\nparameter can change the type it represents during the compilation and\nevaluation of a script.\n\nUsing the `def` type can have a slight impact on performance. Use only primitive\ntypes and reference types directly when performance is critical.\n\n*Errors*\n\n* If a `def` type value represents an inappropriate type for evaluation of an\n  operation at run-time.\n\n*Examples*\n\n* General uses of the `def` type.\n+\n[source,Painless]\n----\ndef dp = 1;               <1>\ndef dr = new ArrayList(); <2>\ndr = dp;                  <3>\n----\n+\n<1> declare `def dp`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `dp`\n<2> declare `def dr`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `def` -> `def`;\n    store `def` to `dr`\n<3> load from `dp` -> `def`;\n    store `def` to `dr`;\n    (note the switch in the type `dr` represents from `ArrayList` to `int`)\n+\n* A `def` type value representing the child-most descendant of a value.\n+\n[source,Painless]\n----\nObject l = new ArrayList(); <1>\ndef d = l;                  <2>\nd.ensureCapacity(10);       <3>\n----\n+\n<1> declare `Object l`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `Object reference`\n            -> `Object reference`;\n    store `Object reference` to `l`\n<2> declare `def d`;\n    load from `l` -> `Object reference`;\n    implicit cast `Object reference` to `def` -> `def`;\n    store `def` to `d`;\n<3> load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `ensureCapacity` on `ArrayList reference` with arguments (`int 10`);\n    (note `def` was implicit cast to `ArrayList reference`\n            since ArrayList` is the child-most descendant type value that the\n            `def` type value represents)\n\n[[string-type]]\n==== String Type\n\nThe `String` type is a specialized reference type that does not require\nexplicit allocation. Use a <<string-literals, string literal>> to directly\nevaluate a `String` type value. While not required, the\n<<new-instance-operator, new instance operator>> can allocate `String` type\ninstances.\n\n*Examples*\n\n* General use of the `String` type.\n+\n[source,Painless]\n----\nString r = \"some text\";             <1>\nString s = 'some text';             <2>\nString t = new String(\"some text\"); <3>\nString u;                           <4>\n----\n+\n<1> declare `String r`;\n    store `String \"some text\"` to `r`\n<2> declare `String s`;\n    store `String 'some text'` to `s`\n<3> declare `String t`;\n    allocate `String` instance with arguments (`String \"some text\"`)\n            -> `String \"some text\"`;\n    store `String \"some text\"` to `t`\n<4> declare `String u`;\n    store default `null` to `u`\n\n[[void-type]]\n==== void Type\n\nThe `void` type represents the concept of a lack of type. Use the `void` type to\nindicate a function returns no value.\n\n*Examples*\n\n* Use of the `void` type in a function.\n+\n[source,Painless]\n----\nvoid addToList(List l, def d) {\n    l.add(d);\n}\n----\n\n[[array-type]]\n==== Array Type\n\nAn array type is a specialized reference type where an array type instance\ncontains a series of values allocated to the heap. Each value in an array type\ninstance is defined as an element. All elements in an array type instance are of\nthe same type (element type) specified as part of declaration. Each element is\nassigned an index within the range `[0, length)` where length is the total\nnumber of elements allocated for an array type instance.\n\nUse the <<new-array-operator, new array operator>> or the\n<<array-initialization-operator, array initialization operator>> to allocate an\narray type instance. Declare an array type <<painless-variables, variable>> or\naccess an array type member field (from a reference type instance), and assign\nit an array type value for evaluation during later operations. The default value\nfor a newly-declared array type variable is `null`. An array type value is\nshallow-copied during an assignment or as an argument for a method/function\ncall. Assign `null` to an array type variable to indicate the array type value\nrefers to no array type instance. The JVM will garbage collect an array type\ninstance when it is no longer referred to by any array type values. Pass `null`\nas an argument to a method/function call to indicate the argument refers to no\narray type instance.\n\nUse the <<array-length-operator, array length operator>> to retrieve the length\nof an array type value as an `int` type value. Use the\n<<array-access-operator, array access operator>> to load from and store to\nan individual element within an array type instance.\n\nWhen an array type instance is allocated with multiple dimensions using the\nrange `[2, d]` where `d >= 2`, each element within each dimension in the range\n`[1, d-1]` is also an array type. The element type of each dimension, `n`, is an\narray type with the number of dimensions equal to `d-n`. For example, consider\n`int[][][]` with 3 dimensions. Each element in the 3rd dimension, `d-3`, is the\nprimitive type `int`. Each element in the 2nd dimension, `d-2`, is the array\ntype `int[]`. And each element in the 1st dimension, `d-1` is the array type\n`int[][]`.\n\n*Examples*\n\n* General use of single-dimensional arrays.\n+\n[source,Painless]\n----\nint[] x;                   <1>\nfloat[] y = new float[10]; <2>\ndef z = new float[5];      <3>\ny[9] = 1.0F;               <4>\nz[0] = y[9];               <5>\n----\n+\n<1> declare `int[] x`;\n    store default `null` to `x`\n<2> declare `float[] y`;\n    allocate `1-d float array` instance with `length [10]`\n            -> `1-d float array reference`;\n    store `1-d float array reference` to `y`\n<3> declare `def z`;\n    allocate `1-d float array` instance with `length [5]`\n            -> `1-d float array reference`;\n    implicit cast `1-d float array reference` to `def` -> `def`;\n    store `def` to `z`\n<4> load from `y` -> `1-d float array reference`;\n    store `float 1.0` to `index [9]` of `1-d float array reference`\n<5> load from `y` -> `1-d float array reference @0`;\n    load from `index [9]` of `1-d float array reference @0` -> `float 1.0`;\n    load from `z` -> `def`;\n    implicit cast `def` to `1-d float array reference @1`\n            -> `1-d float array reference @1`;\n    store `float 1.0` to `index [0]` of `1-d float array reference @1`\n+\n* General use of a multi-dimensional array.\n+\n[source,Painless]\n----\nint[][][] ia3 = new int[2][3][4]; <1>\nia3[1][2][3] = 99;                <2>\nint i = ia3[1][2][3];             <3>\n----\n+\n<1> declare `int[][][] ia`;\n    allocate `3-d int array` instance with length `[2, 3, 4]`\n            -> `3-d int array reference`;\n    store `3-d int array reference` to `ia3`\n<2> load from `ia3` -> `3-d int array reference`;\n    store `int 99` to `index [1, 2, 3]` of `3-d int array reference`\n<3> declare `int i`;\n    load from `ia3` -> `3-d int array reference`;\n    load from `index [1, 2, 3]` of `3-d int array reference` -> `int 99`;\n    store `int 99` to `i`\n"
}