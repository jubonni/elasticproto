{
    "meta": {
        "size": 19876,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-restore-snapshot.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "snapshots-restore-snapshot",
        "version": "8.15"
    },
    "doc": "[[snapshots-restore-snapshot]]\n== Restore a snapshot\n\nThis guide shows you how to restore a snapshot. Snapshots are a convenient way\nto store a copy of your data outside of a cluster. You can restore a snapshot\nto recover indices and data streams after deletion or a hardware failure. You\ncan also use snapshots to transfer data between clusters.\n\nIn this guide, you'll learn how to:\n\n* Get a list of available snapshots\n* Restore an index or data stream from a snapshot\n* Restore a feature state\n* Restore an entire cluster\n* Monitor the restore operation\n* Cancel an ongoing restore\n\nThis guide also provides tips for <<restore-different-cluster,restoring to\nanother cluster>> and <<troubleshoot-restore,troubleshooting common restore\nerrors>>.\n\n[discrete]\n[[restore-snapshot-prereqs]]\n=== Prerequisites\n\ninclude::register-repository.asciidoc[tag=kib-snapshot-prereqs]\n\ninclude::apis/restore-snapshot-api.asciidoc[tag=restore-prereqs]\n\n[discrete]\n[[restore-snapshot-considerations]]\n=== Considerations\n\nWhen restoring data from a snapshot, keep the following in mind:\n\n* If you restore a data stream, you also restore its backing indices.\n\n* You can only restore an existing index if it's <<indices-close,closed>> and\nthe index in the snapshot has the same number of primary shards.\n\n* You can't restore an existing open index. This includes\nbacking indices for a data stream.\n\n*  The restore operation automatically opens restored indices, including backing\nindices.\n\n* You can restore only a specific backing index from a data stream. However, the\nrestore operation doesn't add the restored backing index to any existing data\nstream.\n\n[discrete]\n[[get-snapshot-list]]\n=== Get a list of available snapshots\n\nTo view a list of available snapshots in {kib}, go to the main menu and click\n*Stack Management > Snapshot and Restore*.\n\nYou can also use the <<get-snapshot-repo-api,get repository API>> and the\n<<get-snapshot-api,get snapshot API>> to find snapshots that are available to\nrestore. First, use the get repository API to fetch a list of registered\nsnapshot repositories.\n\n[source,console]\n----\nGET _snapshot\n----\n// TEST[setup:setup-snapshots]\n\nThen use the get snapshot API to get a list of snapshots in a specific\nrepository. This also returns each snapshot's contents.\n\n[source,console]\n----\nGET _snapshot/my_repository/*?verbose=false\n----\n// TEST[setup:setup-snapshots]\n\n[discrete]\n[[restore-index-data-stream]]\n=== Restore an index or data stream\n\nYou can restore a snapshot using {kib}'s *Snapshot and Restore* feature or the\n<<restore-snapshot-api,restore snapshot API>>.\n\nBy default, a restore request attempts to restore all regular indices and\nregular data streams in a snapshot. In most cases, you only need to restore a\nspecific index or data stream from a snapshot. However, you can't restore an\nexisting open index.\n\nIf you're restoring data to a pre-existing cluster, use one of the\nfollowing methods to avoid conflicts with existing indices and data streams:\n\n* <<delete-restore>>\n* <<rename-on-restore>>\n\n[discrete]\n[[delete-restore]]\n==== Delete and restore\n\nThe simplest way to avoid conflicts is to delete an existing index or data\nstream before restoring it. To prevent the accidental re-creation of the index\nor data stream, we recommend you temporarily stop all indexing until the restore\noperation is complete.\n\nWARNING: If the\n<<action-destructive-requires-name,`action.destructive_requires_name`>> cluster\nsetting is `false`, don't use the <<indices-delete-index,delete index API>> to\ntarget the `*` or `.*` wildcard pattern. If you use {es}'s security features,\nthis will delete system indices required for authentication. Instead, target the\n`*,-.*` wildcard pattern to exclude these system indices and other index names\nthat begin with a dot (`.`).\n\n[source,console]\n----\n# Delete an index\nDELETE my-index\n\n# Delete a data stream\nDELETE _data_stream/logs-my_app-default\n----\n// TEST[setup:setup-snapshots]\n\nIn the restore request, explicitly specify any indices and data streams to\nrestore.\n\n[source,console]\n----\nPOST _snapshot/my_repository/my_snapshot_2099.05.06/_restore\n{\n  \"indices\": \"my-index,logs-my_app-default\"\n}\n----\n// TEST[continued]\n// TEST[s/_restore/_restore?wait_for_completion=true/]\n\n[discrete]\n[[rename-on-restore]]\n==== Rename on restore\n\nIf you want to avoid deleting existing data, you can instead\nrename the indices and data streams you restore. You typically use this method\nto compare existing data to historical data from a snapshot. For example, you\ncan use this method to review documents after an accidental update or deletion.\n\nBefore you start, ensure the cluster has enough capacity for both the existing\nand restored data.\n\nThe following restore snapshot API request prepends `restored-` to the name of\nany restored index or data stream.\n\n[source,console]\n----\nPOST _snapshot/my_repository/my_snapshot_2099.05.06/_restore\n{\n  \"indices\": \"my-index,logs-my_app-default\",\n  \"rename_pattern\": \"(.+)\",\n  \"rename_replacement\": \"restored-$1\"\n}\n----\n// TEST[setup:setup-snapshots]\n// TEST[s/_restore/_restore?wait_for_completion=true/]\n\nIf the rename options produce two or more indices or data streams with the same\nname, the restore operation fails.\n\nIf you rename a data stream, its backing indices are also renamed. For example,\nif you rename the `logs-my_app-default` data stream to\n`restored-logs-my_app-default`, the backing index\n`.ds-logs-my_app-default-2099.03.09-000005` is renamed to\n`.ds-restored-logs-my_app-default-2099.03.09-000005`.\n\nWhen the restore operation is complete, you can compare the original and\nrestored data. If you no longer need an original index or data stream, you can\ndelete it and use a <<docs-reindex,reindex>> to rename the restored one.\n\n[source,console]\n----\n# Delete the original index\nDELETE my-index\n\n# Reindex the restored index to rename it\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"restored-my-index\"\n  },\n  \"dest\": {\n    \"index\": \"my-index\"\n  }\n}\n\n# Delete the original data stream\nDELETE _data_stream/logs-my_app-default\n\n# Reindex the restored data stream to rename it\nPOST _reindex\n{\n  \"source\": {\n    \"index\": \"restored-logs-my_app-default\"\n  },\n  \"dest\": {\n    \"index\": \"logs-my_app-default\",\n    \"op_type\": \"create\"\n  }\n}\n----\n// TEST[continued]\n\n[discrete]\n[[restore-feature-state]]\n=== Restore a feature state\n\nYou can restore a <<feature-state,feature state>> to recover system indices,\nsystem data streams, and other configuration data for a feature from a snapshot.\n\nIf you restore a snapshot's cluster state, the operation restores all feature\nstates in the snapshot by default. Similarly, if you don't restore a snapshot's\ncluster state, the operation doesn't restore any feature states by default. You\ncan also choose to restore only specific feature states from a snapshot,\nregardless of the cluster state.\n\nTo view a snapshot's feature states, use the get snapshot API.\n\n[source,console]\n----\nGET _snapshot/my_repository/my_snapshot_2099.05.06\n----\n// TEST[setup:setup-snapshots]\n\nThe response's `feature_states` property contains a list of features in the\nsnapshot as well as each feature's indices.\n\nTo restore a specific feature state from the snapshot, specify the\n`feature_name` from the response in the restore snapshot API's\n<<restore-snapshot-api-feature-states,`feature_states`>> parameter.\n\nNOTE: When you restore a feature state, {es} closes and overwrites the feature's existing indices.\n\nWARNING: Restoring the `security` feature state overwrites system indices\nused for authentication. If you use {ess}, ensure you have access to the {ess}\nConsole before restoring the `security` feature state. If you run {es} on your\nown hardware, <<restore-create-file-realm-user,create a superuser in the file\nrealm>> to ensure you'll still be able to access your cluster.\n\n[source,console]\n----\nPOST _snapshot/my_repository/my_snapshot_2099.05.06/_restore\n{\n  \"feature_states\": [ \"geoip\" ],\n  \"include_global_state\": false,    <1>\n  \"indices\": \"-*\"                   <2>\n}\n----\n// TEST[setup:setup-snapshots]\n// TEST[s/^/DELETE my-index\\nDELETE _data_stream\\/logs-my_app-default\\n/]\n// TEST[s/_restore/_restore?wait_for_completion=true/]\n// TEST[s/\"feature_states\": \\[ \"geoip\" \\],//]\n\n<1> Exclude the cluster state from the restore operation.\n<2> Exclude the other indices and data streams in the snapshot from the restore operation.\n\n[discrete]\n[[restore-entire-cluster]]\n=== Restore an entire cluster\n\nIn some cases, you need to restore an entire cluster from a snapshot, including\nthe cluster state and all <<feature-state,feature states>>. These cases should\nbe rare, such as in the event of a catastrophic failure.\n\nRestoring an entire cluster involves deleting important system indices,\nincluding those used for authentication. Consider whether you can restore\nspecific indices or data streams instead.\n\nIf you're restoring to a different cluster, see <<restore-different-cluster>>\nbefore you start.\n\n. If you <<back-up-config-files,backed up the cluster's configuration\nfiles>>, you can restore them to each node. This step is optional and requires a\n<<restart-cluster, full cluster restart>>.\n+\nAfter you shut down a node, copy the backed-up configuration files over to the\nnode's `$ES_PATH_CONF` directory. Before restarting the node, ensure\n`elasticsearch.yml` contains the appropriate node roles, node name, and\nother node-specific settings.\n+\nIf you choose to perform this step, you must repeat this process on each node in\nthe cluster.\n\n. Temporarily stop indexing and turn off the following features:\n+\n--\n* GeoIP database downloader and ILM history store\n+\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"ingest.geoip.downloader.enabled\": false,\n    \"indices.lifecycle.history_index_enabled\": false\n  }\n}\n----\n\n* ILM\n+\n[source,console]\n----\nPOST _ilm/stop\n----\n\n////\n[source,console]\n----\nPOST _ilm/start\n----\n// TEST[continued]\n////\n\n* Machine Learning\n+\n[source,console]\n----\nPOST _ml/set_upgrade_mode?enabled=true\n----\n\n////\n[source,console]\n----\nPOST _ml/set_upgrade_mode?enabled=false\n----\n// TEST[continued]\n////\n\n* Monitoring\n+\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"xpack.monitoring.collection.enabled\": false\n  }\n}\n----\n// TEST[warning:[xpack.monitoring.collection.enabled] setting was deprecated in Elasticsearch and will be removed in a future release.]\n\n* Watcher\n+\n[source,console]\n----\nPOST _watcher/_stop\n----\n\n////\n[source,console]\n----\nPOST _watcher/_start\n----\n// TEST[continued]\n////\n\n* Universal Profiling\n+\nCheck if Universal Profiling index template management is enabled:\n+\n[source,console]\n----\nGET /_cluster/settings?filter_path=**.xpack.profiling.templates.enabled&include_defaults=true\n----\n+\nIf the value is `true`, disable Universal Profiling index template management:\n+\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"xpack.profiling.templates.enabled\": false\n  }\n}\n----\n--\n\n. [[restore-create-file-realm-user]]If you use {es} security features, log in to\na node host, navigate to the {es} installation directory, and add a user with\nthe `superuser` role to the file realm using the\n<<users-command,`elasticsearch-users`>> tool.\n+\n\nFor example, the following command creates a user named `restore_user`.\n+\n\n[source,sh]\n----\n./bin/elasticsearch-users useradd restore_user -p my_password -r superuser\n----\n+\n\nUse this file realm user to authenticate requests until the restore operation is\ncomplete.\n\n. Use the <<cluster-update-settings,cluster update settings API>> to set\n<<action-destructive-requires-name,`action.destructive_requires_name`>> to\n`false`. This lets you delete data streams and indices using wildcards.\n+\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"action.destructive_requires_name\": false\n  }\n}\n----\n// TEST[setup:setup-snapshots]\n\n. Delete all existing data streams on the cluster.\n+\n[source,console]\n----\nDELETE _data_stream/*?expand_wildcards=all\n----\n// TEST[continued]\n\n. Delete all existing indices on the cluster.\n+\n[source,console]\n----\nDELETE *?expand_wildcards=all\n----\n// TEST[continued]\n\n. Restore the entire snapshot, including the cluster state. By default,\nrestoring the cluster state also restores any feature states in the snapshot.\n+\n[source,console]\n----\nPOST _snapshot/my_repository/my_snapshot_2099.05.06/_restore\n{\n  \"indices\": \"*\",\n  \"include_global_state\": true\n}\n----\n// TEST[continued]\n// TEST[s/_restore/_restore?wait_for_completion=true/]\n\n. When the restore operation is complete, resume indexing and restart any\nfeatures you stopped:\n+\nNOTE: When the snapshot is restored, the license that was in use at the time the snapshot\nwas taken will be restored as well. If your license has expired since the snapshot was taken,\nyou will need to use the <<update-license,Update License API>> to install a current license.\n+\n--\n* GeoIP database downloader and ILM history store\n+\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"ingest.geoip.downloader.enabled\": true,\n    \"indices.lifecycle.history_index_enabled\": true\n  }\n}\n----\n//TEST[s/true/false/]\n\n* ILM\n+\n[source,console]\n----\nPOST _ilm/start\n----\n\n* Machine Learning\n+\n[source,console]\n----\nPOST _ml/set_upgrade_mode?enabled=false\n----\n\n* Monitoring\n+\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"xpack.monitoring.collection.enabled\": true\n  }\n}\n----\n// TEST[warning:[xpack.monitoring.collection.enabled] setting was deprecated in Elasticsearch and will be removed in a future release.]\n// TEST[s/true/false/]\n\n* Watcher\n+\n[source,console]\n----\nPOST _watcher/_start\n----\n--\n\n* Universal Profiling\n+\nIf the value was `true` initially, enable Universal Profiling index template management again, otherwise skip this step:\n+\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"xpack.profiling.templates.enabled\": true\n  }\n}\n----\n//TEST[s/true/false/]\n\n. If wanted, reset the `action.destructive_requires_name` cluster setting.\n+\n[source,console]\n----\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"action.destructive_requires_name\": null\n  }\n}\n----\n\n[discrete]\n[[monitor-restore]]\n=== Monitor a restore\n\nThe restore operation uses the <<indices-recovery,shard recovery process>> to\nrestore an index's primary shards from a snapshot. While the restore operation\nrecovers primary shards, the cluster will have a `yellow`\n<<cluster-health,health status>>.\n\nAfter all primary shards are recovered, the replication process creates and\ndistributes replicas across eligible data nodes. When replication is complete,\nthe cluster health status typically becomes `green`.\n\nOnce you start a restore in {kib}, you\u2019re navigated to the **Restore Status**\npage. You can use this page to track the current state for each shard in the\nsnapshot.\n\nYou can also monitor snapshot recover using {es} APIs. To monitor the cluster\nhealth status, use the <<cluster-health,cluster health API>>.\n\n[source,console]\n----\nGET _cluster/health\n----\n\nTo get detailed information about ongoing shard recoveries, use the\n<<indices-recovery,index recovery API>>.\n\n[source,console]\n----\nGET my-index/_recovery\n----\n// TEST[setup:setup-snapshots]\n\nTo view any unassigned shards, use the <<cat-shards,cat shards API>>.\n\n[source,console]\n----\nGET _cat/shards?v=true&h=index,shard,prirep,state,node,unassigned.reason&s=state\n----\n\nUnassigned shards have a `state` of `UNASSIGNED`. The `prirep` value is `p` for\nprimary shards and `r` for replicas. The `unassigned.reason` describes why the\nshard remains unassigned.\n\nTo get a more in-depth explanation of an unassigned shard's allocation status,\nuse the <<cluster-allocation-explain,cluster allocation explanation API>>.\n\n[source,console]\n----\nGET _cluster/allocation/explain\n{\n  \"index\": \"my-index\",\n  \"shard\": 0,\n  \"primary\": false,\n  \"current_node\": \"my-node\"\n}\n----\n// TEST[s/^/PUT my-index\\n/]\n// TEST[s/\"primary\": false,/\"primary\": false/]\n// TEST[s/\"current_node\": \"my-node\"//]\n\n[discrete]\n[[cancel-restore]]\n=== Cancel a restore\n\nYou can delete an index or data stream to cancel its ongoing restore. This also\ndeletes any existing data in the cluster for the index or data stream. Deleting\nan index or data stream doesn't affect the snapshot or its data.\n\n[source,console]\n----\n# Delete an index\nDELETE my-index\n\n# Delete a data stream\nDELETE _data_stream/logs-my_app-default\n----\n// TEST[setup:setup-snapshots]\n\n[discrete]\n[[restore-different-cluster]]\n=== Restore to a different cluster\n\nTIP: {ess} can help you restore snapshots from other deployments. See\n{cloud}/ec-restoring-snapshots.html[Work with snapshots].\n\nSnapshots aren't tied to a particular cluster or a cluster name. You can create\na snapshot in one cluster and restore it in another\n<<snapshot-restore-version-compatibility,compatible cluster>>. Any data stream\nor index you restore from a snapshot must also be compatible with the current\ncluster\u2019s version. The topology of the clusters doesn't need to match.\n\nTo restore a snapshot, its repository must be\n<<snapshots-register-repository,registered>> and available to the new cluster.\nIf the original cluster still has write access to the repository, register the\nrepository as read-only. This prevents multiple clusters from writing to the\nrepository at the same time and corrupting the repository's contents. It also\nprevents {es} from caching the repository's contents, which means that changes\nmade by other clusters will become visible straight away.\n\nBefore you start a restore operation, ensure the new cluster has enough capacity\nfor any data streams or indices you want to restore. If the new cluster has a\nsmaller capacity, you can:\n\n* Add nodes or upgrade your hardware to increase capacity.\n* Restore fewer indices and data streams.\n* Reduce the <<dynamic-index-number-of-replicas,number of replicas>> for\nrestored indices.\n+\nFor example, the following restore snapshot API request uses the\n`index_settings` option to set `index.number_of_replicas` to `1`.\n+\n[source,console]\n----\nPOST _snapshot/my_repository/my_snapshot_2099.05.06/_restore\n{\n  \"indices\": \"my-index,logs-my_app-default\",\n  \"index_settings\": {\n    \"index.number_of_replicas\": 1\n  }\n}\n----\n// TEST[setup:setup-snapshots]\n// TEST[s/^/DELETE my-index\\nDELETE _data_stream\\/logs-my_app-default\\n/]\n// TEST[s/_restore/_restore?wait_for_completion=true/]\n\nIf indices or backing indices in the original cluster were assigned to particular nodes using\n<<shard-allocation-filtering,shard allocation filtering>>, the same rules will be enforced in the new cluster. If the new cluster does not contain nodes with appropriate attributes that a restored index can be allocated on, the\nindex will not be successfully restored unless these index allocation settings are changed during the restore operation.\n\nThe restore operation also checks that restored persistent settings are compatible with the current cluster to avoid accidentally\nrestoring incompatible settings. If you need to restore a snapshot with incompatible persistent settings, try restoring it without\nthe <<restore-snapshot-api-include-global-state,global cluster state>>.\n\n[discrete]\n[[troubleshoot-restore]]\n=== Troubleshoot restore errors\n\nHere's how to resolve common errors returned by restore requests.\n\n[discrete]\n==== Cannot restore index [<index>] because an open index with same name already exists in the cluster\n\nYou can't restore an open index that already exists. To resolve this error, try\none of the methods in <<restore-index-data-stream>>.\n\n[discrete]\n==== Cannot restore index [<index>] with [x] shards from a snapshot of index [<snapshot-index>] with [y] shards\n\nYou can only restore an existing index if it's closed and the index in the\nsnapshot has the same number of primary shards. This error indicates the index\nin the snapshot has a different number of primary shards.\n\nTo resolve this error, try one of the methods in <<restore-index-data-stream>>.\n"
}