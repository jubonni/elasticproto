{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.869586",
        "size": 15227,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "modules-scripting-using",
        "version": "8.15"
    },
    "doc": "[[modules-scripting-using]]\n== How to write scripts\n\nWherever scripting is supported in the {es} APIs, the syntax follows the same\npattern; you specify the language of your script, provide the script logic (or\nsource), and add parameters that are passed into the script:\n\n[source,js]\n-------------------------------------\n  \"script\": {\n    \"lang\":   \"...\",\n    \"source\" | \"id\": \"...\",\n    \"params\": { ... }\n  }\n-------------------------------------\n// NOTCONSOLE\n\n`lang`::\n\n    Specifies the language the script is written in. Defaults to `painless`.\n\n`source`, `id`::\n\n    The script itself, which you specify as `source` for an inline script or\n    `id` for a stored script. Use the <<stored-script-apis,stored script APIs>>\n    to create and manage stored scripts.\n\n`params`::\n\n    Specifies any named parameters that are passed into the script as\n    variables. <<prefer-params,Use parameters>> instead of hard-coded values to decrease compile time.\n\n[discrete]\n[[hello-world-script]]\n=== Write your first script\n<<modules-scripting-painless,Painless>> is the default scripting language\nfor {es}. It is secure, performant, and provides a natural syntax for anyone\nwith a little coding experience.\n\nA Painless script is structured as one or more statements and optionally\nhas one or more user-defined functions at the beginning. A script must always\nhave at least one statement.\n\nThe {painless}/painless-execute-api.html[Painless execute API] provides the ability to\ntest a script with simple user-defined parameters and receive a result. Let's\nstart with a complete script and review its constituent parts.\n\nFirst, index a document with a single field so that we have some data to work\nwith:\n\n[source,console]\n----\nPUT my-index-000001/_doc/1\n{\n  \"my_field\": 5\n}\n----\n\nWe can then construct a script that operates on that field and run evaluate the\nscript as part of a query. The following query uses the\n<<script-fields,`script_fields`>> parameter of the search API to retrieve a\nscript valuation. There's a lot happening here, but we'll break it down the\ncomponents to understand them individually. For now, you only need to\nunderstand that this script takes `my_field` and operates on it.\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"script_fields\": {\n    \"my_doubled_field\": {\n      \"script\": { <1>\n        \"source\": \"doc['my_field'].value * params['multiplier']\", <2>\n        \"params\": {\n          \"multiplier\": 2\n        }\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n<1> `script` object\n<2> `script` source\n\nThe `script` is a standard JSON object that defines scripts under most APIs\nin {es}. This object requires `source` to define the script itself. The\nscript doesn't specify a language, so it defaults to Painless.\n\n[discrete]\n[[prefer-params]]\n=== Use parameters in your script\n\nThe first time {es} sees a new script, it compiles the script and stores the\ncompiled version in a cache. Compilation can be a heavy process. Rather than\nhard-coding values in your script, pass them as named `params` instead.\n\nFor example, in the previous script, we could have just hard coded values and\nwritten a script that is seemingly less complex. We could just retrieve the\nfirst value for `my_field` and then multiply it by `2`:\n\n[source,painless]\n----\n\"source\": \"return doc['my_field'].value * 2\"\n----\n\nThough it works, this solution is pretty inflexible. We have to modify the\nscript source to change the multiplier, and {es} has to recompile the script\nevery time that the multiplier changes.\n\nInstead of hard-coding values, use named `params` to make scripts flexible, and\nalso reduce compilation time when the script runs. You can now make changes to\nthe `multiplier` parameter without {es} recompiling the script.\n\n[source,painless]\n----\n\"source\": \"doc['my_field'].value * params['multiplier']\",\n\"params\": {\n  \"multiplier\": 2\n}\n----\n\nYou can compile up to 150 scripts per 5 minutes by default.\nFor ingest contexts, the default script compilation rate is unlimited.\n\n[source,js]\n----\nscript.context.field.max_compilations_rate=100/10m\n----\n// NOTCONSOLE\n\nIMPORTANT: If you compile too many unique scripts within a short time, {es}\nrejects the new dynamic scripts with a `circuit_breaking_exception` error.\n\n[discrete]\n[[script-shorten-syntax]]\n=== Shorten your script\nUsing syntactic abilities that are native to Painless, you can reduce verbosity\nin your scripts and make them shorter. Here's a simple script that we can make\nshorter:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"script_fields\": {\n    \"my_doubled_field\": {\n      \"script\": {\n        \"lang\":   \"painless\",\n        \"source\": \"doc['my_field'].value * params.get('multiplier');\",\n        \"params\": {\n          \"multiplier\": 2\n        }\n      }\n    }\n  }\n}\n----\n// TEST[s/^/PUT my-index-000001\\n/]\n\nLet's look at a shortened version of the script to see what improvements it\nincludes over the previous iteration:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"script_fields\": {\n    \"my_doubled_field\": {\n      \"script\": {\n        \"source\": \"field('my_field').get(null) * params['multiplier']\",\n        \"params\": {\n          \"multiplier\": 2\n        }\n      }\n    }\n  }\n}\n----\n// TEST[s/^/PUT my-index-000001\\n/]\n\nThis version of the script removes several components and simplifies the syntax\nsignificantly:\n\n* The `lang` declaration. Because Painless is the default language, you don't\nneed to specify the language if you're writing a Painless script.\n* The `return` keyword. Painless automatically uses the final statement in a\nscript (when possible) to produce a return value in a script context that\nrequires one.\n* The `get` method, which is replaced with brackets `[]`. Painless\nuses a shortcut specifically for the `Map` type that allows us to use brackets\ninstead of the lengthier `get` method.\n* The semicolon at the end of the `source` statement. Painless does not\nrequire semicolons for the final statement of a block. However, it does require\nthem in other cases to remove ambiguity.\n\nUse this abbreviated syntax anywhere that {es} supports scripts, such as\nwhen you're creating <<runtime-mapping-fields,runtime fields>>.\n\n[discrete]\n[[script-stored-scripts]]\n=== Store and retrieve scripts\nYou can store and retrieve scripts from the cluster state using the\n<<stored-script-apis,stored script APIs>>. Stored scripts reduce compilation\ntime and make searches faster.\n\nNOTE: Unlike regular scripts, stored scripts require that you specify a script\nlanguage using the `lang` parameter.\n\nTo create a script, use the <<create-stored-script-api,create stored script\nAPI>>. For example, the following request creates a stored script named\n`calculate-score`.\n\n[source,console]\n----\nPOST _scripts/calculate-score\n{\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"Math.log(_score * 2) + params['my_modifier']\"\n  }\n}\n----\n\nYou can retrieve that script by using the <<get-stored-script-api,get stored\nscript API>>.\n\n[source,console]\n----\nGET _scripts/calculate-score\n----\n// TEST[continued]\n\nTo use the stored script in a query, include the script `id` in the `script`\ndeclaration:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"script_score\": {\n      \"query\": {\n        \"match\": {\n            \"message\": \"some message\"\n        }\n      },\n      \"script\": {\n        \"id\": \"calculate-score\", <1>\n        \"params\": {\n          \"my_modifier\": 2\n        }\n      }\n    }\n  }\n}\n----\n// TEST[setup:my_index]\n// TEST[continued]\n<1> `id` of the stored script\n\nTo delete a stored script, submit a <<delete-stored-script-api,delete stored\nscript API>> request.\n\n[source,console]\n----\nDELETE _scripts/calculate-score\n----\n// TEST[continued]\n\n[discrete]\n[[scripts-update-scripts]]\n=== Update documents with scripts\nYou can use the <<docs-update,update API>> to update documents with a specified\nscript. The script can update, delete, or skip modifying the document. The\nupdate API also supports passing a partial document, which is merged into the\nexisting document.\n\nFirst, let's index a simple document:\n\n[source,console]\n----\nPUT my-index-000001/_doc/1\n{\n  \"counter\" : 1,\n  \"tags\" : [\"red\"]\n}\n----\n\nTo increment the counter, you can submit an update request with the following\nscript:\n\n[source,console]\n----\nPOST my-index-000001/_update/1\n{\n  \"script\" : {\n    \"source\": \"ctx._source.counter += params.count\",\n    \"lang\": \"painless\",\n    \"params\" : {\n      \"count\" : 4\n    }\n  }\n}\n----\n// TEST[continued]\n\nSimilarly, you can use an update script to add a tag to the list of tags.\nBecause this is just a list, the tag is added even it exists:\n\n[source,console]\n----\nPOST my-index-000001/_update/1\n{\n  \"script\": {\n    \"source\": \"ctx._source.tags.add(params['tag'])\",\n    \"lang\": \"painless\",\n    \"params\": {\n      \"tag\": \"blue\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nYou can also remove a tag from the list of tags. The `remove` method of a Java\n`List` is available in Painless. It takes the index of the element you\nwant to remove. To avoid a possible runtime error, you first need to make sure\nthe tag exists. If the list contains duplicates of the tag, this script just\nremoves one occurrence.\n\n[source,console]\n----\nPOST my-index-000001/_update/1\n{\n  \"script\": {\n    \"source\": \"if (ctx._source.tags.contains(params['tag'])) { ctx._source.tags.remove(ctx._source.tags.indexOf(params['tag'])) }\",\n    \"lang\": \"painless\",\n    \"params\": {\n      \"tag\": \"blue\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nYou can also add and remove fields from a document. For example, this script\nadds the field `new_field`:\n\n[source,console]\n----\nPOST my-index-000001/_update/1\n{\n  \"script\" : \"ctx._source.new_field = 'value_of_new_field'\"\n}\n----\n// TEST[continued]\n\nConversely, this script removes the field `new_field`:\n\n[source,console]\n----\nPOST my-index-000001/_update/1\n{\n  \"script\" : \"ctx._source.remove('new_field')\"\n}\n----\n// TEST[continued]\n\nInstead of updating the document, you can also change the operation that is\nexecuted from within the script. For example, this request deletes the document\nif the `tags` field contains `green`. Otherwise it does nothing (`noop`):\n\n[source,console]\n----\nPOST my-index-000001/_update/1\n{\n  \"script\": {\n    \"source\": \"if (ctx._source.tags.contains(params['tag'])) { ctx.op = 'delete' } else { ctx.op = 'none' }\",\n    \"lang\": \"painless\",\n    \"params\": {\n      \"tag\": \"green\"\n    }\n  }\n}\n----\n// TEST[continued]\n\n[[scripts-and-search-speed]]\n=== Scripts, caching, and search speed\n{es} performs a number of optimizations to make using scripts as fast as\npossible. One important optimization is a script cache. The compiled script is\nplaced in a cache so that requests that reference the script do not incur a\ncompilation penalty.\n\nCache sizing is important. Your script cache should be large enough to hold all\nof the scripts that users need to be accessed concurrently.\n\nIf you see a large number of script cache evictions and a rising number of\ncompilations in <<cluster-nodes-stats,node stats>>, your cache might be too\nsmall.\n\nAll scripts are cached by default so that they only need to be recompiled\nwhen updates occur. By default, scripts do not have a time-based expiration.\nYou can change this behavior by using the `script.cache.expire` setting.\nUse the `script.cache.max_size` setting to configure the size of the cache.\n\nNOTE: The size of scripts is limited to 65,535 bytes. Set the value of `script.max_size_in_bytes` to increase that soft limit. If your scripts are\nreally large, then consider using a\n<<modules-scripting-engine,native script engine>>.\n\n[discrete]\n==== Improving search speed\nScripts are incredibly useful, but can't use {es}'s index structures or related\noptimizations. This relationship can sometimes result in slower search speeds.\n\nIf you often use scripts to transform indexed data, you can make search faster\nby transforming data during ingest instead. However, that often means slower\nindex speeds. Let's look at a practical example to illustrate how you can\nincrease search speed.\n\nWhen running searches, it's common to sort results by the sum of two values.\nFor example, consider an index named `my_test_scores` that contains test score\ndata. This index includes two fields of type `long`:\n\n* `math_score`\n* `verbal_score`\n\nYou can run a query with a script that adds these values together. There's\nnothing wrong with this approach, but the query will be slower because the\nscript valuation occurs as part of the request. The following request returns\ndocuments where `grad_year` equals `2099`, and sorts by the results by the\nvaluation of the script.\n\n[source,console]\n----\nGET /my_test_scores/_search\n{\n  \"query\": {\n    \"term\": {\n      \"grad_year\": \"2099\"\n    }\n  },\n  \"sort\": [\n    {\n      \"_script\": {\n        \"type\": \"number\",\n        \"script\": {\n          \"source\": \"doc['math_score'].value + doc['verbal_score'].value\"\n        },\n        \"order\": \"desc\"\n      }\n    }\n  ]\n}\n----\n// TEST[s/^/PUT my_test_scores\\n/]\n\nIf you're searching a small index, then including the script as part of your\nsearch query can be a good solution. If you want to make search faster, you can\nperform this calculation during ingest and index the sum to a field instead.\n\nFirst, we'll add a new field to the index named `total_score`, which will\ncontain sum of the `math_score` and `verbal_score` field values.\n\n[source,console]\n----\nPUT /my_test_scores/_mapping\n{\n  \"properties\": {\n    \"total_score\": {\n      \"type\": \"long\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nNext, use an <<ingest,ingest pipeline>> containing the\n<<script-processor,script processor>> to calculate the sum of `math_score` and\n`verbal_score` and index it in the `total_score` field.\n\n[source,console]\n----\nPUT _ingest/pipeline/my_test_scores_pipeline\n{\n  \"description\": \"Calculates the total test score\",\n  \"processors\": [\n    {\n      \"script\": {\n        \"source\": \"ctx.total_score = (ctx.math_score + ctx.verbal_score)\"\n      }\n    }\n  ]\n}\n----\n// TEST[continued]\n\nTo update existing data, use this pipeline to <<docs-reindex,reindex>> any\ndocuments from `my_test_scores` to a new index named `my_test_scores_2`.\n\n[source,console]\n----\nPOST /_reindex\n{\n  \"source\": {\n    \"index\": \"my_test_scores\"\n  },\n  \"dest\": {\n    \"index\": \"my_test_scores_2\",\n    \"pipeline\": \"my_test_scores_pipeline\"\n  }\n}\n----\n// TEST[continued]\n\nContinue using the pipeline to index any new documents to `my_test_scores_2`.\n\n[source,console]\n----\nPOST /my_test_scores_2/_doc/?pipeline=my_test_scores_pipeline\n{\n  \"student\": \"kimchy\",\n  \"grad_year\": \"2099\",\n  \"math_score\": 1200,\n  \"verbal_score\": 800\n}\n----\n// TEST[continued]\n\nThese changes slow the index process, but allow for faster searches. Instead of\nusing a script, you can sort searches made on `my_test_scores_2` using the\n`total_score` field. The response is near real-time! Though this process slows\ningest time, it greatly increases queries at search time.\n\n[source,console]\n----\nGET /my_test_scores_2/_search\n{\n  \"query\": {\n    \"term\": {\n      \"grad_year\": \"2099\"\n    }\n  },\n  \"sort\": [\n    {\n      \"total_score\": {\n        \"order\": \"desc\"\n      }\n    }\n  ]\n}\n----\n// TEST[continued]\n\n////\n[source,console]\n----\nDELETE /_ingest/pipeline/my_test_scores_pipeline\n----\n// TEST[continued]\n\n////\n\ninclude::dissect-syntax.asciidoc[]\ninclude::grok-syntax.asciidoc[]\n"
}