{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.449068",
        "size": 9093,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "query-dsl-simple-query-string-query",
        "version": "8.15"
    },
    "doc": "[[query-dsl-simple-query-string-query]]\n=== Simple query string query\n++++\n<titleabbrev>Simple query string</titleabbrev>\n++++\n\nReturns documents based on a provided query string, using a parser with a\nlimited but fault-tolerant syntax.\n\nThis query uses a <<simple-query-string-syntax,simple syntax>> to parse and\nsplit the provided query string into terms based on special operators. The query\nthen <<analysis,analyzes>> each term independently before returning matching\ndocuments.\n\nWhile its syntax is more limited than the\n<<query-dsl-query-string-query,`query_string` query>>, the `simple_query_string`\nquery does not return errors for invalid syntax. Instead, it ignores any invalid\nparts of the query string.\n\n[[simple-query-string-query-ex-request]]\n==== Example request\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"simple_query_string\" : {\n        \"query\": \"\\\"fried eggs\\\" +(eggplant | potato) -frittata\",\n        \"fields\": [\"title^5\", \"body\"],\n        \"default_operator\": \"and\"\n    }\n  }\n}\n--------------------------------------------------\n\n\n[[simple-query-string-top-level-params]]\n==== Top-level parameters for `simple_query_string`\n\n`query`::\n(Required, string) Query string you wish to parse and use for search. See <<simple-query-string-syntax>>.\n\n`fields`::\n+\n--\n(Optional, array of strings) Array of fields you wish to search.\n\nThis field accepts wildcard expressions. You also can boost relevance scores for\nmatches to particular fields using a caret (`^`) notation. See\n<<simple-query-string-boost>> for examples.\n\nDefaults to the `index.query.default_field` index setting, which has a default\nvalue of `*`. The `*` value extracts all fields that are eligible to term\nqueries and filters the metadata fields. All extracted fields are then combined\nto build a query if no `prefix` is specified.\n\nWARNING: There is a limit on the number of fields that can be queried at once.\nIt is defined by the `indices.query.bool.max_clause_count`\n<<search-settings,search setting>>, which defaults to `1024`.\n--\n\n`default_operator`::\n+\n--\n(Optional, string) Default boolean logic used to interpret text in the query\nstring if no operators are specified. Valid values are:\n\n`OR` (Default)::\nFor example, a query string of `capital of Hungary` is interpreted as `capital\nOR of OR Hungary`.\n\n`AND`::\nFor example, a query string of `capital of Hungary` is interpreted as `capital\nAND of AND Hungary`.\n--\n\n`analyze_wildcard`::\n(Optional, Boolean) If `true`, the query attempts to analyze wildcard terms in\nthe query string. Defaults to `false`.\n\n`analyzer`::\n(Optional, string) <<analysis,Analyzer>> used to convert text in the\nquery string into tokens. Defaults to the\n<<specify-index-time-analyzer,index-time analyzer>> mapped for the\n`default_field`. If no analyzer is mapped, the index's default analyzer is used.\n\n`auto_generate_synonyms_phrase_query`::\n(Optional, Boolean) If `true`, the parser creates a\n<<query-dsl-match-query-phrase,`match_phrase`>> query for each\n<<token-graphs-multi-position-tokens,multi-position token>>. Defaults to `true`.\nFor examples, see <<simple-query-string-synonyms>>.\n\n`flags`::\n(Optional, string) List of enabled operators for the\n<<simple-query-string-syntax,simple query string syntax>>. Defaults to `ALL`\n(all operators). See <<supported-flags>> for valid values.\n\n`fuzzy_max_expansions`::\n(Optional, integer) Maximum number of terms to which the query expands for fuzzy\nmatching. Defaults to `50`.\n\n`fuzzy_prefix_length`::\n(Optional, integer) Number of beginning characters left unchanged for fuzzy\nmatching. Defaults to `0`.\n\n`fuzzy_transpositions`::\n(Optional, Boolean) If `true`, edits for fuzzy matching include\ntranspositions of two adjacent characters (ab \u2192 ba). Defaults to `true`.\n\n`lenient`::\n(Optional, Boolean) If `true`, format-based errors, such as providing a text\nvalue for a <<number,numeric>> field, are ignored. Defaults to `false`.\n\n`minimum_should_match`::\n(Optional, string) Minimum number of clauses that must match for a document to\nbe returned. See the <<query-dsl-minimum-should-match, `minimum_should_match`\nparameter>> for valid values and more information.\n\n`quote_field_suffix`::\n+\n--\n(Optional, string) Suffix appended to quoted text in the query string.\n\nYou can use this suffix to use a different analysis method for exact matches.\nSee <<mixing-exact-search-with-stemming>>.\n--\n\n\n[[simple-query-string-query-notes]]\n==== Notes\n\n[[simple-query-string-syntax]]\n===== Simple query string syntax\nThe `simple_query_string` query supports the following operators:\n\n* `+` signifies AND operation\n* `|` signifies OR operation\n* `-` negates a single token\n* `\"` wraps a number of tokens to signify a phrase for searching\n* `*` at the end of a term signifies a prefix query\n* `(` and `)` signify precedence\n* `~N` after a word signifies edit distance (fuzziness)\n* `~N` after a phrase signifies slop amount\n\nTo use one of these characters literally, escape it with a preceding backslash\n(`\\`).\n\nThe behavior of these operators may differ depending on the `default_operator`\nvalue. For example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"simple_query_string\": {\n      \"fields\": [ \"content\" ],\n      \"query\": \"foo bar -baz\"\n    }\n  }\n}\n--------------------------------------------------\n\nThis search is intended to only return documents containing `foo` or `bar` that\nalso do **not** contain `baz`. However because of a `default_operator` of `OR`,\nthis search actually returns documents that contain `foo` or `bar` and any\ndocuments that don't contain `baz`. To return documents as intended, change the\nquery string to `foo bar +-baz`.\n\n[[supported-flags]]\n===== Limit operators\nYou can use the `flags` parameter to limit the supported operators for the\nsimple query string syntax.\n\nTo explicitly enable only specific operators, use a `|` separator. For example,\na `flags` value of `OR|AND|PREFIX` disables all operators except `OR`, `AND`,\nand `PREFIX`.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"simple_query_string\": {\n      \"query\": \"foo | bar + baz*\",\n      \"flags\": \"OR|AND|PREFIX\"\n    }\n  }\n}\n--------------------------------------------------\n\n[[supported-flags-values]]\n====== Valid values\nThe available flags are:\n\n`ALL` (Default)::\nEnables all optional operators.\n\n`AND`::\nEnables the `+` AND operator.\n\n`ESCAPE`::\nEnables `\\` as an escape character.\n\n`FUZZY`::\nEnables the `~N` operator after a word, where `N` is an integer denoting the\nallowed edit distance for matching. See <<fuzziness>>.\n\n`NEAR`::\nEnables the `~N` operator, after a phrase where `N` is the maximum number of\npositions allowed between matching tokens. Synonymous to `SLOP`. \n\n`NONE`::\nDisables all operators.\n\n`NOT`::\nEnables the `-` NOT operator.\n\n`OR`::\nEnables the `\\|` OR operator.\n\n`PHRASE`::\nEnables the `\"` quotes operator used to search for phrases.\n\n`PRECEDENCE`::\nEnables the `(` and `)` operators to control operator precedence.\n\n`PREFIX`::\nEnables the `*` prefix operator.\n\n`SLOP`::\nEnables the `~N` operator, after a phrase where `N` is maximum number of\npositions allowed between matching tokens. Synonymous to `NEAR`.\n\n`WHITESPACE`::\nEnables whitespace as split characters.\n\n[[simple-query-string-boost]]\n===== Wildcards and per-field boosts in the `fields` parameter\n\nFields can be specified with wildcards, eg:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"simple_query_string\" : {\n      \"query\":    \"Will Smith\",\n      \"fields\": [ \"title\", \"*_name\" ] <1>\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Query the `title`, `first_name` and `last_name` fields.\n\nIndividual fields can be boosted with the caret (`^`) notation:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"simple_query_string\" : {\n      \"query\" : \"this is a test\",\n      \"fields\" : [ \"subject^3\", \"message\" ] <1>\n    }\n  }\n}\n--------------------------------------------------\n\n<1> The `subject` field is three times as important as the `message` field.\n\n[[simple-query-string-synonyms]]\n===== Multi-position tokens\n\nBy default, the `simple_query_string` query parser creates a\n<<query-dsl-match-query-phrase,`match_phrase`>> query for each\n<<token-graphs-multi-position-tokens,multi-position token>> in the query string.\nFor example, the parser creates a `match_phrase` query for the multi-word\nsynonym `ny, new york`:\n\n`(ny OR (\"new york\"))`\n\nTo match multi-position tokens with an `AND` conjunction instead, set\n`auto_generate_synonyms_phrase_query` to `false`:\n\n[source,console]\n----\nGET /_search\n{\n  \"query\": {\n    \"simple_query_string\": {\n      \"query\": \"ny city\",\n      \"auto_generate_synonyms_phrase_query\": false\n    }\n  }\n}\n----\n\nFor the above example, the parser creates the following\n<<query-dsl-bool-query,`bool`>> query:\n\n`(ny OR (new AND york)) city)`\n\nThis `bool` query matches documents with the term `ny` or the conjunction\n`new AND york`.\n"
}