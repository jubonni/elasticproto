{
    "meta": {
        "size": 20069,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-casting.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-casting",
        "version": "8.15"
    },
    "doc": "[[painless-casting]]\n=== Casting\n\nA cast converts the value of an original type to the equivalent value of a\ntarget type. An implicit cast infers the target type and automatically occurs\nduring certain <<painless-operators, operations>>. An explicit cast specifies\nthe target type and forcefully occurs as its own operation. Use the `cast\noperator '()'` to specify an explicit cast.\n\nRefer to the <<allowed-casts, cast table>> for a quick reference on all\nallowed casts.\n\n*Errors*\n\n* If during a cast there exists no equivalent value for the target type.\n* If an implicit cast is given, but an explicit cast is required.\n\n*Grammar*\n\n[source,ANTLR4]\n----\ncast: '(' TYPE ')' expression\n----\n\n*Examples*\n\n* Valid casts.\n+\n[source,Painless]\n----\nint i = (int)5L;         <1>\nMap m = new HashMap();   <2>\nHashMap hm = (HashMap)m; <3>\n----\n+\n<1> declare `int i`;\n    explicit cast `long 5` to `int 5` -> `int 5`;\n    store `int 5` to `i`\n<2> declare `Map m`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `Map reference` -> `Map reference`;\n    store `Map reference` to `m`\n<3> declare `HashMap hm`;\n    load from `m` -> `Map reference`;\n    explicit cast `Map reference` to `HashMap reference` -> `HashMap reference`;\n    store `HashMap reference` to `hm`\n\n[[numeric-type-casting]]\n==== Numeric Type Casting\n\nA <<primitive-types, numeric type>> cast converts the value of an original\nnumeric type to the equivalent value of a target numeric type. A cast between\ntwo numeric type values results in data loss when the value of the original\nnumeric type is larger than the target numeric type can accommodate. A cast\nbetween an integer type value and a floating point type value can result in\nprecision loss.\n\nThe allowed casts for values of each numeric type are shown as a row in the\nfollowing table:\n\n|====\n|        | byte     | short    | char     | int      | long     | float    | double\n| byte   |          | implicit | implicit | implicit | implicit | implicit | implicit\n| short  | explicit |          | explicit | implicit | implicit | implicit | implicit\n| char   | explicit | explicit |          | implicit | implicit | implicit | implicit\n| int    | explicit | explicit | explicit |          | implicit | implicit | implicit\n| long   | explicit | explicit | explicit | explicit |          | implicit | implicit\n| float  | explicit | explicit | explicit | explicit | explicit |          | implicit\n| double | explicit | explicit | explicit | explicit | explicit | explicit |\n|====\n\n*Examples*\n\n* Valid numeric type casts.\n+\n[source,Painless]\n----\nint a = 1;            <1>\nlong b = a;           <2>\nshort c = (short)b;   <3>\ndouble e = (double)a; <4>\n----\n+\n<1> declare `int a`;\n    store `int 1` to `a`\n<2> declare `long b`;\n    load from `a` -> `int 1`;\n    implicit cast `int 1` to `long 1` -> `long 1`;\n    store `long 1` to `b`\n<3> declare `short c`;\n    load from `b` -> `long 1`;\n    explicit cast `long 1` to `short 1` -> `short 1`;\n    store `short 1` value to `c`\n<4> declare `double e`;\n    load from `a` -> `int 1`;\n    explicit cast `int 1` to `double 1.0`;\n    store `double 1.0` to `e`;\n    (note the explicit cast is extraneous since an implicit cast is valid)\n+\n* Invalid numeric type casts resulting in errors.\n+\n[source,Painless]\n----\nint a = 1.0; // error <1>\nint b = 2;            <2>\nbyte c = b;  // error <3>\n----\n+\n<1> declare `int i`;\n    *error* -> cannot implicit cast `double 1.0` to `int 1`;\n    (note an explicit cast is valid)\n<2> declare `int b`;\n    store `int 2` to `b`\n<3> declare byte `c`;\n    load from `b` -> `int 2`;\n    *error* -> cannot implicit cast `int 2` to `byte 2`;\n    (note an explicit cast is valid)\n\n[[reference-type-casting]]\n==== Reference Type Casting\n\nA <<reference-types, reference type>> cast converts the value of an original\nreference type to the equivalent value of a target reference type. An implicit\ncast between two reference type values is allowed when the original reference\ntype is a descendant of the target type. An explicit cast between two reference\ntype values is allowed when the original type is a descendant of the target type\nor the target type is a descendant of the original type.\n\n*Examples*\n\n* Valid reference type casts.\n+\n[source,Painless]\n----\nList x;                        <1>\nArrayList y = new ArrayList(); <2>\nx = y;                         <3>\ny = (ArrayList)x;              <4>\nx = (List)y;                   <5>\n----\n+\n<1> declare `List x`;\n    store default value `null` to `x`\n<2> declare `ArrayList y`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    store `ArrayList reference` to `y`;\n<3> load from `y` -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `x`;\n    (note `ArrayList` is a descendant of `List`)\n<4> load from `x` -> `List reference`;\n    explicit cast `List reference` to `ArrayList reference`\n            -> `ArrayList reference`;\n    store `ArrayList reference` to `y`;\n<5> load from `y` -> `ArrayList reference`;\n    explicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `x`;\n    (note the explicit cast is extraneous, and an implicit cast is valid)\n+\n* Invalid reference type casts resulting in errors.\n+\n[source,Painless]\n----\nList x = new ArrayList();          <1>\nArrayList y = x;          // error <2>\nMap m = (Map)x;           // error <3>\n----\n+\n<1> declare `List x`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `x`\n<2> declare `ArrayList y`;\n    load from `x` -> `List reference`;\n    *error* -> cannot implicit cast `List reference` to `ArrayList reference`;\n    (note an explicit cast is valid since `ArrayList` is a descendant of `List`)\n<3> declare `ArrayList y`;\n    load from `x` -> `List reference`;\n    *error* -> cannot explicit cast `List reference` to `Map reference`;\n    (note no cast is valid since neither `List` nor `Map` is a descendant of the\n            other)\n\n[[dynamic-type-casting]]\n==== Dynamic Type Casting\n\nA <<dynamic-types, dynamic (`def`) type>> cast converts the value of an original\n`def` type to the equivalent value of any target type or converts the value of\nany original type to the equivalent value of a target `def` type.\n\nAn implicit cast from any original type value to a `def` type value is always\nallowed. An explicit cast from any original type value to a `def` type value is\nalways allowed but never necessary.\n\nAn implicit or explicit cast from an original `def` type value to\nany target type value is allowed if and only if the cast is normally allowed\nbased on the current type value the `def` type value represents.\n\n*Examples*\n\n* Valid dynamic type casts with any original type to a target `def` type.\n+\n[source,Painless]\n----\ndef d0 = 3;               <1>\nd0 = new ArrayList();     <2>\nObject o = new HashMap(); <3>\ndef d1 = o;               <4>\nint i = d1.size();        <5>\n----\n+\n<1> declare `def d0`;\n    implicit cast `int 3` to `def`;\n    store `int 3` to `d0`\n<2> allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `def` -> `def`;\n    store `def` to `d0`\n<3> declare `Object o`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `Object reference`\n            -> `Object reference`;\n    store `Object reference` to `o`\n<4> declare `def d1`;\n    load from `o` -> `Object reference`;\n    implicit cast `Object reference` to `def` -> `def`;\n    store `def` to `d1`\n<5> declare `int i`;\n    load from `d1` -> `def`;\n    implicit cast `def` to `HashMap reference` -> HashMap reference`;\n    call `size` on `HashMap reference` -> `int 0`;\n    store `int 0` to `i`;\n    (note `def` was implicit cast to `HashMap reference` since `HashMap` is the\n            child-most descendant type value that the `def` type value\n            represents)\n+\n* Valid dynamic type casts with an original `def` type to any target type.\n+\n[source,Painless]\n----\ndef d = 1.0;         <1>\nint i = (int)d;      <2>\nd = 1;               <3>\nfloat f = d;         <4>\nd = new ArrayList(); <5>\nList l = d;          <6>\n----\n+\n<1> declare `def d`;\n    implicit cast `double 1.0` to `def` -> `def`;\n    store `def` to `d`\n<2> declare `int i`;\n    load from `d` -> `def`;\n    implicit cast `def` to `double 1.0` -> `double 1.0`;\n    explicit cast `double 1.0` to `int 1` -> `int 1`;\n    store `int 1` to `i`;\n    (note the explicit cast is necessary since a `double` type value is not\n            converted to an `int` type value implicitly)\n<3> store `int 1` to `d`;\n    (note the switch in the type `d` represents from `double` to `int`)\n<4> declare `float i`;\n    load from `d` -> `def`;\n    implicit cast `def` to `int 1` -> `int 1`;\n    implicit cast `int 1` to `float 1.0` -> `float 1.0`;\n    store `float 1.0` to `f`\n<5> allocate `ArrayList` instance -> `ArrayList reference`;\n    store `ArrayList reference` to `d`;\n    (note the switch in the type `d` represents from `int` to `ArrayList`)\n<6> declare `List l`;\n    load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `l`\n+\n* Invalid dynamic type casts resulting in errors.\n+\n[source,Painless]\n----\ndef d = 1;                  <1>\nshort s = d;       // error <2>\nd = new HashMap();          <3>\nList l = d;        // error <4>\n----\n<1> declare `def d`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `d`\n<2> declare `short s`;\n    load from `d` -> `def`;\n    implicit cast `def` to `int 1` -> `int 1`;\n    *error* -> cannot implicit cast `int 1` to `short 1`;\n    (note an explicit cast is valid)\n<3> allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `def` -> `def`;\n    store `def` to `d`\n<4> declare `List l`;\n    load from `d` -> `def`;\n    implicit cast `def` to `HashMap reference`;\n    *error* -> cannot implicit cast `HashMap reference` to `List reference`;\n    (note no cast is valid since neither `HashMap` nor `List` is a descendant of\n            the other)\n\n[[string-character-casting]]\n==== String to Character Casting\n\nUse the cast operator to convert a <<string-type, `String` type>> value into a\n<<primitive-types, `char` type>> value.\n\n*Errors*\n\n* If the `String` type value isn't one character in length.\n* If the `String` type value is `null`.\n\n*Examples*\n\n* Casting string literals into `char` type values.\n+\n[source,Painless]\n----\nchar c = (char)\"C\"; <1>\nc = (char)'c';      <2>\n----\n+\n<1> declare `char c`;\n    explicit cast `String \"C\"` to `char C` -> `char C`;\n    store `char C` to `c`\n<2> explicit cast `String 'c'` to `char c` -> `char c`;\n    store `char c` to `c`\n+\n* Casting a `String` reference into a `char` type value.\n+\n[source,Painless]\n----\nString s = \"s\";   <1>\nchar c = (char)s; <2>\n----\n<1> declare `String s`;\n    store `String \"s\"` to `s`;\n<2> declare `char c`\n    load from `s` -> `String \"s\"`;\n    explicit cast `String \"s\"` to `char s` -> `char s`;\n    store `char s` to `c`\n\n[[character-string-casting]]\n==== Character to String Casting\n\nUse the cast operator to convert a <<primitive-types, `char` type>> value into a\n<<string-type, `String` type>> value.\n\n*Examples*\n\n* Casting a `String` reference into a `char` type value.\n+\n[source,Painless]\n----\nchar c = 65;          <1>\nString s = (String)c; <2>\n----\n<1> declare `char c`;\n    store `char 65` to `c`;\n<2> declare `String s`\n    load from `c` -> `char A`;\n    explicit cast `char A` to `String \"A\"` -> `String \"A\"`;\n    store `String \"A\"` to `s`\n\n[[boxing-unboxing]]\n==== Boxing and Unboxing\n\nBoxing is a special type of cast used to convert a primitive type to its\ncorresponding reference type. Unboxing is the reverse used to convert a\nreference type to its corresponding primitive type.\n\nImplicit boxing/unboxing occurs during the following operations:\n\n* Conversions between a `def` type and a primitive type are implicitly\n  boxed/unboxed as necessary, though this is referred to as an implicit cast\n  throughout the documentation.\n* Method/function call arguments are implicitly boxed/unboxed as necessary.\n* A primitive type value is implicitly boxed when a reference type method\n  is called on it.\n\nExplicit boxing/unboxing is not allowed. Use the reference type API to\nexplicitly convert a primitive type value to its respective reference type\nvalue and vice versa.\n\n*Errors*\n\n* If an explicit cast is made to box/unbox a primitive type.\n\n*Examples*\n\n* Uses of implicit boxing/unboxing.\n+\n[source,Painless]\n----\nList l = new ArrayList();       <1>\nl.add(1);                       <2>\nInteger I = Integer.valueOf(0); <3>\nint i = l.get(i);               <4>\n----\n+\n<1> declare `List l`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    store `ArrayList reference` to `l`;\n<2> load from `l` -> `List reference`;\n    implicit cast `int 1` to `def` -> `def`;\n    call `add` on `List reference` with arguments (`def`);\n    (note internally `int 1` is boxed to `Integer 1` to store as a `def` type\n            value)\n<3> declare `Integer I`;\n    call `valueOf` on `Integer` with arguments of (`int 0`) -> `Integer 0`;\n    store `Integer 0` to `I`;\n<4> declare `int i`;\n    load from `I` -> `Integer 0`;\n    unbox `Integer 0` -> `int 0`;\n    load from `l` -> `List reference`;\n    call `get` on `List reference` with arguments (`int 0`) -> `def`;\n    implicit cast `def` to `int 1` -> `int 1`;\n    store `int 1` to `i`;\n    (note internally `int 1` is unboxed from `Integer 1` when loaded from a\n            `def` type value)\n+\n* Uses of invalid boxing/unboxing resulting in errors.\n+\n[source,Painless]\n----\nInteger x = 1;                   // error <1>\nInteger y = (Integer)1;          // error <2>\nint a = Integer.valueOf(1);      // error <3>\nint b = (int)Integer.valueOf(1); // error <4>\n----\n+\n<1> declare `Integer x`;\n    *error* -> cannot implicit box `int 1` to `Integer 1` during assignment\n<2> declare `Integer y`;\n    *error* -> cannot explicit box `int 1` to `Integer 1` during assignment\n<3> declare `int a`;\n    call `valueOf` on `Integer` with arguments of (`int 1`) -> `Integer 1`;\n    *error* -> cannot implicit unbox `Integer 1` to `int 1` during assignment\n<4> declare `int a`;\n    call `valueOf` on `Integer` with arguments of (`int 1`) -> `Integer 1`;\n    *error* -> cannot explicit unbox `Integer 1` to `int 1` during assignment\n\n[[promotion]]\n==== Promotion\n\nPromotion is when a single value is implicitly cast to a certain type or\nmultiple values are implicitly cast to the same type as required for evaluation\nby certain operations. Each operation that requires promotion has a promotion\ntable that shows all required implicit casts based on the type(s) of value(s). A\nvalue promoted to a `def` type at compile-time is promoted again at run-time\nbased on the type the `def` value represents.\n\n*Errors*\n\n* If a specific operation cannot find an allowed promotion type for the type(s)\n  of value(s) given.\n\n*Examples*\n\n* Uses of promotion.\n+\n[source,Painless]\n----\ndouble d = 2 + 2.0; <1>\ndef x = 1;          <2>\nfloat f = x + 2.0F; <3>\n----\n<1> declare `double d`;\n    promote `int 2` and `double 2.0 @0`: result `double`;\n    implicit cast `int 2` to `double 2.0 @1` -> `double 2.0 @1`;\n    add `double 2.0 @1` and `double 2.0 @0` -> `double 4.0`;\n    store `double 4.0` to `d`\n<2> declare `def x`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `x`;\n<3> declare `float f`;\n    load from `x` -> `def`;\n    implicit cast `def` to `int 1` -> `int 1`;\n    promote `int 1` and `float 2.0`: result `float`;\n    implicit cast `int 1` to `float 1.0` -> `float `1.0`;\n    add `float 1.0` and `float 2.0` -> `float 3.0`;\n    store `float 3.0` to `f`;\n    (note this example illustrates promotion done at run-time as promotion\n            done at compile-time would have resolved to a `def` type value)\n\n[[allowed-casts]]\n==== Allowed Casts\n\nThe following tables show all allowed casts. Read the tables row by row, where\nthe original type is shown in the first column, and each subsequent column\nindicates whether a cast to the specified target type is implicit (I),\nexplicit (E), boxed/unboxed for methods only (A), a reference type cast (@),\nor is not allowed (-). See <<reference-type-casting, reference type casting>>\nfor allowed reference type casts.\n\n*Primitive/Reference Types*\n\n[cols=\"<3,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|                 | O | N | T | b | y | s | c | i | j | f | d | B | Y | S | C | I | J | F | D | R | def\n| Object    ( O ) |   | @ | @ | - | - | - | - | - | - | - | - | @ | @ | @ | @ | @ | @ | @ | @ | @ | I\n| Number    ( N ) | I |   | - | - | - | - | - | - | - | - | - | - | @ | @ | - | @ | @ | @ | @ | @ | I\n| String    ( T ) | I | - |   | - | - | - | - | - | - | - | - | - | - | - | E | - | - | - | - | - | I\n| boolean   ( b ) | A | - | - |   | - | - | - | - | - | - | - | A | - | - | - | - | - | - | - | - | I\n| byte      ( y ) | A | A | - | - |   | I | E | I | I | I | I | - | A | A | - | A | A | A | A | - | I\n| short     ( s ) | A | A | - | - | E |   | E | I | I | I | I | - | - | A | - | A | A | A | A | - | I\n| char      ( c ) | A | - | E | - | E | E |   | I | I | I | I | - | - | - | A | A | A | A | A | - | I\n| int       ( i ) | A | A | - | - | E | E | E |   | I | I | I | - | - | - | - | A | A | A | A | - | I\n| long      ( j ) | A | A | - | - | E | E | E | E |   | I | I | - | - | - | - | - | A | A | A | - | I\n| float     ( f ) | A | A | - | - | E | E | E | E | E |   | I | - | - | - | - | - | - | A | A | - | I\n| double    ( d ) | A | A | - | - | E | E | E | E | E | E |   | - | - | - | - | - | - | - | A | - | I\n| Boolean   ( B ) | A | - | - | A | - | - | - | - | - | - | - |   | - | - | - | - | - | - | - | @ | I\n| Byte      ( Y ) | A | I | - | - | A | A | - | A | A | A | A | - |   | A | - | A | A | A | A | @ | I\n| Short     ( S ) | A | I | - | - | - | A | - | A | A | A | A | - | - |   | - | A | A | A | A | @ | I\n| Character ( C ) | A | - | - | - | - | - | A | A | A | A | A | - | - | - |   | A | A | A | A | @ | I\n| Integer   ( I ) | A | - | - | - | - | - | - | A | A | A | A | - | - | - | - |   | A | A | A | @ | I\n| Long      ( J ) | A | - | - | - | - | - | - | - | A | A | A | - | - | - | - | - |   | A | A | @ | I\n| Float     ( F ) | A | - | - | - | - | - | - | - | - | A | A | - | - | - | - | - | - |   | A | @ | I\n| Double    ( D ) | A | - | - | - | - | - | - | - | - | - | A | - | - | - | - | - | - | - |   | @ | I\n| Reference ( R ) | I | @ | @ | - | - | - | - | - | - | - | - | @ | @ | @ | @ | @ | @ | @ | @ | @ | I\n|====\n\n*`def` Type*\n\n[cols=\"<3,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|                        | O | N | T | b | y | s | c | i | j | f | d | B | Y | S | C | I | J | F | D | R\n| def as String          | I | - | I | - | - | - | E | - | - | - | - | - | - | - | E | - | - | - | - | @\n| def as boolean/Boolean | I | - | - | I | - | - | - | - | - | - | - | I | - | - | - | - | - | - | - | @\n| def as byte/Byte       | I | - | - | - | I | I | E | I | I | I | I | - | I | I | E | I | I | I | I | @\n| def as short/Short     | I | - | - | - | E | I | E | I | I | I | I | - | E | I | E | I | I | I | I | @\n| def as char/Character  | I | - | - | - | E | E | I | I | I | I | I | - | E | E | I | I | I | I | I | @\n| def as int/Integer     | I | - | - | - | E | E | E | I | I | I | I | - | E | E | E | I | I | I | I | @\n| def as long/Long       | I | - | - | - | E | E | E | E | I | I | I | - | E | E | E | E | I | I | I | @\n| def as float/Float     | I | - | - | - | E | E | E | E | E | I | I | - | E | E | E | E | E | I | I | @\n| def as double/Double   | I | - | - | - | E | E | E | E | E | E | I | - | E | E | E | E | E | E | I | @\n| def as Reference       | @ | @ | @ | - | - | - | - | - | - | - | - | @ | @ | @ | @ | @ | @ | @ | @ | @\n|====\n"
}