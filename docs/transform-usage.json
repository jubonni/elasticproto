{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.814070",
        "size": 3052,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/transform-usage.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "transform-usage",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[transform-usage]]\n= When to use {transforms}\n\n{es} aggregations are a powerful and flexible feature that enable you to\nsummarize and retrieve complex insights about your data. You can summarize\ncomplex things like the number of web requests per day on a busy website, broken\ndown by geography and browser type. If you use the same data set to try to\ncalculate something as simple as a single number for the average duration of\nvisitor web sessions, however, you can quickly run out of memory.\n\nWhy does this occur? A web session duration is an example of a behavioral\nattribute not held on any one log record; it has to be derived by finding the\nfirst and last records for each session in our weblogs. This derivation requires\nsome complex query expressions and a lot of memory to connect all the data\npoints. If you have an ongoing background process that fuses related events from\none index into entity-centric summaries in another index, you get a more useful,\njoined-up picture. This new index is sometimes referred to as a _{dataframe}_.\n\nYou might want to consider using {transforms} instead of aggregations when:\n\n* You need a complete _feature index_ rather than a top-N set of items.\n+\nIn {ml}, you often need a complete set of behavioral features rather just the\ntop-N. For example, if you are predicting customer churn, you might look at\nfeatures such as the number of website visits in the last week, the total number\nof sales, or the number of emails sent. The {stack} {ml-features} create models\nbased on this multi-dimensional feature space, so they benefit from the full\nfeature indices that are created by {transforms}.\n+\nThis scenario also applies when you are trying to search across the results of\nan aggregation or multiple aggregations. Aggregation results can be ordered or\nfiltered, but there are\n{ref}/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-order[limitations to ordering]\nand\n{ref}/search-aggregations-pipeline-bucket-selector-aggregation.html[filtering by bucket selector]\nis constrained by the maximum number of buckets returned. If you want to search\nall aggregation results, you need to create the complete {dataframe}. If you\nneed to sort or filter the aggregation results by multiple fields, {transforms}\nare particularly useful.\n\n* You need to sort aggregation results by a pipeline aggregation.\n+\n{ref}/search-aggregations-pipeline.html[Pipeline aggregations] cannot be used\nfor sorting. Technically, this is because pipeline aggregations are run during\nthe reduce phase after all other aggregations have already completed. If you\ncreate a {transform}, you can effectively perform multiple passes over the data.\n\n* You want to create summary tables to optimize queries.\n+\nFor example, if you\nhave a high level dashboard that is accessed by a large number of users and it\nuses a complex aggregation over a large dataset, it may be more efficient to\ncreate a {transform} to cache results. Thus, each user doesn't need to run the\naggregation query.\n"
}