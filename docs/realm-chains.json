{
    "meta": {
        "size": 4403,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/realm-chains.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "realm-chains",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[realm-chains]]\n=== Realm chains\n\n<<realms,Realms>> live within a _realm chain_. It is essentially a prioritized\nlist of configured realms (typically of various types). Realms are consulted in\nascending order (that is to say, the realm with the lowest `order` value is\nconsulted first). You must make sure each configured realm has a distinct\n`order` setting. In the event that two or more realms have the same `order`,\nthe node will fail to start.\n\nDuring the authentication process, {stack} {security-features} consult and try\nto authenticate the request one realm at a time. Once one of the realms\nsuccessfully authenticates the request, the authentication is considered to be\nsuccessful. The authenticated user is associated with the request, which then\nproceeds to the authorization phase. If a realm cannot authenticate the request,\nthe next realm in the chain is consulted. If all realms in the chain cannot\nauthenticate the request, the authentication is considered to be unsuccessful\nand an authentication error is returned (as HTTP status code `401`).\n\nNOTE: Some systems (e.g. Active Directory) have a temporary lock-out period\nafter several successive failed login attempts. If the same username exists in\nmultiple realms, unintentional account lockouts are possible. For more\ninformation, see <<trouble-shoot-active-directory>>.\n\nThe default realm chain contains the `file` and `native` realms. To explicitly\nconfigure a realm chain, you specify the chain in the `elasticsearch.yml` file.\nIf your realm chain does not contain `file` or `native` realm or does not disable\nthem explicitly, `file` and `native` realms will be added automatically to the\nbeginning of the realm chain in that order. To opt-out from the automatic behaviour,\nyou can explicitly configure the `file` and `native` realms with the `order`\nand `enabled` settings.\n\nThe following snippet configures a realm chain that enables the `file` realm\nas well as two LDAP realms and an Active Directory realm, but disables the\n`native` realm.\n\n[source,yaml]\n----------------------------------------\nxpack.security.authc.realms:\n  file.file1:\n      order: 0\n\n  ldap.ldap1:\n      order: 1\n      enabled: false\n      url: 'url_to_ldap1'\n      ...\n\n  ldap.ldap2:\n      order: 2\n      url: 'url_to_ldap2'\n      ...\n\n  active_directory.ad1:\n      order: 3\n      url: 'url_to_ad'\n\n  native.native1:\n      enabled: false\n----------------------------------------\n\nAs can be seen above, each realm has a unique name that identifies it. Each type\nof realm dictates its own set of required and optional settings. That said,\nthere are\n<<ref-realm-settings,settings that are common to all realms>>.\n\n[[authorization_realms]]\n==== Delegating authorization to another realm\n\nSome realms have the ability to perform _authentication_ internally, but\ndelegate the lookup and assignment of roles (that is, _authorization_) to\nanother realm.\n\nFor example, you may wish to use a PKI realm to authenticate your users with\nTLS client certificates, then lookup that user in an LDAP realm and use their\nLDAP group assignments to determine their roles in Elasticsearch.\n\nAny realm that supports retrieving users (without needing their credentials) can\nbe used as an _authorization realm_ (that is, its name may appear as one of the\nvalues in the list of `authorization_realms`). See <<user-lookup>> for\nfurther explanation on which realms support this.\n\nFor realms that support this feature, it can be enabled by configuring the\n`authorization_realms` setting on the authenticating realm. Check the list of\n<<realm-settings,supported settings>> for each realm\nto see if they support the `authorization_realms` setting.\n\nIf delegated authorization is enabled for a realm, it authenticates the user in\nits standard manner (including relevant caching) then looks for that user in the\nconfigured list of authorization realms. It tries each realm in the order they\nare specified in the `authorization_realms` setting. The user is retrieved by\nprincipal - the user must have identical usernames in the _authentication_ and\n_authorization realms_. If the user cannot be found in any of the authorization\nrealms, authentication fails.\n\nSee <<configuring-authorization-delegation>> for more details.\n\nNOTE: Delegated authorization requires that you have a\n{subscriptions}[subscription] that includes custom authentication and\nauthorization realms.\n"
}