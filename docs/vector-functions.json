{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.836071",
        "size": 9997,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/vector-functions.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "vector-functions",
        "version": "8.15"
    },
    "doc": "[[vector-functions]]\n===== Functions for vector fields\n\nNOTE: During vector functions' calculation, all matched documents are\nlinearly scanned. Thus, expect the query time grow linearly\nwith the number of matched documents. For this reason, we recommend\nto limit the number of matched documents with a `query` parameter.\n\nThis is the list of available vector functions and vector access methods:\n\n1. <<vector-functions-cosine,`cosineSimilarity`>> \u2013 calculates cosine similarity\n2. <<vector-functions-dot-product,`dotProduct`>> \u2013 calculates dot product\n3. <<vector-functions-l1,`l1norm`>> \u2013 calculates L^1^ distance\n4. <<vector-functions-hamming,`hamming`>> \u2013 calculates Hamming distance\n5. <<vector-functions-l2,`l2norm`>> - calculates L^2^ distance\n6. <<vector-functions-accessing-vectors,`doc[<field>].vectorValue`>> \u2013 returns a vector's value as an array of floats\n7. <<vector-functions-accessing-vectors,`doc[<field>].magnitude`>> \u2013 returns a vector's magnitude\n\nNOTE: The `cosineSimilarity` and `dotProduct` functions are not supported for `bit` vectors.\n\nNOTE: The recommended way to access dense vectors is through the\n`cosineSimilarity`, `dotProduct`, `l1norm` or `l2norm` functions. Please note\nhowever, that you should call these functions only once per script. For example,\ndon\u2019t use these functions in a loop to calculate the similarity between a\ndocument vector and multiple other vectors. If you need that functionality,\nreimplement these functions yourself by\n<<vector-functions-accessing-vectors,accessing vector values directly>>.\n\nLet's create an index with a `dense_vector` mapping and index a couple\nof documents into it.\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my_dense_vector\": {\n        \"type\": \"dense_vector\",\n        \"index\": false,\n        \"dims\": 3\n      },\n      \"my_byte_dense_vector\": {\n        \"type\": \"dense_vector\",\n        \"index\": false,\n        \"dims\": 3,\n        \"element_type\": \"byte\"\n      },\n      \"status\" : {\n        \"type\" : \"keyword\"\n      }\n    }\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  \"my_dense_vector\": [0.5, 10, 6],\n  \"my_byte_dense_vector\": [0, 10, 6],\n  \"status\" : \"published\"\n}\n\nPUT my-index-000001/_doc/2\n{\n  \"my_dense_vector\": [-0.5, 10, 10],\n  \"my_byte_dense_vector\": [0, 10, 10],\n  \"status\" : \"published\"\n}\n\nPOST my-index-000001/_refresh\n\n--------------------------------------------------\n// TESTSETUP\n\n[[vector-functions-cosine]]\n====== Cosine similarity\n\nThe `cosineSimilarity` function calculates the measure of\ncosine similarity between a given query vector and document vectors.\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"script_score\": {\n      \"query\" : {\n        \"bool\" : {\n          \"filter\" : {\n            \"term\" : {\n              \"status\" : \"published\" <1>\n            }\n          }\n        }\n      },\n      \"script\": {\n        \"source\": \"cosineSimilarity(params.query_vector, 'my_dense_vector') + 1.0\", <2>\n        \"params\": {\n          \"query_vector\": [4, 3.4, -0.2]  <3>\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> To restrict the number of documents on which script score calculation is applied, provide a filter.\n<2> The script adds 1.0 to the cosine similarity to prevent the score from being negative.\n<3> To take advantage of the script optimizations, provide a query vector as a script parameter.\n\nNOTE: If a document's dense vector field has a number of dimensions\ndifferent from the query's vector, an error will be thrown.\n\n[[vector-functions-dot-product]]\n====== Dot product\n\nThe `dotProduct` function calculates the measure of\ndot product between a given query vector and document vectors.\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"script_score\": {\n      \"query\" : {\n        \"bool\" : {\n          \"filter\" : {\n            \"term\" : {\n              \"status\" : \"published\"\n            }\n          }\n        }\n      },\n      \"script\": {\n        \"source\": \"\"\"\n          double value = dotProduct(params.query_vector, 'my_dense_vector');\n          return sigmoid(1, Math.E, -value); <1>\n        \"\"\",\n        \"params\": {\n          \"query_vector\": [4, 3.4, -0.2]\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Using the standard sigmoid function prevents scores from being negative.\n\n[[vector-functions-l1]]\n====== L^1^ distance (Manhattan distance)\n\nThe `l1norm` function calculates L^1^ distance\n(Manhattan distance) between a given query vector and\ndocument vectors.\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"script_score\": {\n      \"query\" : {\n        \"bool\" : {\n          \"filter\" : {\n            \"term\" : {\n              \"status\" : \"published\"\n            }\n          }\n        }\n      },\n      \"script\": {\n        \"source\": \"1 / (1 + l1norm(params.queryVector, 'my_dense_vector'))\", <1>\n        \"params\": {\n          \"queryVector\": [4, 3.4, -0.2]\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Unlike `cosineSimilarity` that represent similarity, `l1norm` and\n`l2norm` shown below represent distances or differences. This means, that\nthe more similar the vectors are, the lower the scores will be that are\nproduced by the `l1norm` and `l2norm` functions.\nThus, as we need more similar vectors to score higher,\nwe reversed the output from `l1norm` and `l2norm`. Also, to avoid\ndivision by 0 when a document vector matches the query exactly,\nwe added `1` in the denominator.\n\n[[vector-functions-hamming]]\n====== Hamming distance\n\nThe `hamming` function calculates {wikipedia}/Hamming_distance[Hamming distance] between a given query vector and\ndocument vectors. It is only available for byte and bit vectors.\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"script_score\": {\n      \"query\" : {\n        \"bool\" : {\n          \"filter\" : {\n            \"term\" : {\n              \"status\" : \"published\"\n            }\n          }\n        }\n      },\n      \"script\": {\n        \"source\": \"(24 - hamming(params.queryVector, 'my_byte_dense_vector')) / 24\", <1>\n        \"params\": {\n          \"queryVector\": [4, 3, 0]\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Calculate the Hamming distance and normalize it by the bits to get a score between 0 and 1.\n\n[[vector-functions-l2]]\n====== L^2^ distance (Euclidean distance)\n\nThe `l2norm` function calculates L^2^ distance\n(Euclidean distance) between a given query vector and\ndocument vectors.\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"script_score\": {\n      \"query\" : {\n        \"bool\" : {\n          \"filter\" : {\n            \"term\" : {\n              \"status\" : \"published\"\n            }\n          }\n        }\n      },\n      \"script\": {\n        \"source\": \"1 / (1 + l2norm(params.queryVector, 'my_dense_vector'))\",\n        \"params\": {\n          \"queryVector\": [4, 3.4, -0.2]\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n[[vector-functions-missing-values]]\n====== Checking for missing values\n\nIf a document doesn't have a value for a vector field on which a vector function\nis executed, an error will be thrown.\n\nYou can check if a document has a value for the field `my_vector` with\n`doc['my_vector'].size() == 0`. Your overall script can look like this:\n\n[source,js]\n--------------------------------------------------\n\"source\": \"doc['my_vector'].size() == 0 ? 0 : cosineSimilarity(params.queryVector, 'my_vector')\"\n--------------------------------------------------\n// NOTCONSOLE\n\n[[vector-functions-accessing-vectors]]\n====== Accessing vectors directly\n\nYou can access vector values directly through the following functions:\n\n- `doc[<field>].vectorValue` \u2013 returns a vector's value as an array of floats\n\nNOTE: For `bit` vectors, it does return a `float[]`, where each element represents 8 bits.\n\n- `doc[<field>].magnitude` \u2013 returns a vector's magnitude as a float\n(for vectors created prior to version 7.5 the magnitude is not stored.\nSo this function calculates it anew every time it is called).\n\nNOTE: For `bit` vectors, this is just the square root of the sum of `1` bits.\n\nFor example, the script below implements a cosine similarity using these\ntwo functions:\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"script_score\": {\n      \"query\" : {\n        \"bool\" : {\n          \"filter\" : {\n            \"term\" : {\n              \"status\" : \"published\"\n            }\n          }\n        }\n      },\n      \"script\": {\n        \"source\": \"\"\"\n          float[] v = doc['my_dense_vector'].vectorValue;\n          float vm = doc['my_dense_vector'].magnitude;\n          float dotProduct = 0;\n          for (int i = 0; i < v.length; i++) {\n            dotProduct += v[i] * params.queryVector[i];\n          }\n          return dotProduct / (vm * (float) params.queryVectorMag);\n        \"\"\",\n        \"params\": {\n          \"queryVector\": [4, 3.4, -0.2],\n          \"queryVectorMag\": 5.25357\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n[[vector-functions-bit-vectors]]\n====== Bit vectors and vector functions\n\nWhen using `bit` vectors, not all the vector functions are available. The supported functions are:\n\n* <<vector-functions-hamming,`hamming`>> \u2013 calculates Hamming distance, the sum of the bitwise XOR of the two vectors\n* <<vector-functions-l1,`l1norm`>> \u2013 calculates L^1^ distance, this is simply the `hamming` distance\n* <<vector-functions-l2,`l2norm`>> - calculates L^2^ distance, this is the square root of the `hamming` distance\n\nCurrently, the `cosineSimilarity` and `dotProduct` functions are not supported for `bit` vectors.\n\n"
}