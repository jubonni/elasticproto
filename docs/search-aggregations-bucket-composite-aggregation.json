{
    "meta": {
        "timestamp": "2024-11-01T02:49:24.685079",
        "size": 27095,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-bucket-composite-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-composite-aggregation]]\n=== Composite aggregation\n++++\n<titleabbrev>Composite</titleabbrev>\n++++\n\nWARNING: The composite aggregation is expensive. Load test your application\nbefore deploying a composite aggregation in production.\n\nA multi-bucket aggregation that creates composite buckets from different sources.\n\nUnlike the other `multi-bucket` aggregations, you can use the `composite`\naggregation to paginate **all** buckets from a multi-level aggregation\nefficiently. This aggregation provides a way to stream **all** buckets of a\nspecific aggregation, similar to what\n<<scroll-search-results, scroll>> does for documents.\n\nThe composite buckets are built from the combinations of the\nvalues extracted/created for each document and each combination is considered as\na composite bucket.\n\n//////////////////////////\n\n[source,console]\n--------------------------------------------------\nPUT /sales\n{\n  \"mappings\": {\n    \"properties\": {\n      \"product\": {\n          \"type\": \"keyword\"\n      },\n      \"timestamp\": {\n          \"type\": \"date\"\n      },\n      \"price\": {\n          \"type\": \"long\"\n      },\n      \"shop\": {\n          \"type\": \"keyword\"\n      },\n      \"location\": {\n          \"type\": \"geo_point\"\n      },\n      \"nested\": {\n          \"type\": \"nested\",\n          \"properties\": {\n            \"product\": {\n                \"type\": \"keyword\"\n            },\n            \"timestamp\": {\n                \"type\": \"date\"\n            },\n            \"price\": {\n                \"type\": \"long\"\n            },\n            \"shop\": {\n                \"type\": \"keyword\"\n            }\n          }\n       }\n    }\n  }\n}\n\nPOST /sales/_bulk?refresh\n{\"index\":{\"_id\":0}}\n{\"product\": \"mad max\", \"price\": \"20\", \"timestamp\": \"2017-05-09T14:35\"}\n{\"index\":{\"_id\":1}}\n{\"product\": \"mad max\", \"price\": \"25\", \"timestamp\": \"2017-05-09T12:35\"}\n{\"index\":{\"_id\":2}}\n{\"product\": \"rocky\", \"price\": \"10\", \"timestamp\": \"2017-05-08T09:10\"}\n{\"index\":{\"_id\":3}}\n{\"product\": \"mad max\", \"price\": \"27\", \"timestamp\": \"2017-05-10T07:07\"}\n{\"index\":{\"_id\":4}}\n{\"product\": \"apocalypse now\", \"price\": \"10\", \"timestamp\": \"2017-05-11T08:35\"}\n-------------------------------------------------\n// TESTSETUP\n\n//////////////////////////\n\nFor example, consider the following document:\n\n[source,js]\n--------------------------------------------------\n{\n  \"keyword\": [\"foo\", \"bar\"],\n  \"number\": [23, 65, 76]\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nUsing `keyword` and `number` as source fields for the aggregation results in\nthe following composite buckets:\n\n[source,js]\n--------------------------------------------------\n{ \"keyword\": \"foo\", \"number\": 23 }\n{ \"keyword\": \"foo\", \"number\": 65 }\n{ \"keyword\": \"foo\", \"number\": 76 }\n{ \"keyword\": \"bar\", \"number\": 23 }\n{ \"keyword\": \"bar\", \"number\": 65 }\n{ \"keyword\": \"bar\", \"number\": 76 }\n--------------------------------------------------\n// NOTCONSOLE\n\n==== Value sources\n\nThe `sources` parameter defines the source fields to use when building\ncomposite buckets. The order that the `sources` are defined controls the order\nthat the keys are returned.\n\nNOTE: You must use a unique name when defining `sources`.\n\nThe `sources` parameter can be any of the following types:\n\n* <<_terms,Terms>>\n* <<_histogram,Histogram>>\n* <<_date_histogram,Date histogram>>\n* <<_geotile_grid,GeoTile grid>>\n\n[[_terms]]\n===== Terms\n\nThe `terms` value source is similar to a simple `terms` aggregation.\nThe values are extracted from a field exactly like the `terms` aggregation.\n\nExample:\n\n[source,console,id=composite-aggregation-terms-field-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"product\": { \"terms\": { \"field\": \"product\" } } }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nLike the `terms` aggregation, it's possible to use a\n<<runtime,runtime field>> to create values for the composite buckets:\n\n[source,console,id=composite-aggregation-terms-runtime-field-example]\n----\nGET /_search\n{\n  \"runtime_mappings\": {\n    \"day_of_week\": {\n      \"type\": \"keyword\",\n      \"script\": \"\"\"\n        emit(doc['timestamp'].value.dayOfWeekEnum\n          .getDisplayName(TextStyle.FULL, Locale.ENGLISH))\n      \"\"\"\n    }\n  },\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          {\n            \"dow\": {\n              \"terms\": { \"field\": \"day_of_week\" }\n            }\n          }\n        ]\n      }\n    }\n  }\n}\n----\n\n////\n[source,console-result]\n----\n{\n  \"timed_out\": false,\n  \"took\": \"$body.took\",\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"failed\": 0,\n    \"skipped\": 0\n  },\n  \"hits\": \"$body.hits\",\n  \"aggregations\": {\n    \"my_buckets\": {\n      \"after_key\": { \"dow\": \"Wednesday\" },\n      \"buckets\": [\n        { \"key\": { \"dow\": \"Monday\"    }, \"doc_count\": 1 },\n        { \"key\": { \"dow\": \"Thursday\"  }, \"doc_count\": 1 },\n        { \"key\": { \"dow\": \"Tuesday\"   }, \"doc_count\": 2 },\n        { \"key\": { \"dow\": \"Wednesday\" }, \"doc_count\": 1 }\n      ]\n    }\n  }\n}\n----\n////\n\nAlthough similar, the `terms` value source doesn't support the same set of\nparameters as the `terms` aggregation. For other supported value source\nparameters, see:\n\n* <<_order>>\n* <<_missing_bucket>>\n\n[[_histogram]]\n===== Histogram\n\nThe `histogram` value source can be applied on numeric values to build fixed size\ninterval over the values. The `interval` parameter defines how the numeric values should be\ntransformed. For instance an `interval` set to 5 will translate any numeric values to its closest interval,\na value of `101` would be translated to `100` which is the key for the interval between 100 and 105.\n\nExample:\n\n[source,console,id=composite-aggregation-histogram-field-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"histo\": { \"histogram\": { \"field\": \"price\", \"interval\": 5 } } }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nLike the `histogram` aggregation it's possible to use a\n<<runtime,runtime field>> to create values for the composite buckets:\n\n[source,console,id=composite-aggregation-histogram-runtime-field-example]\n----\nGET /_search\n{\n  \"runtime_mappings\": {\n    \"price.discounted\": {\n      \"type\": \"double\",\n      \"script\": \"\"\"\n        double price = doc['price'].value;\n        if (doc['product'].value == 'mad max') {\n          price *= 0.8;\n        }\n        emit(price);\n      \"\"\"\n    }\n  },\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          {\n            \"price\": {\n              \"histogram\": {\n                \"interval\": 5,\n                \"field\": \"price.discounted\"\n              }\n            }\n          }\n        ]\n      }\n    }\n  }\n}\n----\n\n////\n[source,console-result]\n----\n{\n  \"timed_out\": false,\n  \"took\": \"$body.took\",\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"failed\": 0,\n    \"skipped\": 0\n  },\n  \"hits\": \"$body.hits\",\n  \"aggregations\": {\n    \"my_buckets\": {\n      \"after_key\": { \"price\": 20.0 },\n      \"buckets\": [\n        { \"key\": { \"price\": 10.0 }, \"doc_count\": 2 },\n        { \"key\": { \"price\": 15.0 }, \"doc_count\": 1 },\n        { \"key\": { \"price\": 20.0 }, \"doc_count\": 2 }\n      ]\n    }\n  }\n}\n----\n////\n\n[[_date_histogram]]\n===== Date histogram\n\nThe `date_histogram` is similar to the `histogram` value source except that the interval\nis specified by date/time expression:\n\n[source,console,id=composite-aggregation-datehistogram-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"date\": { \"date_histogram\": { \"field\": \"timestamp\", \"calendar_interval\": \"1d\" } } }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThe example above creates an interval per day and translates all `timestamp` values to the start of its closest intervals.\nAvailable expressions for interval: `year`, `quarter`, `month`, `week`, `day`, `hour`, `minute`, `second`\n\nTime values can also be specified via abbreviations supported by <<time-units,time units>> parsing.\nNote that fractional time values are not supported, but you can address this by shifting to another\ntime unit (e.g., `1.5h` could instead be specified as `90m`).\n\n*Format*\n\nInternally, a date is represented as a 64 bit number representing a timestamp in milliseconds-since-the-epoch.\nThese timestamps are returned as the bucket keys. It is possible to return a formatted date string instead using\nthe format specified with the format parameter:\n\n[source,console,id=composite-aggregation-datehistogram-format-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          {\n            \"date\": {\n              \"date_histogram\": {\n                \"field\": \"timestamp\",\n                \"calendar_interval\": \"1d\",\n                \"format\": \"yyyy-MM-dd\"         <1>\n              }\n            }\n          }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Supports expressive date <<date-format-pattern,format pattern>>\n\n*Time Zone*\n\nDate-times are stored in Elasticsearch in UTC. By default, all bucketing and\nrounding is also done in UTC. The `time_zone` parameter can be used to indicate\nthat bucketing should use a different time zone.\n\nTime zones may either be specified as an ISO 8601 UTC offset (e.g. `+01:00` or\n`-08:00`)  or as a timezone id, an identifier used in the TZ database like\n`America/Los_Angeles`.\n\n*Offset*\n\ninclude::datehistogram-aggregation.asciidoc[tag=offset-explanation]\n\n[source,console,id=composite-aggregation-datehistogram-offset-example]\n----\nPUT my-index-000001/_doc/1?refresh\n{\n  \"date\": \"2015-10-01T05:30:00Z\"\n}\n\nPUT my-index-000001/_doc/2?refresh\n{\n  \"date\": \"2015-10-01T06:30:00Z\"\n}\n\nGET my-index-000001/_search?size=0\n{\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\" : {\n        \"sources\" : [\n          {\n            \"date\": {\n              \"date_histogram\" : {\n                \"field\": \"date\",\n                \"calendar_interval\": \"day\",\n                \"offset\": \"+6h\",\n                \"format\": \"iso8601\"\n              }\n            }\n          }\n        ]\n      }\n    }\n  }\n}\n----\n\ninclude::datehistogram-aggregation.asciidoc[tag=offset-result-intro]\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"my_buckets\": {\n      \"after_key\": { \"date\": \"2015-10-01T06:00:00.000Z\" },\n      \"buckets\": [\n        {\n          \"key\": { \"date\": \"2015-09-30T06:00:00.000Z\" },\n          \"doc_count\": 1\n        },\n        {\n          \"key\": { \"date\": \"2015-10-01T06:00:00.000Z\" },\n          \"doc_count\": 1\n        }\n      ]\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\ninclude::datehistogram-aggregation.asciidoc[tag=offset-note]\n\n[[_geotile_grid]]\n===== GeoTile grid\n\nThe `geotile_grid` value source works on `geo_point` fields and groups points into buckets that represent\ncells in a grid. The resulting grid can be sparse and only contains cells\nthat have matching data. Each cell corresponds to a\n{wikipedia}/Tiled_web_map[map tile] as used by many online map\nsites. Each cell is labeled using a \"{zoom}/{x}/{y}\" format, where zoom is equal\nto the user-specified precision.\n\n[source,console,id=composite-aggregation-geotilegrid-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"tile\": { \"geotile_grid\": { \"field\": \"location\", \"precision\": 8 } } }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n*Precision*\n\nThe highest-precision geotile of length 29 produces cells that cover\nless than 10cm by 10cm of land. This precision is uniquely suited for composite aggregations as each\ntile does not have to be generated and loaded in memory.\n\nSee https://wiki.openstreetmap.org/wiki/Zoom_levels[Zoom level documentation]\non how precision (zoom) correlates to size on the ground. Precision for this\naggregation can be between 0 and 29, inclusive.\n\n*Bounding box filtering*\n\nThe geotile source can optionally be constrained to a specific geo bounding box, which reduces\nthe range of tiles used. These bounds are useful when only a specific part of a geographical area needs high\nprecision tiling.\n\n[source,console,id=composite-aggregation-geotilegrid-boundingbox-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          {\n            \"tile\": {\n              \"geotile_grid\": {\n                \"field\": \"location\",\n                \"precision\": 22,\n                \"bounds\": {\n                  \"top_left\": \"POINT (4.9 52.4)\",\n                  \"bottom_right\": \"POINT (5.0 52.3)\"\n                }\n              }\n            }\n          }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n===== Mixing different value sources\n\nThe `sources` parameter accepts an array of value sources.\nIt is possible to mix different value sources to create composite buckets.\nFor example:\n\n[source,console,id=composite-aggregation-mixing-sources-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"date\": { \"date_histogram\": { \"field\": \"timestamp\", \"calendar_interval\": \"1d\" } } },\n          { \"product\": { \"terms\": { \"field\": \"product\" } } }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThis will create composite buckets from the values created by two value sources, a `date_histogram` and a `terms`.\nEach bucket is composed of two values, one for each value source defined in the aggregation.\nAny type of combinations is allowed and the order in the array is preserved\nin the composite buckets.\n\n[source,console,id=composite-aggregation-mixing-three-sources-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"shop\": { \"terms\": { \"field\": \"shop\" } } },\n          { \"product\": { \"terms\": { \"field\": \"product\" } } },\n          { \"date\": { \"date_histogram\": { \"field\": \"timestamp\", \"calendar_interval\": \"1d\" } } }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n[[_order]]\n==== Order\n\nBy default the composite buckets are sorted by their natural ordering. Values are sorted\nin ascending order of their values. When multiple value sources are requested, the ordering is done per value\nsource, the first value of the composite bucket is compared to the first value of the other composite bucket and if they are equals the\nnext values in the composite bucket are used for tie-breaking. This means that the composite bucket\n `[foo, 100]` is considered smaller than `[foobar, 0]` because `foo` is considered smaller than `foobar`.\nIt is possible to define the direction of the sort for each value source by setting `order` to `asc` (default value)\nor `desc` (descending order) directly in the value source definition.\nFor example:\n\n[source,console,id=composite-aggregation-order-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"date\": { \"date_histogram\": { \"field\": \"timestamp\", \"calendar_interval\": \"1d\", \"order\": \"desc\" } } },\n          { \"product\": { \"terms\": { \"field\": \"product\", \"order\": \"asc\" } } }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n\\... will sort the composite bucket in descending order when comparing values from the `date_histogram` source\nand in ascending order when comparing values from the `terms` source.\n\n[[_missing_bucket]]\n==== Missing bucket\n\nBy default documents without a value for a given source are ignored.\nIt is possible to include them in the response by setting `missing_bucket` to\n`true` (defaults to `false`):\n\n[source,console,id=composite-aggregation-missing-bucket-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [{\n          \"product_name\": {\n            \"terms\": {\n              \"field\": \"product\",\n              \"missing_bucket\": true,\n              \"missing_order\": \"last\"\n            }\n          }\n        }]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nIn the above example, the `product_name` source emits an explicit `null` bucket\nfor documents without a `product` value. This bucket is placed last.\n\nYou can control the position of the `null` bucket using the optional\n`missing_order` parameter. If `missing_order` is `first` or `last`, the `null`\nbucket is placed in the respective first or last position. If `missing_order` is\nomitted or `default`, the source's `order` determines the bucket's position. If\n`order` is `asc` (ascending), the bucket is in the first position. If `order` is\n`desc` (descending), the bucket is in the last position.\n\n==== Size\n\nThe `size` parameter can be set to define how many composite buckets should be returned.\nEach composite bucket is considered as a single bucket, so setting a size of 10 will return the\nfirst 10 composite buckets created from the value sources.\nThe response contains the values for each composite bucket in an array containing the values extracted\nfrom each value source. Defaults to `10`.\n\n==== Pagination\n\nIf the number of composite buckets is too high (or unknown) to be returned in a single response\nit is possible to split the retrieval in multiple requests.\nSince the composite buckets are flat by nature, the requested `size` is exactly the number of composite buckets\nthat will be returned in the response (assuming that they are at least `size` composite buckets to return).\nIf all composite buckets should be retrieved it is preferable to use a small size (`100` or `1000` for instance)\nand then use the `after` parameter to retrieve the next results.\nFor example:\n\n[source,console,id=composite-aggregation-after-key-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"size\": 2,\n        \"sources\": [\n          { \"date\": { \"date_histogram\": { \"field\": \"timestamp\", \"calendar_interval\": \"1d\" } } },\n          { \"product\": { \"terms\": { \"field\": \"product\" } } }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\n\\... returns:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"my_buckets\": {\n      \"after_key\": {\n        \"date\": 1494288000000,\n        \"product\": \"mad max\"\n      },\n      \"buckets\": [\n        {\n          \"key\": {\n            \"date\": 1494201600000,\n            \"product\": \"rocky\"\n          },\n          \"doc_count\": 1\n        },\n        {\n          \"key\": {\n            \"date\": 1494288000000,\n            \"product\": \"mad max\"\n          },\n          \"doc_count\": 2\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n\nTo get the next set of buckets, resend the same aggregation with the `after`\nparameter set to the `after_key` value returned in the response.\nFor example, this request uses the `after_key` value provided in the previous response:\n\n[source,console,id=composite-aggregation-after-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"size\": 2,\n        \"sources\": [\n          { \"date\": { \"date_histogram\": { \"field\": \"timestamp\", \"calendar_interval\": \"1d\", \"order\": \"desc\" } } },\n          { \"product\": { \"terms\": { \"field\": \"product\", \"order\": \"asc\" } } }\n        ],\n        \"after\": { \"date\": 1494288000000, \"product\": \"mad max\" } <1>\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Should restrict the aggregation to buckets that sort **after** the provided values.\n\nNOTE: The `after_key` is *usually* the key to the last bucket returned in\nthe response, but that isn't guaranteed. Always use the returned `after_key` instead\nof deriving it from the buckets.\n\n==== Early termination\n\nFor optimal performance the <<index-modules-index-sorting,index sort>> should be set on the index so that it matches\nparts or fully the source order in the composite aggregation.\nFor instance the following index sort:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"settings\": {\n    \"index\": {\n      \"sort.field\": [ \"username\", \"timestamp\" ],   <1>\n      \"sort.order\": [ \"asc\", \"desc\" ]              <2>\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"username\": {\n        \"type\": \"keyword\",\n        \"doc_values\": true\n      },\n      \"timestamp\": {\n        \"type\": \"date\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> This index is sorted by `username` first then by `timestamp`.\n<2> ... in ascending order for the `username` field and in descending order for the `timestamp` field.\n\n.. could be used to optimize these composite aggregations:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"user_name\": { \"terms\": { \"field\": \"user_name\" } } }     <1>\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> `user_name` is a prefix of the index sort and the order matches (`asc`).\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"user_name\": { \"terms\": { \"field\": \"user_name\" } } }, <1>\n          { \"date\": { \"date_histogram\": { \"field\": \"timestamp\", \"calendar_interval\": \"1d\", \"order\": \"desc\" } } } <2>\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> `user_name` is a prefix of the index sort and the order matches (`asc`).\n<2> `timestamp` matches also the prefix and the order matches (`desc`).\n\nIn order to optimize the early termination it is advised to set `track_total_hits` in the request\nto `false`. The number of total hits that match the request can be retrieved on the first request\nand it would be costly to compute this number on every page:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"track_total_hits\": false,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"user_name\": { \"terms\": { \"field\": \"user_name\" } } },\n          { \"date\": { \"date_histogram\": { \"field\": \"timestamp\", \"calendar_interval\": \"1d\", \"order\": \"desc\" } } }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nNote that the order of the source is important, in the example below switching the `user_name` with the `timestamp`\nwould deactivate the sort optimization since this configuration wouldn't match the index sort specification.\nIf the order of sources do not matter for your use case you can follow these simple guidelines:\n\n  * Put the fields with the highest cardinality first.\n  * Make sure that the order of the field matches the order of the index sort.\n  * Put multi-valued fields last since they cannot be used for early termination.\n\nWARNING: <<index-modules-index-sorting,index sort>> can slowdown indexing, it is very important to test index sorting\nwith your specific use case and dataset to ensure that it matches your requirement. If it doesn't note that `composite`\naggregations will also try to early terminate on non-sorted indices if the query matches all document (`match_all` query).\n\n==== Sub-aggregations\n\nLike any `multi-bucket` aggregations the `composite` aggregation can hold sub-aggregations.\nThese sub-aggregations can be used to compute other buckets or statistics on each composite bucket created by this\nparent aggregation.\nFor instance the following example computes the average value of a field\nper composite bucket:\n\n[source,console,id=composite-aggregation-subaggregations-example]\n--------------------------------------------------\nGET /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_buckets\": {\n      \"composite\": {\n        \"sources\": [\n          { \"date\": { \"date_histogram\": { \"field\": \"timestamp\", \"calendar_interval\": \"1d\", \"order\": \"desc\" } } },\n          { \"product\": { \"terms\": { \"field\": \"product\" } } }\n        ]\n      },\n      \"aggregations\": {\n        \"the_avg\": {\n          \"avg\": { \"field\": \"price\" }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\n\\... returns:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"my_buckets\": {\n      \"after_key\": {\n        \"date\": 1494201600000,\n        \"product\": \"rocky\"\n      },\n      \"buckets\": [\n        {\n          \"key\": {\n            \"date\": 1494460800000,\n            \"product\": \"apocalypse now\"\n          },\n          \"doc_count\": 1,\n          \"the_avg\": {\n            \"value\": 10.0\n          }\n        },\n        {\n          \"key\": {\n            \"date\": 1494374400000,\n            \"product\": \"mad max\"\n          },\n          \"doc_count\": 1,\n          \"the_avg\": {\n            \"value\": 27.0\n          }\n        },\n        {\n          \"key\": {\n            \"date\": 1494288000000,\n            \"product\": \"mad max\"\n          },\n          \"doc_count\": 2,\n          \"the_avg\": {\n            \"value\": 22.5\n          }\n        },\n        {\n          \"key\": {\n            \"date\": 1494201600000,\n            \"product\": \"rocky\"\n          },\n          \"doc_count\": 1,\n          \"the_avg\": {\n            \"value\": 10.0\n          }\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n[[search-aggregations-bucket-composite-aggregation-pipeline-aggregations]]\n==== Pipeline aggregations\n\nThe composite agg is not currently compatible with pipeline aggregations, nor does it make sense in most cases.\nE.g. due to the paging nature of composite aggs, a single logical partition (one day for example) might be spread\nover multiple pages. Since pipeline aggregations are purely post-processing on the final list of buckets,\nrunning something like a derivative on a composite page could lead to inaccurate results as it is only taking into\naccount a \"partial\" result on that page.\n\nPipeline aggs that are self contained to a single bucket (such as `bucket_selector`) might be supported in the future.\n"
}