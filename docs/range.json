{
    "meta": {
        "timestamp": "2024-11-01T03:07:10.007271",
        "size": 11609,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/range.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "range",
        "version": "8.15"
    },
    "doc": "[[range]]\n=== Range field types\n++++\n<titleabbrev>Range</titleabbrev>\n++++\n\nRange field types represent a continuous range of values between an upper and lower\nbound. For example, a range can represent _any date in October_ or _any\ninteger from 0 to 9_. They are defined using the operators\n`gt` or `gte` for the lower bound, and `lt` or `lte` for the upper bound.\nThey can be used for querying, and have\nlimited support for aggregations. The only supported aggregations are\n{ref}/search-aggregations-bucket-histogram-aggregation.html[histogram],\n{ref}/search-aggregations-metrics-cardinality-aggregation.html[cardinality].\n\nThe following range types are supported:\n\n[horizontal]\n`integer_range`::   A range of signed 32-bit integers with a minimum value of +-2^31^+ and maximum of +2^31^-1+.\n`float_range`::     A range of single-precision 32-bit IEEE 754 floating point values.\n`long_range`::      A range of signed 64-bit integers with a minimum value of +-2^63^+ and maximum of +2^63^-1+.\n`double_range`::    A range of double-precision 64-bit IEEE 754 floating point values.\n`date_range`::      A range of <<date,`date`>> values. Date ranges support various date formats\n                    through the <<mapping-date-format,`format`>> mapping parameter. Regardless of\n                    the format used, date values are parsed into an unsigned 64-bit integer\n                    representing milliseconds since the Unix epoch in UTC. Values containing the\n                    `now` <<date-math,date math>> expression are not supported.\n`ip_range` ::       A range of ip values supporting either {wikipedia}/IPv4[IPv4] or\n                    {wikipedia}/IPv6[IPv6] (or mixed) addresses.\n\nBelow is an example of configuring a mapping with various range fields followed by an example that indexes several range types.\n\n[source,console]\n--------------------------------------------------\nPUT range_index\n{\n  \"settings\": {\n    \"number_of_shards\": 2\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"expected_attendees\": {\n        \"type\": \"integer_range\"\n      },\n      \"time_frame\": {\n        \"type\": \"date_range\", <1>\n        \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\"\n      }\n    }\n  }\n}\n\nPUT range_index/_doc/1?refresh\n{\n  \"expected_attendees\" : { <2>\n    \"gte\" : 10,\n    \"lt\" : 20\n  },\n  \"time_frame\" : {\n    \"gte\" : \"2015-10-31 12:00:00\", <3>\n    \"lte\" : \"2015-11-01\"\n  }\n}\n--------------------------------------------------\n// TESTSETUP\n\n<1> `date_range` types accept the same field parameters defined by the <<date, `date`>> type.\n<2> Example indexing a meeting with 10 to 20 attendees, not including 20.\n<3> Example date range using date time stamp.\n\nThe following is an example of a <<query-dsl-term-query, term query>> on the `integer_range` field named \"expected_attendees\".\n12 is a value inside the range, so it will match.\n\n[source,console]\n--------------------------------------------------\nGET range_index/_search\n{\n  \"query\" : {\n    \"term\" : {\n      \"expected_attendees\" : {\n        \"value\": 12\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThe result produced by the above query.\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 13,\n  \"timed_out\": false,\n  \"_shards\" : {\n    \"total\": 2,\n    \"successful\": 2,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\" : {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"range_index\",\n        \"_id\" : \"1\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"expected_attendees\" : {\n            \"gte\" : 10, \"lt\" : 20\n          },\n          \"time_frame\" : {\n            \"gte\" : \"2015-10-31 12:00:00\", \"lte\" : \"2015-11-01\"\n          }\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 13/\"took\" : $body.took/]\n\nThe following is an example of a `date_range` query over the `date_range` field named \"time_frame\".\n\n[source,console]\n--------------------------------------------------\nGET range_index/_search\n{\n  \"query\" : {\n    \"range\" : {\n      \"time_frame\" : { <1>\n        \"gte\" : \"2015-10-31\",\n        \"lte\" : \"2015-11-01\",\n        \"relation\" : \"within\" <2>\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Range queries work the same as described in <<query-dsl-range-query, range query>>.\n<2> Range queries over range <<mapping-types, fields>> support a `relation` parameter which can be one of `WITHIN`, `CONTAINS`,\n    `INTERSECTS` (default).\n\nThis query produces a similar result:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 13,\n  \"timed_out\": false,\n  \"_shards\" : {\n    \"total\": 2,\n    \"successful\": 2,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\" : {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"range_index\",\n        \"_id\" : \"1\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"expected_attendees\" : {\n            \"gte\" : 10, \"lt\" : 20\n          },\n          \"time_frame\" : {\n            \"gte\" : \"2015-10-31 12:00:00\", \"lte\" : \"2015-11-01\"\n          }\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 13/\"took\" : $body.took/]\n\n[[ip-range]]\n==== IP Range\n\nIn addition to the range format above, IP ranges can be provided in\n{wikipedia}/Classless_Inter-Domain_Routing#CIDR_notation[CIDR] notation:\n\n[source,console]\n--------------------------------------------------\nPUT range_index/_mapping\n{\n  \"properties\": {\n    \"ip_allowlist\": {\n      \"type\": \"ip_range\"\n    }\n  }\n}\n\nPUT range_index/_doc/2\n{\n  \"ip_allowlist\" : \"192.168.0.0/16\"\n}\n--------------------------------------------------\n\n[[range-params]]\n==== Parameters for range fields\n\nThe following parameters are accepted by range types:\n\n[horizontal]\n\n<<coerce,`coerce`>>::\n\n    Try to convert strings to numbers and truncate fractions for integers.\n    Accepts `true` (default) and `false`.\n\n<<doc-values,`doc_values`>>::\n\n    Should the field be stored on disk in a column-stride fashion, so that it\n    can later be used for sorting, aggregations, or scripting? Accepts `true`\n    (default) or `false`.\n\n<<mapping-index,`index`>>::\n\n    Should the field be searchable? Accepts `true` (default) and `false`.\n\n<<mapping-store,`store`>>::\n\n    Whether the field value should be stored and retrievable separately from\n    the <<mapping-source-field,`_source`>> field. Accepts `true` or `false`\n    (default).\n\n[[range-synthetic-source]]\n==== Synthetic `_source`\n\nIMPORTANT: Synthetic `_source` is Generally Available only for TSDB indices\n(indices that have `index.mode` set to `time_series`). For other indices\nsynthetic `_source` is in technical preview. Features in technical preview may\nbe changed or removed in a future release. Elastic will work to fix\nany issues, but features in technical preview are not subject to the support SLA\nof official GA features.\n\n`range` fields support <<synthetic-source,synthetic `_source`>> in their default\nconfiguration.\n\nSynthetic source may sort `range` field values and remove duplicates for all `range` fields except `ip_range`. Ranges are sorted by their lower bound and then by upper bound. For example:\n[source,console,id=synthetic-source-range-sorting-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"my_range\": { \"type\": \"long_range\" }\n    }\n  }\n}\n\nPUT idx/_doc/1\n{\n  \"my_range\": [\n    {\n        \"gte\": 200,\n        \"lte\": 300\n    },\n    {\n        \"gte\": 1,\n        \"lte\": 100\n    },\n    {\n        \"gte\": 200,\n        \"lte\": 300\n    },\n    {\n        \"gte\": 200,\n        \"lte\": 500\n    }\n  ]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"my_range\": [\n    {\n        \"gte\": 1,\n        \"lte\": 100\n    },\n    {\n        \"gte\": 200,\n        \"lte\": 300\n    },\n    {\n        \"gte\": 200,\n        \"lte\": 500\n    }\n  ]\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\nValues of `ip_range` fields are not sorted but original order is not preserved. Duplicate ranges are removed. If `ip_range` field value is provided as a CIDR, it will be represented as a range of IP addresses in synthetic source.\n\nFor example:\n[source,console,id=synthetic-source-range-ip-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"my_range\": { \"type\": \"ip_range\" }\n    }\n  }\n}\n\nPUT idx/_doc/1\n{\n  \"my_range\": [\n    \"10.0.0.0/24\",\n    {\n      \"gte\": \"10.0.0.0\",\n      \"lte\": \"10.0.0.255\"\n    }\n  ]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"my_range\": {\n      \"gte\": \"10.0.0.0\",\n      \"lte\": \"10.0.0.255\"\n    }\n\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\n[[range-synthetic-source-inclusive]]\nRange field values are always represented as inclusive on both sides with bounds adjusted accordingly. Default values for range bounds are represented as `null`. This is true even if range bound was explicitly provided. For example:\n[source,console,id=synthetic-source-range-normalization-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"my_range\": { \"type\": \"long_range\" }\n    }\n  }\n}\n\nPUT idx/_doc/1\n{\n  \"my_range\": {\n    \"gt\": 200,\n    \"lt\": 300\n  }\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"my_range\": {\n    \"gte\": 201,\n    \"lte\": 299\n  }\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\n[[range-synthetic-source-default-bounds]]\nDefault values for range bounds are represented as `null` in synthetic source. This is true even if range bound was explicitly provided with default value. For example:\n[source,console,id=synthetic-source-range-bounds-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"my_range\": { \"type\": \"integer_range\" }\n    }\n  }\n}\n\nPUT idx/_doc/1\n{\n  \"my_range\": {\n    \"lte\": 2147483647\n  }\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"my_range\": {\n    \"gte\": null,\n    \"lte\": null\n  }\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\n`date` ranges are formatted using provided `format` or by default using `yyyy-MM-dd'T'HH:mm:ss.SSSZ` format. For example:\n[source,console,id=synthetic-source-range-date-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"my_range\": { \"type\": \"date_range\" }\n    }\n  }\n}\n\nPUT idx/_doc/1\n{\n  \"my_range\": [\n    {\n      \"gte\": 1504224000000,\n      \"lte\": 1504569600000\n    },\n    {\n      \"gte\": \"2017-09-01\",\n      \"lte\": \"2017-09-10\"\n    }\n  ]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n\n[source,console-result]\n----\n{\n  \"my_range\": [\n    {\n      \"gte\": \"2017-09-01T00:00:00.000Z\",\n      \"lte\": \"2017-09-05T00:00:00.000Z\"\n    },\n    {\n      \"gte\": \"2017-09-01T00:00:00.000Z\",\n      \"lte\": \"2017-09-10T23:59:59.999Z\"\n    }\n  ]\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n"
}