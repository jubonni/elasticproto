{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.034271",
        "size": 5180,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-data-types.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "sql-data-types",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[sql-data-types]]\n=== Data Types\n\n[cols=\"^,^m,^,^\"]\n\n|===\ns|{es} type\ns|{es-sql} type\ns|SQL type\ns|SQL precision\n\n4+h| Core types\n\n| <<null-value, `null`>>                   | null            | NULL        | 0\n| <<boolean, `boolean`>>                   | boolean         | BOOLEAN     | 1\n| <<number, `byte`>>                       | byte            | TINYINT     | 3\n| <<number, `short`>>                      | short           | SMALLINT    | 5\n| <<number, `integer`>>                    | integer         | INTEGER     | 10\n| <<number, `long`>>                       | long            | BIGINT      | 19\n| <<number, `unsigned_long`>>              | experimental:[] unsigned_long   | BIGINT      | 20\n| <<number, `double`>>                     | double          | DOUBLE      | 15\n| <<number, `float`>>                      | float           | REAL        | 7\n| <<number, `half_float`>>                 | half_float      | FLOAT       | 3\n| <<number, `scaled_float`>>               | scaled_float    | DOUBLE      | 15\n| <<keyword, keyword type family>>         | keyword         | VARCHAR     | 32,766\n| <<text, `text`>>                         | text            | VARCHAR     | 2,147,483,647\n| <<binary, `binary`>>                     | binary          | VARBINARY   | 2,147,483,647\n| <<date, `date`>>                         | datetime        | TIMESTAMP   | 29\n| <<ip, `ip`>>                             | ip              | VARCHAR     | 39\n| <<version, `version`>>                   | version         | VARCHAR     | 32,766\n\n4+h| Complex types\n\n| <<object, `object`>>        | object        | STRUCT      | 0\n| <<nested, `nested`>>        | nested        | STRUCT      | 0\n\n4+h| Unsupported types\n\n| _types not mentioned above_ | unsupported   | OTHER       | 0\n\n|===\n\n[NOTE]\nMost of {es} <<mapping-types, data types>> are available in {es-sql}, as indicated above.\nAs one can see, all of {es} <<mapping-types, data types>> are mapped to the data type with the same\nname in {es-sql}, with the exception of **date** data type which is mapped to **datetime** in {es-sql}.\nThis is to avoid confusion with the ANSI SQL types **DATE** (date only) and **TIME** (time only), which are also\nsupported by {es-sql} in queries (with the use of\n<<sql-functions-type-conversion-cast>>/<<sql-functions-type-conversion-convert>>), but don't correspond to an\nactual mapping in {es} (see the <<es-sql-only-types, `table`>> below).\n\nObviously, not all types in {es} have an equivalent in SQL and vice-versa hence why, {es-sql}\nuses the data type _particularities_ of the former over the latter as ultimately {es} is the backing store.\n\nIn addition to the types above, {es-sql} also supports at _runtime_ SQL-specific types that do not have an equivalent in {es}.\nSuch types cannot be loaded from {es} (as it does not know about them) however can be used inside {es-sql} in queries or their results.\n\n[[es-sql-only-types]]\n\nThe table below indicates these types:\n\n[cols=\"^m,^\"]\n\n|===\ns|SQL type\ns|SQL precision\n\n\n| date                      | 29\n| time                      | 18\n| interval_year             | 7\n| interval_month            | 7\n| interval_day              | 23\n| interval_hour             | 23\n| interval_minute           | 23\n| interval_second           | 23\n| interval_year_to_month    | 7\n| interval_day_to_hour      | 23\n| interval_day_to_minute    | 23\n| interval_day_to_second    | 23\n| interval_hour_to_minute   | 23\n| interval_hour_to_second   | 23\n| interval_minute_to_second | 23\n| geo_point                 | 52\n| geo_shape                 | 2,147,483,647\n| shape                     | 2,147,483,647\n\n|===\n\n\n[[sql-multi-field]]\n[discrete]\n==== SQL and multi-fields\n\nA core concept in {es} is that of an `analyzed` field, that is a full-text value that is interpreted in order\nto be effectively indexed. These fields are of type <<text, `text`>> and are not used for sorting or aggregations as their actual value depends on the <<analyzer, `analyzer`>> used hence why {es} also offers the <<keyword, `keyword`>> type for storing the _exact_\nvalue.\n\nIn most case, and the default actually, is to use both types for strings which {es} supports through <<multi-fields, multi-fields>>, that is the ability to index the same string in multiple ways; for example index it both as `text` for search but also as `keyword` for sorting and aggregations.\n\nAs SQL requires exact values, when encountering a `text` field {es-sql} will search for an exact multi-field that it can use for comparisons, sorting and aggregations.\nTo do that, it will search for the first `keyword` that it can find that is _not_ normalized and use that as the original field _exact_ value.\n\nConsider the following `string` mapping:\n\n[source,js]\n----\n{\n  \"first_name\": {\n    \"type\": \"text\",\n    \"fields\": {\n      \"raw\": {\n        \"type\": \"keyword\"\n      }\n    }\n  }\n}\n----\n// NOTCONSOLE\n\nThe following SQL query:\n\n[source, sql]\n----\nSELECT first_name FROM index WHERE first_name = 'John'\n----\n\nis identical to:\n\n[source, sql]\n----\nSELECT first_name FROM index WHERE first_name.raw = 'John'\n----\n\nas {es-sql} automatically _picks_ up the `raw` multi-field from `raw` for exact matching.\n"
}