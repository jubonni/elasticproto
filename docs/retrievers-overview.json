{
    "meta": {
        "size": 7707,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/retrievers-overview.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "retrievers-overview",
        "version": "8.15"
    },
    "doc": "[[retrievers-overview]]\n=== Retrievers\n\nA retriever is an abstraction that was added to the Search API in *8.14.0* and was made generally available in *8.16.0*.\nThis abstraction enables the configuration of multi-stage retrieval pipelines within a single `_search` call.\nThis simplifies your search application logic, because you no longer need to configure complex searches via multiple {es} calls or implement additional client-side logic to combine results from different queries.\n\nThis document provides a general overview of the retriever abstraction.\nFor implementation details, including notable restrictions, check out the\n<<retriever,reference documentation>> in the `_search` API docs.\n\n[discrete]\n[[retrievers-overview-types]]\n==== Retriever types\n\nRetrievers come in various types, each tailored for different search operations.\nThe following retrievers are currently available:\n\n* <<standard-retriever,*Standard Retriever*>>. Returns top documents from a\ntraditional https://www.elastic.co/guide/en/elasticsearch/reference/master/query-dsl.html[query].\nMimics a traditional query but in the context of a retriever framework. This\nensures backward compatibility as existing `_search` requests remain supported.\nThat way you can transition to the new abstraction at your own pace without\nmixing syntaxes.\n* <<knn-retriever,*kNN Retriever*>>. Returns top documents from a <<search-api-knn,knn search>>,\nin the context of a retriever framework.\n* <<rrf-retriever,*RRF Retriever*>>. Combines and ranks multiple first-stage retrievers using\nthe reciprocal rank fusion (RRF) algorithm. Allows you to combine multiple result sets\nwith different relevance indicators into a single result set.\nAn RRF retriever is a *compound retriever*, where its `filter` element is\npropagated to its sub retrievers.\n+\n\n* <<text-similarity-reranker-retriever,*Text Similarity Re-ranker Retriever*>>. Used for <<semantic-reranking,semantic reranking>>.\nRequires first creating a `rerank` task using the <<put-inference-api,{es} Inference API>>.\n\n[discrete]\n==== What makes retrievers useful?\n\nHere's an overview of what makes retrievers useful and how they differ from regular queries.\n\n. *Simplified user experience*.\nRetrievers simplify the user experience by allowing entire retrieval pipelines to be configured in a single API call.\nThis maintains backward compatibility with traditional query elements by automatically translating them to the appropriate retriever.\n. *Structured retrieval*.\nRetrievers provide a more structured way to define search operations.\nThey allow searches to be described using a \"retriever tree\", a hierarchical structure that clarifies the sequence and logic of operations, making complex searches more understandable and manageable.\n. *Composability and flexibility*.\nRetrievers enable flexible composability, allowing you to build pipelines and seamlessly integrate different retrieval strategies into these pipelines.\nRetrievers make it easy to test out different retrieval strategy combinations.\n. *Compound operations*.\nA retriever can have sub retrievers.\nThis allows complex nested searches where the results of one retriever feed into another, supporting sophisticated querying strategies that might involve multiple stages or criteria.\n. *Retrieval as a first-class concept*.\nUnlike traditional queries, where the query is a part of a larger search API call, retrievers are designed as standalone entities that can be combined or used in isolation.\nThis enables a more modular and flexible approach to constructing searches.\n. *Enhanced control over document scoring and ranking*.\nRetrievers allow for more explicit control over how documents are scored and filtered.\nFor instance, you can specify minimum score thresholds, apply complex filters without affecting scoring, and use parameters like `terminate_after` for performance optimizations.\n. *Integration with existing {es} functionalities*.\nEven though retrievers can be used instead of existing `_search` API syntax (like the\n`query` and `knn`), they are designed to integrate seamlessly with things like pagination (`search_after`) and sorting.\nThey also maintain compatibility with aggregation operations by treating the combination of all leaf retrievers as\n`should` clauses in a boolean query.\n. *Cleaner separation of concerns*.\nWhen using compound retrievers, only the query element is allowed, which enforces a cleaner separation of concerns and prevents the complexity that might arise from overly nested or interdependent configurations.\n\n[discrete]\n[[retrievers-overview-example]]\n==== Example\n\nThe following example demonstrates the powerful queries that we can now compose, and how retrievers simplify this process. We can use any combination of retrievers we want, propagating the\nresults of a nested retriever to its parent. In this scenario, we'll make use of all 4 (currently) available retrievers, i.e. `standard`, `knn`, `text_similarity_reranker` and `rrf`.\nWe'll first combine the results of a `semantic` query using the `standard` retriever, and that of a `knn` search on a dense vector field, using `rrf` to get the top 100 results.\nFinally, we'll then rerank the top-50 results of `rrf` using the `text_similarity_reranker`\n\n[source,js]\n----\nGET example-index/_search\n{\n  \"retriever\": {\n    \"text_similarity_reranker\": {\n      \"retriever\": {\n        \"rrf\": {\n          \"retrievers\": [\n            {\n                \"standard\": {\n                  \"query\": {\n                    \"semantic\": {\n                      \"field\": \"inference_field\",\n                      \"query\": \"state of the art vector database\"\n                    }\n                  }\n                }\n            },\n            {\n              \"knn\": {\n                \"query_vector\": [\n                  0.54,\n                  ...,\n                  0.245\n                ],\n                \"field\": \"embedding\",\n                \"k\": 10,\n                \"num_candidates\": 15\n              }\n            }\n          ],\n          \"rank_window_size\": 100,\n          \"rank_constant\": 10\n        }\n      },\n      \"rank_window_size\": 50,\n      \"field\": \"description\",\n      \"inference_text\": \"what's the best way to create complex pipelines and retrieve documents?\",\n      \"inference_id\": \"my-awesome-rerank-model\"\n    }\n  }\n}\n----\n//NOTCONSOLE\n\n[discrete]\n[[retrievers-overview-glossary]]\n==== Glossary\n\nHere are some important terms:\n\n* *Retrieval Pipeline*. Defines the entire retrieval and ranking logic to\nproduce top hits.\n* *Retriever Tree*. A hierarchical structure that defines how retrievers interact.\n* *First-stage Retriever*. Returns an initial set of candidate documents.\n* *Compound Retriever*. Builds on one or more retrievers,\nenhancing document retrieval and ranking logic.\n* *Combiners*. Compound retrievers that merge top hits\nfrom multiple sub-retrievers.\n* *Rerankers*. Special compound retrievers that reorder hits and may adjust the number of hits, with distinctions between first-stage and second-stage rerankers.\n\n[discrete]\n[[retrievers-overview-play-in-search]]\n==== Retrievers in action\n\nThe Search Playground builds Elasticsearch queries using the retriever abstraction.\nIt automatically detects the fields and types in your index and builds a retriever tree based on your selections.\n\nYou can use the Playground to experiment with different retriever configurations and see how they affect search results.\n\nRefer to the {kibana-ref}/playground.html[Playground documentation] for more information.\n\n[discrete]\n[[retrievers-overview-api-reference]]\n==== API reference\n\nFor implementation details, including notable restrictions, check out the <<retriever,reference documentation>> in the Search API docs.\n"
}