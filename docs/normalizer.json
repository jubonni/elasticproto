{
    "meta": {
        "size": 3202,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/normalizer.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "normalizer",
        "version": "8.15"
    },
    "doc": "[[normalizer]]\n=== `normalizer`\n\nThe `normalizer` property of <<keyword,`keyword`>> fields is similar to\n<<analyzer,`analyzer`>> except that it guarantees that the analysis chain\nproduces a single token.\n\nThe `normalizer` is applied prior to indexing the keyword, as well as at\nsearch-time when the `keyword` field is searched via a query parser such as\nthe <<query-dsl-match-query,`match`>> query or via a term-level query\nsuch as the <<query-dsl-term-query,`term`>> query.\n\nA simple normalizer called `lowercase` ships with elasticsearch and can be used.\nCustom normalizers can be defined as part of analysis settings as follows.\n\n\n[source,console]\n--------------------------------\nPUT index\n{\n  \"settings\": {\n    \"analysis\": {\n      \"normalizer\": {\n        \"my_normalizer\": {\n          \"type\": \"custom\",\n          \"char_filter\": [],\n          \"filter\": [\"lowercase\", \"asciifolding\"]\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"foo\": {\n        \"type\": \"keyword\",\n        \"normalizer\": \"my_normalizer\"\n      }\n    }\n  }\n}\n\nPUT index/_doc/1\n{\n  \"foo\": \"B\u00c0R\"\n}\n\nPUT index/_doc/2\n{\n  \"foo\": \"bar\"\n}\n\nPUT index/_doc/3\n{\n  \"foo\": \"baz\"\n}\n\nPOST index/_refresh\n\nGET index/_search\n{\n  \"query\": {\n    \"term\": {\n      \"foo\": \"BAR\"\n    }\n  }\n}\n\nGET index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"foo\": \"BAR\"\n    }\n  }\n}\n--------------------------------\n\nThe above queries match documents 1 and 2 since `B\u00c0R` is converted to `bar` at\nboth index and query time.\n\n[source,console-result]\n----------------------------\n{\n  \"took\": $body.took,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 2,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.4700036,\n    \"hits\": [\n      {\n        \"_index\": \"index\",\n        \"_id\": \"1\",\n        \"_score\": 0.4700036,\n        \"_source\": {\n          \"foo\": \"B\u00c0R\"\n        }\n      },\n      {\n        \"_index\": \"index\",\n        \"_id\": \"2\",\n        \"_score\": 0.4700036,\n        \"_source\": {\n          \"foo\": \"bar\"\n        }\n      }\n    ]\n  }\n}\n----------------------------\n// TESTRESPONSE[s/\"took\".*/\"took\": \"$body.took\",/]\n\nAlso, the fact that keywords are converted prior to indexing also means that\naggregations return normalized values:\n\n[source,console]\n----------------------------\nGET index/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"foo_terms\": {\n      \"terms\": {\n        \"field\": \"foo\"\n      }\n    }\n  }\n}\n----------------------------\n// TEST[continued]\n\nreturns\n\n[source,console-result]\n----------------------------\n{\n  \"took\": 43,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 3,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": null,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"foo_terms\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"bar\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"baz\",\n          \"doc_count\": 1\n        }\n      ]\n    }\n  }\n}\n----------------------------\n// TESTRESPONSE[s/\"took\".*/\"took\": \"$body.took\",/]\n"
}