{
    "meta": {
        "size": 6133,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/regexp-syntax.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "regexp-syntax",
        "version": "8.15"
    },
    "doc": "[[regexp-syntax]]\n== Regular expression syntax\n\nA {wikipedia}/Regular_expression[regular expression] is a way to\nmatch patterns in data using placeholder characters, called operators.\n\n{es} supports regular expressions in the following queries:\n\n* <<query-dsl-regexp-query, `regexp`>>\n* <<query-dsl-query-string-query, `query_string`>>\n\n{es} uses https://lucene.apache.org/core/[Apache Lucene]'s regular expression\nengine to parse these queries.\n\n[discrete]\n[[regexp-reserved-characters]]\n=== Reserved characters\nLucene's regular expression engine supports all Unicode characters. However, the\nfollowing characters are reserved as operators:\n\n....\n. ? + * | { } [ ] ( ) \" \\\n....\n\nDepending on the <<regexp-optional-operators, optional operators>> enabled, the\nfollowing characters may also be reserved:\n\n....\n# @ & < >  ~\n....\n\nTo use one of these characters literally, escape it with a preceding\nbackslash or surround it with double quotes. For example:\n\n....\n\\@                  # renders as a literal '@'\n\\\\                  # renders as a literal '\\'\n\"john@smith.com\"    # renders as 'john@smith.com'\n....\n\n[NOTE]\n====\n\nThe backslash is an escape character in both JSON strings and regular\nexpressions. You need to escape both backslashes in a query, unless you use a\nlanguage client, which takes care of this. For example, the string `a\\b` needs\nto be indexed as `\"a\\\\b\"`:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001/_doc/1\n{\n  \"my_field\": \"a\\\\b\"\n}\n--------------------------------------------------\n\nThis document matches the following `regexp` query:\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"regexp\": {\n      \"my_field.keyword\": \"a\\\\\\\\.*\"\n    }\n  }\n}\n--------------------------------------------------\n//TEST[continued]\n====\n\n[discrete]\n[[regexp-standard-operators]]\n=== Standard operators\n\nLucene's regular expression engine does not use the\n{wikipedia}/Perl_Compatible_Regular_Expressions[Perl\nCompatible Regular Expressions (PCRE)] library, but it does support the\nfollowing standard operators.\n\n`.`::\n+\n--\nMatches any character. For example:\n\n....\nab.     # matches 'aba', 'abb', 'abz', etc.\n....\n--\n\n`?`::\n+\n--\nRepeat the preceding character zero or one times. Often used to make the\npreceding character optional. For example:\n\n....\nabc?     # matches 'ab' and 'abc'\n....\n--\n\n`+`::\n+\n--\nRepeat the preceding character one or more times. For example:\n\n....\nab+     # matches 'ab', 'abb', 'abbb', etc.\n....\n--\n\n`*`::\n+\n--\nRepeat the preceding character zero or more times. For example:\n\n....\nab*     # matches 'a', 'ab', 'abb', 'abbb', etc.\n....\n--\n\n`{}`::\n+\n--\nMinimum and maximum number of times the preceding character can repeat. For\nexample:\n\n....\na{2}    # matches 'aa'\na{2,4}  # matches 'aa', 'aaa', and 'aaaa'\na{2,}   # matches 'a` repeated two or more times\n....\n--\n\n`|`::\n+\n--\nOR operator. The match will succeed if the longest pattern on either the left\nside OR the right side matches. For example:\n....\nabc|xyz  # matches 'abc' and 'xyz'\n....\n--\n\n`( \u2026 )`::\n+\n--\nForms a group. You can use a group to treat part of the expression as a single\ncharacter. For example:\n\n....\nabc(def)?  # matches 'abc' and 'abcdef' but not 'abcd'\n....\n--\n\n`[ \u2026 ]`::\n+\n--\nMatch one of the characters in the brackets. For example:\n\n....\n[abc]   # matches 'a', 'b', 'c'\n....\n\nInside the brackets, `-` indicates a range unless `-` is the first character or\nescaped. For example:\n\n....\n[a-c]   # matches 'a', 'b', or 'c'\n[-abc]  # '-' is first character. Matches '-', 'a', 'b', or 'c'\n[abc\\-] # Escapes '-'. Matches 'a', 'b', 'c', or '-'\n....\n\nA `^` before a character in the brackets negates the character or range. For\nexample:\n\n....\n[^abc]      # matches any character except 'a', 'b', or 'c'\n[^a-c]      # matches any character except 'a', 'b', or 'c'\n[^-abc]     # matches any character except '-', 'a', 'b', or 'c'\n[^abc\\-]    # matches any character except 'a', 'b', 'c', or '-'\n....\n--\n\n[discrete]\n[[regexp-optional-operators]]\n=== Optional operators\n\nYou can use the `flags` parameter to enable more optional operators for\nLucene's regular expression engine.\n\nTo enable multiple operators, use a `|` separator. For example, a `flags` value\nof `COMPLEMENT|INTERVAL` enables the `COMPLEMENT` and `INTERVAL` operators.\n\n[discrete]\n==== Valid values \n\n`ALL` (Default)::\nEnables all optional operators.\n\n`\"\"` (empty string)::\nAlias for the `ALL` value.\n\n`COMPLEMENT`::\n+\n--\nEnables the `~` operator. You can use `~` to negate the shortest following\npattern. For example:\n\n....\na~bc   # matches 'adc' and 'aec' but not 'abc'\n....\n--\n\n`EMPTY`::\n+\n--\nEnables the `#` (empty language) operator. The `#` operator doesn't match any\nstring, not even an empty string.\n\nIf you create regular expressions by programmatically combining values, you can\npass `#` to specify \"no string.\" This lets you avoid accidentally matching empty\nstrings or other unwanted strings. For example:\n\n....\n#|abc  # matches 'abc' but nothing else, not even an empty string\n....\n--\n\n`INTERVAL`::\n+\n--\nEnables the `<>` operators. You can use `<>` to match a numeric range. For\nexample:\n\n....\nfoo<1-100>      # matches 'foo1', 'foo2' ... 'foo99', 'foo100'\nfoo<01-100>     # matches 'foo01', 'foo02' ... 'foo99', 'foo100'\n....\n--\n\n`INTERSECTION`::\n+\n--\nEnables the `&` operator, which acts as an AND operator. The match will succeed\nif patterns on both the left side AND the right side matches. For example:\n\n....\naaa.+&.+bbb  # matches 'aaabbb'\n....\n--\n\n`ANYSTRING`::\n+\n--\nEnables the `@` operator. You can use `@` to match any entire\nstring.\n\nYou can combine the `@` operator with `&` and `~` operators to create an\n\"everything except\" logic. For example:\n\n....\n@&~(abc.+)  # matches everything except terms beginning with 'abc'\n....\n--\n\n`NONE`::\nDisables all optional operators.\n\n[discrete]\n[[regexp-unsupported-operators]]\n=== Unsupported operators\nLucene's regular expression engine does not support anchor operators, such as\n`^` (beginning of line) or `$` (end of line). To match a term, the regular\nexpression must match the entire string.\n"
}