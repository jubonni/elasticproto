{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.365077",
        "size": 16521,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-syntax-select.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "sql-syntax-select",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[sql-syntax-select]]\n=== SELECT\n\n.Synopsis:\n[source, sql]\n----\nSELECT [TOP [ count ] ] select_expr [, ...]\n[ FROM table_name ]\n[ WHERE condition ]\n[ GROUP BY grouping_element [, ...] ]\n[ HAVING condition]\n[ ORDER BY expression [ ASC | DESC ] [, ...] ]\n[ LIMIT [ count ] ]\n[ PIVOT ( aggregation_expr FOR column IN ( value [ [ AS ] alias ] [, ...] ) ) ]\n----\n\n*Description*: Retrieves rows from zero or more tables.\n\nThe general execution of `SELECT` is as follows:\n\n. All elements in the `FROM` list are computed (each element can be base or alias table). Currently `FROM` supports exactly one table. Do note however that the table name can be a pattern (see <<sql-syntax-from, FROM Clause>> below).\n. If the `WHERE` clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See <<sql-syntax-where, WHERE Clause>> below.)\n. If the `GROUP BY` clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the `HAVING` clause is present, it eliminates groups that do not satisfy the given condition. (See <<sql-syntax-group-by, GROUP BY Clause>> and <<sql-syntax-having, HAVING Clause>> below.)\n. The actual output rows are computed using the `SELECT` output expressions for each selected row or row group.\n. If the `ORDER BY` clause is specified, the returned rows are sorted in the specified order. If `ORDER BY` is not given, the rows are returned in whatever order the system finds fastest to produce. (See <<sql-syntax-order-by,ORDER BY Clause>> below.)\n. If the `LIMIT` or `TOP` is specified (cannot use both in the same query), the `SELECT` statement only returns a subset of the result rows. (See <<sql-syntax-limit, LIMIT Clause>> and <<sql-syntax-top, TOP clause>> below.)\n\n\n[[sql-syntax-select-list]]\n==== `SELECT` List\n\n`SELECT` list, namely the expressions between `SELECT` and `FROM`, represent the output rows of the `SELECT` statement.\n\nAs with a table, every output column of a `SELECT` has a name which can be either specified per column through the `AS` keyword :\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[selectColumnAlias]\n----\n\nNote: `AS` is an optional keyword however it helps with the readability and in some case ambiguity of the query\nwhich is why it is recommended to specify it.\n\nassigned by {es-sql} if no name is given:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[selectInline]\n----\n\nor if it's a simple column reference, use its name as the column name:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[selectColumn]\n----\n\n[[sql-syntax-select-wildcard]]\n==== Wildcard\n\nTo select all the columns in the source, one can use `*`:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[wildcardWithOrder]\n----\n\nwhich essentially returns all(top-level fields, sub-fields, such as multi-fields are ignored] columns found.\n\n[[sql-syntax-top]]\n==== TOP\n\nThe `TOP` clause can be used before the <<sql-syntax-select-list, `SELECT` list>> or the <<sql-syntax-select-wildcard, `wildcard`> to\nrestrict (limit) the number of rows returned using the format:\n\n[source, sql]\n----\nSELECT TOP <count> <select list> ...\n----\n\nwhere\n\ncount:: is a positive integer or zero indicating the maximum *possible* number of results being returned (as there might be fewer matches\nthan the limit). If `0` is specified, no results are returned.\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[topBasic]\n----\n\n[NOTE]\n<<sql-syntax-top, `TOP`>> and <<sql-syntax-limit, `LIMIT`>> cannot be used together in the same query and an error is returned otherwise.\n\n[[sql-syntax-from]]\n==== FROM Clause\n\nThe `FROM` clause specifies one table for the `SELECT` and has the following syntax:\n\n[source, sql]\n----\nFROM table_name [ [ AS ] alias ]\n----\n\nwhere:\n\n`table_name`::\n\nRepresents the name (optionally qualified) of an existing table, either a concrete or base one (actual index) or alias.\n\n\nIf the table name contains special SQL characters (such as `.`,`-`,`*`,etc...) use double quotes to escape them:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[fromTableQuoted]\n----\n\nThe name can be a <<api-multi-index, pattern>> pointing to multiple indices (likely requiring quoting as mentioned above) with the restriction that *all* resolved concrete tables have **exact mapping**.\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[fromTablePatternQuoted]\n----\n\nexperimental:[] To run a <<modules-cross-cluster-search,{ccs}>>, specify a\ncluster name using the `<remote_cluster>:<target>` syntax, where\n`<remote_cluster>` maps to a SQL catalog (cluster) and `<target>` to a table\n(index or data stream). The `<remote_cluster>` supports wildcards (`*`)\nand `<target>` can be an <<sql-index-patterns, index pattern>>.\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/multi-cluster-with-security/multi-cluster-docs.csv-spec[fromQualifiedTableQuoted]\n----\n\n`alias`::\nA substitute name for the `FROM` item containing the alias. An alias is used for brevity or to eliminate ambiguity. When an alias is provided, it completely hides the actual name of the table and must be used in its place.\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[fromTableAlias]\n----\n\n[[sql-syntax-where]]\n==== WHERE Clause\n\nThe optional `WHERE` clause is used to filter rows from the query and has the following syntax:\n\n[source, sql]\n----\nWHERE condition\n----\n\nwhere:\n\n`condition`::\n\nRepresents an expression that evaluates to a `boolean`. Only the rows that match the condition (to `true`) are returned.\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[basicWhere]\n----\n\n[[sql-syntax-group-by]]\n==== GROUP BY\n\nThe `GROUP BY` clause is used to divide the results into groups of rows on matching values from the designated columns. It has the following syntax:\n\n[source, sql]\n----\nGROUP BY grouping_element [, ...]\n----\n\nwhere:\n\n`grouping_element`::\n\nRepresents an expression on which rows are being grouped _on_. It can be a column name, alias or ordinal number of a column or an arbitrary expression of column values.\n\nA common, group by column name:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByColumn]\n----\n\nGrouping by output ordinal:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByOrdinal]\n----\n\nGrouping by alias:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByAlias]\n----\n\nAnd grouping by column expression (typically used along-side an alias):\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByExpression]\n----\n\nOr a mixture of the above:\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByMulti]\n----\n\n\nWhen a `GROUP BY` clause is used in a `SELECT`, _all_ output expressions must be either aggregate functions or expressions used for grouping or derivatives of (otherwise there would be more than one possible value to return for each ungrouped column).\n\nTo wit:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByAndAgg]\n----\n\nExpressions over aggregates used in output:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByAndAggExpression]\n----\n\nMultiple aggregates used:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByAndMultipleAggs]\n----\n\n[TIP]\nIf custom bucketing is required, it can be achieved with the use of <<sql-functions-conditional-case, `CASE`>>,\nas shown <<sql-functions-conditional-case-groupby-custom-buckets, here>>.\n\n[[sql-syntax-group-by-implicit]]\n===== Implicit Grouping\n\nWhen an aggregation is used without an associated `GROUP BY`, an __implicit grouping__ is applied, meaning all selected rows are considered to form a single default, or implicit group.\nAs such, the query emits only a single row (as there is only a single group).\n\nA common example is counting the number of records:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByImplicitCount]\n----\n\nOf course, multiple aggregations can be applied:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByImplicitMultipleAggs]\n----\n\n[[sql-syntax-having]]\n==== HAVING\n\nThe `HAVING` clause can be used _only_ along aggregate functions (and thus `GROUP BY`) to filter what groups are kept or not and has the following syntax:\n\n[source, sql]\n----\nHAVING condition\n----\n\nwhere:\n\n`condition`::\n\nRepresents an expression that evaluates to a `boolean`. Only groups that match the condition (to `true`) are returned.\n\nBoth `WHERE` and `HAVING` are used for filtering however there are several significant differences between them:\n\n. `WHERE` works on individual *rows*, `HAVING` works on the *groups* created by ``GROUP BY``\n. `WHERE` is evaluated *before* grouping, `HAVING` is evaluated *after* grouping\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByHaving]\n----\n\nFurther more, one can use multiple aggregate expressions inside `HAVING` even ones that are not used in the output (`SELECT`):\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByHavingMultiple]\n----\n\n[[sql-syntax-having-group-by-implicit]]\n===== Implicit Grouping\n\nAs indicated above, it is possible to have a `HAVING` clause without a `GROUP BY`. In this case, the so-called <<sql-syntax-group-by-implicit, __implicit grouping__>> is applied, meaning all selected rows are considered to form a single group and `HAVING` can be applied on any of the aggregate functions specified on this group.\nAs such, the query emits only a single row (as there is only a single group) and `HAVING` condition returns either one row (the group) or zero if the condition fails.\n\nIn this example, `HAVING` matches:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByHavingImplicitMatch]\n----\n\n//However `HAVING` can also not match, in which case an empty result is returned:\n//\n//[source, sql]\n//----\n//include-tagged::{sql-specs}/docs/docs.csv-spec[groupByHavingImplicitNoMatch]\n//----\n\n\n[[sql-syntax-order-by]]\n==== ORDER BY\n\nThe `ORDER BY` clause is used to sort the results of `SELECT` by one or more expressions:\n\n[source, sql]\n----\nORDER BY expression [ ASC | DESC ] [, ...]\n----\n\nwhere:\n\n`expression`::\n\nRepresents an input column, an output column or an ordinal number of the position (starting from one) of an output column. Additionally, ordering can be done based on the results _score_.\nThe direction, if not specified, is by default `ASC` (ascending).\nRegardless of the ordering specified, null values are ordered last (at the end).\n\nIMPORTANT: When used along-side, `GROUP BY` expression can point _only_ to the columns used for grouping or aggregate functions.\n\nFor example, the following query sorts by an arbitrary input field (`page_count`):\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[orderByBasic]\n----\n\n[[sql-syntax-order-by-grouping]]\n==== Order By and Grouping\n\nFor queries that perform grouping, ordering can be applied either on the grouping columns (by default ascending) or on aggregate functions.\n\nNOTE: With `GROUP BY`, make sure the ordering targets the resulting group - applying it to individual elements inside the group will have no impact on the results since regardless of the order, values inside the group are aggregated.\n\nFor example, to order groups simply indicate the grouping key:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[orderByGroup]\n----\n\nMultiple keys can be specified of course:\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[groupByMulti]\n----\n\nFurther more, it is possible to order groups based on aggregations of their values:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[orderByAgg]\n----\n\nIMPORTANT: Ordering by aggregation is possible for up to *10000* entries for memory consumption reasons.\nIn cases where the results pass this threshold, use <<sql-syntax-limit,`LIMIT`>> or <<sql-syntax-top, `TOP`>> to reduce the number\nof results.\n\n[[sql-syntax-order-by-score]]\n==== Order By Score\n\nWhen doing full-text queries in the `WHERE` clause, results can be returned based on their\n{defguide}/relevance-intro.html[score] or _relevance_ to the given query.\n\nNOTE: When doing multiple text queries in the `WHERE` clause then, their scores will be\ncombined using the same rules as {es}'s\n<<query-dsl-bool-query,bool query>>.\n\nTo sort based on the `score`, use the special function `SCORE()`:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[orderByScore]\n----\n\nNote that you can return `SCORE()` by using a full-text search predicate in the `WHERE` clause.\nThis is possible even if `SCORE()` is not used for sorting:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[orderByScoreWithMatch]\n----\n\nNOTE:\nTrying to return `score` from a non full-text query will return the same value for all results, as\nall are equally relevant.\n\n[[sql-syntax-limit]]\n==== LIMIT\n\nThe `LIMIT` clause restricts (limits) the number of rows returned using the format:\n\n[source, sql]\n----\nLIMIT ( <count> | ALL )\n----\n\nwhere\n\ncount:: is a positive integer or zero indicating the maximum *possible* number of results being returned (as there might be fewer matches\nthan the limit). If `0` is specified, no results are returned.\n\nALL:: indicates there is no limit and thus all results are being returned.\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[limitBasic]\n----\n\n[NOTE]\n<<sql-syntax-top, `TOP`>> and <<sql-syntax-limit, `LIMIT`>> cannot be used together in the same query and an error is returned otherwise.\n\n[[sql-syntax-pivot]]\n==== PIVOT\n\nThe `PIVOT` clause performs a cross tabulation on the results of the query: it aggregates the results and rotates rows into columns. The rotation is done by turning unique values from one column in the expression - the pivoting column - into multiple columns in the output. The column values are aggregations on the remaining columns specified in the expression.\n\nThe clause can be broken down in three parts: the aggregation, the `FOR`- and the `IN`-subclause.\n\nThe `aggregation_expr` subclause specifies an expression containing an <<sql-functions-aggs, aggregation function>> to be applied on one of the source columns. Only one aggregation can be provided, currently.\n\nThe `FOR`-subclause specifies the pivoting column: the distinct values of this column will become the candidate set of values to be rotated.\n\nThe `IN`-subclause defines a filter: the intersection between the set provided here and the candidate set from the `FOR`-subclause will be rotated to become the headers of the columns appended to the end result. The filter can not be a subquery, one must provide here literal values, obtained in advance.\n\nThe pivoting operation will perform an implicit <<sql-syntax-group-by, GROUP BY>> on all source columns not specified in the `PIVOT` clause, along with the values filtered through the `IN`-clause. Consider the following statement:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/pivot.csv-spec[sumWithoutSubquery]\n----\n\nThe query execution could logically be broken down in the following steps:\n\n. a <<sql-syntax-group-by, GROUP BY>> on the column in the `FOR`-clause: `languages`;\n. the resulting values are filtered through the set provided in the `IN`-clause;\n. the now filtered column is pivoted to form the headers of the two additional columns appended to the result: `1` and `2`;\n. a <<sql-syntax-group-by, GROUP BY>> on all columns of the source table `test_emp`, except `salary` (part of the aggregation subclause) and `languages` (part of the `FOR`-clause);\n. the values in these appended columns are the `SUM` aggregations of `salary`, grouped by the respective language.\n\n\nThe table-value expression to cross-tabulate can also be the result of a subquery:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/pivot.csv-spec[averageWithOneValue]\n----\n\nThe pivoted columns can be aliased (and quoting is required to accommodate white spaces), with or without a supporting `AS` token:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/pivot.csv-spec[averageWithTwoValuesAndAlias]\n----\n\nThe resulting cross tabulation can further have the <<sql-syntax-order-by,ORDER BY>> and <<sql-syntax-limit, LIMIT>> clauses applied:\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/pivot.csv-spec[averageWithOneValueAndOrder]\n----\n\n"
}