{
    "meta": {
        "timestamp": "2024-11-01T03:07:08.748276",
        "size": 3078,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-phonetic.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "analysis-phonetic",
        "version": "8.15"
    },
    "doc": "[[analysis-phonetic]]\n=== Phonetic analysis plugin\n\nThe Phonetic Analysis plugin provides token filters which convert tokens to\ntheir phonetic representation using Soundex, Metaphone, and a variety of other\nalgorithms.\n\n:plugin_name: analysis-phonetic\ninclude::install_remove.asciidoc[]\n\n\n[[analysis-phonetic-token-filter]]\n==== `phonetic` token filter\n\nThe `phonetic` token filter takes the following settings:\n\n`encoder`::\n\n    Which phonetic encoder to use. Accepts `metaphone` (default),\n    `double_metaphone`, `soundex`, `refined_soundex`, `caverphone1`,\n    `caverphone2`, `cologne`, `nysiis`, `koelnerphonetik`, `haasephonetik`,\n    `beider_morse`, `daitch_mokotoff`.\n\n`replace`::\n\n    Whether or not the original token should be replaced by the phonetic\n    token. Accepts `true` (default) and `false`. Not supported by\n    `beider_morse` encoding.\n\n[source,console]\n--------------------------------------------------\nPUT phonetic_sample\n{\n  \"settings\": {\n    \"index\": {\n      \"analysis\": {\n        \"analyzer\": {\n          \"my_analyzer\": {\n            \"tokenizer\": \"standard\",\n            \"filter\": [\n              \"lowercase\",\n              \"my_metaphone\"\n            ]\n          }\n        },\n        \"filter\": {\n          \"my_metaphone\": {\n            \"type\": \"phonetic\",\n            \"encoder\": \"metaphone\",\n            \"replace\": false\n          }\n        }\n      }\n    }\n  }\n}\n\nGET phonetic_sample/_analyze\n{\n  \"analyzer\": \"my_analyzer\",\n  \"text\": \"Joe Bloggs\" <1>\n}\n--------------------------------------------------\n\n<1> Returns: `J`, `joe`, `BLKS`, `bloggs`\n\nIt is important to note that `\"replace\": false` can lead to unexpected behavior since\nthe original and the phonetically analyzed version are both kept at the same token position.\nSome queries handle these stacked tokens in special ways. For example, the fuzzy `match`\nquery does not apply {ref}/common-options.html#fuzziness[fuzziness] to stacked synonym tokens.\nThis can lead to issues that are difficult to diagnose and reason about. For this reason, it\nis often beneficial to use separate fields for analysis with and without phonetic filtering.\nThat way searches can be run against both fields with differing boosts and trade-offs (e.g.\nonly run a fuzzy `match` query on the original text field, but not on the phonetic version).\n\n[discrete]\n===== Double metaphone settings\n\nIf the `double_metaphone` encoder is used, then this additional setting is\nsupported:\n\n`max_code_len`::\n\n    The maximum length of the emitted metaphone token. Defaults to `4`.\n\n[discrete]\n===== Beider Morse settings\n\nIf the `beider_morse` encoder is used, then these additional settings are\nsupported:\n\n`rule_type`::\n\n    Whether matching should be `exact` or `approx` (default).\n\n`name_type`::\n\n    Whether names are `ashkenazi`, `sephardic`, or `generic` (default).\n\n`languageset`::\n\n    An array of languages to check. If not specified, then the language will\n    be guessed. Accepts: `any`, `common`, `cyrillic`, `english`, `french`,\n    `german`, `hebrew`, `hungarian`, `polish`, `romanian`, `russian`,\n    `spanish`.\n"
}