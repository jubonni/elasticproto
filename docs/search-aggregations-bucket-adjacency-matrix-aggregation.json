{
    "meta": {
        "timestamp": "2024-11-01T03:07:08.725288",
        "size": 4630,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-adjacency-matrix-aggregation.html",
        "type": "documentation",
        "role": [
            "child_attributes"
        ],
        "has_code": true,
        "title": "search-aggregations-bucket-adjacency-matrix-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-adjacency-matrix-aggregation]]\n=== Adjacency matrix aggregation\n++++\n<titleabbrev>Adjacency matrix</titleabbrev>\n++++\n\nA bucket aggregation returning a form of {wikipedia}/Adjacency_matrix[adjacency matrix].\nThe request provides a collection of named filter expressions, similar to the `filters` aggregation\nrequest. \nEach bucket in the response represents a non-empty cell in the matrix of intersecting filters.\n\nGiven filters named `A`, `B` and `C` the response would return buckets with the following names:\n\n\n[options=\"header\"]\n|=======================\n|  h|A   h|B  h|C   \nh|A |A   |A&B |A&C \nh|B |    |B   |B&C \nh|C |    |    |C  \n|=======================\n\nThe intersecting buckets e.g `A&C` are labelled using a combination of the two filter names with a default separator\nof `&`. Note that the response does not also include a `C&A` bucket as this would be the\nsame set of documents as `A&C`. The matrix is said to be _symmetric_ so we only return half of it. To do this we sort \nthe filter name strings and always use the lowest of a pair as the value to the left of the separator. \n\n\n[[adjacency-matrix-agg-ex]]\n==== Example\n\nThe following `interactions` aggregation uses `adjacency_matrix` to determine\nwhich groups of individuals exchanged emails.\n\n[source,console,id=adjacency-matrix-aggregation-example]\n--------------------------------------------------\nPUT emails/_bulk?refresh\n{ \"index\" : { \"_id\" : 1 } }\n{ \"accounts\" : [\"hillary\", \"sidney\"]}\n{ \"index\" : { \"_id\" : 2 } }\n{ \"accounts\" : [\"hillary\", \"donald\"]}\n{ \"index\" : { \"_id\" : 3 } }\n{ \"accounts\" : [\"vladimir\", \"donald\"]}\n\nGET emails/_search\n{\n  \"size\": 0,\n  \"aggs\" : {\n    \"interactions\" : {\n      \"adjacency_matrix\" : {\n        \"filters\" : {\n          \"grpA\" : { \"terms\" : { \"accounts\" : [\"hillary\", \"sidney\"] }},\n          \"grpB\" : { \"terms\" : { \"accounts\" : [\"donald\", \"mitt\"] }},\n          \"grpC\" : { \"terms\" : { \"accounts\" : [\"vladimir\", \"nigel\"] }}\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThe response contains buckets with document counts for each filter and\ncombination of filters. Buckets with no matching documents are excluded from the\nresponse.\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 9,\n  \"timed_out\": false,\n  \"_shards\": ...,\n  \"hits\": ...,\n  \"aggregations\": {\n    \"interactions\": {\n      \"buckets\": [\n        {\n          \"key\":\"grpA\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\":\"grpA&grpB\",\n          \"doc_count\": 1\n        },\n        {\n          \"key\":\"grpB\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\":\"grpB&grpC\",\n          \"doc_count\": 1\n        },\n        {\n          \"key\":\"grpC\",\n          \"doc_count\": 1\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 9/\"took\": $body.took/]\n// TESTRESPONSE[s/\"_shards\": \\.\\.\\./\"_shards\": $body._shards/]\n// TESTRESPONSE[s/\"hits\": \\.\\.\\./\"hits\": $body.hits/]\n\n[role=\"child_attributes\"]\n[[adjacency-matrix-agg-params]]\n==== Parameters\n\n`filters`::\n(Required, object)\nFilters used to create buckets.\n+\n.Properties of `filters`\n[%collapsible%open]\n====\n`<filter>`::\n(Required, <<query-dsl,Query DSL object>>)\nQuery used to filter documents. The key is the filter name.\n+\nAt least one filter is required. The total number of filters cannot exceed the\n<<indices-query-bool-max-clause-count,`indices.query.bool.max_clause_count`>>\nsetting. See <<adjacency-matrix-agg-filter-limits>>.\n====\n\n`separator`::\n(Optional, string)\nSeparator used to concatenate filter names. Defaults to `&`.\n\n[[adjacency-matrix-agg-response]]\n==== Response body\n\n`key`::\n(string)\nFilters for the bucket. If the bucket uses multiple filters, filter names are\nconcatenated using a `separator`.\n\n`doc_count`::\n(integer)\nNumber of documents matching the bucket's filters.\n\n[[adjacency-matrix-agg-usage]]\n==== Usage\nOn its own this aggregation can provide all of the data required to create an undirected weighted graph.\nHowever, when used with child aggregations such as a `date_histogram` the results can provide the\nadditional levels of data required to perform {wikipedia}/Dynamic_network_analysis[dynamic network analysis]\nwhere examining interactions _over time_ becomes important.\n\n[[adjacency-matrix-agg-filter-limits]]\n==== Filter limits\nFor N filters the matrix of buckets produced can be N\u00b2/2 which can be costly.\nThe circuit breaker settings prevent results producing too many buckets and to avoid excessive disk seeks\nthe `indices.query.bool.max_clause_count` setting is used to limit the number of filters.\n"
}