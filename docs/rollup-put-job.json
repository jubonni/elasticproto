{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.971278",
        "size": 10664,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/rollup-put-job.html",
        "type": "documentation",
        "role": [
            "xpack",
            "child_attributes"
        ],
        "has_code": true,
        "title": "rollup-put-job",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[rollup-put-job]]\n=== Create {rollup-jobs} API\n[subs=\"attributes\"]\n++++\n<titleabbrev>Create {rollup-jobs}</titleabbrev>\n++++\n\ndeprecated::[8.11.0,\"Rollups will be removed in a future version. Use <<downsampling,downsampling>> instead.\"]\n\nWARNING: From 8.15.0 invoking this API in a cluster with no rollup usage will fail with a message about Rollup's\ndeprecation and planned removal. A cluster either needs to contain a rollup job or a rollup index in order for this API\nto be allowed to execute.\n\nCreates a {rollup-job}.\n\n[[rollup-put-job-api-request]]\n==== {api-request-title}\n\n`PUT _rollup/job/<job_id>`\n\n[[rollup-put-job-api-prereqs]]\n==== {api-prereq-title}\n\n* If the {es} {security-features} are enabled, you must have `manage` or\n`manage_rollup` cluster privileges to use this API. For more information, see\n<<security-privileges>>.\n\n[[rollup-put-job-api-desc]]\n==== {api-description-title}\n\nThe {rollup-job} configuration contains all the details about how the job should\nrun, when it indexes documents, and what future queries will be able to execute\nagainst the rollup index.\n\nThere are three main sections to the job configuration: the logistical details\nabout the job (cron schedule, etc), the fields that are used for grouping, and\nwhat metrics to collect for each group.\n\nJobs are created in a `STOPPED` state. You can start them with the\n<<rollup-start-job,start {rollup-jobs} API>>.\n\n[[rollup-put-job-api-path-params]]\n==== {api-path-parms-title}\n\n`<job_id>`::\n  (Required, string) Identifier for the {rollup-job}. This can be any\n  alphanumeric string and uniquely identifies the data that is associated with\n  the {rollup-job}. The ID is persistent; it is stored with the rolled up data.\n  If you create a job, let it run for a while, then delete the job, the data\n  that the job rolled up is still be associated with this job ID. You cannot\n  create a new job with the same ID since that could lead to problems with\n  mismatched job configurations.\n\n[role=\"child_attributes\"]\n[[rollup-put-job-api-request-body]]\n==== {api-request-body-title}\n\n`cron`::\n(Required, string) A cron string which defines the intervals when the\n{rollup-job} should be executed. When the interval triggers, the indexer\nattempts to rollup the data in the index pattern. The cron pattern is\nunrelated to the time interval of the data being rolled up. For example, you\nmay wish to create hourly rollups of your document but to only run the indexer\non a daily basis at midnight, as defined by the cron. The cron pattern is\ndefined just like a {watcher} cron schedule.\n\n//Begin groups\n[[rollup-groups-config]]\n`groups`::\n(Required, object) Defines the grouping fields and aggregations that are\ndefined for this {rollup-job}. These fields will then be available later for\naggregating into buckets.\n+\nThese aggs and fields can be used in any combination. Think of the `groups`\nconfiguration as defining a set of tools that can later be used in aggregations\nto partition the data. Unlike raw data, we have to think ahead to which fields\nand aggregations might be used. Rollups provide enough flexibility that you\nsimply need to determine _which_ fields are needed, not _in what order_ they are\nneeded.\n+\nThere are three types of groupings currently available: `date_histogram`,\n`histogram`, and `terms`.\n+\n.Properties of `groups`\n[%collapsible%open]\n====\n//Begin date_histogram\n`date_histogram`:::\n(Required, object) A date histogram group aggregates a `date` field into\ntime-based buckets. This group is *mandatory*; you currently cannot rollup\ndocuments without a timestamp and a `date_histogram` group. The\n`date_histogram` group has several parameters:\n+\n.Properties of `date_histogram`\n[%collapsible%open]\n=====\n`calendar_interval` or `fixed_interval`::::\n(Required, <<time-units,time units>>) The interval of time buckets to be\ngenerated when rolling up. For example, `60m` produces 60 minute (hourly)\nrollups. This follows standard time formatting syntax as used elsewhere in {es}.\nThe interval defines the _minimum_ interval that can be aggregated only. If\nhourly (`60m`) intervals are configured, <<rollup-search,rollup search>>\ncan execute aggregations with 60m or greater (weekly, monthly, etc) intervals.\nSo define the interval as the smallest unit that you wish to later query. For\nmore information about the difference between calendar and fixed time\nintervals, see <<calendar_and_fixed_intervals>>.\n+\n--\nNOTE: Smaller, more granular intervals take up proportionally more space.\n\n--\n\n`delay`::::\n(Optional,<<time-units,time units>>) How long to wait before rolling up new\ndocuments. By default, the indexer attempts to roll up all data that is\navailable. However, it is not uncommon for data to arrive out of order,\nsometimes even a few days late. The indexer is unable to deal with data that\narrives after a time-span has been rolled up. That is to say, there is no\nprovision to update already-existing rollups.\n+\n--\nInstead, you should specify a `delay` that matches the longest period of time\nyou expect out-of-order data to arrive. For example, a `delay` of `1d`\ninstructs the indexer to roll up documents up to `now - 1d`, which provides\na day of buffer time for out-of-order documents to arrive.\n--\n\n`field`::::\n(Required, string) The date field that is to be rolled up.\n\n`time_zone`::::\n(Optional, string) Defines what time_zone the rollup documents are stored as.\nUnlike raw data, which can shift timezones on the fly, rolled documents have to\nbe stored with a specific timezone. By default, rollup documents are stored\nin `UTC`.\n=====\n//End date_histogram\n\n//Begin histogram\n`histogram`:::\n(Optional, object) The histogram group aggregates one or more numeric fields\ninto numeric histogram intervals.\n+\n.Properties of `histogram`\n[%collapsible%open]\n=====\n`fields`::::\n(Required, array) The set of fields that you wish to build histograms for. All\nfields specified must be some kind of numeric. Order does not matter.\n\n`interval`::::\n(Required, integer) The interval of histogram buckets to be generated when\nrolling up. For example, a value of `5` creates buckets that are five units wide\n(`0-5`, `5-10`, etc). Note that only one interval can be specified in the\n`histogram` group, meaning that all fields being grouped via the histogram\nmust share the same interval.\n=====\n//End histogram\n\n//Begin terms\n`terms`:::\n(Optional, object) The terms group can be used on `keyword` or numeric fields to\nallow bucketing via the `terms` aggregation at a later point. The indexer\nenumerates and stores _all_ values of a field for each time-period. This can be\npotentially costly for high-cardinality groups such as IP addresses, especially\nif the time-bucket is particularly sparse.\n+\n--\nTIP: While it is unlikely that a rollup will ever be larger in size than the raw\ndata, defining `terms` groups on multiple high-cardinality fields can\neffectively reduce the compression of a rollup to a large extent. You should be\njudicious which high-cardinality fields are included for that reason.\n\n--\n+\n.Properties of `terms`\n[%collapsible%open]\n=====\n\n`fields`::::\n(Required, string) The set of fields that you wish to collect terms for. This\narray can contain fields that are both `keyword` and numerics. Order does not\nmatter.\n=====\n//End terms\n====\n//End groups\n\n`index_pattern`::\n(Required, string) The index or index pattern to roll up. Supports\nwildcard-style patterns (`logstash-*`). The job attempts to rollup the entire\nindex or index-pattern.\n+\n--\nNOTE: The `index_pattern` cannot be a pattern that would also match the\ndestination `rollup_index`. For example, the pattern `foo-*` would match the\nrollup index `foo-rollup`. This situation would cause problems because the\n{rollup-job} would attempt to rollup its own data at runtime. If you attempt to\nconfigure a pattern that matches the `rollup_index`, an exception occurs to\nprevent this behavior.\n\n--\n\n//Begin metrics\n[[rollup-metrics-config]]\n`metrics`::\n(Optional, object) Defines the metrics to collect for each grouping tuple. By\ndefault, only the doc_counts are collected for each group. To make rollup useful,\nyou will often add metrics like averages, mins, maxes, etc. Metrics are defined\non a per-field basis and for each field you configure which metric should be\ncollected.\n+\nThe `metrics` configuration accepts an array of objects, where each object has\ntwo parameters.\n+\n.Properties of metric objects\n[%collapsible%open]\n====\n`field`:::\n(Required, string) The field to collect metrics for. This must be a numeric of\nsome kind.\n\n`metrics`:::\n(Required, array) An array of metrics to collect for the field. At least one\nmetric must be configured. Acceptable metrics are `min`,`max`,`sum`,`avg`, and\n`value_count`.\n====\n//End metrics\n\n`page_size`::\n(Required, integer) The number of bucket results that are processed on each\niteration of the rollup indexer. A larger value tends to execute faster, but\nrequires more memory during processing. This value has no effect on how the data\nis rolled up; it is merely used for tweaking the speed or memory cost of\nthe indexer.\n\n`rollup_index`::\n(Required, string) The index that contains the rollup results. The index can\nbe shared with other {rollup-jobs}. The data is stored so that it doesn't\ninterfere with unrelated jobs.\n\n`timeout`::\n(Optional, <<time-units,time value>>)\nTime to wait for the request to complete. Defaults to `20s` (20 seconds).\n\n[[rollup-put-job-api-example]]\n==== {api-example-title}\n\nThe following example creates a {rollup-job} named `sensor`, targeting the\n`sensor-*` index pattern:\n\n[source,console]\n--------------------------------------------------\nPUT _rollup/job/sensor\n{\n  \"index_pattern\": \"sensor-*\",\n  \"rollup_index\": \"sensor_rollup\",\n  \"cron\": \"*/30 * * * * ?\",\n  \"page_size\": 1000,\n  \"groups\": { <1>\n    \"date_histogram\": {\n      \"field\": \"timestamp\",\n      \"fixed_interval\": \"1h\",\n      \"delay\": \"7d\"\n    },\n    \"terms\": {\n      \"fields\": [ \"node\" ]\n    }\n  },\n  \"metrics\": [ <2>\n      {\n      \"field\": \"temperature\",\n      \"metrics\": [ \"min\", \"max\", \"sum\" ]\n    },\n    {\n      \"field\": \"voltage\",\n      \"metrics\": [ \"avg\" ]\n    }\n  ]\n}\n--------------------------------------------------\n// TEST[setup:sensor_index]\n<1> This configuration enables date histograms to be used on the `timestamp`\nfield and `terms` aggregations to be used on the `node` field.\n<2> This configuration defines metrics over two fields: `temperature` and\n`voltage`. For the `temperature` field, we are collecting the min, max, and\nsum of the temperature. For `voltage`, we are collecting the average.\n\nWhen the job is created, you receive the following results:\n\n[source,console-result]\n----\n{\n  \"acknowledged\": true\n}\n----\n"
}