{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.441271",
        "size": 5217,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-index-lifecycle.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "ilm-index-lifecycle",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[ilm-index-lifecycle]]\n=== Index lifecycle\n++++\n<titleabbrev>Index lifecycle</titleabbrev>\n++++\n\n<<index-lifecycle-management,{ilm-init}>> defines five index lifecycle _phases_:\n\n* **Hot**: The index is actively being updated and queried.\n* **Warm**: The index is no longer being updated but is still being queried.\n* **Cold**: The index is no longer being updated and is queried infrequently. The information still\nneeds to be searchable, but it's okay if those queries are slower.\n* **Frozen**: The index is no longer being updated and is queried rarely. The information still\nneeds to be searchable, but it's okay if those queries are extremely slow.\n* **Delete**: The index is no longer needed and can safely be removed.\n\nAn index's _lifecycle policy_ specifies which phases\nare applicable, what actions are performed in each phase,\nand when it transitions between phases.\n\nYou can manually apply a lifecycle policy when you create an index.\nFor time series indices, you need to associate the lifecycle policy with\nthe index template used to create new indices in the series.\nWhen an index rolls over, a manually-applied policy isn't automatically applied to the new index.\n\nIf you use {es}'s security features, {ilm-init} performs operations as the user\nwho last updated the policy. {ilm-init} only has the\n<<defining-roles,roles>> assigned to the user at the time of the last policy\nupdate.\n\n[discrete]\n[[ilm-phase-transitions]]\n=== Phase transitions\n\n{ilm-init} moves indices through the lifecycle according to their age.\nTo control the timing of these transitions, you set a _minimum age_ for each phase. For an index to\nmove to the next phase, all actions in the current phase must be complete and the index must be\nolder than the minimum age of the next phase. Configured minimum ages must increase between\nsubsequent phases, for example, a \"warm\" phase with a minimum age of 10 days can only be followed by\na \"cold\" phase with a minimum age either unset, or >= 10 days.\n\nThe minimum age defaults to zero, which causes {ilm-init} to move indices to the next phase\nas soon as all actions in the current phase complete.\n\n[NOTE]\n====\nIf an index has been <<ilm-rollover,rolled over>>, then the `min_age` value is relative to the time \nthe index was rolled over, not the index creation time. <<min-age-calculation,Learn more>>.\n====\n\nIf an index has unallocated shards and the <<cluster-health,cluster health status>> is yellow,\nthe index can still transition to the next phase according to its {ilm} policy.\nHowever, because {es} can only perform certain clean up tasks on a green\ncluster, there might be unexpected side effects.\n\nTo avoid increased disk usage and reliability issues,\naddress any cluster health problems in a timely fashion.\n\n\n[discrete]\n[[ilm-phase-execution]]\n=== Phase execution\n\n{ilm-init} controls the order in which the actions in a phase are executed and\nwhat _steps_ are executed to perform the necessary index operations for each action.\n\nWhen an index enters a phase, {ilm-init} caches the phase definition in the index metadata.\nThis ensures that policy updates don't put the index into a state where it can never exit the phase.\nIf changes can be safely applied, {ilm-init} updates the cached phase definition.\nIf they cannot, phase execution continues using the cached definition.\n\n{ilm-init} runs periodically, checks to see if an index meets policy criteria,\nand executes whatever steps are needed.\nTo avoid race conditions, {ilm-init} might need to run more than once to execute all of the steps\nrequired to complete an action.\nFor example, if {ilm-init} determines that an index has met the rollover criteria,\nit begins executing the steps required to complete the rollover action.\nIf it reaches a point where it is not safe to advance to the next step, execution stops.\nThe next time {ilm-init} runs, {ilm-init} picks up execution where it left off.\nThis means that even if `indices.lifecycle.poll_interval` is set to 10 minutes and an index meets\nthe rollover criteria, it could be 20 minutes before the rollover is complete.\n\n[discrete]\n[[ilm-phase-actions]]\n=== Phase actions\n\n{ilm-init} supports the following actions in each phase. {ilm-init} executes the\nactions in the order listed.\n\n* Hot\n  - <<ilm-set-priority,Set Priority>>\n  - <<ilm-unfollow,Unfollow>>\n  - <<ilm-rollover,Rollover>>\n  - <<ilm-readonly,Read-Only>>\n  - <<ilm-downsample,Downsample>>\n  - <<ilm-shrink,Shrink>>\n  - <<ilm-forcemerge,Force Merge>>\n  - <<ilm-searchable-snapshot, Searchable Snapshot>>\n* Warm\n  - <<ilm-set-priority,Set Priority>>\n  - <<ilm-unfollow,Unfollow>>\n  - <<ilm-readonly,Read-Only>>\n  - <<ilm-downsample,Downsample>>\n  - <<ilm-allocate,Allocate>>\n  - <<ilm-migrate,Migrate>>\n  - <<ilm-shrink,Shrink>>\n  - <<ilm-forcemerge,Force Merge>>\n* Cold\n  - <<ilm-set-priority,Set Priority>>\n  - <<ilm-unfollow,Unfollow>>\n  - <<ilm-readonly,Read-Only>>\n  - <<ilm-downsample,Downsample>>\n  - <<ilm-searchable-snapshot, Searchable Snapshot>>\n  - <<ilm-allocate,Allocate>>\n  - <<ilm-migrate,Migrate>>\n* Frozen\n  - <<ilm-unfollow,Unfollow>>\n  - <<ilm-searchable-snapshot, Searchable Snapshot>>\n* Delete\n  - <<ilm-wait-for-snapshot,Wait For Snapshot>>\n  - <<ilm-delete,Delete>>\n"
}