{
    "meta": {
        "size": 7836,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-configuring-detector-custom-rules.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "ml-configuring-detector-custom-rules",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[ml-configuring-detector-custom-rules]]\n= Customizing detectors with custom rules\n\n<<ml-ad-rules,Custom rules>> \u2013 or _job rules_ as {kib} refers to them \u2013 enable you \nto change the behavior of anomaly detectors based on domain-specific knowledge.\n\nCustom rules describe _when_ a detector should take a certain _action_ instead\nof following its default behavior. To specify the _when_ a rule uses\na `scope` and `conditions`. You can think of `scope` as the categorical\nspecification of a rule, while `conditions` are the numerical part.\nA rule can have a scope, one or more conditions, or a combination of\nscope and conditions. For the full list of specification details, see the\n{ref}/ml-put-job.html#put-customrules[`custom_rules` object] in the create\n{anomaly-jobs} API.\n\n[[ml-custom-rules-scope]]\n== Specifying custom rule scope\n\nLet us assume we are configuring an {anomaly-job} in order to detect DNS data\nexfiltration. Our data contain fields \"subdomain\" and \"highest_registered_domain\".\nWe can use a detector that looks like\n`high_info_content(subdomain) over highest_registered_domain`. If we run such a\njob, it is possible that we discover a lot of anomalies on frequently used\ndomains that we have reasons to trust. As security analysts, we are not\ninterested in such anomalies. Ideally, we could instruct the detector to skip\nresults for domains that we consider safe. Using a rule with a scope allows us\nto achieve this.\n\nFirst, we need to create a list of our safe domains. Those lists are called \n_filters_ in {ml}. Filters can be shared across {anomaly-jobs}.\n\nYou can create a filter in **Anomaly Detection > Settings > Filter Lists** in \n{kib} or by using the {ref}/ml-put-filter.html[put filter API]:\n\n[source,console]\n----------------------------------\nPUT _ml/filters/safe_domains\n{\n  \"description\": \"Our list of safe domains\",\n  \"items\": [\"safe.com\", \"trusted.com\"]\n}\n----------------------------------\n// TEST[skip:needs-licence]\n\nNow, we can create our {anomaly-job} specifying a scope that uses the\n`safe_domains` filter for the `highest_registered_domain` field:\n\n[source,console]\n----------------------------------\nPUT _ml/anomaly_detectors/dns_exfiltration_with_rule\n{\n  \"analysis_config\" : {\n    \"bucket_span\":\"5m\",\n    \"detectors\" :[{\n      \"function\":\"high_info_content\",\n      \"field_name\": \"subdomain\",\n      \"over_field_name\": \"highest_registered_domain\",\n      \"custom_rules\": [{\n        \"actions\": [\"skip_result\"],\n        \"scope\": {\n          \"highest_registered_domain\": {\n            \"filter_id\": \"safe_domains\",\n            \"filter_type\": \"include\"\n          }\n        }\n      }]\n    }]\n  },\n  \"data_description\" : {\n    \"time_field\":\"timestamp\"\n  }\n}\n----------------------------------\n// TEST[skip:needs-licence]\n\nAs time advances and we see more data and more results, we might encounter new \ndomains that we want to add in the filter. We can do that in the\n**Anomaly Detection > Settings > Filter Lists** in {kib} or by using the \n{ref}/ml-update-filter.html[update filter API]:\n\n[source,console]\n----------------------------------\nPOST _ml/filters/safe_domains/_update\n{\n  \"add_items\": [\"another-safe.com\"]\n}\n----------------------------------\n// TEST[skip:setup:ml_filter_safe_domains]\n\nNote that we can use any of the `partition_field_name`, `over_field_name`, or \n`by_field_name` fields in the `scope`.\n\nIn the following example we scope multiple fields:\n\n[source,console]\n----------------------------------\nPUT _ml/anomaly_detectors/scoping_multiple_fields\n{\n  \"analysis_config\" : {\n    \"bucket_span\":\"5m\",\n    \"detectors\" :[{\n      \"function\":\"count\",\n      \"partition_field_name\": \"my_partition\",\n      \"over_field_name\": \"my_over\",\n      \"by_field_name\": \"my_by\",\n      \"custom_rules\": [{\n        \"actions\": [\"skip_result\"],\n        \"scope\": {\n          \"my_partition\": {\n            \"filter_id\": \"filter_1\"\n          },\n          \"my_over\": {\n            \"filter_id\": \"filter_2\"\n          },\n          \"my_by\": {\n            \"filter_id\": \"filter_3\"\n          }\n        }\n      }]\n    }]\n  },\n  \"data_description\" : {\n    \"time_field\":\"timestamp\"\n  }\n}\n----------------------------------\n// TEST[skip:needs-licence]\n\nSuch a detector skips results when the values of all three scoped fields are \nincluded in the referenced filters.\n\n[[ml-custom-rules-conditions]]\n== Specifying custom rule conditions\n\nImagine a detector that looks for anomalies in CPU utilization. Given a machine \nthat is idle for long enough, small movement in CPU could result in anomalous \nresults where the `actual` value is quite small, for example, 0.02. Given our \nknowledge about how CPU utilization behaves we might determine that anomalies \nwith such small actual values are not interesting for investigation.\n\nLet us now configure an {anomaly-job} with a rule that skips results where CPU \nutilization is less than 0.20.\n\n[source,console]\n----------------------------------\nPUT _ml/anomaly_detectors/cpu_with_rule\n{\n  \"analysis_config\" : {\n    \"bucket_span\":\"5m\",\n    \"detectors\" :[{\n      \"function\":\"high_mean\",\n      \"field_name\": \"cpu_utilization\",\n      \"custom_rules\": [{\n        \"actions\": [\"skip_result\"],\n        \"conditions\": [\n          {\n            \"applies_to\": \"actual\",\n            \"operator\": \"lt\",\n            \"value\": 0.20\n          }\n        ]\n      }]\n    }]\n  },\n  \"data_description\" : {\n    \"time_field\":\"timestamp\"\n  }\n}\n----------------------------------\n// TEST[skip:needs-licence]\n\nWhen there are multiple conditions they are combined with a logical `AND`. This \nis useful when we want the rule to apply to a range. We create a rule with two \nconditions, one for each end of the desired range.\n\nHere is an example where a count detector skips results when the count is \ngreater than 30 and less than 50:\n\n[source,console]\n----------------------------------\nPUT _ml/anomaly_detectors/rule_with_range\n{\n  \"analysis_config\" : {\n    \"bucket_span\":\"5m\",\n    \"detectors\" :[{\n      \"function\":\"count\",\n      \"custom_rules\": [{\n        \"actions\": [\"skip_result\"],\n        \"conditions\": [\n          {\n            \"applies_to\": \"actual\",\n            \"operator\": \"gt\",\n            \"value\": 30\n          },\n          {\n            \"applies_to\": \"actual\",\n            \"operator\": \"lt\",\n            \"value\": 50\n          }\n        ]\n      }]\n    }]\n  },\n  \"data_description\" : {\n    \"time_field\":\"timestamp\"\n  }\n}\n----------------------------------\n// TEST[skip:needs-licence]\n\n[[ml-custom-rules-lifecycle]]\n== Custom rules in the lifecycle of a job\n\nCustom rules only affect results created after the rules were applied. Let us \nimagine that we have configured an {anomaly-job} and it has been running for \nsome time. After observing its results, we decide that we can employ rules to \nget rid of some uninteresting results. We can use the \n{ref}/ml-update-job.html[update {anomaly-job} API] to do so. However, the rule \nwe added will only be in effect for any results created from the moment we\nadded the rule onwards. Past results remain unaffected.\n\n[[ml-custom-rules-filtering]]\n== Using custom rules vs. filtering data\n\nIt might appear like using rules is just another way of filtering the data that \nfeeds into an {anomaly-job}. For example, a rule that skips results when the \npartition field value is in a filter sounds equivalent to having a query that \nfilters out such documents. However, there is a fundamental difference. When the \ndata is filtered before reaching a job, it is as if they never existed for the \njob. With rules, the data still reaches the job and affects its behavior \n(depending on the rule actions).\n\nFor example, a rule with the `skip_result` action means all data is still\nmodeled. On the other hand, a rule with the `skip_model_update` action means\nresults are still created even though the model is not updated by data matched \nby a rule.\n"
}