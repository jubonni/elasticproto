{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.045069",
        "size": 9387,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-range-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "search-aggregations-bucket-range-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-range-aggregation]]\n=== Range aggregation\n++++\n<titleabbrev>Range</titleabbrev>\n++++\n\nA multi-bucket value source based aggregation that enables the user to define a set of ranges - each representing a bucket. During the aggregation process, the values extracted from each document will be checked against each bucket range and \"bucket\" the relevant/matching document.\nNote that this aggregation includes the `from` value and excludes the `to` value for each range.\n\nExample:\n\n[source,console,id=range-aggregation-example]\n----\nGET sales/_search\n{\n  \"aggs\": {\n    \"price_ranges\": {\n      \"range\": {\n        \"field\": \"price\",\n        \"ranges\": [\n          { \"to\": 100.0 },\n          { \"from\": 100.0, \"to\": 200.0 },\n          { \"from\": 200.0 }\n        ]\n      }\n    }\n  }\n}\n----\n// TEST[setup:sales]\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nResponse:\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"price_ranges\": {\n      \"buckets\": [\n        {\n          \"key\": \"*-100.0\",\n          \"to\": 100.0,\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"100.0-200.0\",\n          \"from\": 100.0,\n          \"to\": 200.0,\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"200.0-*\",\n          \"from\": 200.0,\n          \"doc_count\": 3\n        }\n      ]\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n==== Keyed Response\n\nSetting the `keyed` flag to `true` will associate a unique string key with each bucket and return the ranges as a hash rather than an array:\n\n[source,console,id=range-aggregation-keyed-example]\n----\nGET sales/_search\n{\n  \"aggs\": {\n    \"price_ranges\": {\n      \"range\": {\n        \"field\": \"price\",\n        \"keyed\": true,\n        \"ranges\": [\n          { \"to\": 100 },\n          { \"from\": 100, \"to\": 200 },\n          { \"from\": 200 }\n        ]\n      }\n    }\n  }\n}\n----\n// TEST[setup:sales]\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nResponse:\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"price_ranges\": {\n      \"buckets\": {\n        \"*-100.0\": {\n          \"to\": 100.0,\n          \"doc_count\": 2\n        },\n        \"100.0-200.0\": {\n          \"from\": 100.0,\n          \"to\": 200.0,\n          \"doc_count\": 2\n        },\n        \"200.0-*\": {\n          \"from\": 200.0,\n          \"doc_count\": 3\n        }\n      }\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\.//]\n\nIt is also possible to customize the key for each range:\n\n[source,console,id=range-aggregation-custom-keys-example]\n----\nGET sales/_search\n{\n  \"aggs\": {\n    \"price_ranges\": {\n      \"range\": {\n        \"field\": \"price\",\n        \"keyed\": true,\n        \"ranges\": [\n          { \"key\": \"cheap\", \"to\": 100 },\n          { \"key\": \"average\", \"from\": 100, \"to\": 200 },\n          { \"key\": \"expensive\", \"from\": 200 }\n        ]\n      }\n    }\n  }\n}\n----\n// TEST[setup:sales]\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nResponse:\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"price_ranges\": {\n      \"buckets\": {\n        \"cheap\": {\n          \"to\": 100.0,\n          \"doc_count\": 2\n        },\n        \"average\": {\n          \"from\": 100.0,\n          \"to\": 200.0,\n          \"doc_count\": 2\n        },\n        \"expensive\": {\n          \"from\": 200.0,\n          \"doc_count\": 3\n        }\n      }\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n==== Script\n\nIf the data in your documents doesn't exactly match what you'd like to aggregate,\nuse a <<runtime,runtime field>>. For example, if you need to\napply a particular currency conversion rate:\n\n[source,console,id=range-aggregation-runtime-field-example]\n----\nGET sales/_search\n{\n  \"runtime_mappings\": {\n    \"price.euros\": {\n      \"type\": \"double\",\n      \"script\": {\n        \"source\": \"\"\"\n          emit(doc['price'].value * params.conversion_rate)\n        \"\"\",\n        \"params\": {\n          \"conversion_rate\": 0.835526591\n        }\n      }\n    }\n  },\n  \"aggs\": {\n    \"price_ranges\": {\n      \"range\": {\n        \"field\": \"price.euros\",\n        \"ranges\": [\n          { \"to\": 100 },\n          { \"from\": 100, \"to\": 200 },\n          { \"from\": 200 }\n        ]\n      }\n    }\n  }\n}\n----\n// TEST[setup:sales]\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\n//////////////////////////\n\n[source,console-result]\n----\n{\n  \"aggregations\": {\n    \"price_ranges\": {\n      \"buckets\": [\n        {\n          \"key\": \"*-100.0\",\n          \"to\": 100.0,\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"100.0-200.0\",\n          \"from\": 100.0,\n          \"to\": 200.0,\n          \"doc_count\": 5\n        },\n        {\n          \"key\": \"200.0-*\",\n          \"from\": 200.0,\n          \"doc_count\": 0\n        }\n      ]\n    }\n  }\n}\n----\n\n//////////////////////////\n\n==== Sub Aggregations\n\nThe following example, not only \"bucket\" the documents to the different buckets but also computes statistics over the prices in each price range\n\n[source,console,id=range-aggregation-sub-aggregation-example]\n----\nGET sales/_search\n{\n  \"aggs\": {\n    \"price_ranges\": {\n      \"range\": {\n        \"field\": \"price\",\n        \"ranges\": [\n          { \"to\": 100 },\n          { \"from\": 100, \"to\": 200 },\n          { \"from\": 200 }\n        ]\n      },\n      \"aggs\": {\n        \"price_stats\": {\n          \"stats\": { \"field\": \"price\" }\n        }\n      }\n    }\n  }\n}\n----\n// TEST[setup:sales]\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nResponse:\n\n[source,console-result]\n----\n{\n  ...\n  \"aggregations\": {\n    \"price_ranges\": {\n      \"buckets\": [\n        {\n          \"key\": \"*-100.0\",\n          \"to\": 100.0,\n          \"doc_count\": 2,\n          \"price_stats\": {\n            \"count\": 2,\n            \"min\": 10.0,\n            \"max\": 50.0,\n            \"avg\": 30.0,\n            \"sum\": 60.0\n          }\n        },\n        {\n          \"key\": \"100.0-200.0\",\n          \"from\": 100.0,\n          \"to\": 200.0,\n          \"doc_count\": 2,\n          \"price_stats\": {\n            \"count\": 2,\n            \"min\": 150.0,\n            \"max\": 175.0,\n            \"avg\": 162.5,\n            \"sum\": 325.0\n          }\n        },\n        {\n          \"key\": \"200.0-*\",\n          \"from\": 200.0,\n          \"doc_count\": 3,\n          \"price_stats\": {\n            \"count\": 3,\n            \"min\": 200.0,\n            \"max\": 200.0,\n            \"avg\": 200.0,\n            \"sum\": 600.0\n          }\n        }\n      ]\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n[[search-aggregations-bucket-range-aggregation-histogram-fields]]\n==== Histogram fields\n\nRunning a range aggregation over histogram fields computes the total number of counts for each configured range.\n\nThis is done without interpolating between the histogram field values. Consequently, it is possible to have a range\nthat is \"in-between\" two histogram values. The resulting range bucket would have a zero doc count.\n\nHere is an example, executing a range aggregation against the following index that stores pre-aggregated histograms\nwith latency metrics (in milliseconds) for different networks:\n\n[source,console]\n----\nPUT metrics_index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"network\": {\n        \"properties\": {\n          \"name\": {\n            \"type\": \"keyword\"\n          }\n        }\n      },\n      \"latency_histo\": {\n         \"type\": \"histogram\"\n      }\n    }\n  }\n}\n\nPUT metrics_index/_doc/1?refresh\n{\n  \"network.name\" : \"net-1\",\n  \"latency_histo\" : {\n      \"values\" : [1, 3, 8, 12, 15],\n      \"counts\" : [3, 7, 23, 12, 6]\n   }\n}\n\nPUT metrics_index/_doc/2?refresh\n{\n  \"network.name\" : \"net-2\",\n  \"latency_histo\" : {\n      \"values\" : [1, 6, 8, 12, 14],\n      \"counts\" : [8, 17, 8, 7, 6]\n   }\n}\n\nGET metrics_index/_search?size=0&filter_path=aggregations\n{\n  \"aggs\": {\n    \"latency_ranges\": {\n      \"range\": {\n        \"field\": \"latency_histo\",\n        \"ranges\": [\n          {\"to\": 2},\n          {\"from\": 2, \"to\": 3},\n          {\"from\": 3, \"to\": 10},\n          {\"from\": 10}\n        ]\n      }\n    }\n  }\n}\n----\n\nThe `range` aggregation will sum the counts of each range computed based on the `values` and\nreturn the following output:\n\n[source,console-result]\n----\n{\n  \"aggregations\": {\n    \"latency_ranges\": {\n      \"buckets\": [\n        {\n          \"key\": \"*-2.0\",\n          \"to\": 2.0,\n          \"doc_count\": 11\n        },\n        {\n          \"key\": \"2.0-3.0\",\n          \"from\": 2.0,\n          \"to\": 3.0,\n          \"doc_count\": 0\n        },\n        {\n          \"key\": \"3.0-10.0\",\n          \"from\": 3.0,\n          \"to\": 10.0,\n          \"doc_count\": 55\n        },\n        {\n          \"key\": \"10.0-*\",\n          \"from\": 10.0,\n          \"doc_count\": 31\n        }\n      ]\n    }\n  }\n}\n----\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\n[IMPORTANT]\n========\nRange aggregation is a bucket aggregation, which partitions documents into buckets rather than calculating metrics over fields like\nmetrics aggregations do. Each bucket represents a collection of documents which sub-aggregations can run on.\nOn the other hand, a histogram field is a pre-aggregated field representing multiple values inside a single field:\nbuckets of numerical data and a count of items/documents for each bucket. This mismatch between the range aggregations expected input\n(expecting raw documents) and the histogram field (that provides summary information) limits the outcome of the aggregation\nto only the doc counts for each bucket.\n\n**Consequently, when executing a range aggregation over a histogram field, no sub-aggregations are allowed.**\n========\n"
}