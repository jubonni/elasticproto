{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.122579",
        "size": 23976,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html",
        "type": "documentation",
        "role": [
            "child_attributes"
        ],
        "has_code": true,
        "title": "docs-bulk",
        "version": "8.15"
    },
    "doc": "[[docs-bulk]]\n=== Bulk API\n++++\n<titleabbrev>Bulk</titleabbrev>\n++++\n\nPerforms multiple indexing or delete operations in a single API call.\nThis reduces overhead and can greatly increase indexing speed.\n\n[source,console]\n--------------------------------------------------\nPOST _bulk\n{ \"index\" : { \"_index\" : \"test\", \"_id\" : \"1\" } }\n{ \"field1\" : \"value1\" }\n{ \"delete\" : { \"_index\" : \"test\", \"_id\" : \"2\" } }\n{ \"create\" : { \"_index\" : \"test\", \"_id\" : \"3\" } }\n{ \"field1\" : \"value3\" }\n{ \"update\" : {\"_id\" : \"1\", \"_index\" : \"test\"} }\n{ \"doc\" : {\"field2\" : \"value2\"} }\n--------------------------------------------------\n\n[[docs-bulk-api-request]]\n==== {api-request-title}\n\n`POST /_bulk`\n\n`POST /<target>/_bulk`\n\n[[docs-bulk-api-prereqs]]\n==== {api-prereq-title}\n\n* If the {es} {security-features} are enabled, you must have the following\n<<privileges-list-indices,index privileges>> for the target data stream, index,\nor index alias:\n\n** To use the `create` action, you must have the `create_doc`, `create`,\n`index`, or `write` index privilege. Data streams support only the `create`\naction.\n\n** To use the `index` action, you must have the `create`, `index`, or `write`\nindex privilege.\n\n** To use the `delete` action, you must have the `delete` or `write` index\nprivilege.\n\n** To use the `update` action, you must have the `index` or `write` index\nprivilege.\n\n** To automatically create a data stream or index with a bulk API request, you\nmust have the `auto_configure`, `create_index`, or `manage` index privilege.\n\n** To make the result of a bulk operation visible to search using the `refresh`\nparameter, you must have the `maintenance` or `manage` index privilege.\n\n* Automatic data stream creation requires a matching index template with data\nstream enabled. See <<set-up-a-data-stream>>.\n\n[[docs-bulk-api-desc]]\n==== {api-description-title}\n\nProvides a way to perform multiple `index`, `create`, `delete`, and `update` actions in a single request.\n\nThe actions are specified in the request body using a newline delimited JSON (NDJSON) structure:\n\n[source,js]\n--------------------------------------------------\naction_and_meta_data\\n\noptional_source\\n\naction_and_meta_data\\n\noptional_source\\n\n....\naction_and_meta_data\\n\noptional_source\\n\n--------------------------------------------------\n// NOTCONSOLE\n\nThe `index` and `create` actions expect a source on the next line,\nand have the same semantics as the `op_type` parameter in the standard index API:\n`create` fails if a document with the same ID already exists in the target,\n`index` adds or replaces a document as necessary.\n\nNOTE: <<data-streams,Data streams>> support only the `create` action. To update\nor delete a document in a data stream, you must target the backing index\ncontaining the document. See <<update-delete-docs-in-a-backing-index>>.\n\n`update` expects that the partial doc, upsert,\nand script and its options are specified on the next line.\n\n`delete` does not expect a source on the next line and\nhas the same semantics as the standard delete API.\n\n[NOTE]\n====\nThe final line of data must end with a newline character `\\n`.\nEach newline character may be preceded by a carriage return `\\r`.\nWhen sending NDJSON data to the `_bulk` endpoint, use a `Content-Type` header of\n`application/json` or `application/x-ndjson`.\n====\n\nBecause this format uses literal `\\n`'s as delimiters,\nmake sure that the JSON actions and sources are not pretty printed.\n\nIf you provide a `<target>` in the request path,\nit is used for any actions that don't explicitly specify an `_index` argument.\n\nA note on the format: The idea here is to make processing of this as\nfast as possible. As some of the actions are redirected to other\nshards on other nodes, only `action_meta_data` is parsed on the\nreceiving node side.\n\nClient libraries using this protocol should try and strive to do\nsomething similar on the client side, and reduce buffering as much as\npossible.\n\nThere is no \"correct\" number of actions to perform in a single bulk request.\nExperiment with different settings to find the optimal size for your particular\nworkload. Note that {es} limits the maximum size of a HTTP request to `100mb`\nby default so clients must ensure that no request exceeds this size. It is not\npossible to index a single document which exceeds the size limit, so you must\npre-process any such documents into smaller pieces before sending them to {es}.\nFor instance, split documents into pages or chapters before indexing them, or\nstore raw binary data in a system outside {es} and replacing the raw data with\na link to the external system in the documents that you send to {es}.\n\n[discrete]\n[[bulk-clients]]\n===== Client support for bulk requests\n\nSome of the officially supported clients provide helpers to assist with\nbulk requests and reindexing:\n\nGo::\n\n    See https://github.com/elastic/go-elasticsearch/tree/master/_examples/bulk#indexergo[esutil.BulkIndexer]\n\nPerl::\n\n    See https://metacpan.org/pod/Search::Elasticsearch::Client::5_0::Bulk[Search::Elasticsearch::Client::5_0::Bulk]\n    and https://metacpan.org/pod/Search::Elasticsearch::Client::5_0::Scroll[Search::Elasticsearch::Client::5_0::Scroll]\n\nPython::\n\n    See https://elasticsearch-py.readthedocs.io/en/latest/helpers.html[elasticsearch.helpers.*]\n\nJavaScript::\n\n    See {jsclient-current}/client-helpers.html[client.helpers.*]\n\n.NET::\n    See https://www.elastic.co/guide/en/elasticsearch/client/net-api/current/indexing-documents.html[`BulkAllObservable`]\n\nPHP::\n    See https://www.elastic.co/guide/en/elasticsearch/client/php-api/current/indexing_documents.html#_bulk_indexing[Bulk indexing]\n\n[discrete]\n[[bulk-curl]]\n===== Submitting bulk requests with cURL\n\nIf you're providing text file input to `curl`, you *must* use the\n`--data-binary` flag instead of plain `-d`. The latter doesn't preserve\nnewlines. Example:\n\n[source,js]\n--------------------------------------------------\n$ cat requests\n{ \"index\" : { \"_index\" : \"test\", \"_id\" : \"1\" } }\n{ \"field1\" : \"value1\" }\n$ curl -s -H \"Content-Type: application/x-ndjson\" -XPOST localhost:9200/_bulk --data-binary \"@requests\"; echo\n{\"took\":7, \"errors\": false, \"items\":[{\"index\":{\"_index\":\"test\",\"_id\":\"1\",\"_version\":1,\"result\":\"created\",\"forced_refresh\":false}}]}\n--------------------------------------------------\n// NOTCONSOLE\n// Not converting to console because this shows how curl works\n\n[discrete]\n[[bulk-optimistic-concurrency-control]]\n===== Optimistic concurrency control\n\nEach `index` and `delete` action within a bulk API call may include the\n`if_seq_no` and `if_primary_term` parameters in their respective action\nand meta data lines. The `if_seq_no` and `if_primary_term` parameters control\nhow operations are executed, based on the last modification to existing\ndocuments. See <<optimistic-concurrency-control>> for more details.\n\n\n[discrete]\n[[bulk-versioning]]\n===== Versioning\n\nEach bulk item can include the version value using the\n`version` field. It automatically follows the behavior of the\nindex / delete operation based on the `_version` mapping. It also\nsupport the `version_type` (see <<index-versioning, versioning>>).\n\n[discrete]\n[[bulk-routing]]\n===== Routing\n\nEach bulk item can include the routing value using the\n`routing` field. It automatically follows the behavior of the\nindex / delete operation based on the `_routing` mapping.\n\nNOTE: Data streams do not support custom routing unless they were created with\nthe <<put-index-template-api-request-body,`allow_custom_routing`>> setting\nenabled in the template.\n\n[discrete]\n[[bulk-wait-for-active-shards]]\n===== Wait for active shards\n\nWhen making bulk calls, you can set the `wait_for_active_shards`\nparameter to require a minimum number of shard copies to be active\nbefore starting to process the bulk request. See\n<<index-wait-for-active-shards,here>> for further details and a usage\nexample.\n\n[discrete]\n[[bulk-refresh]]\n===== Refresh\n\nControl when the changes made by this request are visible to search. See\n<<docs-refresh,refresh>>.\n\nNOTE: Only the shards that receive the bulk request will be affected by\n`refresh`. Imagine a `_bulk?refresh=wait_for` request with three\ndocuments in it that happen to be routed to different shards in an index\nwith five shards. The request will only wait for those three shards to\nrefresh. The other two shards that make up the index do not\nparticipate in the `_bulk` request at all.\n\n[discrete]\n[[bulk-security]]\n===== Security\n\nSee <<api-url-access-control>>.\n\n[[docs-bulk-api-path-params]]\n==== {api-path-parms-title}\n\n`<target>`::\n(Optional, string)\nName of the data stream, index, or index alias to perform bulk actions\non.\n\n[[docs-bulk-api-query-params]]\n==== {api-query-parms-title}\n\n`list_executed_pipelines`::\n(Optional, Boolean) If `true`, the response will include the ingest pipelines that\nwere executed for each `index` or `create`.\nDefaults to `false`.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=pipeline]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=refresh]\n\n`require_alias`::\n(Optional, Boolean) If `true`, the request's actions must target an index alias.\nDefaults to `false`.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=routing]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=source]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=source_excludes]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=source_includes]\n\n`timeout`::\n+\n--\n(Optional, <<time-units, time units>>)\nPeriod each action waits for the following operations:\n\n* <<index-creation,Automatic index creation>>\n* <<dynamic-mapping,Dynamic mapping>> updates\n* <<index-wait-for-active-shards,Waiting for active shards>>\n\nDefaults to `1m` (one minute). This guarantees {es} waits for at least the\ntimeout before failing. The actual wait time could be longer, particularly when\nmultiple waits occur.\n--\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=wait_for_active_shards]\n\n[[bulk-api-request-body]]\n==== {api-request-body-title}\nThe request body contains a newline-delimited list of `create`, `delete`, `index`,\nand `update` actions and their associated source data.\n\n`create`::\n(Optional, string)\nIndexes the specified document if it does not already exist.\nThe following line must contain the source data to be indexed.\n+\n--\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-index-ds]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-id]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-list-executed-pipelines]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-require-alias]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-dynamic-templates]\n--\n\n`delete`::\n(Optional, string)\nRemoves the specified document from the index.\n+\n--\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-index]\n\n`_id`::\n(Required, string) The document ID.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-require-alias]\n--\n\n`index`::\n(Optional, string)\nIndexes the specified document.\nIf the document exists, replaces the document and increments the version.\nThe following line must contain the source data to be indexed.\n+\n--\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-index]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-id]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-list-executed-pipelines]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-require-alias]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-dynamic-templates]\n--\n\n`update`::\n(Optional, string)\nPerforms a partial document update.\nThe following line must contain the partial document and update options.\n+\n--\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-index]\n\n`_id`::\n(Required, string) The document ID.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=bulk-require-alias]\n--\n\n`doc`::\n(Optional, object)\nThe partial document to index.\nRequired for `update` operations.\n\n`<fields>`::\n(Optional, object)\nThe document source to index.\nRequired for `create` and `index` operations.\n\n[role=\"child_attributes\"]\n[[bulk-api-response-body]]\n==== {api-response-body-title}\n\nThe bulk API's response contains the individual results of each operation in the\nrequest, returned in the order submitted. The success or failure of an\nindividual operation does not affect other operations in the request.\n\n`took`::\n(integer)\nHow long, in milliseconds, it took to process the bulk request.\n\n`errors`::\n(Boolean)\nIf `true`, one or more of the operations in the bulk request did not complete\nsuccessfully.\n\n`items`::\n(array of objects)\nContains the result of each operation in the bulk request, in the order they\nwere submitted.\n+\n.Properties of `items` objects\n[%collapsible%open]\n====\n<action>::\n(object)\nThe parameter name is an action associated with the operation. Possible values\nare `create`, `delete`, `index`, and `update`.\n+\nThe parameter value is an object that contains information for the associated\noperation.\n+\n.Properties of `<action>`\n[%collapsible%open]\n=====\n`_index`::\n(string)\nName of the index associated with the operation. If the operation targeted a\ndata stream, this is the backing index into which the document was written.\n\n`_id`::\n(integer)\nThe document ID associated with the operation.\n\n`_version`::\n(integer)\nThe document version associated with the operation. The document version is\nincremented each time the document is updated.\n+\nThis parameter is only returned for successful actions.\n\n`result`::\n(string)\nResult of the operation. Successful values are `created`, `deleted`, and\n`updated`. Other valid values are `noop` and `not_found`.\n\n`_shards`::\n(object)\nContains shard information for the operation.\n+\nThis parameter is only returned for successful operations.\n+\n.Properties of `_shards`\n[%collapsible%open]\n======\n`total`::\n(integer)\nNumber of shards the operation attempted to execute on.\n\n`successful`::\n(integer)\nNumber of shards the operation succeeded on.\n\n`failed`::\n(integer)\nNumber of shards the operation attempted to execute on but failed.\n======\n\n`_seq_no`::\n(integer)\nThe sequence number assigned to the document for the operation.\nSequence numbers are used to ensure an older version of a document\ndoesn\u2019t overwrite a newer version. See <<optimistic-concurrency-control-index>>.\n+\nThis parameter is only returned for successful operations.\n\n`_primary_term`::\n(integer)\nThe primary term assigned to the document for the operation.\nSee <<optimistic-concurrency-control-index>>.\n+\nThis parameter is only returned for successful operations.\n\n`status`::\n(integer)\nHTTP status code returned for the operation.\n\n`error`::\n(object)\nContains additional information about the failed operation.\n+\nThe parameter is only returned for failed operations.\n+\n.Properties of `error`\n[%collapsible%open]\n======\n`type`::\n(string)\nError type for the operation.\n\n`reason`::\n(string)\nReason for the failed operation.\n\n`index_uuid`::\n(string)\nThe universally unique identifier (UUID) of the index associated with the failed\noperation.\n\n`shard`::\n(string)\nID of the shard associated with the failed operation.\n\n`index`::\n(string)\nName of the index associated with the failed operation. If the operation\ntargeted a data stream, this is the backing index into which the document was\nattempted to be written.\n======\n=====\n====\n\n[[docs-bulk-api-example]]\n==== {api-examples-title}\n\n[source,console]\n--------------------------------------------------\nPOST _bulk\n{ \"index\" : { \"_index\" : \"test\", \"_id\" : \"1\" } }\n{ \"field1\" : \"value1\" }\n{ \"delete\" : { \"_index\" : \"test\", \"_id\" : \"2\" } }\n{ \"create\" : { \"_index\" : \"test\", \"_id\" : \"3\" } }\n{ \"field1\" : \"value3\" }\n{ \"update\" : {\"_id\" : \"1\", \"_index\" : \"test\"} }\n{ \"doc\" : {\"field2\" : \"value2\"} }\n--------------------------------------------------\n\nThe API returns the following result:\n\n[source,console-result]\n--------------------------------------------------\n{\n   \"took\": 30,\n   \"errors\": false,\n   \"items\": [\n      {\n         \"index\": {\n            \"_index\": \"test\",\n            \"_id\": \"1\",\n            \"_version\": 1,\n            \"result\": \"created\",\n            \"_shards\": {\n               \"total\": 2,\n               \"successful\": 1,\n               \"failed\": 0\n            },\n            \"status\": 201,\n            \"_seq_no\" : 0,\n            \"_primary_term\": 1\n         }\n      },\n      {\n         \"delete\": {\n            \"_index\": \"test\",\n            \"_id\": \"2\",\n            \"_version\": 1,\n            \"result\": \"not_found\",\n            \"_shards\": {\n               \"total\": 2,\n               \"successful\": 1,\n               \"failed\": 0\n            },\n            \"status\": 404,\n            \"_seq_no\" : 1,\n            \"_primary_term\" : 2\n         }\n      },\n      {\n         \"create\": {\n            \"_index\": \"test\",\n            \"_id\": \"3\",\n            \"_version\": 1,\n            \"result\": \"created\",\n            \"_shards\": {\n               \"total\": 2,\n               \"successful\": 1,\n               \"failed\": 0\n            },\n            \"status\": 201,\n            \"_seq_no\" : 2,\n            \"_primary_term\" : 3\n         }\n      },\n      {\n         \"update\": {\n            \"_index\": \"test\",\n            \"_id\": \"1\",\n            \"_version\": 2,\n            \"result\": \"updated\",\n            \"_shards\": {\n                \"total\": 2,\n                \"successful\": 1,\n                \"failed\": 0\n            },\n            \"status\": 200,\n            \"_seq_no\" : 3,\n            \"_primary_term\" : 4\n         }\n      }\n   ]\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 30/\"took\": $body.took/]\n// TESTRESPONSE[s/\"index_uuid\": .../\"index_uuid\": $body.items.3.update.error.index_uuid/]\n// TESTRESPONSE[s/\"_seq_no\" : 0/\"_seq_no\" : $body.items.0.index._seq_no/]\n// TESTRESPONSE[s/\"_primary_term\" : 1/\"_primary_term\" : $body.items.0.index._primary_term/]\n// TESTRESPONSE[s/\"_seq_no\" : 1/\"_seq_no\" : $body.items.1.delete._seq_no/]\n// TESTRESPONSE[s/\"_primary_term\" : 2/\"_primary_term\" : $body.items.1.delete._primary_term/]\n// TESTRESPONSE[s/\"_seq_no\" : 2/\"_seq_no\" : $body.items.2.create._seq_no/]\n// TESTRESPONSE[s/\"_primary_term\" : 3/\"_primary_term\" : $body.items.2.create._primary_term/]\n// TESTRESPONSE[s/\"_seq_no\" : 3/\"_seq_no\" : $body.items.3.update._seq_no/]\n// TESTRESPONSE[s/\"_primary_term\" : 4/\"_primary_term\" : $body.items.3.update._primary_term/]\n\n[discrete]\n[[bulk-update]]\n===== Bulk update example\n\nWhen using the `update` action, `retry_on_conflict` can be used as a field in\nthe action itself (not in the extra payload line), to specify how many\ntimes an update should be retried in the case of a version conflict.\n\nThe `update` action payload supports the following options: `doc`\n(partial document), `upsert`, `doc_as_upsert`, `script`, `params` (for\nscript), `lang` (for script), and `_source`. See update documentation for details on\nthe options. Example with update actions:\n\n[source,console]\n--------------------------------------------------\nPOST _bulk\n{ \"update\" : {\"_id\" : \"1\", \"_index\" : \"index1\", \"retry_on_conflict\" : 3} }\n{ \"doc\" : {\"field\" : \"value\"} }\n{ \"update\" : { \"_id\" : \"0\", \"_index\" : \"index1\", \"retry_on_conflict\" : 3} }\n{ \"script\" : { \"source\": \"ctx._source.counter += params.param1\", \"lang\" : \"painless\", \"params\" : {\"param1\" : 1}}, \"upsert\" : {\"counter\" : 1}}\n{ \"update\" : {\"_id\" : \"2\", \"_index\" : \"index1\", \"retry_on_conflict\" : 3} }\n{ \"doc\" : {\"field\" : \"value\"}, \"doc_as_upsert\" : true }\n{ \"update\" : {\"_id\" : \"3\", \"_index\" : \"index1\", \"_source\" : true} }\n{ \"doc\" : {\"field\" : \"value\"} }\n{ \"update\" : {\"_id\" : \"4\", \"_index\" : \"index1\"} }\n{ \"doc\" : {\"field\" : \"value\"}, \"_source\": true}\n--------------------------------------------------\n\n[discrete]\n[[bulk-failures-ex]]\n===== Example with failed actions\n\nThe following bulk API request includes operations that update non-existent\ndocuments.\n\n[source,console]\n----\nPOST /_bulk\n{ \"update\": {\"_id\": \"5\", \"_index\": \"index1\"} }\n{ \"doc\": {\"my_field\": \"foo\"} }\n{ \"update\": {\"_id\": \"6\", \"_index\": \"index1\"} }\n{ \"doc\": {\"my_field\": \"foo\"} }\n{ \"create\": {\"_id\": \"7\", \"_index\": \"index1\"} }\n{ \"my_field\": \"foo\" }\n----\n\nBecause these operations cannot complete successfully, the API returns a\nresponse with an `errors` flag of `true`.\n\nThe response also includes an `error` object for any failed operations. The\n`error` object contains additional information about the failure, such as the\nerror type and reason.\n\n[source,console-result]\n----\n{\n  \"took\": 486,\n  \"errors\": true,\n  \"items\": [\n    {\n      \"update\": {\n        \"_index\": \"index1\",\n        \"_id\": \"5\",\n        \"status\": 404,\n        \"error\": {\n          \"type\": \"document_missing_exception\",\n          \"reason\": \"[5]: document missing\",\n          \"index_uuid\": \"aAsFqTI0Tc2W0LCWgPNrOA\",\n          \"shard\": \"0\",\n          \"index\": \"index1\"\n        }\n      }\n    },\n    {\n      \"update\": {\n        \"_index\": \"index1\",\n        \"_id\": \"6\",\n        \"status\": 404,\n        \"error\": {\n          \"type\": \"document_missing_exception\",\n          \"reason\": \"[6]: document missing\",\n          \"index_uuid\": \"aAsFqTI0Tc2W0LCWgPNrOA\",\n          \"shard\": \"0\",\n          \"index\": \"index1\"\n        }\n      }\n    },\n    {\n      \"create\": {\n        \"_index\": \"index1\",\n        \"_id\": \"7\",\n        \"_version\": 1,\n        \"result\": \"created\",\n        \"_shards\": {\n          \"total\": 2,\n          \"successful\": 1,\n          \"failed\": 0\n        },\n        \"_seq_no\": 0,\n        \"_primary_term\": 1,\n        \"status\": 201\n      }\n    }\n  ]\n}\n----\n// TESTRESPONSE[s/\"took\": 486/\"took\": $body.took/]\n// TESTRESPONSE[s/\"_seq_no\": 0/\"_seq_no\": $body.items.2.create._seq_no/]\n// TESTRESPONSE[s/\"index_uuid\": \"aAsFqTI0Tc2W0LCWgPNrOA\"/\"index_uuid\": $body.$_path/]\n\nTo return only information about failed operations, use the\n<<common-options-response-filtering,`filter_path`>> query parameter with an\nargument of `items.*.error`.\n\n[source,console]\n----\nPOST /_bulk?filter_path=items.*.error\n{ \"update\": {\"_id\": \"5\", \"_index\": \"index1\"} }\n{ \"doc\": {\"my_field\": \"baz\"} }\n{ \"update\": {\"_id\": \"6\", \"_index\": \"index1\"} }\n{ \"doc\": {\"my_field\": \"baz\"} }\n{ \"update\": {\"_id\": \"7\", \"_index\": \"index1\"} }\n{ \"doc\": {\"my_field\": \"baz\"} }\n----\n// TEST[continued]\n\nThe API returns the following result.\n\n[source,console-result]\n----\n{\n  \"items\": [\n    {\n      \"update\": {\n        \"error\": {\n          \"type\": \"document_missing_exception\",\n          \"reason\": \"[5]: document missing\",\n          \"index_uuid\": \"aAsFqTI0Tc2W0LCWgPNrOA\",\n          \"shard\": \"0\",\n          \"index\": \"index1\"\n        }\n      }\n    },\n    {\n      \"update\": {\n        \"error\": {\n          \"type\": \"document_missing_exception\",\n          \"reason\": \"[6]: document missing\",\n          \"index_uuid\": \"aAsFqTI0Tc2W0LCWgPNrOA\",\n          \"shard\": \"0\",\n          \"index\": \"index1\"\n        }\n      }\n    }\n  ]\n}\n----\n// TESTRESPONSE[s/\"index_uuid\": \"aAsFqTI0Tc2W0LCWgPNrOA\"/\"index_uuid\": $body.$_path/]\n\n\n[discrete]\n[[bulk-dynamic-templates]]\n===== Example with dynamic templates parameter\n\nThe below example creates a dynamic template, then performs a bulk request\nconsisting of index/create requests with the `dynamic_templates` parameter.\n\n[source,console]\n----\nPUT my-index/\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"geo_point\": {\n             \"mapping\": {\n                \"type\" : \"geo_point\"\n             }\n        }\n      }\n    ]\n  }\n}\n\nPOST /_bulk\n{ \"index\" : { \"_index\" : \"my_index\", \"_id\" : \"1\", \"dynamic_templates\": {\"work_location\": \"geo_point\"}} }\n{ \"field\" : \"value1\", \"work_location\": \"41.12,-71.34\", \"raw_location\": \"41.12,-71.34\"}\n{ \"create\" : { \"_index\" : \"my_index\", \"_id\" : \"2\", \"dynamic_templates\": {\"home_location\": \"geo_point\"}} }\n{ \"field\" : \"value2\", \"home_location\": \"41.12,-71.34\"}\n----\n\nThe bulk request creates two new fields `work_location` and `home_location` with type `geo_point` according\nto the `dynamic_templates` parameter; however, the `raw_location` field is created using default dynamic mapping\nrules, as a `text` field in that case since it is supplied as a string in the JSON document.\n"
}