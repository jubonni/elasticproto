{
    "meta": {
        "size": 9319,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/customizing-watches.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "customizing-watches",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[customizing-watches]]\n== Customizing watches\n\nNow that you've seen how to set up simple watches to\n<<watch-log-data,watch your log data>> and\n<<watch-cluster-status,monitor your cluster health>>, let's take a closer\nlook at how you can customize a watch by modifying its <<changing-inputs,inputs>>,\n<<changing-conditions,conditions>>, <<using-transforms,transforms>>, and\n<<customizing-actions,actions>>.\n\n[[changing-inputs]]\n=== Changing inputs\n\nThe Watch Input is called when the watch triggered to load an initial payload.\nThis payload is stored in the _Watch Execution Context_ and from then on is\navailable for other watch elements to access (e.g. watch conditions can\nbe evaluated based on the data in this payload).\n\n{watcher} supports four types of inputs <<loading-static-data,simple>>,\n<<loading-search-results,search>>, <<loading-http-data,http>>, and\n<<input-chain,chain>>.\n\n[[loading-static-data]]\n==== Loading a static payload with the simple input\n\nTo load static data into the watch payload for testing purposes, you can use the\n<<input-simple,simple>> input. For example, the following input stores three\nfields in the payload:\n\n[source,js]\n-------------------------------------\n\"input\" : {\n  \"simple\" : {\n    \"color\"  : \"red\",\n    \"status\" : \"error\",\n    \"count\"  : 3\n  }\n}\n-------------------------------------\n// NOTCONSOLE\n\nSee <<input-simple>> for more details.\n\n[[loading-search-results]]\n==== Loading a payload from Elasticsearch with the search input\n\nYou can use the `search` input to load Elasticsearch search results as the watch\ninitial payload.\n\nA <<input-search,search>> input contains a `request` object that specifies the\nindices you want to search, the <<search-type,search type>>,\nand the search request body. The `body` field of a search input is the same as\nthe body of an Elasticsearch `_search` request, making the full Elasticsearch\nQuery DSL available for you to use.\n\nFor example, the following `search` input loads the latest VIX quote:\n\n[source,js]\n--------------------------------------------------\n{\n  \"input\" : {\n    \"search\" : {\n      \"request\" : {\n        \"indices\" : [ \"<stock-quotes-{now/d}>\" ], <1>\n        \"body\" : {\n          \"size\" : 1,\n          \"sort\" : {\n            \"timestamp\" : { \"order\" : \"desc\"}\n          },\n          \"query\" : {\n            \"term\" : { \"symbol\" : \"vix\"}\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n<1> Will resolve to today's daily quotes index\n\nSee <<input-search>> for more details.\n\n[[loading-http-data]]\n==== Loading a payload from a remote HTTP service with HTTP input\n\nUse the `http` input to issue an HTTP request and load the returned response as\nthe watch initial payload. This input expects the response body content type\nto either be JSON or YAML.\n\nFor example, the following `http` input loads the current weather forecast for\nAmsterdam using http://openweathermap.org/appid[OpenWeatherMap] online service:\n\n[source,js]\n--------------------------------------------------\n{\n  \"input\" : {\n    \"http\" : {\n      \"request\" : {\n        \"url\" : \"http://api.openweathermap.org/data/2.5/weather\",\n        \"params\" : {\n          \"lat\" : \"52.374031\",\n          \"lon\" : \"4.88969\",\n          \"appid\" : \"<your openweathermap appid>\"\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\nSee <<input-http>> for more details.\n\n[[chaining-inputs]]\n==== Chaining inputs\n\nYou can create an <<input-chain,input chain>> to load data from multiple sources\ninto a watch payload. The inputs in a chain are processed in order, so the\ndata loaded by one input can be used by subsequent inputs.\n\nSee <<input-chain>> for more details.\n\n[[changing-conditions]]\n=== Changing conditions\n\nThe Watch Condition is evaluated as part of the watch execution. The condition\ndetermines whether the actions associated with the watch should execute or not.\n\n{watcher} supports four types of conditions <<condition-always,always>>,\n<<condition-never,never>>, <<condition-compare,compare>>, and\n<<condition-script,script>>.\n\nThe first two are pretty self-explanatory--they are shortcuts for setting a\nwatch's condition to `true` or `false`.\n\n==== Simple value comparison with the compare condition\n\nThe `compare` condition enables you to perform simple comparisons against values\nin the Watch payload. While you can also do this with a `script` condition, with\n`compare` you can define inline comparisons without having to enable dynamic\nscripting.\n\nFor example, the following compare condition checks to see if the `search` input\nreturned any hits:\n\n[source,js]\n--------------------------------------------------\n\"condition\" : {\n    \"compare\" : { \"ctx.payload.hits.total\" : { \"gt\" : 0 }}\n  },\n--------------------------------------------------\n// NOTCONSOLE\nSee <<condition-compare>> for more details.\n\n==== Powerful comparison logic with the script condition\n\nFor more complex conditional logic you can use the `script` condition. The\n`script` condition accepts a script that when executed returns `true` (indicating\nthe condition is met) or `false` (indicating the condition is not met). The script\nlanguage defaults to the default script language in Elasticsearch, but you can\nalso use any other supported language in the system.\n\nNOTE: Starting with 5.0, Elasticsearch is shipped with the new\n      <<modules-scripting-painless,Painless>> scripting language.\n      Painless was created and designed specifically for use in Elasticsearch.\n      Beyond providing an extensive feature set, its biggest trait is that it's\n      properly sandboxed and safe to use anywhere in the system (including in\n      {watcher}) without the need to enable dynamic scripting.\n\nFor example, the following `script` condition checks if the change in the latest\nVIX quote loaded by the `http` input is either greater than 5% or lower than -5%:\n\n[source,js]\n--------------------------------------------------\n\"condition\" : {\n  \"script\" : {\n    \"source\" : \"Math.abs(ctx.payload.hits.hits[0]._source.ChangePercent) > 5\",\n    \"lang\" : \"painless\"\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\nSee <<condition-script>> for more details.\n\n[[using-transforms]]\n=== Using transforms\n\nTransforms are constructs in a watch that can change the current payload\nassociated with the watch execution context.\n\n{watcher} supports three types of transforms <<transform-search,search>>,\n<<transform-script,script>> and <<transform-chain,chain>>. A `search` transform\nreplaces the existing payload with the response of a new search request. You can\nuse `script` transforms to modify the existing payload. A `chain` transform\nenables you to perform a series of `search` and `script` transforms.\n\nSee <<transform>> for more details.\n\n[[customizing-actions]]\n=== Customizing actions\n\nActions are associated with a watch and are executed as part of the watch execution\nonly when the watch condition is met.\n\n{watcher} supports the following action types: <<actions-email,email>>,\n<<actions-slack,slack>>, <<actions-pagerduty,pagerduty>>,\n<<actions-index,index>>, <<actions-logging,logging>>, and <<actions-webhook,webhook>>.\n\nTo use the `email` action, you need to <<configuring-email,configure an email account>>\nin `elasticsearch.yml` that {watcher} can use to send email. Your custom email\nmessages can be plain text or styled using HTML. You can include information from\nthe watch execution payload using <<templates,templates>>, as well as attach the\nentire watch payload to the message.\n\nFor example, the following email action uses a template in the email body and\nattaches the payload data to the message:\n\n[source,js]\n--------------------------------------------------\n\"actions\" : {\n  \"send_email\" : { <1>\n    \"email\" : { <2>\n      \"to\" : \"email@example.org\",\n      \"subject\" : \"Watcher Notification\",\n      \"body\" : \"{{ctx.payload.hits.total}} error logs found\",\n      \"attachments\" : {\n        \"data_attachment\" : {\n          \"data\" : {\n            \"format\" : \"json\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n<1> The id of the action\n<2> The action type, in this case it's an `email` action\n\nAnother example for an action is the `webhook` action. This enables you to send\na request to any external webservice. For example, the following `webhook` action\ncreates a new issue in GitHub\n\n[source,js]\n--------------------------------------------------\n\"actions\" : {\n  \"create_github_issue\" : {\n    \"webhook\" : {\n      \"method\" : \"POST\",\n      \"url\" : \"https://api.github.com/repos/<owner>/<repo>/issues\", <1>\n      \"body\" : \"{\n        \\\"title\\\": \\\"Found errors in 'contact.html'\\\",\n        \\\"body\\\": \\\"Found {{ctx.payload.hits.total}} errors in this page in the last 5 minutes\\\",\n        \\\"assignee\\\": \\\"web-admin\\\",\n        \\\"labels\\\": [ \\\"bug\\\", \\\"sev2\\\" ]\n      }\",\n      \"auth\" : {\n        \"basic\" : {\n          \"username\" : \"<username>\", <2>\n          \"password\" : \"<password>\" <3>\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n<1> `<owner>` is the owner of the GitHub repo and `<repo>` is the name of the repo.\n<2> The username that creates the issue\n<3> The password of that user\n\nTo learn how to create other actions see <<actions>>.\n"
}