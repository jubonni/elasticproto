{
    "meta": {
        "timestamp": "2024-11-01T03:07:10.395272",
        "size": 19114,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-templates.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "dynamic-templates",
        "version": "8.15"
    },
    "doc": "[[dynamic-templates]]\n=== Dynamic templates\n\nDynamic templates allow you greater control of how {es} maps your data beyond\nthe default <<dynamic-field-mapping,dynamic field mapping rules>>. You enable\ndynamic mapping by setting the dynamic parameter to `true` or `runtime`. You\ncan then use dynamic templates to define custom mappings that can be applied to\ndynamically added fields based on the matching condition:\n\n* <<match-mapping-type,`match_mapping_type` and `unmatch_mapping_type`>>\noperate on the data type that {es} detects\n* <<match-unmatch,`match` and `unmatch`>> use a pattern to match on the field\nname\n* <<path-match-unmatch,`path_match` and `path_unmatch`>> operate on the full\ndotted path to the field\n\n* If a dynamic template doesn't define `match_mapping_type`, `match`, or\n`path_match`, it won't match any field. You can still refer to the template by\nname in `dynamic_templates` section of a <<bulk,bulk request>>.\n\nUse the `{name}` and `{dynamic_type}` <<template-variables,template variables>>\nin the mapping specification as placeholders.\n\nIMPORTANT: Dynamic field mappings are only added when a field contains a\nconcrete value. {es} doesn't add a dynamic field mapping when the field contains\n`null` or an empty array. If the `null_value` option is used in a\n`dynamic_template`, it will only be applied after the first document with a\nconcrete value for the field has been\nindexed.\n\nDynamic templates are specified as an array of named objects:\n\n[source,js]\n--------------------------------------------------\n  \"dynamic_templates\": [\n    {\n      \"my_template_name\": { <1>\n        ... match conditions ... <2>\n        \"mapping\": { ... } <3>\n      }\n    },\n    ...\n  ]\n--------------------------------------------------\n// NOTCONSOLE\n<1> The template name can be any string value.\n<2> The match conditions can include any of : `match_mapping_type`, `match`, `match_pattern`, `unmatch`, `path_match`, `path_unmatch`.\n<3> The mapping that the matched field should use.\n\n[[dynamic-templates-validation]]\n==== Validating dynamic templates\nIf a provided mapping contains an invalid mapping snippet, a validation error\nis returned. Validation occurs when applying the dynamic template at index time,\nand, in most cases, when the dynamic template is updated. Providing an invalid mapping\nsnippet may cause the update or validation of a dynamic template to fail under certain conditions:\n\n* If no `match_mapping_type` has been specified but the template is valid for at least one predefined mapping type,\n  the mapping snippet is considered valid. However, a validation error is returned at index time if a field matching\n  the template is indexed as a different type. For example, configuring a dynamic template with no `match_mapping_type`\n  is considered valid as string type, but if a field matching the dynamic template is indexed as a long, a validation\n  error is returned at index time. It is recommended to configure the `match_mapping_type` to the expected JSON type or\n  configure the desired `type` in the mapping snippet.\n\n* If the `{name}` placeholder is used in the mapping snippet, validation is skipped when updating the dynamic\n  template. This is because the field name is unknown at that time. Instead, validation occurs when the template is applied\n  at index time.\n\nTemplates are processed in order -- the first matching template wins. When\nputting new dynamic templates through the <<indices-put-mapping, update mapping>> API,\nall existing templates are overwritten. This allows for dynamic templates to be\nreordered or deleted after they were initially added.\n\n[[dynamic-mapping-runtime-fields]]\n==== Mapping runtime fields in a dynamic template\nIf you want {es} to dynamically map new fields of a certain type as runtime\nfields, set `\"dynamic\":\"runtime\"` in the index mappings. These fields are not\nindexed, and are loaded from `_source` at query time.\n\nAlternatively, you can use the default dynamic mapping rules and then create\ndynamic templates to map specific fields as runtime fields. You set\n`\"dynamic\":\"true\"` in your index mapping, and then create a dynamic template to map\nnew fields of a certain type as runtime fields.\n\nLet's say you have data where each of the fields start with `ip_`. Based on the\n<<match-mapping-type,dynamic mapping rules>>, {es} maps any `string` that passes\n`numeric` detection as a `float` or `long`. However, you can create a dynamic\ntemplate that maps new strings as runtime fields of type `ip`.\n\nThe following request defines a dynamic template named `strings_as_ip`. When\n{es} detects new `string` fields matching the `ip*` pattern, it maps those\nfields as runtime fields of type `ip`. Because `ip` fields aren't mapped\ndynamically, you can use this template with either `\"dynamic\":\"true\"` or\n`\"dynamic\":\"runtime\"`.\n\n[source,console]\n----\nPUT my-index-000001/\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"strings_as_ip\": {\n          \"match_mapping_type\": \"string\",\n          \"match\": \"ip*\",\n          \"runtime\": {\n            \"type\": \"ip\"\n          }\n        }\n      }\n    ]\n  }\n}\n----\n\nSee <<text-only-mappings-strings,this example>> for how to use dynamic templates\nto map `string` fields as either indexed fields or runtime fields.\n\n[[match-mapping-type]]\n==== `match_mapping_type` and `unmatch_mapping_type`\n\nThe `match_mapping_type` parameter matches fields by the data type detected by\nthe JSON parser, while `unmatch_mapping_type` excludes fields based on the data\ntype.\n\nBecause JSON doesn't distinguish a `long` from an `integer` or a `double` from\na `float`, any parsed floating point number is considered a `double` JSON data\ntype, while any parsed `integer` number is considered a `long`.\n\nNOTE: With dynamic mappings, {es} will always choose the wider data type. The\none exception is `float`, which requires less storage space than `double` and\nis precise enough for most applications. Runtime fields do not support `float`,\nwhich is why `\"dynamic\":\"runtime\"` uses `double`.\n\n{es} automatically detects the following data types:\n\ninclude::field-mapping.asciidoc[tag=dynamic-field-mapping-types-tag]\n\nYou can specify either a single data type or a list of data types for either\nthe `match_mapping_type` or `unmatch_mapping_type` parameters. You can also\nuse a wildcard (`*`) for the `match_mapping_type` parameter to match all\ndata types.\n\nFor example, if we wanted to map all integer fields as `integer` instead of\n`long`, and all `string` fields as both `text` and `keyword`, we\ncould use the following template:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"numeric_counts\": {\n          \"match_mapping_type\": [\"long\", \"double\"],\n          \"match\": \"count\",\n          \"mapping\": {\n            \"type\": \"{dynamic_type}\",\n            \"index\": false\n          }\n        }\n      },\n      {\n        \"integers\": {\n          \"match_mapping_type\": \"long\",\n          \"mapping\": {\n            \"type\": \"integer\"\n          }\n        }\n      },\n      {\n        \"strings\": {\n          \"match_mapping_type\": \"string\",\n          \"mapping\": {\n            \"type\": \"text\",\n            \"fields\": {\n              \"raw\": {\n                \"type\":  \"keyword\",\n                \"ignore_above\": 256\n              }\n            }\n          }\n        }\n      },\n      {\n        \"non_objects_keyword\": {\n          \"match_mapping_type\": \"*\",\n          \"unmatch_mapping_type\": \"object\",\n          \"mapping\": {\n            \"type\": \"keyword\"\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  \"my_integer\": 5, <1>\n  \"my_string\": \"Some string\", <2>\n  \"my_boolean\": \"false\", <3>\n  \"field\": {\"count\": 4} <4>\n}\n--------------------------------------------------\n\n<1> The `my_integer` field is mapped as an `integer`.\n<2> The `my_string` field is mapped as a `text`, with a `keyword` <<multi-fields,multi-field>>.\n<3> The `my_boolean` field is mapped as a `keyword`.\n<4> The `field.count` field is mapped as a `long`.\n\n[[match-unmatch]]\n==== `match` and `unmatch`\n\nThe `match` parameter uses one or more patterns to match on the field name, while\n`unmatch` uses one or more patterns to exclude fields matched by `match`.\n\nThe `match_pattern` parameter adjusts the behavior of the `match` parameter\nto support full Java regular expressions matching on the field name\ninstead of simple wildcards. For example:\n\n[source,js]\n--------------------------------------------------\n  \"match_pattern\": \"regex\",\n  \"match\": \"^profit_\\d+$\"\n--------------------------------------------------\n// NOTCONSOLE\n\nThe following example matches all `string` fields whose name starts with\n`long_` (except for those which end with `_text`) and maps them as `long`\nfields:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"longs_as_strings\": {\n          \"match_mapping_type\": \"string\",\n          \"match\":   \"long_*\",\n          \"unmatch\": \"*_text\",\n          \"mapping\": {\n            \"type\": \"long\"\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  \"long_num\": \"5\", <1>\n  \"long_text\": \"foo\" <2>\n}\n--------------------------------------------------\n\n<1> The `long_num` field is mapped as a `long`.\n<2> The `long_text` field uses the default `string` mapping.\n\n\nYou can specify a list of patterns using a JSON array for either the\n`match` or `unmatch` fields.\n\nThe next example matches all fields whose name starts with `ip_` or ends with `_ip`, \nexcept for fields which start with `one` or end with `two` and maps them\nas `ip` fields:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"ip_fields\": {\n          \"match\":   [\"ip_*\", \"*_ip\"],\n          \"unmatch\": [\"one*\", \"*two\"],\n          \"mapping\": {\n            \"type\": \"ip\"\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index/_doc/1\n{\n  \"one_ip\":   \"will not match\", <1>\n  \"ip_two\":   \"will not match\", <2>\n  \"three_ip\": \"12.12.12.12\", <3>\n  \"ip_four\":  \"13.13.13.13\" <4>\n}\n--------------------------------------------------\n\n<1> The `one_ip` field is unmatched, so uses the default mapping of `text`.\n<2> The `ip_two` field is unmatched, so uses the default mapping of `text`.\n<3> The `three_ip` field is mapped as type `ip`.\n<4> The `ip_four` field is mapped as type `ip`.\n\n\n[[path-match-unmatch]]\n==== `path_match` and `path_unmatch`\n\nThe `path_match` and `path_unmatch` parameters work in the same way as `match`\nand `unmatch`, but operate on the full dotted path to the field, not just the\nfinal name, e.g. `some_object.*.some_field`.\n\nThis example copies the values of any fields in the `name` object to the\ntop-level `full_name` field, except for the `middle` field:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"full_name\": {\n          \"path_match\":   \"name.*\",\n          \"path_unmatch\": \"*.middle\",\n          \"mapping\": {\n            \"type\":       \"text\",\n            \"copy_to\":    \"full_name\"\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  \"name\": {\n    \"first\":  \"John\",\n    \"middle\": \"Winston\",\n    \"last\":   \"Lennon\"\n  }\n}\n--------------------------------------------------\n\nAnd the following example uses an array of patterns for both `path_match`\nand `path_unmatch`.\n\nThe values of any fields in the `name` object or the `user.name` object\nare copied to the top-level `full_name` field, except for the `middle`\nand `midinitial` fields:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"full_name\": {\n          \"path_match\":   [\"name.*\", \"user.name.*\"],\n          \"path_unmatch\": [\"*.middle\", \"*.midinitial\"],\n          \"mapping\": {\n            \"type\":       \"text\",\n            \"copy_to\":    \"full_name\"\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  \"name\": {\n    \"first\":  \"John\",\n    \"middle\": \"Winston\",\n    \"last\":   \"Lennon\"\n  }\n}\n\nPUT my-index-000001/_doc/2\n{\n  \"user\": {\n    \"name\": {\n      \"first\":      \"Jane\",\n      \"midinitial\": \"M\",\n      \"last\":       \"Salazar\"\n    }\n  }\n}\n--------------------------------------------------\n\n\nNote that the `path_match` and `path_unmatch` parameters match on object paths\nin addition to leaf fields. As an example, indexing the following document will\nresult in an error because the `path_match` setting also matches the object\nfield `name.title`, which can't be mapped as text:\n\n[source,console]\n----\nPUT my-index-000001/_doc/2\n{\n  \"name\": {\n    \"first\":  \"Paul\",\n    \"last\":   \"McCartney\",\n    \"title\": {\n      \"value\": \"Sir\",\n      \"category\": \"order of chivalry\"\n    }\n  }\n}\n----\n// TEST[continued]\n// TEST[catch:bad_request]\n\n[[template-variables]]\n==== Template variables\n\nThe `{name}` and `{dynamic_type}` placeholders are replaced in the `mapping`\nwith the field name and detected dynamic type. The following example sets all\nstring fields to use an <<analyzer,`analyzer`>> with the same name as the\nfield, and disables <<doc-values,`doc_values`>> for all non-string fields:\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"named_analyzers\": {\n          \"match_mapping_type\": \"string\",\n          \"match\": \"*\",\n          \"mapping\": {\n            \"type\": \"text\",\n            \"analyzer\": \"{name}\"\n          }\n        }\n      },\n      {\n        \"no_doc_values\": {\n          \"match_mapping_type\":\"*\",\n          \"mapping\": {\n            \"type\": \"{dynamic_type}\",\n            \"doc_values\": false\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  \"english\": \"Some English text\", <1>\n  \"count\":   5 <2>\n}\n----\n\n<1> The `english` field is mapped as a `string` field with the `english` analyzer.\n<2> The `count` field is mapped as a `long` field with `doc_values` disabled.\n\n[[template-examples]]\n==== Dynamic template examples\n\nHere are some examples of potentially useful dynamic templates:\n\n===== Structured search\n\nWhen you set `\"dynamic\":\"true\"`, {es} will map string fields as a `text` field with\na `keyword` subfield. If you are only indexing structured content and not\ninterested in full text search, you can make {es} map your fields\nonly as `keyword` fields. However, you must search on the exact same value that\nwas indexed to search those fields.\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"strings_as_keywords\": {\n          \"match_mapping_type\": \"string\",\n          \"mapping\": {\n            \"type\": \"keyword\"\n          }\n        }\n      }\n    ]\n  }\n}\n----\n\n[[text-only-mappings-strings]]\n===== `text`-only mappings for strings\n\nContrary to the previous example, if you only care about full-text search on\nstring fields and don't plan on running aggregations, sorting, or exact\nsearches, you could tell instruct {es} to map strings as `text`:\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"strings_as_text\": {\n          \"match_mapping_type\": \"string\",\n          \"mapping\": {\n            \"type\": \"text\"\n          }\n        }\n      }\n    ]\n  }\n}\n----\n\nAlternatively, you can create a dynamic template to map your string fields as\n`keyword` fields in the runtime section of the mapping. When {es} detects new\nfields of type `string`, those fields will be created as runtime fields of\ntype `keyword`.\n\nAlthough your `string` fields won't be indexed, their values are stored in\n`_source` and can be used in search requests, aggregations, filtering, and\nsorting.\n\nFor example, the following request creates a dynamic template to map `string`\nfields as runtime fields of type `keyword`. Although the `runtime` definition\nis blank, new `string` fields will be mapped as `keyword` runtime fields based\non the <<dynamic-field-mapping-types,dynamic mapping rules>> that {es} uses for\nadding field types to the mapping. Any `string` that doesn't pass date\ndetection or numeric detection is automatically mapped as a `keyword`:\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"strings_as_keywords\": {\n          \"match_mapping_type\": \"string\",\n          \"runtime\": {}\n        }\n      }\n    ]\n  }\n}\n----\n\nYou index a simple document:\n\n[source,console]\n----\nPUT my-index-000001/_doc/1\n{\n  \"english\": \"Some English text\",\n  \"count\":   5\n}\n----\n//TEST[continued]\n\nWhen you view the mapping, you'll see that the `english` field is a runtime\nfield of type `keyword`:\n\n[source,console]\n----\nGET my-index-000001/_mapping\n----\n//TEST[continued]\n\n[source,console-result]\n----\n{\n  \"my-index-000001\" : {\n    \"mappings\" : {\n      \"dynamic_templates\" : [\n        {\n          \"strings_as_keywords\" : {\n            \"match_mapping_type\" : \"string\",\n            \"runtime\" : { }\n          }\n        }\n      ],\n      \"runtime\" : {\n        \"english\" : {\n          \"type\" : \"keyword\"\n        }\n      },\n      \"properties\" : {\n        \"count\" : {\n          \"type\" : \"long\"\n        }\n      }\n    }\n  }\n}\n----\n\n===== Disabled norms\n\nNorms are index-time scoring factors. If you do not care about scoring, which\nwould be the case for instance if you never sort documents by score, you could\ndisable the storage of these scoring factors in the index and save some space.\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"strings_as_keywords\": {\n          \"match_mapping_type\": \"string\",\n          \"mapping\": {\n            \"type\": \"text\",\n            \"norms\": false,\n            \"fields\": {\n              \"keyword\": {\n                \"type\": \"keyword\",\n                \"ignore_above\": 256\n              }\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n----\n\nThe sub `keyword` field appears in this template to be consistent with the\ndefault rules of dynamic mappings. Of course if you do not need them because\nyou don't need to perform exact search or aggregate on this field, you could\nremove it as described in the previous section.\n\n===== Time series\n\nWhen doing time series analysis with Elasticsearch, it is common to have many\nnumeric fields that you will often aggregate on but never filter on. In such a\ncase, you could disable indexing on those fields to save disk space and also\nmaybe gain some indexing speed:\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"unindexed_longs\": {\n          \"match_mapping_type\": \"long\",\n          \"mapping\": {\n            \"type\": \"long\",\n            \"index\": false\n          }\n        }\n      },\n      {\n        \"unindexed_doubles\": {\n          \"match_mapping_type\": \"double\",\n          \"mapping\": {\n            \"type\": \"float\", <1>\n            \"index\": false\n          }\n        }\n      }\n    ]\n  }\n}\n----\n\n<1> Like the default dynamic mapping rules, doubles are mapped as floats, which\n    are usually accurate enough, yet require half the disk space.\n"
}