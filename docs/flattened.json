{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.134066",
        "size": 12463,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/flattened.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "flattened",
        "version": "8.15"
    },
    "doc": "[[flattened]]\n=== Flattened field type\n++++\n<titleabbrev>Flattened</titleabbrev>\n++++\n\nBy default, each subfield in an object is mapped and indexed separately. If\nthe names or types of the subfields are not known in advance, then they are\n<<dynamic-mapping, mapped dynamically>>.\n\nThe `flattened` type provides an alternative approach, where the entire\nobject is mapped as a single field. Given an object, the `flattened`\nmapping will parse out its leaf values and index them into one field as\nkeywords. The object's contents can then be searched through simple queries\nand aggregations.\n\nThis data type can be useful for indexing objects with a large or unknown\nnumber of unique keys. Only one field mapping is created for the whole JSON\nobject, which can help prevent a <<mapping-limit-settings, mappings explosion>>\nfrom having too many distinct field mappings.\n\nOn the other hand, flattened object fields present a trade-off in terms of\nsearch functionality. Only basic queries are allowed, with no support for\nnumeric range queries or highlighting. Further information on the limitations\ncan be found in the <<supported-operations, Supported operations>> section.\n\nNOTE: The `flattened` mapping type should **not** be used for indexing all\ndocument content, as it treats all values as keywords and does not provide full\nsearch functionality. The default approach, where each subfield has its own\nentry in the mappings, works well in the majority of cases.\n\nA flattened object field can be created as follows:\n\n[source,console]\n--------------------------------\nPUT bug_reports\n{\n  \"mappings\": {\n    \"properties\": {\n      \"title\": {\n        \"type\": \"text\"\n      },\n      \"labels\": {\n        \"type\": \"flattened\"\n      }\n    }\n  }\n}\n\nPOST bug_reports/_doc/1\n{\n  \"title\": \"Results are not sorted correctly.\",\n  \"labels\": {\n    \"priority\": \"urgent\",\n    \"release\": [\"v1.2.5\", \"v1.3.0\"],\n    \"timestamp\": {\n      \"created\": 1541458026,\n      \"closed\": 1541457010\n    }\n  }\n}\n--------------------------------\n// TESTSETUP\n\nDuring indexing, tokens are created for each leaf value in the JSON object. The\nvalues are indexed as string keywords, without analysis or special handling for\nnumbers or dates.\n\nQuerying the top-level `flattened` field searches all leaf values in the\nobject:\n\n[source,console]\n--------------------------------\nPOST bug_reports/_search\n{\n  \"query\": {\n    \"term\": {\"labels\": \"urgent\"}\n  }\n}\n--------------------------------\n\nTo query on a specific key in the flattened object, object dot notation is used:\n\n[source,console]\n--------------------------------\nPOST bug_reports/_search\n{\n  \"query\": {\n    \"term\": {\"labels.release\": \"v1.3.0\"}\n  }\n}\n--------------------------------\n\n[[supported-operations]]\n==== Supported operations\n\nBecause of the similarities in the way values are indexed, `flattened`\nfields share much of the same mapping and search functionality as\n<<keyword, `keyword`>> fields.\n\nCurrently, flattened object fields can be used with the following query types:\n\n- `term`, `terms`, and `terms_set`\n- `prefix`\n- `range`\n- `match` and `multi_match`\n- `query_string` and `simple_query_string`\n- `exists`\n\nWhen querying, it is not possible to refer to field keys using wildcards, as in\n`{ \"term\": {\"labels.time*\": 1541457010}}`. Note that all queries, including\n`range`, treat the values as string keywords. Highlighting is not supported on\n`flattened` fields.\n\nIt is possible to sort on a flattened object field, as well as perform simple\nkeyword-style aggregations such as `terms`. As with queries, there is no\nspecial support for numerics -- all values in the JSON object are treated as\nkeywords. When sorting, this implies that values are compared\nlexicographically.\n\nFlattened object fields currently cannot be stored. It is not possible to\nspecify the <<mapping-store, `store`>> parameter in the mapping.\n\n[[search-fields-flattened]]\n==== Retrieving flattened fields\n\nField values and concrete subfields can be retrieved using the\n<<search-fields-param,fields parameter>>. content. Since the `flattened` field maps an\nentire object with potentially many subfields as a single field, the response contains\nthe unaltered structure from `_source`.\n\nSingle subfields, however, can be fetched by specifying them explicitly in the request.\nThis only works for concrete paths, but not using wildcards:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"flattened_field\": {\n        \"type\": \"flattened\"\n      }\n    }\n  }\n}\n\nPUT my-index-000001/_doc/1?refresh=true\n{\n  \"flattened_field\" : {\n    \"subfield\" : \"value\"\n  }\n}\n\nPOST my-index-000001/_search\n{\n  \"fields\": [\"flattened_field.subfield\"],\n  \"_source\": false\n}\n--------------------------------------------------\n\n[source,console-result]\n----\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.0,\n    \"hits\": [{\n      \"_index\": \"my-index-000001\",\n      \"_id\": \"1\",\n      \"_score\": 1.0,\n      \"fields\": {\n        \"flattened_field.subfield\" : [ \"value\" ]\n      }\n    }]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 2/\"took\": $body.took/]\n// TESTRESPONSE[s/\"max_score\" : 1.0/\"max_score\" : $body.hits.max_score/]\n// TESTRESPONSE[s/\"_score\" : 1.0/\"_score\" : $body.hits.hits.0._score/]\n\nYou can also use a <<modules-scripting-painless,Painless script>> to retrieve\nvalues from sub-fields of flattened fields. Instead of including\n`doc['<field_name>'].value` in your Painless script, use\n`doc['<field_name>.<sub-field_name>'].value`. For example, if you have a\nflattened field called `label` with a `release` sub-field, your Painless script\nwould be `doc['labels.release'].value`.\n\nFor example, let's say your mapping contains two fields, one of which is of the\n`flattened` type:\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"title\": {\n        \"type\": \"text\"\n      },\n      \"labels\": {\n        \"type\": \"flattened\"\n      }\n    }\n  }\n}\n----\n\nIndex a few documents containing your mapped fields. The `labels` field has\nthree sub-fields:\n\n[source,console]\n----\nPOST /my-index-000001/_bulk?refresh\n{\"index\":{}}\n{\"title\":\"Something really urgent\",\"labels\":{\"priority\":\"urgent\",\"release\":[\"v1.2.5\",\"v1.3.0\"],\"timestamp\":{\"created\":1541458026,\"closed\":1541457010}}}\n{\"index\":{}}\n{\"title\":\"Somewhat less urgent\",\"labels\":{\"priority\":\"high\",\"release\":[\"v1.3.0\"],\"timestamp\":{\"created\":1541458026,\"closed\":1541457010}}}\n{\"index\":{}}\n{\"title\":\"Not urgent\",\"labels\":{\"priority\":\"low\",\"release\":[\"v1.2.0\"],\"timestamp\":{\"created\":1541458026,\"closed\":1541457010}}}\n----\n// TEST[continued]\n\nBecause `labels` is a `flattened` field type, the entire object is mapped as a\nsingle field. To retrieve values from this sub-field in a Painless script, use\nthe `doc['<field_name>.<sub-field_name>'].value` format.\n\n[source,painless]\n----\n\"script\": {\n  \"source\": \"\"\"\n    if (doc['labels.release'].value.equals('v1.3.0'))\n    {emit(doc['labels.release'].value)}\n    else{emit('Version mismatch')}\n  \"\"\"\n----\n\n[[flattened-params]]\n==== Parameters for flattened object fields\n\nThe following mapping parameters are accepted:\n\n[horizontal]\n\n`depth_limit`::\n\n    The maximum allowed depth of the flattened object field, in terms of nested\n    inner objects. If a flattened object field exceeds this limit, then an\n    error will be thrown. Defaults to `20`. Note that `depth_limit` can be\n    updated dynamically through the <<indices-put-mapping, update mapping>> API.\n\n<<doc-values,`doc_values`>>::\n\n    Should the field be stored on disk in a column-stride fashion, so that it\n    can later be used for sorting, aggregations, or scripting? Accepts `true`\n    (default) or `false`.\n\n<<eager-global-ordinals,`eager_global_ordinals`>>::\n\n    Should global ordinals be loaded eagerly on refresh? Accepts `true` or\n    `false` (default). Enabling this is a good idea on fields that are\n    frequently used for terms aggregations.\n\n<<ignore-above,`ignore_above`>>::\n\n    Leaf values longer than this limit will not be indexed. By default, there\n    is no limit and all values will be indexed. Note that this limit applies\n    to the leaf values within the flattened object field, and not the length of\n    the entire field.\n\n<<mapping-index,`index`>>::\n\n    Determines if the field should be searchable. Accepts `true` (default) or\n    `false`.\n\n<<index-options,`index_options`>>::\n\n    What information should be stored in the index for scoring purposes.\n    Defaults to `docs` but can also be set to `freqs` to take term frequency\n    into account when computing scores.\n\n<<null-value,`null_value`>>::\n\n    A string value which is substituted for any explicit `null` values within\n    the flattened object field. Defaults to `null`, which means null fields are\n    treated as if they were missing.\n\n<<similarity,`similarity`>>::\n\n    Which scoring algorithm or _similarity_ should be used. Defaults\n    to `BM25`.\n\n`split_queries_on_whitespace`::\n\n    Whether <<full-text-queries,full text queries>> should split the input on\n    whitespace when building a query for this field. Accepts `true` or `false`\n    (default).\n\n`time_series_dimensions`::\n    (Optional, array of strings) A list of fields inside the flattened object, where each field is a dimension\n    of the time series. Each field is specified using the relative path from the\n    root field and does not include the root field name.\n\n\n[[flattened-synthetic-source]]\n==== Synthetic `_source`\n\nIMPORTANT: Synthetic `_source` is Generally Available only for TSDB indices\n(indices that have `index.mode` set to `time_series`). For other indices\nsynthetic `_source` is in technical preview. Features in technical preview may\nbe changed or removed in a future release. Elastic will work to fix\nany issues, but features in technical preview are not subject to the support SLA\nof official GA features.\n\nFlattened fields support <<synthetic-source,synthetic`_source`>> in their default\nconfiguration.\n\nSynthetic source may sort `flattened` field values and remove duplicates.\nFor example:\n[source,console,id=synthetic-source-flattened-sorting-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"flattened\": { \"type\": \"flattened\" }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"flattened\": {\n    \"field\": [ \"apple\", \"apple\", \"banana\", \"avocado\", \"10\", \"200\", \"AVOCADO\", \"Banana\", \"Tangerine\" ]\n  }\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n[source,console-result]\n----\n{\n  \"flattened\": {\n    \"field\": [ \"10\", \"200\", \"AVOCADO\", \"Banana\", \"Tangerine\", \"apple\", \"avocado\", \"banana\" ]\n  }\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\nSynthetic source always uses nested objects instead of array of objects.\nFor example:\n[source,console,id=synthetic-source-flattened-array-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"flattened\": { \"type\": \"flattened\" }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"flattened\": {\n      \"field\": [\n        { \"id\": 1, \"name\": \"foo\" },\n        { \"id\": 2, \"name\": \"bar\" },\n        { \"id\": 3, \"name\": \"baz\" }\n      ]\n  }\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become (note the nested objects instead of the \"flattened\" array):\n[source,console-result]\n----\n{\n    \"flattened\": {\n      \"field\": {\n          \"id\": [ \"1\", \"2\", \"3\" ],\n          \"name\": [ \"bar\", \"baz\", \"foo\" ]\n      }\n    }\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\nSynthetic source always uses single-valued fields for one-element arrays.\nFor example:\n[source,console,id=synthetic-source-flattened-single-value-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"flattened\": { \"type\": \"flattened\" }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"flattened\": {\n    \"field\": [ \"foo\" ]\n  }\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become (note the nested objects instead of the \"flattened\" array):\n[source,console-result]\n----\n{\n  \"flattened\": {\n    \"field\": \"foo\"\n  }\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n"
}