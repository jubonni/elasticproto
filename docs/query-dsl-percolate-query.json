{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.920071",
        "size": 22911,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-percolate-query.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "query-dsl-percolate-query",
        "version": "8.15"
    },
    "doc": "[[query-dsl-percolate-query]]\n=== Percolate query\n++++\n<titleabbrev>Percolate</titleabbrev>\n++++\n\nThe `percolate` query can be used to match queries\nstored in an index. The `percolate` query itself\ncontains the document that will be used as query\nto match with the stored queries.\n\n==== Sample usage\n\nTIP: To provide a simple example, this documentation uses one index,\n`my-index-000001`, for both the percolate queries and documents. This setup can\nwork well when there are just a few percolate queries registered. For heavier\nusage, we recommend you store queries and documents in separate indices. For\nmore details, refer to <<how-it-works>>.\n\nCreate an index with two fields:\n\n[source,console]\n--------------------------------------------------\nPUT /my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"message\": {\n        \"type\": \"text\"\n      },\n      \"query\": {\n        \"type\": \"percolator\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThe `message` field is the field used to preprocess the document defined in\nthe `percolator` query before it gets indexed into a temporary index.\n\nThe `query` field is used for indexing the query documents. It will hold a\njson object that represents an actual Elasticsearch query. The `query` field\nhas been configured to use the <<percolator,percolator field type>>. This field\ntype understands the query dsl and stores the query in such a way that it can be\nused later on to match documents defined on the `percolate` query.\n\nRegister a query in the percolator:\n\n[source,console]\n--------------------------------------------------\nPUT /my-index-000001/_doc/1?refresh\n{\n  \"query\": {\n    \"match\": {\n      \"message\": \"bonsai tree\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nMatch a document to the registered percolator queries:\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"percolate\": {\n      \"field\": \"query\",\n      \"document\": {\n        \"message\": \"A new bonsai tree in the office\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nThe above request will yield the following response:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 13,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.26152915,\n    \"hits\": [\n      { <1>\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"1\",\n        \"_score\": 0.26152915,\n        \"_source\": {\n          \"query\": {\n            \"match\": {\n              \"message\": \"bonsai tree\"\n            }\n          }\n        },\n        \"fields\" : {\n          \"_percolator_document_slot\" : [0] <2>\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 13,/\"took\": \"$body.took\",/]\n\n<1> The query with id `1` matches our document.\n<2> The `_percolator_document_slot` field indicates which document has matched with this query.\n    Useful when percolating multiple document simultaneously.\n\n==== Parameters\n\nThe following parameters are required when percolating a document:\n\n[horizontal]\n`field`:: The field of type `percolator` that holds the indexed queries. This is a required parameter.\n`name`:: The suffix to be used for the `_percolator_document_slot` field in case multiple `percolate` queries have been specified.\n         This is an optional parameter.\n`document`:: The source of the document being percolated.\n`documents`:: Like the `document` parameter, but accepts multiple documents via a json array.\n`document_type`:: The type / mapping of the document being percolated. This parameter is deprecated and will be removed in Elasticsearch 8.0.\n\nInstead of specifying the source of the document being percolated, the source can also be retrieved from an already\nstored document. The `percolate` query will then internally execute a get request to fetch that document.\n\nIn that case the `document` parameter can be substituted with the following parameters:\n\n[horizontal]\n`index`:: The index the document resides in. This is a required parameter.\n`type`:: The type of the document to fetch. This parameter is deprecated and will be removed in Elasticsearch 8.0.\n`id`:: The id of the document to fetch. This is a required parameter.\n`routing`:: Optionally, routing to be used to fetch document to percolate.\n`preference`:: Optionally, preference to be used to fetch document to percolate.\n`version`:: Optionally, the expected version of the document to be fetched.\n\n==== Percolating in a filter context\n\nIn case you are not interested in the score, better performance can be expected by wrapping\nthe percolator query in a `bool` query's filter clause or in a `constant_score` query:\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"constant_score\": {\n      \"filter\": {\n        \"percolate\": {\n          \"field\": \"query\",\n          \"document\": {\n            \"message\": \"A new bonsai tree in the office\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nAt index time terms are extracted from the percolator query and the percolator\ncan often determine whether a query matches just by looking at those extracted\nterms. However, computing scores requires to deserialize each matching query\nand run it against the percolated document, which is a much more expensive\noperation. Hence if computing scores is not required the `percolate` query\nshould be wrapped in a `constant_score` query or a `bool` query's filter clause.\n\nNote that the `percolate` query never gets cached by the query cache.\n\n==== Percolating multiple documents\n\nThe `percolate` query can match multiple documents simultaneously with the indexed percolator queries.\nPercolating multiple documents in a single request can improve performance as queries only need to be parsed and\nmatched once instead of multiple times.\n\nThe `_percolator_document_slot` field that is being returned with each matched percolator query is important when percolating\nmultiple documents simultaneously. It indicates which documents matched with a particular percolator query. The numbers\ncorrelate with the slot in the `documents` array specified in the `percolate` query.\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"percolate\": {\n      \"field\": \"query\",\n      \"documents\": [ <1>\n        {\n          \"message\": \"bonsai tree\"\n        },\n        {\n          \"message\": \"new tree\"\n        },\n        {\n          \"message\": \"the office\"\n        },\n        {\n          \"message\": \"office tree\"\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n<1> The documents array contains 4 documents that are going to be percolated at the same time.\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 13,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.7093853,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"1\",\n        \"_score\": 0.7093853,\n        \"_source\": {\n          \"query\": {\n            \"match\": {\n              \"message\": \"bonsai tree\"\n            }\n          }\n        },\n        \"fields\" : {\n          \"_percolator_document_slot\" : [0, 1, 3] <1>\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 13,/\"took\": \"$body.took\",/]\n\n<1> The `_percolator_document_slot` indicates that the first, second and last documents specified in the `percolate` query\n    are matching with this query.\n\n==== Percolating an Existing Document\n\nIn order to percolate a newly indexed document, the `percolate` query can be used. Based on the response\nfrom an index request, the `_id` and other meta information can be used to immediately percolate the newly added\ndocument.\n\n===== Example\n\nBased on the previous example.\n\nIndex the document we want to percolate:\n\n[source,console]\n--------------------------------------------------\nPUT /my-index-000001/_doc/2\n{\n  \"message\" : \"A new bonsai tree in the office\"\n}\n--------------------------------------------------\n// TEST[continued]\nIndex response:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"_index\": \"my-index-000001\",\n  \"_id\": \"2\",\n  \"_version\": 1,\n  \"_shards\": {\n    \"total\": 2,\n    \"successful\": 1,\n    \"failed\": 0\n  },\n  \"result\": \"created\",\n  \"_seq_no\" : 1,\n  \"_primary_term\" : 1\n}\n--------------------------------------------------\n\nPercolating an existing document, using the index response as basis to build to new search request:\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"percolate\": {\n      \"field\": \"query\",\n      \"index\": \"my-index-000001\",\n      \"id\": \"2\",\n      \"version\": 1 <1>\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n<1> The version is optional, but useful in certain cases. We can ensure that we are trying to percolate\nthe document we just have indexed. A change may be made after we have indexed, and if that is the\ncase the search request would fail with a version conflict error.\n\nThe search response returned is identical as in the previous example.\n\n\n==== Percolate query and highlighting\n\nThe `percolate` query is handled in a special way when it comes to highlighting. The queries hits are used\nto highlight the document that is provided in the `percolate` query. Whereas with regular highlighting the query in\nthe search request is used to highlight the hits.\n\n===== Example\n\nThis example is based on the mapping of the first example.\n\nSave a query:\n\n[source,console]\n--------------------------------------------------\nPUT /my-index-000001/_doc/3?refresh\n{\n  \"query\": {\n    \"match\": {\n      \"message\": \"brown fox\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nSave another query:\n\n[source,console]\n--------------------------------------------------\nPUT /my-index-000001/_doc/4?refresh\n{\n  \"query\": {\n    \"match\": {\n      \"message\": \"lazy dog\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nExecute a search request with the `percolate` query and highlighting enabled:\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"percolate\": {\n      \"field\": \"query\",\n      \"document\": {\n        \"message\": \"The quick brown fox jumps over the lazy dog\"\n      }\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"message\": {}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nThis will yield the following response.\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 7,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 2,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.26152915,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"3\",\n        \"_score\": 0.26152915,\n        \"_source\": {\n          \"query\": {\n            \"match\": {\n              \"message\": \"brown fox\"\n            }\n          }\n        },\n        \"highlight\": {\n          \"message\": [\n            \"The quick <em>brown</em> <em>fox</em> jumps over the lazy dog\" <1>\n          ]\n        },\n        \"fields\" : {\n          \"_percolator_document_slot\" : [0]\n        }\n      },\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"4\",\n        \"_score\": 0.26152915,\n        \"_source\": {\n          \"query\": {\n            \"match\": {\n              \"message\": \"lazy dog\"\n            }\n          }\n        },\n        \"highlight\": {\n          \"message\": [\n            \"The quick brown fox jumps over the <em>lazy</em> <em>dog</em>\" <1>\n          ]\n        },\n        \"fields\" : {\n          \"_percolator_document_slot\" : [0]\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 7,/\"took\": \"$body.took\",/]\n\n<1> The terms from each query have been highlighted in the document.\n\nInstead of the query in the search request highlighting the percolator hits, the percolator queries are highlighting\nthe document defined in the `percolate` query.\n\nWhen percolating multiple documents at the same time like the request below then the highlight response is different:\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"percolate\": {\n      \"field\": \"query\",\n      \"documents\": [\n        {\n          \"message\": \"bonsai tree\"\n        },\n        {\n          \"message\": \"new tree\"\n        },\n        {\n          \"message\": \"the office\"\n        },\n        {\n          \"message\": \"office tree\"\n        }\n      ]\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"message\": {}\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nThe slightly different response:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 13,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.7093853,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"1\",\n        \"_score\": 0.7093853,\n        \"_source\": {\n          \"query\": {\n            \"match\": {\n              \"message\": \"bonsai tree\"\n            }\n          }\n        },\n        \"fields\" : {\n          \"_percolator_document_slot\" : [0, 1, 3]\n        },\n        \"highlight\" : { <1>\n          \"0_message\" : [\n              \"<em>bonsai</em> <em>tree</em>\"\n          ],\n          \"3_message\" : [\n              \"office <em>tree</em>\"\n          ],\n          \"1_message\" : [\n              \"new <em>tree</em>\"\n          ]\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 13,/\"took\": \"$body.took\",/]\n\n<1> The highlight fields have been prefixed with the document slot they belong to,\n    in order to know which highlight field belongs to what document.\n\n==== Named queries within percolator queries\n\nIf a stored percolator query is a complex query, and you want to track which\nits sub-queries matched a percolated document, then you can use the `\\_name`\nparameter for its sub-queries. In this case, in a response, each hit together with\na `_percolator_document_slot` field contains\n`_percolator_document_slot_<slotNumber>_matched_queries` fields that show\nwhich sub-queries matched each percolated document.\n\nFor example:\n\n[source,console]\n--------------------------------------------------\nPUT /my-index-000001/_doc/5?refresh\n{\n  \"query\": {\n    \"bool\": {\n      \"should\": [\n        {\n          \"match\": {\n            \"message\": {\n              \"query\": \"Japanese art\",\n              \"_name\": \"query1\"\n            }\n          }\n        },\n        {\n          \"match\": {\n            \"message\": {\n              \"query\": \"Holand culture\",\n              \"_name\": \"query2\"\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"percolate\": {\n      \"field\": \"query\",\n      \"documents\": [\n        {\n          \"message\": \"Japanse art\"\n        },\n        {\n          \"message\": \"Holand culture\"\n        },\n        {\n          \"message\": \"Japanese art and Holand culture\"\n        },\n        {\n          \"message\": \"no-match\"\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 55,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 1.1181908,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"5\",\n        \"_score\": 1.1181908,\n        \"_source\": {\n          \"query\": {\n            \"bool\": {\n              \"should\": [\n                {\n                  \"match\": {\n                    \"message\": {\n                      \"query\": \"Japanese art\",\n                      \"_name\": \"query1\"\n                    }\n                  }\n                },\n                {\n                  \"match\": {\n                    \"message\": {\n                      \"query\": \"Holand culture\",\n                      \"_name\": \"query2\"\n                    }\n                  }\n                }\n              ]\n            }\n          }\n        },\n        \"fields\" : {\n          \"_percolator_document_slot\" : [0, 1, 2],\n          \"_percolator_document_slot_0_matched_queries\" : [\"query1\"], <1>\n          \"_percolator_document_slot_1_matched_queries\" : [\"query2\"], <2>\n          \"_percolator_document_slot_2_matched_queries\" : [\"query1\", \"query2\"] <3>\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 55,/\"took\": \"$body.took\",/]\n<1> The first document matched only the first sub-query.\n<2> The second document matched only the second sub-query.\n<3> The third document matched both sub-queries.\n\n==== Specifying multiple percolate queries\n\nIt is possible to specify multiple `percolate` queries in a single search request:\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"should\": [\n        {\n          \"percolate\": {\n            \"field\": \"query\",\n            \"document\": {\n              \"message\": \"bonsai tree\"\n            },\n            \"name\": \"query1\" <1>\n          }\n        },\n        {\n          \"percolate\": {\n            \"field\": \"query\",\n            \"document\": {\n              \"message\": \"tulip flower\"\n            },\n            \"name\": \"query2\" <1>\n          }\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n<1> The `name` parameter will be used to identify which percolator document slots belong to what `percolate` query.\n\nThe `_percolator_document_slot` field name will be suffixed with what is specified in the `_name` parameter.\nIf that isn't specified then the `field` parameter will be used, which in this case will result in ambiguity.\n\nThe above search request returns a response similar to this:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 13,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.26152915,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"1\",\n        \"_score\": 0.26152915,\n        \"_source\": {\n          \"query\": {\n            \"match\": {\n              \"message\": \"bonsai tree\"\n            }\n          }\n        },\n        \"fields\" : {\n          \"_percolator_document_slot_query1\" : [0] <1>\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 13,/\"took\": \"$body.took\",/]\n\n<1> The `_percolator_document_slot_query1` percolator slot field indicates that these matched slots are from the `percolate`\n    query with `_name` parameter set to `query1`.\n\n[[how-it-works]]\n==== How it Works Under the Hood\n\nWhen indexing a document into an index that has the <<percolator,percolator field type>> mapping configured, the query\npart of the document gets parsed into a Lucene query and is stored into the Lucene index. A binary representation\nof the query gets stored, but also the query's terms are analyzed and stored into an indexed field.\n\nAt search time, the document specified in the request gets parsed into a Lucene document and is stored in a in-memory\ntemporary Lucene index. This in-memory index can just hold this one document and it is optimized for that. After this\na special query is built based on the terms in the in-memory index that select candidate percolator queries based on\ntheir indexed query terms. These queries are then evaluated by the in-memory index if they actually match.\n\nThe selecting of candidate percolator queries matches is an important performance optimization during the execution\nof the `percolate` query as it can significantly reduce the number of candidate matches the in-memory index needs to\nevaluate. The reason the `percolate` query can do this is because during indexing of the percolator queries the query\nterms are being extracted and indexed with the percolator query. Unfortunately the percolator cannot extract terms from\nall queries (for example the `wildcard` or `geo_shape` query) and as a result of that in certain cases the percolator\ncan't do the selecting optimization (for example if an unsupported query is defined in a required clause of a boolean query\nor the unsupported query is the only query in the percolator document). These queries are marked by the percolator and\ncan be found by running the following search:\n\n\n[source,console]\n---------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"term\" : {\n      \"query.extraction_result\" : \"failed\"\n    }\n  }\n}\n---------------------------------------------------\n\nNOTE: The above example assumes that there is a `query` field of type\n`percolator` in the mappings.\n\nGiven the design of percolation, it often makes sense to use separate indices for the percolate queries and documents\nbeing percolated, as opposed to a single index as we do in examples. There are a few benefits to this approach:\n\n- Because percolate queries contain a different set of fields from the percolated documents, using two separate indices\nallows for fields to be stored in a denser, more efficient way.\n- Percolate queries do not scale in the same way as other queries, so percolation performance may benefit from using\na different index configuration, like the number of primary shards.\n\n[[percolate-query-notes]]\n==== Notes\n\n===== Allow expensive queries\nPercolate queries will not be executed if <<query-dsl-allow-expensive-queries, `search.allow_expensive_queries`>>\nis set to false.\n\n===== Using custom similarities\nPercolate queries will not respect any configured <<index-modules-similarity, custom similarity>>. They always use the default Lucene similarity.\n"
}