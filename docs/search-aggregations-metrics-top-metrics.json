{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.743580",
        "size": 12031,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-top-metrics.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "search-aggregations-metrics-top-metrics",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[search-aggregations-metrics-top-metrics]]\n=== Top metrics aggregation\n++++\n<titleabbrev>Top metrics</titleabbrev>\n++++\n\nThe `top_metrics` aggregation selects metrics from the document with the largest or smallest \"sort\"\nvalue. For example, this gets the value of the `m` field on the document with the largest value of `s`:\n\n[source,console,id=search-aggregations-metrics-top-metrics-simple]\n----\nPOST /test/_bulk?refresh\n{\"index\": {}}\n{\"s\": 1, \"m\": 3.1415}\n{\"index\": {}}\n{\"s\": 2, \"m\": 1.0}\n{\"index\": {}}\n{\"s\": 3, \"m\": 2.71828}\nPOST /test/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"tm\": {\n      \"top_metrics\": {\n        \"metrics\": {\"field\": \"m\"},\n        \"sort\": {\"s\": \"desc\"}\n      }\n    }\n  }\n}\n----\n\nWhich returns:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"tm\": {\n      \"top\": [ {\"sort\": [3], \"metrics\": {\"m\": 2.718280076980591 } } ]\n    }\n  }\n}\n----\n// TESTRESPONSE\n\n`top_metrics` is fairly similar to <<search-aggregations-metrics-top-hits-aggregation, `top_hits`>>\nin spirit but because it is more limited it is able to do its job using less memory and is often\nfaster.\n\n==== `sort`\n\nThe `sort` field in the metric request functions exactly the same as the `sort` field in the\n<<sort-search-results, search>> request except:\n\n* It can't be used on <<binary,binary>>, <<flattened,flattened>>, <<ip,ip>>,\n  <<keyword,keyword>>, or <<text,text>> fields.\n* It only supports a single sort value so which document wins ties is not specified.\n\nThe metrics that the aggregation returns is the first hit that would be returned by the search\nrequest. So,\n\n`\"sort\": {\"s\": \"desc\"}`:: gets metrics from the document with the highest `s`\n`\"sort\": {\"s\": \"asc\"}`:: gets the metrics from the document with the lowest `s`\n`\"sort\": {\"_geo_distance\": {\"location\": \"POINT (-78.6382 35.7796)\"}}`::\n  gets metrics from the documents with `location` *closest* to `35.7796, -78.6382`\n`\"sort\": \"_score\"`:: gets metrics from the document with the highest score\n\n==== `metrics`\n\n`metrics` selects the fields of the \"top\" document to return. You can request\na single metric with something like `\"metrics\": {\"field\": \"m\"}` or multiple\nmetrics by requesting a list of metrics like `\"metrics\": [{\"field\": \"m\"}, {\"field\": \"i\"}`.\n\n`metrics.field` supports the following field types:\n\n* <<boolean,`boolean`>>\n* <<ip,`ip`>>\n* <<keyword,keywords>>\n* <<number,numbers>>\n\nExcept for keywords, <<runtime,runtime fields>> for corresponding types are also\nsupported. `metrics.field` doesn't support fields with <<array,array values>>. A\n`top_metric` aggregation on array values may return inconsistent results.\n\nThe following example runs a `top_metrics` aggregation on several field types.\n\n[source,console,id=search-aggregations-metrics-top-metrics-list-of-metrics]\n----\nPUT /test\n{\n  \"mappings\": {\n    \"properties\": {\n      \"d\": {\"type\": \"date\"}\n    }\n  }\n}\nPOST /test/_bulk?refresh\n{\"index\": {}}\n{\"s\": 1, \"m\": 3.1415, \"i\": 1, \"d\": \"2020-01-01T00:12:12Z\", \"t\": \"cat\"}\n{\"index\": {}}\n{\"s\": 2, \"m\": 1.0, \"i\": 6, \"d\": \"2020-01-02T00:12:12Z\", \"t\": \"dog\"}\n{\"index\": {}}\n{\"s\": 3, \"m\": 2.71828, \"i\": -12, \"d\": \"2019-12-31T00:12:12Z\", \"t\": \"chicken\"}\nPOST /test/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"tm\": {\n      \"top_metrics\": {\n        \"metrics\": [\n          {\"field\": \"m\"},\n          {\"field\": \"i\"},\n          {\"field\": \"d\"},\n          {\"field\": \"t.keyword\"}\n        ],\n        \"sort\": {\"s\": \"desc\"}\n      }\n    }\n  }\n}\n----\n\nWhich returns:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"tm\": {\n      \"top\": [ {\n        \"sort\": [3],\n        \"metrics\": {\n          \"m\": 2.718280076980591,\n          \"i\": -12,\n          \"d\": \"2019-12-31T00:12:12.000Z\",\n          \"t.keyword\": \"chicken\"\n        }\n      } ]\n    }\n  }\n}\n----\n// TESTRESPONSE\n\n\n==== `missing`\n\nThe `missing` parameter defines how documents with a missing value are treated. \nBy default, if any of the key components are missing, the entire document is \nignored. It is possible to treat the missing components as if they had a value \nby using the `missing` parameter.\n\n[source,console]\n----\nPUT /my-index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"nr\":    { \"type\": \"integer\" },  \n      \"state\":  { \"type\": \"keyword\"  } <1>\n    }\n  }\n}\nPOST /my-index/_bulk?refresh\n{\"index\": {}}\n{\"nr\": 1, \"state\": \"started\"}\n{\"index\": {}}\n{\"nr\": 2, \"state\": \"stopped\"}\n{\"index\": {}}\n{\"nr\": 3, \"state\": \"N/A\"}\n{\"index\": {}}\n{\"nr\": 4} <2>\nPOST /my-index/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"my_top_metrics\": {\n      \"top_metrics\": {\n        \"metrics\": {\n          \"field\": \"state\",\n          \"missing\": \"N/A\"}, <3>\n        \"sort\": {\"nr\": \"desc\"}\n      }\n    }\n  }\n}\n----\n\n<1> If you want to use an aggregation on textual content, it must be a `keyword`\ntype field or you must enable fielddata on that field.\n<2> This document has a missing `state` field value.\n<3> The `missing` parameter defines that if `state` field has a missing value, \nit should be treated as if it had the `N/A` value. \n\nThe request results in the following response:\n\n[source,console-result]\n----\n{\n  \"aggregations\": {\n    \"my_top_metrics\": {\n      \"top\": [\n        {\n          \"sort\": [\n            4\n          ],\n          \"metrics\": {\n            \"state\": \"N/A\"\n          }\n        }\n      ]\n    }\n  }\n}\n----\n\n\n==== `size`\n\n`top_metrics` can return the top few document's worth of metrics using the size parameter:\n\n[source,console,id=search-aggregations-metrics-top-metrics-size]\n----\nPOST /test/_bulk?refresh\n{\"index\": {}}\n{\"s\": 1, \"m\": 3.1415}\n{\"index\": {}}\n{\"s\": 2, \"m\": 1.0}\n{\"index\": {}}\n{\"s\": 3, \"m\": 2.71828}\nPOST /test/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"tm\": {\n      \"top_metrics\": {\n        \"metrics\": {\"field\": \"m\"},\n        \"sort\": {\"s\": \"desc\"},\n        \"size\": 3\n      }\n    }\n  }\n}\n----\n\nWhich returns:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"tm\": {\n      \"top\": [\n        {\"sort\": [3], \"metrics\": {\"m\": 2.718280076980591 } },\n        {\"sort\": [2], \"metrics\": {\"m\": 1.0 } },\n        {\"sort\": [1], \"metrics\": {\"m\": 3.1414999961853027 } }\n      ]\n    }\n  }\n}\n----\n// TESTRESPONSE\n\nThe default `size` is 1. The maximum default size is `10` because the aggregation's\nworking storage is \"dense\", meaning we allocate `size` slots for every bucket. `10`\nis a *very* conservative default maximum and you can raise it if you need to by\nchanging the `top_metrics_max_size` index setting. But know that large sizes can\ntake a fair bit of memory, especially if they are inside of an aggregation which\nmakes many buckes like a large\n<<search-aggregations-metrics-top-metrics-example-terms, terms aggregation>>. If\nyou till want to raise it, use something like:\n\n[source,console]\n----\nPUT /test/_settings\n{\n  \"top_metrics_max_size\": 100\n}\n----\n// TEST[continued]\n\nNOTE: If `size` is more than `1` the `top_metrics` aggregation can't be the *target* of a sort.\n\n==== Examples\n\n[[search-aggregations-metrics-top-metrics-example-terms]]\n===== Use with terms\n\nThis aggregation should be quite useful inside of <<search-aggregations-bucket-terms-aggregation, `terms`>>\naggregation, to, say, find the last value reported by each server.\n\n[source,console,id=search-aggregations-metrics-top-metrics-terms]\n----\nPUT /node\n{\n  \"mappings\": {\n    \"properties\": {\n      \"ip\": {\"type\": \"ip\"},\n      \"date\": {\"type\": \"date\"}\n    }\n  }\n}\nPOST /node/_bulk?refresh\n{\"index\": {}}\n{\"ip\": \"192.168.0.1\", \"date\": \"2020-01-01T01:01:01\", \"m\": 1}\n{\"index\": {}}\n{\"ip\": \"192.168.0.1\", \"date\": \"2020-01-01T02:01:01\", \"m\": 2}\n{\"index\": {}}\n{\"ip\": \"192.168.0.2\", \"date\": \"2020-01-01T02:01:01\", \"m\": 3}\nPOST /node/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"ip\": {\n      \"terms\": {\n        \"field\": \"ip\"\n      },\n      \"aggs\": {\n        \"tm\": {\n          \"top_metrics\": {\n            \"metrics\": {\"field\": \"m\"},\n            \"sort\": {\"date\": \"desc\"}\n          }\n        }\n      }\n    }\n  }\n}\n----\n\nWhich returns:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"ip\": {\n      \"buckets\": [\n        {\n          \"key\": \"192.168.0.1\",\n          \"doc_count\": 2,\n          \"tm\": {\n            \"top\": [ {\"sort\": [\"2020-01-01T02:01:01.000Z\"], \"metrics\": {\"m\": 2 } } ]\n          }\n        },\n        {\n          \"key\": \"192.168.0.2\",\n          \"doc_count\": 1,\n          \"tm\": {\n            \"top\": [ {\"sort\": [\"2020-01-01T02:01:01.000Z\"], \"metrics\": {\"m\": 3 } } ]\n          }\n        }\n      ],\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0\n    }\n  }\n}\n----\n// TESTRESPONSE\n\nUnlike `top_hits`, you can sort buckets by the results of this metric:\n\n[source,console]\n----\nPOST /node/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"ip\": {\n      \"terms\": {\n        \"field\": \"ip\",\n        \"order\": {\"tm.m\": \"desc\"}\n      },\n      \"aggs\": {\n        \"tm\": {\n          \"top_metrics\": {\n            \"metrics\": {\"field\": \"m\"},\n            \"sort\": {\"date\": \"desc\"}\n          }\n        }\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nWhich returns:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"ip\": {\n      \"buckets\": [\n        {\n          \"key\": \"192.168.0.2\",\n          \"doc_count\": 1,\n          \"tm\": {\n            \"top\": [ {\"sort\": [\"2020-01-01T02:01:01.000Z\"], \"metrics\": {\"m\": 3 } } ]\n          }\n        },\n        {\n          \"key\": \"192.168.0.1\",\n          \"doc_count\": 2,\n          \"tm\": {\n            \"top\": [ {\"sort\": [\"2020-01-01T02:01:01.000Z\"], \"metrics\": {\"m\": 2 } } ]\n          }\n        }\n      ],\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0\n    }\n  }\n}\n----\n// TESTRESPONSE\n\n===== Mixed sort types\n\nSorting `top_metrics` by a field that has different types across different\nindices producs somewhat surprising results: floating point fields are\nalways sorted independently of whole numbered fields.\n\n[source,console,id=search-aggregations-metrics-top-metrics-mixed-sort]\n----\nPOST /test/_bulk?refresh\n{\"index\": {\"_index\": \"test1\"}}\n{\"s\": 1, \"m\": 3.1415}\n{\"index\": {\"_index\": \"test1\"}}\n{\"s\": 2, \"m\": 1}\n{\"index\": {\"_index\": \"test2\"}}\n{\"s\": 3.1, \"m\": 2.71828}\nPOST /test*/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"tm\": {\n      \"top_metrics\": {\n        \"metrics\": {\"field\": \"m\"},\n        \"sort\": {\"s\": \"asc\"}\n      }\n    }\n  }\n}\n----\n\nWhich returns:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"tm\": {\n      \"top\": [ {\"sort\": [3.0999999046325684], \"metrics\": {\"m\": 2.718280076980591 } } ]\n    }\n  }\n}\n----\n// TESTRESPONSE\n\nWhile this is better than an error it *probably* isn't what you were going for.\nWhile it does lose some precision, you can explicitly cast the whole number\nfields to floating points with something like:\n\n[source,console]\n----\nPOST /test*/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"tm\": {\n      \"top_metrics\": {\n        \"metrics\": {\"field\": \"m\"},\n        \"sort\": {\"s\": {\"order\": \"asc\", \"numeric_type\": \"double\"}}\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nWhich returns the much more expected:\n\n[source,js]\n----\n{\n  \"aggregations\": {\n    \"tm\": {\n      \"top\": [ {\"sort\": [1.0], \"metrics\": {\"m\": 3.1414999961853027 } } ]\n    }\n  }\n}\n----\n// TESTRESPONSE\n\n===== Use in pipeline aggregations\n\n`top_metrics` can be used in pipeline aggregations that consume a single value per bucket, such as `bucket_selector`\nthat applies per bucket filtering, similar to using a HAVING clause in SQL. This requires setting `size` to 1, and\nspecifying the right path for the (single) metric to be passed to the wrapping aggregator. For example:\n\n[source,console]\n----\nPOST /test*/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"ip\": {\n      \"terms\": {\n        \"field\": \"ip\"\n      },\n      \"aggs\": {\n        \"tm\": {\n          \"top_metrics\": {\n            \"metrics\": {\"field\": \"m\"},\n            \"sort\": {\"s\": \"desc\"},\n            \"size\": 1\n          }\n        },\n        \"having_tm\": {\n          \"bucket_selector\": {\n            \"buckets_path\": {\n              \"top_m\": \"tm[m]\"\n            },\n            \"script\": \"params.top_m < 1000\"\n          }\n        }\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nThe `bucket_path` uses the `top_metrics` name `tm` and a keyword for the metric providing the aggregate value,\nnamely `m`.\n"
}