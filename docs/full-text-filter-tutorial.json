{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.574579",
        "size": 21906,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/full-text-filter-tutorial.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "full-text-filter-tutorial",
        "version": "8.15"
    },
    "doc": "[[full-text-filter-tutorial]]\n== Basic full-text search and filtering in {es}\n++++\n<titleabbrev>Basics: Full-text search and filtering</titleabbrev>\n++++\n\nThis is a hands-on introduction to the basics of full-text search with {es}, also known as _lexical search_, using the <<search-search,`_search` API>> and <<query-dsl,Query DSL>>.\nYou'll also learn how to filter data, to narrow down search results based on exact criteria.\n\nIn this scenario, we're implementing a search function for a cooking blog.\nThe blog contains recipes with various attributes including textual content, categorical data, and numerical ratings.\n\nThe goal is to create search queries that enable users to:\n\n* Find recipes based on ingredients they want to use or avoid\n* Discover dishes suitable for their dietary needs\n* Find highly-rated recipes in specific categories\n* Find recent recipes from their favorite authors\n\nTo achieve these goals we'll use different Elasticsearch queries to perform full-text search, apply filters, and combine multiple search criteria.\n\n[discrete]\n[[full-text-filter-tutorial-requirements]]\n=== Requirements\n\nYou'll need a running {es} cluster, together with {kib} to use the Dev Tools API Console.\nRun the following command in your terminal to set up a <<run-elasticsearch-locally,single-node local cluster in Docker>>:\n\n[source,sh]\n----\ncurl -fsSL https://elastic.co/start-local | sh\n----\n// NOTCONSOLE\n\n[discrete]\n[[full-text-filter-tutorial-create-index]]\n=== Step 1: Create an index\n\nCreate the `cooking_blog` index to get started:\n\n[source,console]\n----\nPUT /cooking_blog\n----\n// TESTSETUP\n\nNow define the mappings for the index:\n\n[source,console]\n----\nPUT /cooking_blog/_mapping\n{\n  \"properties\": {\n    \"title\": {\n      \"type\": \"text\",\n      \"analyzer\": \"standard\", <1>\n      \"fields\": { <2>\n        \"keyword\": {\n          \"type\": \"keyword\",\n          \"ignore_above\": 256 <3>\n        }\n      }\n    },\n    \"description\": {\n      \"type\": \"text\",\n      \"fields\": {\n        \"keyword\": {\n          \"type\": \"keyword\"\n        }\n      }\n    },\n    \"author\": {\n      \"type\": \"text\",\n      \"fields\": {\n        \"keyword\": {\n          \"type\": \"keyword\"\n        }\n      }\n    },\n    \"date\": {\n      \"type\": \"date\",\n      \"format\": \"yyyy-MM-dd\"\n    },\n    \"category\": {\n      \"type\": \"text\",\n      \"fields\": {\n        \"keyword\": {\n          \"type\": \"keyword\"\n        }\n      }\n    },\n    \"tags\": {\n      \"type\": \"text\",\n      \"fields\": {\n        \"keyword\": {\n          \"type\": \"keyword\"\n        }\n      }\n    },\n    \"rating\": {\n      \"type\": \"float\"\n    }\n  }\n}\n----\n// TEST\n<1> The `standard` analyzer is used by default for `text` fields if an `analyzer` isn't specified. It's included here for demonstration purposes.\n<2> <<multi-fields,Multi-fields>> are used here to index `text` fields as both `text` and `keyword` <<mapping-types,data types>>. This enables both full-text search and exact matching/filtering on the same field.\nNote that if you used <<dynamic-field-mapping,dynamic mapping>>, these multi-fields would be created automatically.\n<3> The <<ignore-above,`ignore_above` parameter>> prevents indexing values longer than 256 characters in the `keyword` field. Again this is the default value, but it's included here for for demonstration purposes.\nIt helps to save disk space and avoid potential issues with Lucene's term byte-length limit.\n\n[TIP]\n====\nFull-text search is powered by <<analysis,text analysis>>. \nText analysis normalizes and standardizes text data so it can be efficiently stored in an inverted index and searched in near real-time.\nAnalysis happens at both <<analysis-index-search-time,index and search time>>.\nThis tutorial won't cover analysis in detail, but it's important to understand how text is processed to create effective search queries.\n====\n\n[discrete]\n[[full-text-filter-tutorial-index-data]]\n=== Step 2: Add sample blog posts to your index\n\nNow you'll need to index some example blog posts using the <<bulk, Bulk API>>.\nNote that `text` fields are analyzed and multi-fields are generated at index time.\n\n[source,console]\n----\nPOST /cooking_blog/_bulk?refresh=wait_for\n{\"index\":{\"_id\":\"1\"}}\n{\"title\":\"Perfect Pancakes: A Fluffy Breakfast Delight\",\"description\":\"Learn the secrets to making the fluffiest pancakes, so amazing you won't believe your tastebuds. This recipe uses buttermilk and a special folding technique to create light, airy pancakes that are perfect for lazy Sunday mornings.\",\"author\":\"Maria Rodriguez\",\"date\":\"2023-05-01\",\"category\":\"Breakfast\",\"tags\":[\"pancakes\",\"breakfast\",\"easy recipes\"],\"rating\":4.8}\n{\"index\":{\"_id\":\"2\"}}\n{\"title\":\"Spicy Thai Green Curry: A Vegetarian Adventure\",\"description\":\"Dive into the flavors of Thailand with this vibrant green curry. Packed with vegetables and aromatic herbs, this dish is both healthy and satisfying. Don't worry about the heat - you can easily adjust the spice level to your liking.\",\"author\":\"Liam Chen\",\"date\":\"2023-05-05\",\"category\":\"Main Course\",\"tags\":[\"thai\",\"vegetarian\",\"curry\",\"spicy\"],\"rating\":4.6}\n{\"index\":{\"_id\":\"3\"}}\n{\"title\":\"Classic Beef Stroganoff: A Creamy Comfort Food\",\"description\":\"Indulge in this rich and creamy beef stroganoff. Tender strips of beef in a savory mushroom sauce, served over a bed of egg noodles. It's the ultimate comfort food for chilly evenings.\",\"author\":\"Emma Watson\",\"date\":\"2023-05-10\",\"category\":\"Main Course\",\"tags\":[\"beef\",\"pasta\",\"comfort food\"],\"rating\":4.7}\n{\"index\":{\"_id\":\"4\"}}\n{\"title\":\"Vegan Chocolate Avocado Mousse\",\"description\":\"Discover the magic of avocado in this rich, vegan chocolate mousse. Creamy, indulgent, and secretly healthy, it's the perfect guilt-free dessert for chocolate lovers.\",\"author\":\"Alex Green\",\"date\":\"2023-05-15\",\"category\":\"Dessert\",\"tags\":[\"vegan\",\"chocolate\",\"avocado\",\"healthy dessert\"],\"rating\":4.5}\n{\"index\":{\"_id\":\"5\"}}\n{\"title\":\"Crispy Oven-Fried Chicken\",\"description\":\"Get that perfect crunch without the deep fryer! This oven-fried chicken recipe delivers crispy, juicy results every time. A healthier take on the classic comfort food.\",\"author\":\"Maria Rodriguez\",\"date\":\"2023-05-20\",\"category\":\"Main Course\",\"tags\":[\"chicken\",\"oven-fried\",\"healthy\"],\"rating\":4.9}\n----\n// TEST[continued]\n\n[discrete]\n[[full-text-filter-tutorial-match-query]]\n=== Step 3: Perform basic full-text searches\n\nFull-text search involves executing text-based queries across one or more document fields.\nThese queries calculate a relevance score for each matching document, based on how closely the document's content aligns with the search terms.\n{es} offers various query types, each with its own method for matching text and <<relevance-scores,relevance scoring>>.\n\n[discrete]\n==== `match` query\n\nThe <<query-dsl-match-query, `match`>> query is the standard query for full-text, or \"lexical\", search.\nThe query text will be analyzed according to the analyzer configuration specified on each field (or at query time).\n\nFirst, search the `description` field for \"fluffy pancakes\":\n\n[source,console]\n----\nGET /cooking_blog/_search\n{\n  \"query\": {\n    \"match\": {\n      \"description\": {\n        \"query\": \"fluffy pancakes\" <1>\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n<1> By default, the `match` query uses `OR` logic between the resulting tokens. This means it will match documents that contain either \"fluffy\" or \"pancakes\", or both, in the description field.\n\nAt search time, {es} defaults to the analyzer defined in the field mapping. In this example, we're using the `standard` analyzer. Using a different analyzer at search time is an <<different-analyzers,advanced use case>>.\n\n.Example response\n[%collapsible]\n==============\n[source,console-result]\n----\n{\n  \"took\": 0,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": { <1>\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.8378843, <2>\n    \"hits\": [\n      {\n        \"_index\": \"cooking_blog\",\n        \"_id\": \"1\",\n        \"_score\": 1.8378843, <3>\n        \"_source\": {\n          \"title\": \"Perfect Pancakes: A Fluffy Breakfast Delight\", <4>\n          \"description\": \"Learn the secrets to making the fluffiest pancakes, so amazing you won't believe your tastebuds. This recipe uses buttermilk and a special folding technique to create light, airy pancakes that are perfect for lazy Sunday mornings.\", <5>\n          \"author\": \"Maria Rodriguez\",\n          \"date\": \"2023-05-01\",\n          \"category\": \"Breakfast\",\n          \"tags\": [\n            \"pancakes\",\n            \"breakfast\",\n            \"easy recipes\"\n          ],\n          \"rating\": 4.8\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 0/\"took\": \"$body.took\"/]\n// TESTRESPONSE[s/\"total\": 1/\"total\": $body._shards.total/]\n// TESTRESPONSE[s/\"successful\": 1/\"successful\": $body._shards.successful/]\n// TESTRESPONSE[s/\"value\": 1/\"value\": $body.hits.total.value/]\n// TESTRESPONSE[s/\"max_score\": 1.8378843/\"max_score\": $body.hits.max_score/]\n// TESTRESPONSE[s/\"_score\": 1.8378843/\"_score\": $body.hits.hits.0._score/]\n<1> The `hits` object contains the total number of matching documents and their relation to the total. Refer to <<track-total-hits,Track total hits>> for more details about the `hits` object.\n<2> `max_score` is the highest relevance score among all matching documents. In this example, we only have one matching document.\n<3> `_score` is the relevance score for a specific document, indicating how well it matches the query. Higher scores indicate better matches. In this example the `max_score` is the same as the `_score`, as there is only one matching document.\n<4> The title contains both \"Fluffy\" and \"Pancakes\", matching our search terms exactly.\n<5> The description includes \"fluffiest\" and \"pancakes\", further contributing to the document's relevance due to the analysis process.\n==============\n\n[discrete]\n==== Require all terms in a match query\n\nSpecify the `and` operator to require both terms in the `description` field.\nThis stricter search returns _zero hits_ on our sample data, as no document contains both \"fluffy\" and \"pancakes\" in the description.\n\n[source,console]\n----\nGET /cooking_blog/_search\n{\n  \"query\": {\n    \"match\": {\n      \"description\": {\n        \"query\": \"fluffy pancakes\",\n        \"operator\": \"and\"\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\n.Example response\n[%collapsible]\n==============\n[source,console-result]\n----\n{\n  \"took\": 0,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 0,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": null,\n    \"hits\": []\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 0/\"took\": \"$body.took\"/]\n==============\n\n[discrete]\n==== Specify a minimum number of terms to match\n\nUse the <<query-dsl-minimum-should-match,`minimum_should_match`>> parameter to specify the minimum number of terms a document should have to be included in the search results.\n\nSearch the title field to match at least 2 of the 3 terms: \"fluffy\", \"pancakes\", or \"breakfast\".\nThis is useful for improving relevance while allowing some flexibility.\n\n[source,console]\n----\nGET /cooking_blog/_search\n{\n  \"query\": {\n    \"match\": {\n      \"title\": {\n        \"query\": \"fluffy pancakes breakfast\",\n        \"minimum_should_match\": 2\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\n[discrete]\n[[full-text-filter-tutorial-multi-match]]\n=== Step 4: Search across multiple fields at once\n\nWhen users enter a search query, they often don't know (or care) whether their search terms appear in a specific field.\nA <<query-dsl-multi-match-query,`multi_match`>> query allows searching across multiple fields simultaneously.\n\nLet's start with a basic `multi_match` query:\n\n[source,console]\n----\nGET /cooking_blog/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"vegetarian curry\",\n      \"fields\": [\"title\", \"description\", \"tags\"]\n    }\n  }\n}\n----\n// TEST[continued]\n\nThis query searches for \"vegetarian curry\" across the title, description, and tags fields. Each field is treated with equal importance.\n\nHowever, in many cases, matches in certain fields (like the title) might be more relevant than others. We can adjust the importance of each field using field boosting:\n\n[source,console]\n----\nGET /cooking_blog/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"vegetarian curry\",\n      \"fields\": [\"title^3\", \"description^2\", \"tags\"] <1>\n    }\n  }\n}\n----\n// TEST[continued]\n<1> The `^` syntax applies a boost to specific fields:\n+\n* `title^3`: The title field is 3 times more important than an unboosted field\n* `description^2`: The description is 2 times more important\n* `tags`: No boost applied (equivalent to `^1`)\n+\nThese boosts help tune relevance, prioritizing matches in the title over the description, and matches in the description over tags.\n\nLearn more about fields and per-field boosting in the <<query-dsl-multi-match-query,`multi_match` query>> reference.\n\n.Example response\n[%collapsible]\n==============\n[source,console-result]\n----\n{\n  \"took\": 0,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 7.546015,\n    \"hits\": [\n      {\n        \"_index\": \"cooking_blog\",\n        \"_id\": \"2\",\n        \"_score\": 7.546015,\n        \"_source\": {\n          \"title\": \"Spicy Thai Green Curry: A Vegetarian Adventure\", <1>\n          \"description\": \"Dive into the flavors of Thailand with this vibrant green curry. Packed with vegetables and aromatic herbs, this dish is both healthy and satisfying. Don't worry about the heat - you can easily adjust the spice level to your liking.\", <2>\n          \"author\": \"Liam Chen\",\n          \"date\": \"2023-05-05\",\n          \"category\": \"Main Course\",\n          \"tags\": [ \n            \"thai\",\n            \"vegetarian\",\n            \"curry\",\n            \"spicy\"\n          ], <3>\n          \"rating\": 4.6\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 0/\"took\": \"$body.took\"/]\n// TESTRESPONSE[s/\"_score\": 7.546015/\"_score\": $body.hits.hits.0._score/]\n// TESTRESPONSE[s/\"max_score\": 7.546015/\"max_score\": $body.hits.max_score/]\n<1> The title contains \"Vegetarian\" and \"Curry\", which matches our search terms. The title field has the highest boost (^3), contributing significantly to this document's relevance score.\n<2> The description contains \"curry\" and related terms like \"vegetables\", further increasing the document's relevance.\n<3> The tags include both \"vegetarian\" and \"curry\", providing an exact match for our search terms, albeit with no boost.\n\nThis result demonstrates how the `multi_match` query with field boosts helps users find relevant recipes across multiple fields.\nEven though the exact phrase \"vegetarian curry\" doesn't appear in any single field, the combination of matches across fields produces a highly relevant result.\n==============\n\n[TIP]\n====\nThe `multi_match` query is often recommended over a single `match` query for most text search use cases, as it provides more flexibility and better matches user expectations.\n====\n\n[discrete]\n[[full-text-filter-tutorial-filtering]]\n=== Step 5: Filter and find exact matches\n\n<<filter-context,Filtering>> allows you to narrow down your search results based on exact criteria.\nUnlike full-text searches, filters are binary (yes/no) and do not affect the relevance score.\nFilters execute faster than queries because excluded results don't need to be scored.\n\nThis <<query-dsl-bool-query,`bool`>> query will return only blog posts in the \"Breakfast\" category.\n\n[source,console]\n----\nGET /cooking_blog/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        { \"term\": { \"category.keyword\": \"Breakfast\" } }  <1>\n      ]\n    }\n  }\n}\n----\n// TEST[continued]\n<1> Note the use of `category.keyword` here. This refers to the <<keyword, `keyword`>> multi-field of the `category` field, ensuring an exact, case-sensitive match.\n\n[TIP]\n====\nThe `.keyword` suffix accesses the unanalyzed version of a field, enabling exact, case-sensitive matching. This works in two scenarios:\n\n1. *When using dynamic mapping for text fields*. Elasticsearch automatically creates a `.keyword` sub-field.\n2. *When text fields are explicitly mapped with a `.keyword` sub-field*. For example, we explicitly mapped the `category` field in <<full-text-filter-tutorial-create-index,Step 1>> of this tutorial.\n====\n\n[discrete]\n[[full-text-filter-tutorial-range-query]]\n==== Search for posts within a date range\n\nOften users want to find content published within a specific time frame.\nA <<query-dsl-range-query,`range`>> query finds documents that fall within numeric or date ranges.\n\n[source,console]\n----\nGET /cooking_blog/_search\n{\n  \"query\": {\n    \"range\": {\n      \"date\": {\n        \"gte\": \"2023-05-01\", <1>\n        \"lte\": \"2023-05-31\" <2>\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n<1> Greater than or equal to May 1, 2023.\n<2> Less than or equal to May 31, 2023.\n\n[discrete]\n[[full-text-filter-tutorial-term-query]]\n==== Find exact matches\n\nSometimes users want to search for exact terms to eliminate ambiguity in their search results.\nA <<query-dsl-term-query,`term`>> query searches for an exact term in a field without analyzing it.\nExact, case-sensitive matches on specific terms are often referred to as \"keyword\" searches.\n\nHere you'll search for the author \"Maria Rodriguez\" in the `author.keyword` field.\n\n[source,console]\n----\nGET /cooking_blog/_search\n{\n  \"query\": {\n    \"term\": {\n      \"author.keyword\": \"Maria Rodriguez\" <1>\n    }\n  }\n}\n----\n// TEST[continued]\n<1> The `term` query has zero flexibility. For example, here the queries `maria` or `maria rodriguez` would have zero hits, due to case sensitivity.\n\n[TIP]\n====\nAvoid using the `term` query for <<text,`text` fields>> because they are transformed by the analysis process.\n====\n\n[discrete]\n[[full-text-filter-tutorial-complex-bool]]\n=== Step 6: Combine multiple search criteria\n\nA <<query-dsl-bool-query,`bool`>> query allows you to combine multiple query clauses to create sophisticated searches.\nIn this tutorial scenario it's useful for when users have complex requirements for finding recipes.\n\nLet's create a query that addresses the following user needs:\n\n* Must be a vegetarian main course\n* Should contain \"curry\" or \"spicy\" in the title or description\n* Must not be a dessert\n* Must have a rating of at least 4.5\n* Should prefer recipes published in the last month\n\n[source,console]\n----\nGET /cooking_blog/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"term\": {\n            \"category.keyword\": \"Main Course\"\n          }\n        },\n        {\n          \"term\": {\n            \"tags\": \"vegetarian\"\n          }\n        },\n        {\n          \"range\": {\n            \"rating\": {\n              \"gte\": 4.5\n            }\n          }\n        }\n      ],\n      \"should\": [\n        {\n          \"multi_match\": {\n            \"query\": \"curry spicy\",\n            \"fields\": [\"title^2\", \"description\"]\n          }\n        },\n        {\n          \"range\": {\n            \"date\": {\n              \"gte\": \"now-1M/d\"\n            }\n          }\n        }\n      ],\n      \"must_not\": [ <1>\n        {\n          \"term\": {\n            \"category.keyword\": \"Dessert\"\n          }\n        }\n      ]\n    }\n  }\n}\n----\n// TEST[continued]\n<1> The `must_not` clause excludes documents that match the specified criteria. This is a powerful tool for filtering out unwanted results.\n\n.Example response\n[%collapsible]\n==============\n[source,console-result]\n----\n{\n  \"took\": 1,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 7.9835095,\n    \"hits\": [\n      {\n        \"_index\": \"cooking_blog\",\n        \"_id\": \"2\",\n        \"_score\": 7.9835095,\n        \"_source\": {\n          \"title\": \"Spicy Thai Green Curry: A Vegetarian Adventure\", <1>\n          \"description\": \"Dive into the flavors of Thailand with this vibrant green curry. Packed with vegetables and aromatic herbs, this dish is both healthy and satisfying. Don't worry about the heat - you can easily adjust the spice level to your liking.\", <2>\n          \"author\": \"Liam Chen\",\n          \"date\": \"2023-05-05\",\n          \"category\": \"Main Course\", <3>\n          \"tags\": [ <4>\n            \"thai\",\n            \"vegetarian\", <5>\n            \"curry\",\n            \"spicy\"\n          ],\n          \"rating\": 4.6 <6>\n        }\n      }\n    ]\n  }\n}\n----\n// TESTRESPONSE[s/\"took\": 1/\"took\": \"$body.took\"/]\n<1> The title contains \"Spicy\" and \"Curry\", matching our should condition. With the default <<type-best-fields,best_fields>> behavior, this field contributes most to the relevance score.\n<2> While the description also contains matching terms, only the best matching field's score is used by default.\n<3> The recipe was published within the last month, satisfying our recency preference.\n<4> The \"Main Course\" category matches our `must` condition.\n<5> The \"vegetarian\" tag satisfies another `must` condition, while \"curry\" and \"spicy\" tags align with our `should` preferences.\n<6> The rating of 4.6 meets our minimum rating requirement of 4.5.\n==============\n\n[discrete]\n[[full-text-filter-tutorial-learn-more]]\n=== Learn more\n\nThis tutorial introduced the basics of full-text search and filtering in {es}.\nBuilding a real-world search experience requires understanding many more advanced concepts and techniques.\nHere are some resources once you're ready to dive deeper:\n\n* <<search-analyze, Elasticsearch basics \u2014 Search and analyze data>>: Understand all your options for searching and analyzing data in {es}.\n* <<analysis,Text analysis>>: Understand how text is processed for full-text search.\n* <<search-with-elasticsearch>>: Learn about more advanced search techniques using the `_search` API, including semantic search.\n\n\n"
}