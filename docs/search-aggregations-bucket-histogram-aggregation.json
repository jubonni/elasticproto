{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.706579",
        "size": 13907,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-histogram-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-bucket-histogram-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-histogram-aggregation]]\n=== Histogram aggregation\n++++\n<titleabbrev>Histogram</titleabbrev>\n++++\n\nA multi-bucket values source based aggregation that can be applied on numeric values or numeric range values extracted\nfrom the documents. It dynamically builds fixed size (a.k.a. interval) buckets over the values. For example, if the\ndocuments have a field that holds a price (numeric), we can configure this aggregation to dynamically build buckets with\ninterval `5` (in case of price it may represent $5). When the aggregation executes, the price field of every document\nwill be evaluated and will be rounded down to its closest bucket - for example, if the price is `32` and the bucket size\nis `5` then the rounding will yield `30` and thus the document will \"fall\" into the bucket that is associated with the\nkey `30`.\nTo make this more formal, here is the rounding function that is used:\n\n[source,java]\n--------------------------------------------------\nbucket_key = Math.floor((value - offset) / interval) * interval + offset\n--------------------------------------------------\n\nFor range values, a document can fall into multiple buckets. The first bucket is computed from the lower\nbound of the range in the same way as a bucket for a single value is computed. The final bucket is computed in the same\nway from the upper bound of the range, and the range is counted in all buckets in between and including those two.\n\nThe `interval` must be a positive decimal, while the `offset` must be a decimal in `[0, interval)`\n(a decimal greater than or equal to `0` and less than `interval`)\n\nThe following snippet \"buckets\" the products based on their `price` by interval of `50`:\n\n[source,console,id=histogram-aggregation-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"prices\": {\n      \"histogram\": {\n        \"field\": \"price\",\n        \"interval\": 50\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nAnd the following may be the response:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"prices\": {\n      \"buckets\": [\n        {\n          \"key\": 0.0,\n          \"doc_count\": 1\n        },\n        {\n          \"key\": 50.0,\n          \"doc_count\": 1\n        },\n        {\n          \"key\": 100.0,\n          \"doc_count\": 0\n        },\n        {\n          \"key\": 150.0,\n          \"doc_count\": 2\n        },\n        {\n          \"key\": 200.0,\n          \"doc_count\": 3\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\n==== Minimum document count\n\nThe response above show that no documents has a price that falls within the range of `[100, 150)`. By default the\nresponse will fill gaps in the histogram with empty buckets. It is possible to change that and request buckets with\na higher minimum count thanks to the `min_doc_count` setting:\n\n[source,console,id=histogram-aggregation-min-doc-count-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"prices\": {\n      \"histogram\": {\n        \"field\": \"price\",\n        \"interval\": 50,\n        \"min_doc_count\": 1\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"prices\": {\n      \"buckets\": [\n        {\n          \"key\": 0.0,\n          \"doc_count\": 1\n        },\n        {\n          \"key\": 50.0,\n          \"doc_count\": 1\n        },\n        {\n          \"key\": 150.0,\n          \"doc_count\": 2\n        },\n        {\n          \"key\": 200.0,\n          \"doc_count\": 3\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\n[[search-aggregations-bucket-histogram-aggregation-extended-bounds]]\nBy default the `histogram` returns all the buckets within the range of the data itself, that is, the documents with\nthe smallest values (on which with histogram) will determine the min bucket (the bucket with the smallest key) and the\ndocuments with the highest values will determine the max bucket (the bucket with the highest key). Often, when\nrequesting empty buckets, this causes a confusion, specifically, when the data is also filtered.\n\nTo understand why, let's look at an example:\n\nLets say the you're filtering your request to get all docs with values between `0` and `500`, in addition you'd like\nto slice the data per price using a histogram with an interval of `50`. You also specify `\"min_doc_count\" : 0` as you'd\nlike to get all buckets even the empty ones. If it happens that all products (documents) have prices higher than `100`,\nthe first bucket you'll get will be the one with `100` as its key. This is confusing, as many times, you'd also like\nto get those buckets between `0 - 100`.\n\nWith `extended_bounds` setting, you now can \"force\" the histogram aggregation to start building buckets on a specific\n`min` value and also keep on building buckets up to a `max` value (even if there are no documents anymore). Using\n`extended_bounds` only makes sense when `min_doc_count` is 0 (the empty buckets will never be returned if `min_doc_count`\nis greater than 0).\n\nNote that (as the name suggest) `extended_bounds` is **not** filtering buckets. Meaning, if the `extended_bounds.min` is higher\nthan the values extracted from the documents, the documents will still dictate what the first bucket will be (and the\nsame goes for the `extended_bounds.max` and the last bucket). For filtering buckets, one should nest the histogram aggregation\nunder a range `filter` aggregation with the appropriate `from`/`to` settings.\n\nExample:\n\n[source,console,id=histogram-aggregation-extended-bounds-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"query\": {\n    \"constant_score\": { \"filter\": { \"range\": { \"price\": { \"lte\": \"500\" } } } }\n  },\n  \"aggs\": {\n    \"prices\": {\n      \"histogram\": {\n        \"field\": \"price\",\n        \"interval\": 50,\n        \"extended_bounds\": {\n          \"min\": 0,\n          \"max\": 500\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nWhen aggregating ranges, buckets are based on the values of the returned documents. This means the response may include\nbuckets outside of a query's range. For example, if your query looks for values greater than 100, and you have a range\ncovering 50 to 150, and an interval of 50, that document will land in 3 buckets - 50, 100, and 150. In general, it's\nbest to think of the query and aggregation steps as independent - the query selects a set of documents, and then the\naggregation buckets those documents without regard to how they were selected.\nSee <<search-aggregations-bucket-range-field-note,note on bucketing range\nfields>> for more information and an example.\n\n[[search-aggregations-bucket-histogram-aggregation-hard-bounds]]\nThe `hard_bounds` is a counterpart of `extended_bounds` and can limit the range of buckets in the histogram. It is\nparticularly useful in the case of open <<range, data ranges>> that can result in a very large number of buckets.\n\nExample:\n\n[source,console,id=histogram-aggregation-hard-bounds-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"query\": {\n    \"constant_score\": { \"filter\": { \"range\": { \"price\": { \"lte\": \"500\" } } } }\n  },\n  \"aggs\": {\n    \"prices\": {\n      \"histogram\": {\n        \"field\": \"price\",\n        \"interval\": 50,\n        \"hard_bounds\": {\n          \"min\": 100,\n          \"max\": 200\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nIn this example even though the range specified in the query is up to 500, the histogram will only have 2 buckets starting at 100 and 150.\nAll other buckets will be omitted even if documents that should go to this buckets are present in the results.\n\n==== Order\n\nBy default the returned buckets are sorted by their `key` ascending, though the order behaviour can be controlled using\nthe `order` setting. Supports the same `order` functionality as the <<search-aggregations-bucket-terms-aggregation-order,`Terms Aggregation`>>.\n\n==== Offset\n\nBy default the bucket keys start with 0 and then continue in even spaced steps\nof `interval`, e.g. if the interval is `10`, the first three buckets (assuming\nthere is data inside them) will be `[0, 10)`, `[10, 20)`, `[20, 30)`. The bucket\nboundaries can be shifted by using the `offset` option.\n\nThis can be best illustrated with an example. If there are 10 documents with values ranging from 5 to 14, using interval `10` will result in\ntwo buckets with 5 documents each. If an additional offset `5` is used, there will be only one single bucket `[5, 15)` containing all the 10\ndocuments.\n\n==== Response Format\n\nBy default, the buckets are returned as an ordered array. It is also possible to request the response as a hash\ninstead keyed by the buckets keys:\n\n[source,console,id=histogram-aggregation-keyed-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"prices\": {\n      \"histogram\": {\n        \"field\": \"price\",\n        \"interval\": 50,\n        \"keyed\": true\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"prices\": {\n      \"buckets\": {\n        \"0.0\": {\n          \"key\": 0.0,\n          \"doc_count\": 1\n        },\n        \"50.0\": {\n          \"key\": 50.0,\n          \"doc_count\": 1\n        },\n        \"100.0\": {\n          \"key\": 100.0,\n          \"doc_count\": 0\n        },\n        \"150.0\": {\n          \"key\": 150.0,\n          \"doc_count\": 2\n        },\n        \"200.0\": {\n          \"key\": 200.0,\n          \"doc_count\": 3\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\n==== Missing value\n\nThe `missing` parameter defines how documents that are missing a value should be treated.\nBy default they will be ignored but it is also possible to treat them as if they\nhad a value.\n\n[source,console,id=histogram-aggregation-missing-value-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"quantity\": {\n      \"histogram\": {\n        \"field\": \"quantity\",\n        \"interval\": 10,\n        \"missing\": 0 <1>\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n<1> Documents without a value in the `quantity` field will fall into the same bucket as documents that have the value `0`.\n\n[[search-aggregations-bucket-histogram-aggregation-histogram-fields]]\n==== Histogram fields\n\nRunning a histogram aggregation over histogram fields computes the total number of counts for each interval.\n\nFor example, executing a histogram aggregation against the following index that stores pre-aggregated histograms\nwith latency metrics (in milliseconds) for different networks:\n\n[source,console]\n--------------------------------------------------\nPUT metrics_index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"network\": {\n        \"properties\": {\n          \"name\": {\n            \"type\": \"keyword\"\n          }\n        }\n      },\n      \"latency_histo\": {\n         \"type\": \"histogram\"\n      }\n    }\n  }\n}\n\nPUT metrics_index/_doc/1?refresh\n{\n  \"network.name\" : \"net-1\",\n  \"latency_histo\" : {\n      \"values\" : [1, 3, 8, 12, 15],\n      \"counts\" : [3, 7, 23, 12, 6]\n   }\n}\n\nPUT metrics_index/_doc/2?refresh\n{\n  \"network.name\" : \"net-2\",\n  \"latency_histo\" : {\n      \"values\" : [1, 6, 8, 12, 14],\n      \"counts\" : [8, 17, 8, 7, 6]\n   }\n}\n\nPOST /metrics_index/_search?size=0\n{\n  \"aggs\": {\n    \"latency_buckets\": {\n      \"histogram\": {\n        \"field\": \"latency_histo\",\n        \"interval\": 5\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n\nThe `histogram` aggregation will sum the counts of each interval computed based on the `values` and\nreturn the following output:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"latency_buckets\": {\n      \"buckets\": [\n        {\n          \"key\": 0.0,\n          \"doc_count\": 18\n        },\n        {\n          \"key\": 5.0,\n          \"doc_count\": 48\n        },\n        {\n          \"key\": 10.0,\n          \"doc_count\": 25\n        },\n        {\n          \"key\": 15.0,\n          \"doc_count\": 6\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\n[IMPORTANT]\n========\nHistogram aggregation is a bucket aggregation, which partitions documents into buckets rather than calculating metrics over fields like\nmetrics aggregations do. Each bucket represents a collection of documents which sub-aggregations can run on.\nOn the other hand, a histogram field is a pre-aggregated field representing multiple values inside a single field:\nbuckets of numerical data and a count of items/documents for each bucket. This mismatch between the histogram aggregations expected input\n(expecting raw documents) and the histogram field (that provides summary information) limits the outcome of the aggregation\nto only the doc counts for each bucket.\n\n\n**Consequently, when executing a histogram aggregation over a histogram field, no sub-aggregations are allowed.**\n========\n\nAlso, when running histogram aggregation over histogram field the `missing` parameter is not supported.\n"
}