{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.730276",
        "size": 12063,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-multi-terms-aggregation.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "search-aggregations-bucket-multi-terms-aggregation",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[search-aggregations-bucket-multi-terms-aggregation]]\n=== Multi Terms aggregation\n++++\n<titleabbrev>Multi Terms</titleabbrev>\n++++\n\nA multi-bucket value source based aggregation where buckets are dynamically built - one per unique set of values. The multi terms\naggregation is very similar to the <<search-aggregations-bucket-terms-aggregation-order,`terms aggregation`>>, however in most cases\nit will be slower than the terms aggregation and will consume more memory. Therefore, if the same set of fields is constantly used,\nit would be more efficient to index a combined key for this fields as a separate field and use the terms aggregation on this field.\n\nThe multi_term aggregations are the most useful when you need to sort by a number of document or a metric aggregation on a composite\nkey and get top N results. If sorting is not required and all values are expected to be retrieved using nested terms aggregation or\n<<search-aggregations-bucket-composite-aggregation, `composite aggregations`>> will be a faster and more memory efficient solution.\n\n//////////////////////////\n\n[source,js]\n--------------------------------------------------\nPUT /products\n{\n  \"mappings\": {\n    \"properties\": {\n      \"genre\": {\n        \"type\": \"keyword\"\n      },\n      \"product\": {\n        \"type\": \"keyword\"\n      },\n      \"quantity\": {\n        \"type\": \"integer\"\n      }\n    }\n  }\n}\n\nPOST /products/_bulk?refresh\n{\"index\":{\"_id\":0}}\n{\"genre\": \"rock\", \"product\": \"Product A\", \"quantity\": 4}\n{\"index\":{\"_id\":1}}\n{\"genre\": \"rock\", \"product\": \"Product A\", \"quantity\": 5}\n{\"index\":{\"_id\":2}}\n{\"genre\": \"rock\", \"product\": \"Product B\", \"quantity\": 1}\n{\"index\":{\"_id\":3}}\n{\"genre\": \"jazz\", \"product\": \"Product B\", \"quantity\": 10}\n{\"index\":{\"_id\":4}}\n{\"genre\": \"electronic\", \"product\": \"Product B\", \"quantity\": 3}\n{\"index\":{\"_id\":5}}\n{\"genre\": \"electronic\"}\n\n-------------------------------------------------\n// NOTCONSOLE\n// TESTSETUP\n\n//////////////////////////\n\nExample:\n\n[source,console,id=multi-terms-aggregation-example]\n--------------------------------------------------\nGET /products/_search\n{\n  \"aggs\": {\n    \"genres_and_products\": {\n      \"multi_terms\": {\n        \"terms\": [{\n          \"field\": \"genre\" <1>\n        }, {\n          \"field\": \"product\"\n        }]\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\n<1> `multi_terms` aggregation can work with the same field types as a\n<<search-aggregations-bucket-terms-aggregation-order,`terms aggregation`>> and supports most of the terms aggregation parameters.\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\" : {\n    \"genres_and_products\" : {\n      \"doc_count_error_upper_bound\" : 0,  <1>\n      \"sum_other_doc_count\" : 0,          <2>\n      \"buckets\" : [                       <3>\n        {\n          \"key\" : [                       <4>\n            \"rock\",\n            \"Product A\"\n          ],\n          \"key_as_string\" : \"rock|Product A\",\n          \"doc_count\" : 2\n        },\n        {\n          \"key\" : [\n            \"electronic\",\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"electronic|Product B\",\n          \"doc_count\" : 1\n        },\n        {\n          \"key\" : [\n            \"jazz\",\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"jazz|Product B\",\n          \"doc_count\" : 1\n        },\n        {\n          \"key\" : [\n            \"rock\",\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"rock|Product B\",\n          \"doc_count\" : 1\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n<1> an upper bound of the error on the document counts for each term, see <<search-aggregations-bucket-multi-terms-aggregation-approximate-counts,below>\n<2> when there are lots of unique terms, Elasticsearch only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response\n<3> the list of the top buckets.\n<4> the keys are arrays of values ordered the same ways as expression in the `terms` parameter of the aggregation\n\nBy default, the `multi_terms` aggregation will return the buckets for the top ten terms ordered by the `doc_count`. One can\nchange this default behaviour by setting the `size` parameter.\n\n[[search-aggregations-bucket-multi-terms-aggregation-parameters]]\n==== Aggregation Parameters\n\nThe following parameters are supported. See <<search-aggregations-bucket-terms-aggregation-order,`terms aggregation`>> for more detailed\nexplanation of these parameters.\n\n[horizontal]\nsize::                        Optional. Defines how many term buckets should be returned out of the overall terms list. Defaults to 10.\n\nshard_size::                  Optional. The higher the requested `size` is, the more accurate the results will be, but also, the more\n                              expensive it will be to compute the final results. The default `shard_size` is `(size * 1.5 + 10)`.\n\nshow_term_doc_count_error::   Optional. Calculates the doc count error on per term basis. Defaults to `false`\n\norder::                       Optional. Specifies the order of the buckets. Defaults to the number of documents per bucket. The bucket terms\n                              value is used as a tiebreaker for buckets with the same document count.\n\nmin_doc_count::               Optional. The minimal number of documents in a bucket for it to be returned. Defaults to 1.\n\nshard_min_doc_count::         Optional. The minimal number of documents in a bucket on each shard for it to be returned. Defaults to\n                              `min_doc_count`.\n\ncollect_mode::                Optional. Specifies the strategy for data collection. The `depth_first` or `breadth_first` modes are\n                              supported. Defaults to `breadth_first`.\n\n\n[[search-aggregations-bucket-multi-terms-aggregation-script]]\n==== Script\n\nGenerating the terms using a script:\n\n[source,console,id=multi-terms-aggregation-runtime-field-example]\n----\nGET /products/_search\n{\n  \"runtime_mappings\": {\n    \"genre.length\": {\n      \"type\": \"long\",\n      \"script\": \"emit(doc['genre'].value.length())\"\n    }\n  },\n  \"aggs\": {\n    \"genres_and_products\": {\n      \"multi_terms\": {\n        \"terms\": [\n          {\n            \"field\": \"genre.length\"\n          },\n          {\n            \"field\": \"product\"\n          }\n        ]\n      }\n    }\n  }\n}\n----\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\" : {\n    \"genres_and_products\" : {\n      \"doc_count_error_upper_bound\" : 0,\n      \"sum_other_doc_count\" : 0,\n      \"buckets\" : [\n        {\n          \"key\" : [\n            4,\n            \"Product A\"\n          ],\n          \"key_as_string\" : \"4|Product A\",\n          \"doc_count\" : 2\n        },\n        {\n          \"key\" : [\n            4,\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"4|Product B\",\n          \"doc_count\" : 2\n        },\n        {\n          \"key\" : [\n            10,\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"10|Product B\",\n          \"doc_count\" : 1\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n==== Missing value\n\nThe `missing` parameter defines how documents that are missing a value should be treated.\nBy default if any of the key components are missing the entire document will be ignored\nbut it is also possible to treat them as if they had a value by using the `missing` parameter.\n\n[source,console,id=multi-terms-aggregation-missing-example]\n--------------------------------------------------\nGET /products/_search\n{\n  \"aggs\": {\n    \"genres_and_products\": {\n      \"multi_terms\": {\n        \"terms\": [\n          {\n            \"field\": \"genre\"\n          },\n          {\n            \"field\": \"product\",\n            \"missing\": \"Product Z\"\n          }\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n   ...\n   \"aggregations\" : {\n    \"genres_and_products\" : {\n      \"doc_count_error_upper_bound\" : 0,\n      \"sum_other_doc_count\" : 0,\n      \"buckets\" : [\n        {\n          \"key\" : [\n            \"rock\",\n            \"Product A\"\n          ],\n          \"key_as_string\" : \"rock|Product A\",\n          \"doc_count\" : 2\n        },\n        {\n          \"key\" : [\n            \"electronic\",\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"electronic|Product B\",\n          \"doc_count\" : 1\n        },\n        {\n          \"key\" : [\n            \"electronic\",\n            \"Product Z\"\n          ],\n          \"key_as_string\" : \"electronic|Product Z\",  <1>\n          \"doc_count\" : 1\n        },\n        {\n          \"key\" : [\n            \"jazz\",\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"jazz|Product B\",\n          \"doc_count\" : 1\n        },\n        {\n          \"key\" : [\n            \"rock\",\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"rock|Product B\",\n          \"doc_count\" : 1\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n<1> Documents without a value in the `product` field will fall into the same bucket as documents that have the value `Product Z`.\n\n==== Mixing field types\n\nWARNING: When aggregating on multiple indices the type of the aggregated field may not be the same in all indices.\nSome types are compatible with each other (`integer` and `long` or `float` and `double`) but when the types are a mix\nof decimal and non-decimal number the terms aggregation will promote the non-decimal numbers to decimal numbers.\nThis can result in a loss of precision in the bucket values.\n\n==== Sub aggregation and sorting examples\n\nAs most bucket aggregations the `multi_term` supports sub aggregations and ordering the buckets by metrics sub-aggregation:\n\n[source,console,id=multi-terms-aggregation-subaggregation-example]\n--------------------------------------------------\nGET /products/_search\n{\n  \"aggs\": {\n    \"genres_and_products\": {\n      \"multi_terms\": {\n        \"terms\": [\n          {\n            \"field\": \"genre\"\n          },\n          {\n            \"field\": \"product\"\n          }\n        ],\n        \"order\": {\n          \"total_quantity\": \"desc\"\n        }\n      },\n      \"aggs\": {\n        \"total_quantity\": {\n          \"sum\": {\n            \"field\": \"quantity\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\" : {\n    \"genres_and_products\" : {\n      \"doc_count_error_upper_bound\" : 0,\n      \"sum_other_doc_count\" : 0,\n      \"buckets\" : [\n        {\n          \"key\" : [\n            \"jazz\",\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"jazz|Product B\",\n          \"doc_count\" : 1,\n          \"total_quantity\" : {\n            \"value\" : 10.0\n          }\n        },\n        {\n          \"key\" : [\n            \"rock\",\n            \"Product A\"\n          ],\n          \"key_as_string\" : \"rock|Product A\",\n          \"doc_count\" : 2,\n          \"total_quantity\" : {\n            \"value\" : 9.0\n          }\n        },\n        {\n          \"key\" : [\n            \"electronic\",\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"electronic|Product B\",\n          \"doc_count\" : 1,\n          \"total_quantity\" : {\n            \"value\" : 3.0\n          }\n        },\n        {\n          \"key\" : [\n            \"rock\",\n            \"Product B\"\n          ],\n          \"key_as_string\" : \"rock|Product B\",\n          \"doc_count\" : 1,\n          \"total_quantity\" : {\n            \"value\" : 1.0\n          }\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n"
}