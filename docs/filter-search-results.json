{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.536581",
        "size": 8574,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/filter-search-results.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "filter-search-results",
        "version": "8.15"
    },
    "doc": "[[filter-search-results]]\n=== Filter search results\n\nYou can use two methods to filter search results:\n\n* Use a boolean query with a `filter` clause. Search requests apply\n<<query-dsl-bool-query,boolean filters>> to both search hits and\n<<search-aggregations,aggregations>>.\n\n* Use the search API's `post_filter` parameter. Search requests apply\n<<post-filter,post filters>> only to search hits, not aggregations. You can use\na post filter to calculate aggregations based on a broader result set, and then\nfurther narrow the results.\n+\nYou can also <<rescore,rescore>> hits after the post filter to\nimprove relevance and reorder results.\n\n[discrete]\n[[post-filter]]\n==== Post filter\n\nWhen you use the `post_filter` parameter to filter search results, the search\nhits are filtered after the aggregations are calculated. A post filter has no\nimpact on the aggregation results.\n\nFor example, you are selling shirts that have the following properties:\n\n[source,console]\n--------------------------------------------------\nPUT /shirts\n{\n  \"mappings\": {\n    \"properties\": {\n      \"brand\": { \"type\": \"keyword\"},\n      \"color\": { \"type\": \"keyword\"},\n      \"model\": { \"type\": \"keyword\"}\n    }\n  }\n}\n\nPUT /shirts/_doc/1?refresh\n{\n  \"brand\": \"gucci\",\n  \"color\": \"red\",\n  \"model\": \"slim\"\n}\n--------------------------------------------------\n// TESTSETUP\n\n\nImagine a user has specified two filters:\n\n`color:red` and `brand:gucci`. You only want to show them red shirts made by\nGucci in the search results. Normally you would do this with a \n<<query-dsl-bool-query,`bool` query>>:\n\n[source,console]\n--------------------------------------------------\nGET /shirts/_search \n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        { \"term\": { \"color\": \"red\"   }},\n        { \"term\": { \"brand\": \"gucci\" }}\n      ]\n    }\n  }\n}\n--------------------------------------------------\n\nHowever, you would also like to use _faceted navigation_ to display a list of\nother options that the user could click on. Perhaps you have a `model` field\nthat would allow the user to limit their search results to red Gucci\n`t-shirts` or `dress-shirts`.\n\nThis can be done with a \n<<search-aggregations-bucket-terms-aggregation,`terms` aggregation>>:\n\n[source,console]\n--------------------------------------------------\nGET /shirts/_search \n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        { \"term\": { \"color\": \"red\"   }},\n        { \"term\": { \"brand\": \"gucci\" }}\n      ]\n    }\n  },\n  \"aggs\": {\n    \"models\": {\n      \"terms\": { \"field\": \"model\" } <1>\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Returns the most popular models of red shirts by Gucci.\n\nBut perhaps you would also like to tell the user how many Gucci shirts are\navailable in *other colors*. If you just add a `terms` aggregation on the\n`color` field, you will only get back the color `red`, because your query\nreturns only red shirts by Gucci.\n\nInstead, you want to include shirts of all colors during aggregation, then\napply the `colors` filter only to the search results. This is the purpose of\nthe `post_filter`:\n\n[source,console]\n--------------------------------------------------\nGET /shirts/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": {\n        \"term\": { \"brand\": \"gucci\" } <1>\n      }\n    }\n  },\n  \"aggs\": {\n    \"colors\": {\n      \"terms\": { \"field\": \"color\" } <2>\n    },\n    \"color_red\": {\n      \"filter\": {\n        \"term\": { \"color\": \"red\" } <3>\n      },\n      \"aggs\": {\n        \"models\": {\n          \"terms\": { \"field\": \"model\" } <3>\n        }\n      }\n    }\n  },\n  \"post_filter\": { <4>\n    \"term\": { \"color\": \"red\" }\n  }\n}\n--------------------------------------------------\n\n<1> The main query now finds all shirts by Gucci, regardless of color.\n<2> The `colors` agg returns popular colors for shirts by Gucci.\n<3> The `color_red` agg limits the `models` sub-aggregation \n    to *red* Gucci shirts.\n<4> Finally, the `post_filter` removes colors other than red\n    from the search `hits`.\n\n[discrete]\n[[rescore]]\n==== Rescore filtered search results\n\nRescoring can help to improve precision by reordering just the top (eg\n100 - 500) documents returned by the\n<<request-body-search-query,`query`>> and\n<<post-filter,`post_filter`>> phases, using a\nsecondary (usually more costly) algorithm, instead of applying the\ncostly algorithm to all documents in the index.\n\nA `rescore` request is executed on each shard before it returns its\nresults to be sorted by the node handling the overall search request.\n\nCurrently the rescore API has only one implementation: the query\nrescorer, which uses a query to tweak the scoring. In the future,\nalternative rescorers may be made available, for example, a pair-wise rescorer.\n\nNOTE: An error will be thrown if an explicit <<sort-search-results,`sort`>>\n(other than `_score` in descending order) is provided with a `rescore` query.\n\nNOTE: when exposing pagination to your users, you should not change\n`window_size` as you step through each page (by passing different\n`from` values) since that can alter the top hits causing results to\nconfusingly shift as the user steps through pages.\n\n[discrete]\n[[query-rescorer]]\n===== Query rescorer\n\nThe query rescorer executes a second query only on the Top-K results\nreturned by the <<request-body-search-query,`query`>> and\n<<post-filter,`post_filter`>> phases. The\nnumber of docs which will be examined on each shard can be controlled by\nthe `window_size` parameter, which defaults to 10.\n\nBy default the scores from the original query and the rescore query are\ncombined linearly to produce the final `_score` for each document. The\nrelative importance of the original query and of the rescore query can\nbe controlled with the `query_weight` and `rescore_query_weight`\nrespectively. Both default to `1`.\n\nFor example:\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n   \"query\" : {\n      \"match\" : {\n         \"message\" : {\n            \"operator\" : \"or\",\n            \"query\" : \"the quick brown\"\n         }\n      }\n   },\n   \"rescore\" : {\n      \"window_size\" : 50,\n      \"query\" : {\n         \"rescore_query\" : {\n            \"match_phrase\" : {\n               \"message\" : {\n                  \"query\" : \"the quick brown\",\n                  \"slop\" : 2\n               }\n            }\n         },\n         \"query_weight\" : 0.7,\n         \"rescore_query_weight\" : 1.2\n      }\n   }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nThe way the scores are combined can be controlled with the `score_mode`:\n[cols=\"<,<\",options=\"header\",]\n|=======================================================================\n|Score Mode |Description\n|`total`    |Add the original score and the rescore query score. The default.\n|`multiply` |Multiply the original score by the rescore query score. Useful\nfor <<query-dsl-function-score-query,`function query`>> rescores.\n|`avg`      |Average the original score and the rescore query score.\n|`max`      |Take the max of original score and the rescore query score.\n|`min`      |Take the min of the original score and the rescore query score.\n|=======================================================================\n\n[discrete]\n[[multiple-rescores]]\n===== Multiple rescores\n\nIt is also possible to execute multiple rescores in sequence:\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n   \"query\" : {\n      \"match\" : {\n         \"message\" : {\n            \"operator\" : \"or\",\n            \"query\" : \"the quick brown\"\n         }\n      }\n   },\n   \"rescore\" : [ {\n      \"window_size\" : 100,\n      \"query\" : {\n         \"rescore_query\" : {\n            \"match_phrase\" : {\n               \"message\" : {\n                  \"query\" : \"the quick brown\",\n                  \"slop\" : 2\n               }\n            }\n         },\n         \"query_weight\" : 0.7,\n         \"rescore_query_weight\" : 1.2\n      }\n   }, {\n      \"window_size\" : 10,\n      \"query\" : {\n         \"score_mode\": \"multiply\",\n         \"rescore_query\" : {\n            \"function_score\" : {\n               \"script_score\": {\n                  \"script\": {\n                    \"source\": \"Math.log10(doc.count.value + 2)\"\n                  }\n               }\n            }\n         }\n      }\n   } ]\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nThe first one gets the results of the query then the second one gets the\nresults of the first, etc. The second rescore will \"see\" the sorting done\nby the first rescore so it is possible to use a large window on the first\nrescore to pull documents into a smaller window for the second rescore.\n"
}