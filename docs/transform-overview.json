{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.814069",
        "size": 5994,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/transform-overview.html",
        "type": "documentation",
        "role": [
            "xpack",
            "screenshot",
            "screenshot"
        ],
        "has_code": false,
        "title": "transform-overview",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[transform-overview]]\n= {transform-cap} overview\n++++\n<titleabbrev>Overview</titleabbrev>\n++++\n\nYou can choose either of the following methods to transform your data:\n<<pivot-transform-overview,pivot>> or <<latest-transform-overview,latest>>.\n\n[IMPORTANT]\n====\n* All {transforms} leave your source index intact. They create a new\n  index that is dedicated to the transformed data.\n* {transforms-cap} might have more configuration options provided by the APIs \n  than the options available in {kib}. For all the {transform} configuration \n  options, refer to the <<transform-apis,API documentation>>.\n====\n\n{transforms-cap} are persistent tasks; they are stored in cluster state which \nmakes them resilient for node failures. Refer to <<transform-checkpoints>> and \n<<ml-transform-checkpoint-errors>> to learn more about the machinery behind \n{transforms}.\n\n\n[[pivot-transform-overview]]\n== Pivot {transforms}\n\nYou can use {transforms} to _pivot_ your data into a new entity-centric index.\nBy transforming and summarizing your data, it becomes possible to visualize and\nanalyze it in alternative and interesting ways.\n\nA lot of {es} indices are organized as a stream of events: each event is an\nindividual document, for example a single item purchase. {transforms-cap} enable\nyou to summarize this data, bringing it into an organized, more\nanalysis-friendly format. For example, you can summarize all the purchases of a\nsingle customer.\n\n{transforms-cap} enable you to define a pivot, which is a set of\nfeatures that transform the index into a different, more digestible format.\nPivoting results in a summary of your data in a new index.\n\nTo define a pivot, first you select one or more fields that you will use to\ngroup your data. You can select categorical fields (terms) and numerical fields\nfor grouping. If you use numerical fields, the field values are bucketed using\nan interval that you specify.\n\nThe second step is deciding how you want to aggregate the grouped data. When\nusing aggregations, you practically ask questions about the index. There are\ndifferent types of aggregations, each with its own purpose and output. To learn\nmore about the supported aggregations and group-by fields, see\n<<put-transform>>.\n\nAs an optional step, you can also add a query to further limit the scope of the\naggregation.\n\nThe {transform} performs a composite aggregation that paginates through all the\ndata defined by the source index query. The output of the aggregation is stored\nin a _destination index_. Each time the {transform} queries the source index, it\ncreates a _checkpoint_. You can decide whether you want the {transform} to run\nonce or continuously. A _batch {transform}_ is a single operation that has a\nsingle checkpoint. _{ctransforms-cap}_ continually increment and process\ncheckpoints as new source data is ingested.\n\nImagine that you run a webshop that sells clothes. Every order creates a\ndocument that contains a unique order ID, the name and the category of the\nordered product, its price, the ordered quantity, the exact date of the order,\nand some customer information (name, gender, location, etc). Your data set\ncontains all the transactions from last year.\n\nIf you want to check the sales in the different categories in your last fiscal\nyear, define a {transform} that groups the data by the product categories\n(women's shoes, men's clothing, etc.) and the order date. Use the last year as\nthe interval for the order date. Then add a sum aggregation on the ordered\nquantity. The result is an entity-centric index that shows the number of sold\nitems in every product category in the last year.\n\n[role=\"screenshot\"]\nimage::images/pivot-preview.png[\"Example of a pivot {transform} preview in {kib}\"]\n\n[[latest-transform-overview]]\n== Latest {transforms}\n\nYou can use the `latest` type of {transform} to copy the most recent documents\ninto a new index. You must identify one or more fields as the unique key for\ngrouping your data, as well as a date field that sorts the data chronologically.\nFor example, you can use this type of {transform} to keep track of the latest\npurchase for each customer or the latest event for each host.\n\n[role=\"screenshot\"]\nimage::images/latest-preview.png[\"Example of a latest {transform} preview in {kib}\"]\n\nAs in the case of a pivot, a latest {transform} can run once or continuously. It\nperforms a composite aggregation on the data in the source index and stores the\noutput in the destination index. If the {transform} runs continuously, new unique\nkey values are automatically added to the destination index and the most recent\ndocuments for existing key values are automatically updated at each checkpoint.\n\n[[transform-performance]]\n== Performance considerations\n\n{transforms-cap} perform search aggregations on the source indices then index\nthe results into the destination index. Therefore, a {transform} never takes\nless time or uses less resources than the aggregation and indexing processes.\n\nIf your {transform} must process a lot of historic data, it has high resource\nusage initially--particularly during the first checkpoint.\n\nFor better performance, make sure that your search aggregations and queries are\noptimized and that your {transform} is processing only necessary data. Consider\nwhether you can apply a source query to the {transform} to reduce the scope of\ndata it processes. Also consider whether the cluster has sufficient resources in\nplace to support both the composite aggregation search and the indexing of its\nresults.\n\nIf you prefer to spread out the impact on your cluster (at the cost of a slower\n{transform}), you can throttle the rate at which it performs search and index\nrequests. Set the `docs_per_second` limit when you <<put-transform,create>> or\n<<update-transform,update>> your {transform}. If you want to calculate the\ncurrent rate, use the following information from the\n{ref}/get-transform-stats.html[get {transform} stats API]:\n```\ndocuments_processed / search_time_in_ms * 1000\n```\n"
}