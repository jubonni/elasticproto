{
    "meta": {
        "size": 5527,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-bucket-sort-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-pipeline-bucket-sort-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-pipeline-bucket-sort-aggregation]]\n=== Bucket sort aggregation\n++++\n<titleabbrev>Bucket sort</titleabbrev>\n++++\n\nA parent pipeline aggregation which sorts the buckets of its parent multi-bucket aggregation.\nZero or more sort fields may be specified together with the corresponding sort order.\nEach bucket may be sorted based on its `_key`, `_count` or its sub-aggregations.\nIn addition, parameters `from` and `size` may be set in order to truncate the result buckets.\n\nNOTE: The `bucket_sort` aggregation, like all pipeline aggregations, is executed after all other non-pipeline aggregations.\nThis means the sorting only applies to whatever buckets are already returned from the parent aggregation. For example,\nif the parent aggregation is `terms` and its `size` is set to `10`, the `bucket_sort` will only sort over those 10\nreturned term buckets.\n\n==== Syntax\n\nA `bucket_sort` aggregation looks like this in isolation:\n\n[source,js]\n--------------------------------------------------\n{\n  \"bucket_sort\": {\n    \"sort\": [\n      { \"sort_field_1\": { \"order\": \"asc\" } },   <1>\n      { \"sort_field_2\": { \"order\": \"desc\" } },\n      \"sort_field_3\"\n    ],\n    \"from\": 1,\n    \"size\": 3\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n<1> Here, `sort_field_1` is the bucket path to the variable to be used as the primary sort and its order\nis ascending.\n\n[[bucket-sort-params]]\n.`bucket_sort` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description |Required |Default Value\n|`sort` |The list of fields to sort on. See <<sort-search-results,`sort`>> for more details. |Optional |\n|`from` |Buckets in positions prior to the set value will be truncated. |Optional | `0`\n|`size` |The number of buckets to return. Defaults to all buckets of the parent aggregation. |Optional |\n|`gap_policy` |The policy to apply when gaps are found in the data (see <<gap-policy>> for more\n details)|Optional |`skip`\n|===\n\nThe following snippet returns the buckets corresponding to the 3 months with the highest total sales in descending order:\n\n[source,console]\n--------------------------------------------------\nPOST /sales/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"sales_per_month\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"month\"\n      },\n      \"aggs\": {\n        \"total_sales\": {\n          \"sum\": {\n            \"field\": \"price\"\n          }\n        },\n        \"sales_bucket_sort\": {\n          \"bucket_sort\": {\n            \"sort\": [\n              { \"total_sales\": { \"order\": \"desc\" } } <1>\n            ],\n            \"size\": 3                                <2>\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n<1> `sort` is set to use the values of `total_sales` in descending order\n<2> `size` is set to `3` meaning only the top 3 months in `total_sales` will be returned\n\nAnd the following may be the response:\n\n[source,console-result]\n--------------------------------------------------\n{\n   \"took\": 82,\n   \"timed_out\": false,\n   \"_shards\": ...,\n   \"hits\": ...,\n   \"aggregations\": {\n      \"sales_per_month\": {\n         \"buckets\": [\n            {\n               \"key_as_string\": \"2015/01/01 00:00:00\",\n               \"key\": 1420070400000,\n               \"doc_count\": 3,\n               \"total_sales\": {\n                   \"value\": 550.0\n               }\n            },\n            {\n               \"key_as_string\": \"2015/03/01 00:00:00\",\n               \"key\": 1425168000000,\n               \"doc_count\": 2,\n               \"total_sales\": {\n                   \"value\": 375.0\n               }\n            },\n            {\n               \"key_as_string\": \"2015/02/01 00:00:00\",\n               \"key\": 1422748800000,\n               \"doc_count\": 2,\n               \"total_sales\": {\n                   \"value\": 60.0\n               }\n            }\n         ]\n      }\n   }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 82/\"took\": $body.took/]\n// TESTRESPONSE[s/\"_shards\": \\.\\.\\./\"_shards\": $body._shards/]\n// TESTRESPONSE[s/\"hits\": \\.\\.\\./\"hits\": $body.hits/]\n\n==== Truncating without sorting\n\nIt is also possible to use this aggregation in order to truncate the result buckets\nwithout doing any sorting. To do so, just use the `from` and/or `size` parameters\nwithout specifying `sort`.\n\nThe following example simply truncates the result so that only the second bucket is returned:\n\n[source,console]\n--------------------------------------------------\nPOST /sales/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"sales_per_month\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"month\"\n      },\n      \"aggs\": {\n        \"bucket_truncate\": {\n          \"bucket_sort\": {\n            \"from\": 1,\n            \"size\": 1\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n   \"took\": 11,\n   \"timed_out\": false,\n   \"_shards\": ...,\n   \"hits\": ...,\n   \"aggregations\": {\n      \"sales_per_month\": {\n         \"buckets\": [\n            {\n               \"key_as_string\": \"2015/02/01 00:00:00\",\n               \"key\": 1422748800000,\n               \"doc_count\": 2\n            }\n         ]\n      }\n   }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 11/\"took\": $body.took/]\n// TESTRESPONSE[s/\"_shards\": \\.\\.\\./\"_shards\": $body._shards/]\n// TESTRESPONSE[s/\"hits\": \\.\\.\\./\"hits\": $body.hits/]\n"
}