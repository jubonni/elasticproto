{
    "meta": {
        "timestamp": "2024-11-01T03:07:10.158277",
        "size": 8195,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-application-security-key-restrictions.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "search-application-security-key-restrictions",
        "version": "8.15"
    },
    "doc": "[#search-application-security]\n=== Using search applications with untrusted clients\n++++\n<titleabbrev>Security</titleabbrev>\n++++\n\nWhen building a frontend application for search use cases, there are two main approaches to returning search results:\n\n. The client (user's browser) makes API requests to the application backend, which in turn makes a request to {es}.\nThe {es} cluster is not exposed to the end user.\n. *The client (user's browser) makes API requests directly to the search service - in this case the {es} cluster is reachable to the client.*\n\nThis guide describes best practices when taking the second approach.\nSpecifically, we will explain how to use search applications with frontend apps that make direct requests to the <<search-application-search,Search Application Search API>>.\n\nThis approach has a few advantages:\n\n* No need to maintain a passthrough query system between frontend applications and {es}\n* Direct requests to {es} result in faster response times\n* Query configuration is managed in one place: your search application configuration in {es}\n\nWe will cover:\n\n* <<search-application-security-key-restrictions>>\n* <<search-application-security-parameter-validation,Parameter validation in the Search Application Search API>>\n* <<search-application-security-cors,Working with CORS>>\n\n[discrete]\n[[search-application-security-key-restrictions]]\n==== Using {es} API keys with role restrictions\n\nWhen frontend applications can make direct API requests to {es}, it's important to limit the operations they can perform.\nIn our case, frontend applications should only be able to call the Search Application *Search API*.\nTo ensure this, we will create {es} API keys with <<role-restriction,role restrictions>>.\nA role restriction is used to specify under what conditions a role should be effective.\n\nThe following {es} API key has access to the `website-product-search` search application, only through the Search Application Search API:\n\n[source,console]\n----\nPOST /_security/api_key\n{\n  \"name\": \"my-restricted-api-key\",\n  \"expiration\": \"7d\",\n  \"role_descriptors\": {\n    \"my-restricted-role-descriptor\": {\n      \"indices\": [\n        {\n          \"names\": [\"website-product-search\"], <1>\n          \"privileges\": [\"read\"]\n        }\n      ],\n      \"restriction\":  {\n        \"workflows\": [\"search_application_query\"] <2>\n      }\n    }\n  }\n}\n----\n// TEST[skip:TODO]\n\n<1> `indices.name` must be the name(s) of the Search Application(s), not the underlying {es} indices.\n<2> `restriction.workflows` must be set to the concrete value `search_application_query`.\n\n[IMPORTANT]\n====\nIt is crucial to specify the workflow restriction.\nWithout this the {es} API key can directly call `_search` and issue arbitrary {es} queries.\nThis is insecure when dealing with untrusted clients.\n====\n\nThe response will look like this:\n\n[source,console-result]\n----\n{\n  \"id\": \"v1CCJYkBvb5Pg9T-_JgO\",\n  \"name\": \"my-restricted-api-key\",\n  \"expiration\": 1689156288526,\n  \"api_key\": \"ztVI-1Q4RjS8qFDxAVet5w\",\n  \"encoded\": \"djFDQ0pZa0J2YjVQZzlULV9KZ086enRWSS0xUTRSalM4cUZEeEFWZXQ1dw\"\n}\n----\n// TEST[skip:TODO]\n\nThe encoded value can then be directly used in the Authorization header.\nHere's an example using cURL:\n\n[source,shell]\n----\ncurl -XPOST \"http://localhost:9200/_application/search_application/website-product-search/_search\" \\\n -H \"Content-Type: application/json\" \\\n -H \"Authorization: ApiKey djFDQ0pZa0J2YjVQZzlULV9KZ086enRWSS0xUTRSalM4cUZEeEFWZXQ1dw\" \\\n -d '{\n  \"params\": {\n    \"field_name\": \"color\",\n    \"field_value\": \"red\",\n    \"agg_size\": 5\n  }\n}'\n----\n// NOTCONSOLE\n\n[TIP]\n====\nIf `expiration` is not present, by default {es} API keys never expire.\nThe API key can be invalidated using the <<security-api-invalidate-api-key,invalidate API key API>>.\n====\n\n[TIP]\n====\n{es} API keys with role restrictions can also use field and document level security.\nThis further limits how frontend applications query a search application.\n====\n\n[discrete]\n[[search-application-security-parameter-validation]]\n==== Parameter validation with search applications\n\nYour search applications use <<search-application-api, search templates>> to render queries.\nThe template parameters are passed to the Search Application Search API.\nIn the case of APIs used by frontend applications or untrusted clients, we need to have strict parameter validation.\nSearch applications define a JSON schema that describes which parameters the Search Application Search API allows.\n\nThe following example defines a search application with strict parameter validation:\n\n[source,console]\n----\nPUT _application/search_application/website-product-search\n{\n  \"indices\": [\n    \"website-products\"\n  ],\n  \"template\": {\n    \"script\": {\n      \"source\": {\n        \"query\": {\n          \"term\": {\n            \"{{field_name}}\": \"{{field_value}}\"\n          }\n        },\n        \"aggs\": {\n          \"color_facet\": {\n            \"terms\": {\n              \"field\": \"color\",\n              \"size\": \"{{agg_size}}\"\n            }\n          }\n        }\n      },\n      \"params\": {\n        \"field_name\": \"product_name\",\n        \"field_value\": \"hello world\",\n        \"agg_size\": 5\n      }\n    },\n    \"dictionary\": {\n      \"properties\": {\n        \"field_name\": {\n          \"type\": \"string\",\n          \"enum\": [\"name\", \"color\", \"description\"]\n        },\n        \"field_value\": {\n          \"type\": \"string\"\n        },\n        \"agg_size\": {\n          \"type\": \"integer\",\n          \"minimum\": 1,\n          \"maximum\": 10\n        }\n      },\n      \"required\": [\n        \"field_name\"\n      ],\n      \"additionalProperties\": false\n    }\n  }\n}\n----\n// TEST[skip:TODO]\n\nUsing that definition, the Search Application Search API performs the following parameter validation:\n\n* It only accepts the `field_name`, `field_value` and `aggs_size` parameters\n* `field_name` is restricted to only take the values \"name\", \"color\" and \"description\"\n* `agg_size` defines the size of the term aggregation and it can only take values between `1` and `10`\n\n[discrete]\n[[search-application-security-cors]]\n==== Working with CORS\n\nUsing this approach means that your user's browser will make requests to the {es} API directly.\n{es} supports https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[Cross-Origin Resource Sharing (CORS)^], but this feature is disabled by default.\nTherefore the browser will block these requests.\n\nThere are two workarounds for this:\n\n* <<search-application-security-cors-elasticsearch, Enable CORS on {es}>>\n* <<search-application-security-cors-proxy-request, Proxy the request through a server that supports CORS>>\n\n[discrete]\n[[search-application-security-cors-elasticsearch]]\n===== Enable CORS on {es}\n\nThis is the simplest option.\nEnable CORS on {es} by adding the following to your `elasticsearch.yml` file:\n\n[source,yaml]\n----\nhttp.cors.allow-origin: \"*\" # Only use unrestricted value for local development\n# Use a specific origin value in production, like `http.cors.allow-origin: \"https://<my-website-domain.example>\"`\nhttp.cors.enabled: true\nhttp.cors.allow-credentials: true\nhttp.cors.allow-methods: OPTIONS, POST\nhttp.cors.allow-headers: X-Requested-With, X-Auth-Token, Content-Type, Content-Length, Authorization, Access-Control-Allow-Headers, Accept\n----\n\nOn Elastic Cloud, you can do this by {cloud}/ec-add-user-settings.html#ec-add-user-settings[editing your {es} user settings].\n\n. From your deployment menu, go to the *Edit* page.\n. In the *{es}* section, select *Manage user settings and extensions*.\n. Update the user settings with the configuration above.\n. Select *Save changes*.\n\n[discrete]\n[[search-application-security-cors-proxy-request]]\n===== Proxy the request through a server that supports CORS\n\nIf you are unable to enable CORS on {es}, you can proxy the request through a server that supports CORS.\nThis is more complicated, but is a viable option.\n\n[discrete]\n[[search-application-security-learn-more]]\n==== Learn more\n\n* <<role-restriction,Role restrictions>>\n* <<document-level-security,Document level security>> \n* <<field-level-security,Field level security>>\n* <<search-application-api, APIs>>\n** <<put-search-application,PUT Search Application API>>\n** <<search-application-search,Search Application Search API>>"
}