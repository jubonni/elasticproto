{
    "meta": {
        "timestamp": "2024-11-01T02:49:24.986069",
        "size": 14423,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ecommerce-transforms.html",
        "type": "documentation",
        "role": [
            "xpack",
            "screenshot",
            "screenshot",
            "screenshot",
            "screenshot",
            "screenshot",
            "screenshot",
            "screenshot"
        ],
        "has_code": true,
        "title": "ecommerce-transforms",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[ecommerce-transforms]]\n= Tutorial: Transforming the eCommerce sample data\n\n<<transforms,{transforms-cap}>> enable you to retrieve information\nfrom an {es} index, transform it, and store it in another index. Let's use the\n{kibana-ref}/add-sample-data.html[{kib} sample data] to demonstrate how you can\npivot and summarize your data with {transforms}.\n\n. Verify that your environment is set up properly to use {transforms}. If the\n{es} {security-features} are enabled, to complete this tutorial you need a user\nthat has authority to preview and create {transforms}. You must also have\nspecific index privileges for the source and destination indices. See\n<<transform-setup>>.\n\n. Choose your _source index_.\n+\n--\nIn this example, we'll use the eCommerce orders sample data. If you're not\nalready familiar with the `kibana_sample_data_ecommerce` index, use the\n*Revenue* dashboard in {kib} to explore the data. Consider what insights you\nmight want to derive from this eCommerce data.\n--\n\n. Choose the pivot type of {transform} and play with various options for\ngrouping and aggregating the data.\n+\n--\nThere are two types of {transforms}, but first we'll try out _pivoting_ your\ndata, which involves using at least one field to group it and applying at least\none aggregation. You can preview what the transformed data will look\nlike, so go ahead and play with it! You can also enable histogram charts to get\na better understanding of the distribution of values in your data.\n\nFor example, you might want to group the data by product ID and calculate the\ntotal number of sales for each product and its average price. Alternatively, you\nmight want to look at the behavior of individual customers and calculate how\nmuch each customer spent in total and how many different categories of products\nthey purchased. Or you might want to take the currencies or geographies into\nconsideration. What are the most interesting ways you can transform and\ninterpret this data?\n\nGo to *Management* > *Stack Management* > *Data* > *Transforms* in {kib} and use\nthe wizard to create a {transform}:\n\n[role=\"screenshot\"]\nimage::images/ecommerce-pivot1.png[\"Creating a simple {transform} in {kib}\"]\n\nGroup the data by customer ID and add one or more aggregations to learn more\nabout each customer's orders. For example, let's calculate the sum of products\nthey purchased, the total price of their purchases, the maximum number of\nproducts that they purchased in a single order, and their total number of orders. We'll accomplish this by using the\n<<search-aggregations-metrics-sum-aggregation,`sum` aggregation>> on the\n`total_quantity` and `taxless_total_price` fields, the\n<<search-aggregations-metrics-max-aggregation,`max` aggregation>> on the\n`total_quantity` field, and the\n<<search-aggregations-metrics-cardinality-aggregation,`cardinality` aggregation>>\non the `order_id` field:\n\n[role=\"screenshot\"]\nimage::images/ecommerce-pivot2.png[\"Adding multiple aggregations to a {transform} in {kib}\"]\n\nTIP: If you're interested in a subset of the data, you can optionally include a\n<<request-body-search-query,query>> element. In this\nexample, we've filtered the data so that we're only looking at orders with a\n`currency` of `EUR`. Alternatively, we could group the data by that field too.\nIf you want to use more complex queries, you can create your {dataframe} from a\n{kibana-ref}/save-open-search.html[saved search].\n\nIf you prefer, you can use the\n<<preview-transform,preview {transforms} API>>.\n\n.API example\n[%collapsible]\n====\n[source,console]\n--------------------------------------------------\nPOST _transform/_preview\n{\n  \"source\": {\n    \"index\": \"kibana_sample_data_ecommerce\",\n    \"query\": {\n      \"bool\": {\n        \"filter\": {\n          \"term\": {\"currency\": \"EUR\"}\n        }\n      }\n    }\n  },\n  \"pivot\": {\n    \"group_by\": {\n      \"customer_id\": {\n        \"terms\": {\n          \"field\": \"customer_id\"\n        }\n      }\n    },\n    \"aggregations\": {\n      \"total_quantity.sum\": {\n        \"sum\": {\n          \"field\": \"total_quantity\"\n        }\n      },\n      \"taxless_total_price.sum\": {\n        \"sum\": {\n          \"field\": \"taxless_total_price\"\n        }\n      },\n      \"total_quantity.max\": {\n        \"max\": {\n          \"field\": \"total_quantity\"\n        }\n      },\n      \"order_id.cardinality\": {\n        \"cardinality\": {\n          \"field\": \"order_id\"\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[skip:set up sample data]\n====\n--\n\n. When you are satisfied with what you see in the preview, create the\n{transform}.\n+\n--\n.. Supply a {transform} ID, the name of the destination index and optionally a\ndescription. If the destination index does not exist, it will be created\nautomatically when you start the {transform}.\n\n.. Decide whether you want the {transform} to run once or continuously. Since \nthis sample data index is unchanging, let's use the default behavior and just \nrun the {transform} once. If you want to try it out, however, go ahead and click \non *Continuous mode*. You must choose a field that the {transform} can use to \ncheck which entities have changed. In general, it's a good idea to use the \ningest timestamp field. In this example, however, you can use the `order_date` \nfield.\n\n.. Optionally, you can configure a retention policy that applies to your \n{transform}. Select a date field that is used to identify old documents \nin the destination index and provide a maximum age. Documents that are older \nthan the configured value are removed from the destination index.\n\n[role=\"screenshot\"]\nimage::images/ecommerce-pivot3.png[\"Adding transfrom ID and retention policy to a {transform} in {kib}\"]\n\nIn {kib}, before you finish creating the {transform}, you can copy the preview \n{transform} API request to your clipboard. This information is useful later when \nyou're deciding whether you want to manually create the destination index.\n\n[role=\"screenshot\"]\nimage::images/ecommerce-pivot4.png[\"Copy the Dev Console statement of the transform preview to the clipboard\"]\n\nIf you prefer, you can use the\n<<put-transform,create {transforms} API>>.\n\n.API example\n[%collapsible]\n====\n[source,console]\n--------------------------------------------------\nPUT _transform/ecommerce-customer-transform\n{\n  \"source\": {\n    \"index\": [\n      \"kibana_sample_data_ecommerce\"\n    ],\n    \"query\": {\n      \"bool\": {\n        \"filter\": {\n          \"term\": {\n            \"currency\": \"EUR\"\n          }\n        }\n      }\n    }\n  },\n  \"pivot\": {\n    \"group_by\": {\n      \"customer_id\": {\n        \"terms\": {\n          \"field\": \"customer_id\"\n        }\n      }\n    },\n    \"aggregations\": {\n      \"total_quantity.sum\": {\n        \"sum\": {\n          \"field\": \"total_quantity\"\n        }\n      },\n      \"taxless_total_price.sum\": {\n        \"sum\": {\n          \"field\": \"taxless_total_price\"\n        }\n      },\n      \"total_quantity.max\": {\n        \"max\": {\n          \"field\": \"total_quantity\"\n        }\n      },\n      \"order_id.cardinality\": {\n        \"cardinality\": {\n          \"field\": \"order_id\"\n        }\n      }\n    }\n  },\n  \"dest\": {\n    \"index\": \"ecommerce-customers\"\n  },\n  \"retention_policy\": {\n    \"time\": {\n      \"field\": \"order_date\",\n      \"max_age\": \"60d\"\n    }\n  }  \n}\n--------------------------------------------------\n// TEST[skip:setup kibana sample data]\n====\n--\n\n. Optional: Create the destination index.\n+\n--\nIf the destination index does not exist, it is created the first time you start\nyour {transform}. A pivot transform deduces the mappings for the destination\nindex from the source indices and the transform aggregations. If there are\nfields in the destination index that are derived from scripts (for example, \nif you use\n<<search-aggregations-metrics-scripted-metric-aggregation,`scripted_metrics`>>\nor <<search-aggregations-pipeline-bucket-script-aggregation,`bucket_scripts`>>\naggregations), they're created with <<dynamic-mapping,dynamic mappings>>. You\ncan use the preview {transform} API to preview the mappings it will use for the\ndestination index. In {kib}, if you copied the API request to your \nclipboard, paste it into the console, then refer to the `generated_dest_index` \nobject in the API response.\n\nNOTE: {transforms-cap} might have more configuration options provided by the \nAPIs than the options available in {kib}. For example, you can set an ingest \npipeline for `dest` by calling the <<put-transform>>. For all the {transform} \nconfiguration options, refer to the <<transform-apis,documentation>>.\n\n.API example\n[%collapsible]\n====\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"preview\" : [\n    {\n      \"total_quantity\" : {\n        \"max\" : 2,\n        \"sum\" : 118.0\n      },\n      \"taxless_total_price\" : {\n        \"sum\" : 3946.9765625\n      },\n      \"customer_id\" : \"10\",\n      \"order_id\" : {\n        \"cardinality\" : 59\n      }\n    },\n    ...\n  ],\n  \"generated_dest_index\" : {\n    \"mappings\" : {\n      \"_meta\" : {\n        \"_transform\" : {\n          \"transform\" : \"transform-preview\",\n          \"version\" : {\n            \"created\" : \"8.0.0\"\n          },\n          \"creation_date_in_millis\" : 1621991264061\n        },\n        \"created_by\" : \"transform\"\n      },\n      \"properties\" : {\n        \"total_quantity.sum\" : {\n          \"type\" : \"double\"\n        },\n        \"total_quantity\" : {\n          \"type\" : \"object\"\n        },\n        \"taxless_total_price\" : {\n          \"type\" : \"object\"\n        },\n        \"taxless_total_price.sum\" : {\n          \"type\" : \"double\"\n        },\n        \"order_id.cardinality\" : {\n          \"type\" : \"long\"\n        },\n        \"customer_id\" : {\n          \"type\" : \"keyword\"\n        },\n        \"total_quantity.max\" : {\n          \"type\" : \"integer\"\n        },\n        \"order_id\" : {\n          \"type\" : \"object\"\n        }\n      }\n    },\n    \"settings\" : {\n      \"index\" : {\n        \"number_of_shards\" : \"1\",\n        \"auto_expand_replicas\" : \"0-1\"\n      }\n    },\n    \"aliases\" : { }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[skip:needs sample data]\n====\n\nIn some instances the deduced mappings might be incompatible with the actual\ndata. For example, numeric overflows might occur or dynamically mapped fields\nmight contain both numbers and strings. To avoid this problem, create your\ndestination index before you start the {transform}. For more information, see\nthe <<indices-create-index,create index API>>.\n\n.API example\n[%collapsible]\n====\nYou can use the information from the {transform} preview to create the\ndestination index. For example:\n\n[source,console]\n--------------------------------------------------\nPUT /ecommerce-customers\n{\n  \"mappings\": {\n    \"properties\": {\n      \"total_quantity.sum\" : {\n        \"type\" : \"double\"\n      },\n      \"total_quantity\" : {\n        \"type\" : \"object\"\n      },\n      \"taxless_total_price\" : {\n        \"type\" : \"object\"\n      },\n      \"taxless_total_price.sum\" : {\n        \"type\" : \"double\"\n      },\n      \"order_id.cardinality\" : {\n        \"type\" : \"long\"\n      },\n      \"customer_id\" : {\n        \"type\" : \"keyword\"\n      },\n      \"total_quantity.max\" : {\n        \"type\" : \"integer\"\n      },\n      \"order_id\" : {\n        \"type\" : \"object\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST\n====\n--\n\n. Start the {transform}.\n+\n--\n\nTIP: Even though resource utilization is automatically adjusted based on the\ncluster load, a {transform} increases search and indexing load on your\ncluster while it runs. If you're experiencing an excessive load, however, you\ncan stop it.\n\nYou can start, stop, reset, and manage {transforms} in {kib}:\n\n[role=\"screenshot\"]\nimage::images/manage-transforms.png[\"Managing {transforms} in {kib}\"]\n\nAlternatively, you can use the\n<<start-transform,start {transforms}>>, <<stop-transform,stop {transforms}>> and \n<<reset-transform, reset {transforms}>> APIs.\n\nIf you reset a {transform}, all checkpoints, states, and the destination index \n(if it was created by the {transform}) are deleted. The {transform} is ready to \nstart again as if it had just been created.\n\n\n.API example\n[%collapsible]\n====\n[source,console]\n--------------------------------------------------\nPOST _transform/ecommerce-customer-transform/_start\n--------------------------------------------------\n// TEST[skip:setup kibana sample data]\n====\n\nTIP: If you chose a batch {transform}, it is a single operation that has a\nsingle checkpoint. You cannot restart it when it's complete. {ctransforms-cap}\ndiffer in that they continually increment and process checkpoints as new source\ndata is ingested.\n\n--\n\n. Explore the data in your new index.\n+\n--\nFor example, use the *Discover* application in {kib}:\n\n[role=\"screenshot\"]\nimage::images/ecommerce-results.png[\"Exploring the new index in {kib}\"]\n\n--\n\n. Optional: Create another {transform}, this time using the `latest` method.\n+\n--\n\nThis method populates the destination index with the latest documents for each\nunique key value. For example, you might want to find the latest orders (sorted\nby the `order_date` field) for each customer or for each country and region.\n\n[role=\"screenshot\"]\nimage::images/ecommerce-latest1.png[\"Creating a latest {transform} in {kib}\"]\n\n.API example\n[%collapsible]\n====\n[source,console]\n--------------------------------------------------\nPOST _transform/_preview\n{\n  \"source\": {\n    \"index\": \"kibana_sample_data_ecommerce\",\n    \"query\": {\n      \"bool\": {\n        \"filter\": {\n          \"term\": {\"currency\": \"EUR\"}\n        }\n      }\n    }\n  },\n  \"latest\": {\n    \"unique_key\": [\"geoip.country_iso_code\", \"geoip.region_name\"],\n    \"sort\": \"order_date\"\n  }\n}\n--------------------------------------------------\n// TEST[skip:set up sample data]\n====\n\nTIP: If the destination index does not exist, it is created the first time you \nstart your {transform}. Unlike pivot {transforms}, however, latest {transforms} \ndo not deduce mapping definitions when they create the index. Instead, they use \ndynamic mappings. To use explicit mappings, create the destination index \nbefore you start the {transform}.\n\n--\n\n. If you do not want to keep a {transform}, you can delete it in\n{kib} or use the <<delete-transform,delete {transform} API>>. By default, when\nyou delete a {transform}, its destination index and {kib} index patterns remain.\n\nNow that you've created simple {transforms} for {kib} sample data, consider\npossible use cases for your own data. For more ideas, see\n<<transform-usage>> and <<transform-examples>>.\n"
}