{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.745586",
        "size": 15221,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-top-hits-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-metrics-top-hits-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-metrics-top-hits-aggregation]]\n=== Top hits aggregation\n++++\n<titleabbrev>Top hits</titleabbrev>\n++++\n\nA `top_hits` metric aggregator keeps track of the most relevant document being aggregated. This aggregator is intended\nto be used as a sub aggregator, so that the top matching documents can be aggregated per bucket.\n\nTIP: We do not recommend using `top_hits` as a top-level aggregation. If you\nwant to group search hits, use the <<collapse-search-results,`collapse`>>\nparameter instead.\n\nThe `top_hits` aggregator can effectively be used to group result sets by certain fields via a bucket aggregator.\nOne or more bucket aggregators determines by which properties a result set get sliced into.\n\n==== Options\n\n* `from` - The offset from the first result you want to fetch.\n* `size` - The maximum number of top matching hits to return per bucket. By default the top three matching hits are returned.\n* `sort` - How the top matching hits should be sorted. By default the hits are sorted by the score of the main query.\n\n==== Supported per hit features\n\nThe top_hits aggregation returns regular search hits, because of this many per hit features can be supported:\n\n* <<highlighting,Highlighting>>\n* <<request-body-search-explain,Explain>>\n* <<named-queries,Named queries>>\n* <<search-fields-param,Search fields>>\n* <<source-filtering,Source filtering>>\n* <<stored-fields,Stored fields>>\n* <<script-fields,Script fields>>\n* <<docvalue-fields,Doc value fields>>\n* <<request-body-search-version,Include versions>>\n* <<request-body-search-seq-no-primary-term,Include Sequence Numbers and Primary Terms>>\n\nIMPORTANT: If you *only* need `docvalue_fields`, `size`, and `sort` then\n<<search-aggregations-metrics-top-metrics>> might be a more efficient choice than the Top Hits Aggregation.\n\n`top_hits` does not support the <<rescore,`rescore`>> parameter. Query rescoring\napplies only to search hits, not aggregation results. To change the scores used\nby aggregations, use a <<query-dsl-function-score-query,`function_score`>> or\n<<query-dsl-script-score-query,`script_score`>> query.\n\n==== Example\n\nIn the following example we group the sales by type and per type we show the last sale.\nFor each sale only the date and price fields are being included in the source.\n\n[source,console]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"top_tags\": {\n      \"terms\": {\n        \"field\": \"type\",\n        \"size\": 3\n      },\n      \"aggs\": {\n        \"top_sales_hits\": {\n          \"top_hits\": {\n            \"sort\": [\n              {\n                \"date\": {\n                  \"order\": \"desc\"\n                }\n              }\n            ],\n            \"_source\": {\n              \"includes\": [ \"date\", \"price\" ]\n            },\n            \"size\": 1\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nPossible response:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"top_tags\": {\n       \"doc_count_error_upper_bound\": 0,\n       \"sum_other_doc_count\": 0,\n       \"buckets\": [\n          {\n             \"key\": \"hat\",\n             \"doc_count\": 3,\n             \"top_sales_hits\": {\n                \"hits\": {\n                   \"total\" : {\n                       \"value\": 3,\n                       \"relation\": \"eq\"\n                   },\n                   \"max_score\": null,\n                   \"hits\": [\n                      {\n                         \"_index\": \"sales\",\n                         \"_id\": \"AVnNBmauCQpcRyxw6ChK\",\n                         \"_source\": {\n                            \"date\": \"2015/03/01 00:00:00\",\n                            \"price\": 200\n                         },\n                         \"sort\": [\n                            1425168000000\n                         ],\n                         \"_score\": null\n                      }\n                   ]\n                }\n             }\n          },\n          {\n             \"key\": \"t-shirt\",\n             \"doc_count\": 3,\n             \"top_sales_hits\": {\n                \"hits\": {\n                   \"total\" : {\n                       \"value\": 3,\n                       \"relation\": \"eq\"\n                   },\n                   \"max_score\": null,\n                   \"hits\": [\n                      {\n                         \"_index\": \"sales\",\n                         \"_id\": \"AVnNBmauCQpcRyxw6ChL\",\n                         \"_source\": {\n                            \"date\": \"2015/03/01 00:00:00\",\n                            \"price\": 175\n                         },\n                         \"sort\": [\n                            1425168000000\n                         ],\n                         \"_score\": null\n                      }\n                   ]\n                }\n             }\n          },\n          {\n             \"key\": \"bag\",\n             \"doc_count\": 1,\n             \"top_sales_hits\": {\n                \"hits\": {\n                   \"total\" : {\n                       \"value\": 1,\n                       \"relation\": \"eq\"\n                   },\n                   \"max_score\": null,\n                   \"hits\": [\n                      {\n                         \"_index\": \"sales\",\n                         \"_id\": \"AVnNBmatCQpcRyxw6ChH\",\n                         \"_source\": {\n                            \"date\": \"2015/01/01 00:00:00\",\n                            \"price\": 150\n                         },\n                         \"sort\": [\n                            1420070400000\n                         ],\n                         \"_score\": null\n                      }\n                   ]\n                }\n             }\n          }\n       ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n// TESTRESPONSE[s/AVnNBmauCQpcRyxw6ChK/$body.aggregations.top_tags.buckets.0.top_sales_hits.hits.hits.0._id/]\n// TESTRESPONSE[s/AVnNBmauCQpcRyxw6ChL/$body.aggregations.top_tags.buckets.1.top_sales_hits.hits.hits.0._id/]\n// TESTRESPONSE[s/AVnNBmatCQpcRyxw6ChH/$body.aggregations.top_tags.buckets.2.top_sales_hits.hits.hits.0._id/]\n\n\n==== Field collapse example\n\nField collapsing or result grouping is a feature that logically groups a result set into groups and per group returns\ntop documents. The ordering of the groups is determined by the relevancy of the first document in a group. In\nElasticsearch this can be implemented via a bucket aggregator that wraps a `top_hits` aggregator as sub-aggregator.\n\nIn the example below we search across crawled webpages. For each webpage we store the body and the domain the webpage\nbelong to. By defining a `terms` aggregator on the `domain` field we group the result set of webpages by domain. The\n`top_hits` aggregator is then defined as sub-aggregator, so that the top matching hits are collected per bucket.\n\nAlso a `max` aggregator is defined which is used by the `terms` aggregator's order feature to return the buckets by\nrelevancy order of the most relevant document in a bucket.\n\n[source,console]\n--------------------------------------------------\nPOST /sales/_search\n{\n  \"query\": {\n    \"match\": {\n      \"body\": \"elections\"\n    }\n  },\n  \"aggs\": {\n    \"top_sites\": {\n      \"terms\": {\n        \"field\": \"domain\",\n        \"order\": {\n          \"top_hit\": \"desc\"\n        }\n      },\n      \"aggs\": {\n        \"top_tags_hits\": {\n          \"top_hits\": {}\n        },\n        \"top_hit\" : {\n          \"max\": {\n            \"script\": {\n              \"source\": \"_score\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nAt the moment the `max` (or `min`) aggregator is needed to make sure the buckets from the `terms` aggregator are\nordered according to the score of the most relevant webpage per domain. Unfortunately the `top_hits` aggregator\ncan't be used in the `order` option of the `terms` aggregator yet.\n\n==== top_hits support in a nested or reverse_nested aggregator\n\nIf the `top_hits` aggregator is wrapped in a `nested` or `reverse_nested` aggregator then nested hits are being returned.\nNested hits are in a sense hidden mini documents that are part of regular document where in the mapping a nested field type\nhas been configured. The `top_hits` aggregator has the ability to un-hide these documents if it is wrapped in a `nested`\nor `reverse_nested` aggregator. Read more about nested in the <<nested,nested type mapping>>.\n\nIf nested type has been configured a single document is actually indexed as multiple Lucene documents and they share\nthe same id. In order to determine the identity of a nested hit there is more needed than just the id, so that is why\nnested hits also include their nested identity. The nested identity is kept under the `_nested` field in the search hit\nand includes the array field and the offset in the array field the nested hit belongs to. The offset is zero based.\n\nLet's see how it works with a real sample. Considering the following mapping:\n\n[source,console]\n--------------------------------------------------\nPUT /sales\n{\n  \"mappings\": {\n    \"properties\": {\n      \"tags\": { \"type\": \"keyword\" },\n      \"comments\": {                           <1>\n        \"type\": \"nested\",\n        \"properties\": {\n          \"username\": { \"type\": \"keyword\" },\n          \"comment\": { \"type\": \"text\" }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> The `comments` is an array that holds nested documents under the `product` object.\n\nAnd some documents:\n\n[source,console]\n--------------------------------------------------\nPUT /sales/_doc/1?refresh\n{\n  \"tags\": [ \"car\", \"auto\" ],\n  \"comments\": [\n    { \"username\": \"baddriver007\", \"comment\": \"This car could have better brakes\" },\n    { \"username\": \"dr_who\", \"comment\": \"Where's the autopilot? Can't find it\" },\n    { \"username\": \"ilovemotorbikes\", \"comment\": \"This car has two extra wheels\" }\n  ]\n}\n--------------------------------------------------\n// TEST[continued]\n\nIt's now possible to execute the following `top_hits` aggregation (wrapped in a `nested` aggregation):\n\n[source,console]\n--------------------------------------------------\nPOST /sales/_search\n{\n  \"query\": {\n    \"term\": { \"tags\": \"car\" }\n  },\n  \"aggs\": {\n    \"by_sale\": {\n      \"nested\": {\n        \"path\": \"comments\"\n      },\n      \"aggs\": {\n        \"by_user\": {\n          \"terms\": {\n            \"field\": \"comments.username\",\n            \"size\": 1\n          },\n          \"aggs\": {\n            \"by_nested\": {\n              \"top_hits\": {}\n            }\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n// TEST[s/_search/_search\\?filter_path=aggregations.by_sale.by_user.buckets/]\n\nTop hits response snippet with a nested hit, which resides in the first slot of array field `comments`:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"by_sale\": {\n      \"by_user\": {\n        \"buckets\": [\n          {\n            \"key\": \"baddriver007\",\n            \"doc_count\": 1,\n            \"by_nested\": {\n              \"hits\": {\n                \"total\" : {\n                   \"value\": 1,\n                   \"relation\": \"eq\"\n                },\n                \"max_score\": 0.3616575,\n                \"hits\": [\n                  {\n                    \"_index\": \"sales\",\n                    \"_id\": \"1\",\n                    \"_nested\": {\n                      \"field\": \"comments\",  <1>\n                      \"offset\": 0 <2>\n                    },\n                    \"_score\": 0.3616575,\n                    \"_source\": {\n                      \"comment\": \"This car could have better brakes\", <3>\n                      \"username\": \"baddriver007\"\n                    }\n                  }\n                ]\n              }\n            }\n          }\n          ...\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n<1> Name of the array field containing the nested hit\n<2> Position if the nested hit in the containing array\n<3> Source of the nested hit\n\nIf `_source` is requested then just the part of the source of the nested object is returned, not the entire source of the document.\nAlso stored fields on the *nested* inner object level are accessible via `top_hits` aggregator residing in a `nested` or `reverse_nested` aggregator.\n\nOnly nested hits will have a `_nested` field in the hit, non nested (regular) hits will not have a `_nested` field.\n\nThe information in `_nested` can also be used to parse the original source somewhere else if `_source` isn't enabled.\n\nIf there are multiple levels of nested object types defined in mappings then the `_nested` information can also be hierarchical\nin order to express the identity of nested hits that are two layers deep or more.\n\nIn the example below a nested hit resides in the first slot of the field `nested_grand_child_field` which then resides in\nthe second slow of the `nested_child_field` field:\n\n[source,js]\n--------------------------------------------------\n...\n\"hits\": {\n \"total\" : {\n     \"value\": 2565,\n     \"relation\": \"eq\"\n },\n \"max_score\": 1,\n \"hits\": [\n   {\n     \"_index\": \"a\",\n     \"_id\": \"1\",\n     \"_score\": 1,\n     \"_nested\" : {\n       \"field\" : \"nested_child_field\",\n       \"offset\" : 1,\n       \"_nested\" : {\n         \"field\" : \"nested_grand_child_field\",\n         \"offset\" : 0\n       }\n     }\n     \"_source\": ...\n   },\n   ...\n ]\n}\n...\n--------------------------------------------------\n// NOTCONSOLE\n\n==== Use in pipeline aggregations\n\n`top_hits` can be used in pipeline aggregations that consume a single value per bucket, such as `bucket_selector`\nthat applies per bucket filtering, similar to using a HAVING clause in SQL. This requires setting `size` to 1, and\nspecifying the right path for the value to be passed to the wrapping aggregator. The latter can be a `_source`, a\n`_sort` or a `_score` value. For example:\n\n[source,console]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"top_tags\": {\n      \"terms\": {\n        \"field\": \"type\",\n        \"size\": 3\n      },\n      \"aggs\": {\n        \"top_sales_hits\": {\n          \"top_hits\": {\n            \"sort\": [\n              {\n                \"date\": {\n                  \"order\": \"desc\"\n                }\n              }\n            ],\n            \"_source\": {\n              \"includes\": [ \"date\", \"price\" ]\n            },\n            \"size\": 1\n          }\n        },\n        \"having.top_salary\": {\n          \"bucket_selector\": {\n            \"buckets_path\": {\n              \"tp\": \"top_sales_hits[_source.price]\"\n            },\n            \"script\": \"params.tp < 180\"\n          }\n        }\n      }\n    }\n  }\n}\n\n--------------------------------------------------\n// TEST[setup:sales]\n\nThe `bucket_path` uses the `top_hits` name `top_sales_hits` and a keyword for the field providing the aggregate value,\nnamely `_source` field `price` in the example above. Other options include `top_sales_hits[_sort]`, for filtering on the\nsort value `date` above, and `top_sales_hits[_score]`, for filtering on the score of the top hit.\n"
}