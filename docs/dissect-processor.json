{
    "meta": {
        "timestamp": "2024-11-01T02:49:24.958065",
        "size": 9638,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/dissect-processor.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "dissect-processor",
        "version": "8.15"
    },
    "doc": "[[dissect-processor]]\n=== Dissect processor\n++++\n<titleabbrev>Dissect</titleabbrev>\n++++\n\n\nSimilar to the <<grok-processor,Grok Processor>>, dissect also extracts structured fields out of a single text field\nwithin a document. However unlike the <<grok-processor,Grok Processor>>, dissect does not use\n{wikipedia}/Regular_expression[Regular Expressions]. This allows dissect's syntax to be simple and for\nsome cases faster than the <<grok-processor,Grok Processor>>.\n\nDissect matches a single text field against a defined pattern.\n\nFor example the following pattern:\n[source,txt]\n--------------------------------------------------\n%{clientip} %{ident} %{auth} [%{@timestamp}] \\\"%{verb} %{request} HTTP/%{httpversion}\\\" %{status} %{size}\n--------------------------------------------------\nwill match a log line of this format:\n[source,txt]\n--------------------------------------------------\n1.2.3.4 - - [30/Apr/1998:22:00:52 +0000] \\\"GET /english/venues/cities/images/montpellier/18.gif HTTP/1.0\\\" 200 3171\n--------------------------------------------------\nand result in a document with the following fields:\n[source,js]\n--------------------------------------------------\n\"doc\": {\n  \"_index\": \"_index\",\n  \"_type\": \"_type\",\n  \"_id\": \"_id\",\n  \"_source\": {\n    \"request\": \"/english/venues/cities/images/montpellier/18.gif\",\n    \"auth\": \"-\",\n    \"ident\": \"-\",\n    \"verb\": \"GET\",\n    \"@timestamp\": \"30/Apr/1998:22:00:52 +0000\",\n    \"size\": \"3171\",\n    \"clientip\": \"1.2.3.4\",\n    \"httpversion\": \"1.0\",\n    \"status\": \"200\"\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n// tag::intro-example-explanation[]\nA dissect pattern is defined by the parts of the string that will be discarded. In the previous example, the first part\nto be discarded is a single space. Dissect finds this space, then assigns the value of `clientip` everything up\nuntil that space.\nNext, dissect matches the `[` and then `]` and then assigns `@timestamp` to everything in-between `[` and `]`.\nPaying special attention to the parts of the string to discard will help build successful dissect patterns.\n// end::intro-example-explanation[]\n\nSuccessful matches require all keys in a pattern to have a value. If any of the `%{keyname}` defined in the pattern do\nnot have a value, then an exception is thrown and may be handled by the <<handling-pipeline-failures,`on_failure`>> directive.\nAn empty key `%{}` or a <<dissect-modifier-named-skip-key, named skip key>> can be used to match values, but exclude the value from\nthe final document. All matched values are represented as string data types. The <<convert-processor, convert processor>>\nmay be used to convert to expected data type.\n\nDissect also supports <<dissect-key-modifiers,key modifiers>> that can change dissect's default\nbehavior. For example you can instruct dissect to ignore certain fields, append fields, skip over padding, etc.\nSee <<dissect-key-modifiers, below>> for more information.\n\n[[dissect-options]]\n.Dissect Options\n[options=\"header\"]\n|======\n| Name              | Required  | Default  | Description\n| `field`           | yes       | -        | The field to dissect\n| `pattern`         | yes       | -        | The pattern to apply to the field\n| `append_separator`| no        | \"\" (empty string) | The character(s) that separate the appended fields.\n| `ignore_missing`  | no        | false             | If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document\ninclude::common-options.asciidoc[]\n|======\n\n[source,js]\n--------------------------------------------------\n{\n  \"dissect\": {\n    \"field\": \"message\",\n    \"pattern\" : \"%{clientip} %{ident} %{auth} [%{@timestamp}] \\\"%{verb} %{request} HTTP/%{httpversion}\\\" %{status} %{size}\"\n   }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n[[dissect-key-modifiers]]\n==== Dissect key modifiers\n// tag::dissect-key-modifiers[]\nKey modifiers can change the default behavior for dissection. Key modifiers may be found on the left or right\nof the `%{keyname}` always inside the `%{` and `}`. For example `%{+keyname ->}` has the append and right padding\nmodifiers.\n// end::dissect-key-modifiers[]\n\n[[dissect-key-modifiers-table]]\n.Dissect Key Modifiers\n[options=\"header\"]\n|======\n| Modifier      | Name               | Position       | Example                      | Description                                                  | Details\n| `->`          | Skip right padding | (far) right    | `%{keyname1->}`  | Skips any repeated characters to the right                   | <<dissect-modifier-skip-right-padding,link>>\n| `+`           | Append             | left           | `%{+keyname} %{+keyname}`    | Appends two or more fields together                          | <<dissect-modifier-append-key,link>>\n| `+` with `/n` | Append with order  | left and right | `%{+keyname/2} %{+keyname/1}` | Appends two or more fields together in the order specified   | <<dissect-modifier-append-key-with-order,link>>\n| `?`           | Named skip key     | left           | `%{?ignoreme}`  | Skips the matched value in the output. Same behavior as `%{}`| <<dissect-modifier-named-skip-key,link>>\n| `*` and `&`   | Reference keys     | left           | `%{*r1} %{&r1}`    | Sets the output key as value of `*` and output value of `&`  | <<dissect-modifier-reference-keys,link>>\n|======\n\n[[dissect-modifier-skip-right-padding]]\n===== Right padding modifier (`->`)\n\n// tag::dissect-modifier-skip-right-padding[]\nThe algorithm that performs the dissection is very strict in that it requires all characters in the pattern to match\nthe source string. For example, the pattern `%{fookey} %{barkey}` (1 space), will match the string \"foo{nbsp}bar\"\n(1 space), but will not match the string \"foo{nbsp}{nbsp}bar\" (2 spaces) since the pattern has only 1 space and the\nsource string has 2 spaces.\n\nThe right padding modifier helps with this case. Adding the right padding modifier to the pattern `%{fookey->} %{barkey}`,\nIt will now will match \"foo{nbsp}bar\" (1 space) and \"foo{nbsp}{nbsp}bar\" (2 spaces)\nand even \"foo{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}bar\" (10 spaces).\n\nUse the right padding modifier to allow for repetition of the characters after a `%{keyname->}`.\n\nThe right padding modifier may be placed on any key with any other modifiers. It should always be the furthest right\nmodifier. For example: `%{+keyname/1->}` and `%{->}`\n// end::dissect-modifier-skip-right-padding[]\n\nRight padding modifier example\n|======\n| *Pattern* | `%{ts->} %{level}`\n| *Input*   |  1998-08-10T17:15:42,466{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}WARN\n| *Result*  a|\n* ts = 1998-08-10T17:15:42,466\n* level = WARN\n|======\n\n// tag::dissect-modifier-empty-right-padding[]\nThe right padding modifier may be used with an empty key to help skip unwanted data. For example, the same input string, but wrapped with brackets requires the use of an empty right padded key to achieve the same result.\n// end::dissect-modifier-empty-right-padding[]\n\nRight padding modifier with empty key example\n|======\n| *Pattern* | `[%{ts}]%{->}[%{level}]`\n| *Input*   | [1998-08-10T17:15:42,466]{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}[WARN]\n| *Result*  a|\n* ts = 1998-08-10T17:15:42,466\n* level = WARN\n|======\n\n[[append-modifier]]\n===== Append modifier (`+`)\n[[dissect-modifier-append-key]]\n// tag::append-modifier[]\nDissect supports appending two or more results together for the output.\nValues are appended left to right. An append separator can be specified.\nIn this example the append_separator is defined as a space.\n// end::append-modifier[]\n\nAppend modifier example\n|======\n| *Pattern* | `%{+name} %{+name} %{+name} %{+name}`\n| *Input*   | john jacob jingleheimer schmidt\n| *Result*  a|\n* name = john jacob jingleheimer schmidt\n|======\n\n\n[[append-order-modifier]]\n===== Append with order modifier (`+` and `/n`)\n[[dissect-modifier-append-key-with-order]]\n// tag::append-order-modifier[]\nDissect supports appending two or more results together for the output.\nValues are appended based on the order defined (`/n`). An append separator can be specified.\nIn this example the append_separator is defined as a comma.\n// end::append-order-modifier[]\n\nAppend with order modifier example\n|======\n| *Pattern* | `%{+name/2} %{+name/4} %{+name/3} %{+name/1}`\n| *Input*   | john jacob jingleheimer schmidt\n| *Result*  a|\n* name = schmidt,john,jingleheimer,jacob\n|======\n\n[[named-skip-key]]\n===== Named skip key (`?`)\n[[dissect-modifier-named-skip-key]]\n// tag::named-skip-key[]\nDissect supports ignoring matches in the final result. This can be done with an empty key `%{}`, but for readability\nit may be desired to give that empty key a name.\n// end::named-skip-key[]\n\nNamed skip key modifier example\n|======\n| *Pattern* | `%{clientip} %{?ident} %{?auth} [%{@timestamp}]`\n| *Input*   | 1.2.3.4 - - [30/Apr/1998:22:00:52 +0000]\n| *Result*  a|\n* clientip = 1.2.3.4\n* @timestamp = 30/Apr/1998:22:00:52 +0000\n|======\n\n[[reference-keys]]\n===== Reference keys (`*` and `&`)\n[[dissect-modifier-reference-keys]]\n// tag::reference-keys[]\nDissect support using parsed values as the key/value pairings for the structured content. Imagine a system that\npartially logs in key/value pairs. Reference keys allow you to maintain that key/value relationship.\n\nReference key modifier example\n|======\n| *Pattern* | `[%{ts}] [%{level}] %{*p1}:%{&p1} %{*p2}:%{&p2}`\n| *Input*   | [2018-08-10T17:15:42,466] [ERR] ip:1.2.3.4 error:REFUSED\n| *Result*  a|\n* ts = 2018-08-10T17:15:42,466\n* level = ERR\n* ip = 1.2.3.4\n* error = REFUSED\n|======\n// end::reference-keys[]\n"
}