{
    "meta": {
        "size": 16944,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "query-dsl-query-string-query",
        "version": "8.15"
    },
    "doc": "[[query-dsl-query-string-query]]\n=== Query string query\n++++\n<titleabbrev>Query string</titleabbrev>\n++++\n\nTIP: This page contains information about the `query_string` query type. For\ninformation about running a search query in {es}, see <<search-your-data>>.\n\nReturns documents based on a provided query string, using a parser with a strict\nsyntax.\n\nThis query uses a <<query-string-syntax,syntax>> to parse and split the provided\nquery string based on operators, such as `AND` or `NOT`. The query\nthen <<analysis,analyzes>> each split text independently before returning\nmatching documents.\n\nYou can use the `query_string` query to create a complex search that includes\nwildcard characters, searches across multiple fields, and more. While versatile,\nthe query is strict and returns an error if the query string includes any\ninvalid syntax.\n\n[WARNING]\n====\nBecause it returns an error for any invalid syntax, we don't recommend using\nthe `query_string` query for search boxes.\n\nIf you don't need to support a query syntax, consider using the\n<<query-dsl-match-query, `match`>> query. If you need the features of a query\nsyntax, use the <<query-dsl-simple-query-string-query,`simple_query_string`>>\nquery, which is less strict.\n====\n\n\n[[query-string-query-ex-request]]\n==== Example request\n\nWhen running the following search, the `query_string` query splits `(new york\ncity) OR (big apple)` into two parts: `new york city` and `big apple`. The\n`content` field's analyzer then independently converts each part into tokens\nbefore returning matching documents. Because the query syntax does not use\nwhitespace as an operator, `new york city` is passed as-is to the analyzer.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\": {\n      \"query\": \"(new york city) OR (big apple)\",\n      \"default_field\": \"content\"\n    }\n  }\n}\n--------------------------------------------------\n\n[[query-string-top-level-params]]\n==== Top-level parameters for `query_string`\n`query`::\n(Required, string) Query string you wish to parse and use for search. See\n<<query-string-syntax>>.\n\n`default_field`::\n+\n--\n(Optional, string) Default field to search if no field is provided in the query\nstring. Supports wildcards (`*`).\n\n\nDefaults to the <<index-query-default-field,`index.query.default_field`>> index\nsetting, which has a default value of `*`. The `*` value extracts all fields\nthat are eligible for term queries and filters the metadata fields. All\nextracted fields are then combined to build a query if no `prefix` is specified.\n\nSearching across all eligible fields does not include <<nested,nested\ndocuments>>. Use a <<query-dsl-nested-query,`nested` query>> to search those\ndocuments.\n\n[[WARNING]]\n====\nFor mappings with a large number of fields, searching across all eligible fields\ncould be expensive.\n\nThere is a limit on the number of fields times terms that can be queried at once.\nIt is defined by the `indices.query.bool.max_clause_count`\n<<search-settings,search setting>>.\n====\n--\n\n`allow_leading_wildcard`::\n(Optional, Boolean) If `true`, the wildcard characters `*` and `?` are allowed\nas the first character of the query string. Defaults to `true`.\n\n`analyze_wildcard`::\n(Optional, Boolean) If `true`, the query attempts to analyze wildcard terms in\nthe query string. Defaults to `false`.\n\n`analyzer`::\n(Optional, string) <<analysis,Analyzer>> used to convert text in the\nquery string into tokens. Defaults to the\n<<specify-index-time-analyzer,index-time analyzer>> mapped for the\n`default_field`. If no analyzer is mapped, the index's default analyzer is used.\n\n`auto_generate_synonyms_phrase_query`::\n(Optional, Boolean) If `true`, <<query-dsl-match-query-phrase,match phrase>>\nqueries are automatically created for multi-term synonyms. Defaults to `true`.\nSee <<query-string-synonyms>> for an example.\n\n`boost`::\n+\n--\n(Optional, float) Floating point number used to decrease or increase the\n<<relevance-scores,relevance scores>> of the query. Defaults to `1.0`.\n\nBoost values are relative to the default value of `1.0`. A boost value between\n`0` and `1.0` decreases the relevance score. A value greater than `1.0`\nincreases the relevance score.\n--\n\n`default_operator`::\n+\n--\n(Optional, string) Default boolean logic used to interpret text in the query\nstring if no operators are specified. Valid values are:\n\n `OR` (Default)::\nFor example, a query string of `capital of Hungary` is interpreted as `capital\nOR of OR Hungary`.\n\n `AND`::\nFor example, a query string of `capital of Hungary` is interpreted as `capital\nAND of AND Hungary`.\n--\n\n`enable_position_increments`::\n(Optional, Boolean) If `true`, enable position increments in queries constructed\nfrom a `query_string` search. Defaults to `true`.\n\n`fields`::\n(Optional, array of strings) Array of fields to search. Supports wildcards\n(`*`).\n+\nYou can use this parameter query to search across multiple fields. See\n<<query-string-multi-field>>.\n\n`fuzziness`::\n(Optional, string) Maximum edit distance allowed for fuzzy matching. For fuzzy\nsyntax, see <<query-string-fuzziness>>.\n\n`fuzzy_max_expansions`::\n(Optional, integer) Maximum number of terms to which the query expands for fuzzy\nmatching. Defaults to `50`.\n\n`fuzzy_prefix_length`::\n(Optional, integer) Number of beginning characters left unchanged for fuzzy\nmatching. Defaults to `0`.\n\n`fuzzy_transpositions`::\n(Optional, Boolean) If `true`, edits for fuzzy matching include\ntranspositions of two adjacent characters (ab \u2192 ba). Defaults to `true`.\n\n`lenient`::\n(Optional, Boolean) If `true`, format-based errors, such as providing a text\nvalue for a <<number,numeric>> field, are ignored. Defaults to `false`.\n\n`max_determinized_states`::\n+\n--\n(Optional, integer) Maximum number of\n{wikipedia}/Deterministic_finite_automaton[automaton states]\nrequired for the query. Default is `10000`.\n\n{es} uses https://lucene.apache.org/core/[Apache Lucene] internally to parse\nregular expressions. Lucene converts each regular expression to a finite\nautomaton containing a number of determinized states.\n\nYou can use this parameter to prevent that conversion from unintentionally\nconsuming too many resources. You may need to increase this limit to run complex\nregular expressions.\n--\n\n`minimum_should_match`::\n(Optional, string) Minimum number of clauses that must match for a document to\nbe returned. See the <<query-dsl-minimum-should-match, `minimum_should_match`\nparameter>> for valid values and more information. See\n<<query-string-min-should-match>> for an example.\n\n`quote_analyzer`::\n+\n--\n(Optional, string) <<analysis,Analyzer>> used to convert quoted text in the\nquery string into tokens. Defaults to the\n<<search-quote-analyzer,`search_quote_analyzer`>> mapped for the\n`default_field`.\n\nFor quoted text, this parameter overrides the analyzer specified in the\n`analyzer` parameter.\n--\n\n`phrase_slop`::\n(Optional, integer) Maximum number of positions allowed between matching tokens\nfor phrases. Defaults to `0`. If `0`, exact phrase matches are required.\nTransposed terms have a slop of `2`.\n\n`quote_field_suffix`::\n+\n--\n(Optional, string) Suffix appended to quoted text in the query string.\n\nYou can use this suffix to use a different analysis method for exact matches.\nSee <<mixing-exact-search-with-stemming>>.\n--\n\n`rewrite`::\n(Optional, string) Method used to rewrite the query. For valid values and more\ninformation, see the <<query-dsl-multi-term-rewrite, `rewrite` parameter>>.\n\n`time_zone`::\n+\n--\n(Optional, string)\n{wikipedia}/List_of_UTC_time_offsets[Coordinated Universal\nTime (UTC) offset] or\n{wikipedia}/List_of_tz_database_time_zones[IANA time zone]\nused to convert `date` values in the query string to UTC.\n\nValid values are ISO 8601 UTC offsets, such as `+01:00` or -`08:00`, and IANA\ntime zone IDs, such as `America/Los_Angeles`.\n\n[NOTE]\n====\nThe `time_zone` parameter does **not** affect the <<date-math,date math>> value\nof `now`. `now` is always the current system time in UTC. However, the\n`time_zone` parameter does convert dates calculated using `now` and\n<<date-math,date math rounding>>. For example, the `time_zone` parameter will\nconvert a value of `now/d`.\n====\n--\n\n[[query-string-query-notes]]\n==== Notes\n\ninclude::query-string-syntax.asciidoc[]\n\n[[query-string-nested]]\n====== Avoid using the `query_string` query for nested documents\n\n`query_string` searches do not return <<nested,nested>> documents. To search\nnested documents, use the <<query-dsl-nested-query, `nested` query>>.\n\n[[query-string-multi-field]]\n====== Search multiple fields\n\nYou can use the `fields` parameter to perform a `query_string` search across\nmultiple fields.\n\nThe idea of running the `query_string` query against multiple fields is to\nexpand each query term to an OR clause like this:\n\n```\nfield1:query_term OR field2:query_term | ...\n```\n\nFor example, the following query\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\": {\n      \"fields\": [ \"content\", \"name\" ],\n      \"query\": \"this AND that\"\n    }\n  }\n}\n--------------------------------------------------\n\nmatches the same words as\n\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\": {\n      \"query\": \"(content:this OR name:this) AND (content:that OR name:that)\"\n    }\n  }\n}\n--------------------------------------------------\n\nSince several queries are generated from the individual search terms,\ncombining them is automatically done using a `dis_max` query with a `tie_breaker`.\nFor example (the `name` is boosted by 5 using `^5` notation):\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\" : {\n      \"fields\" : [\"content\", \"name^5\"],\n      \"query\" : \"this AND that OR thus\",\n      \"tie_breaker\" : 0\n    }\n  }\n}\n--------------------------------------------------\n\nSimple wildcard can also be used to search \"within\" specific inner\nelements of the document. For example, if we have a `city` object with\nseveral fields (or inner object with fields) in it, we can automatically\nsearch on all \"city\" fields:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\" : {\n      \"fields\" : [\"city.*\"],\n      \"query\" : \"this AND that OR thus\"\n    }\n  }\n}\n--------------------------------------------------\n\nAnother option is to provide the wildcard fields search in the query\nstring itself (properly escaping the `*` sign), for example:\n`city.\\*:something`:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\" : {\n      \"query\" : \"city.\\\\*:(this AND that OR thus)\"\n    }\n  }\n}\n--------------------------------------------------\n\nNOTE: Since `\\` (backslash) is a special character in json strings, it needs to\nbe escaped, hence the two backslashes in the above `query_string`.\n\nThe fields parameter can also include pattern based field names,\nallowing to automatically expand to the relevant fields (dynamically\nintroduced fields included). For example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\" : {\n      \"fields\" : [\"content\", \"name.*^5\"],\n      \"query\" : \"this AND that OR thus\"\n    }\n  }\n}\n--------------------------------------------------\n\n[[query-string-multi-field-parms]]\n====== Additional parameters for multiple field searches\n\nWhen running the `query_string` query against multiple fields, the\nfollowing additional parameters are supported.\n\n`type`::\n+\n--\n(Optional, string) Determines how the query matches and scores documents. Valid\nvalues are:\n\n`best_fields` (Default)::\nFinds documents which match any field and uses the highest\n<<relevance-scores,`_score`>> from any matching field. See\n<<type-best-fields>>.\n\n`bool_prefix`::\nCreates a `match_bool_prefix` query on each field and combines the `_score` from\neach field. See <<type-bool-prefix>>.\n\n`cross_fields`::\nTreats fields with the same `analyzer` as though they were one big field. Looks\nfor each word in **any** field. See <<type-cross-fields>>.\n\n`most_fields`::\nFinds documents which match any field and combines the `_score` from each field.\nSee <<type-most-fields>>.\n\n`phrase`::\nRuns a `match_phrase` query on each field and uses the `_score` from the best\nfield. See <<type-phrase>>.\n\n`phrase_prefix`::\nRuns a `match_phrase_prefix` query on each field and uses the `_score` from the\nbest field. See <<type-phrase>>.\n\nNOTE:\nAdditional top-level `multi_match` parameters may be available based on the\n<<multi-match-types,`type`>> value.\n--\n\n[[query-string-synonyms]]\n===== Synonyms and the `query_string` query\n\nThe `query_string` query supports multi-terms synonym expansion with the <<analysis-synonym-graph-tokenfilter,\nsynonym_graph>> token filter. When this filter is used, the parser creates a phrase query for each multi-terms synonyms.\nFor example, the following synonym: `ny, new york` would produce:\n\n`(ny OR (\"new york\"))`\n\nIt is also possible to match multi terms synonyms with conjunctions instead:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n   \"query\": {\n       \"query_string\" : {\n           \"default_field\": \"title\",\n           \"query\" : \"ny city\",\n           \"auto_generate_synonyms_phrase_query\" : false\n       }\n   }\n}\n--------------------------------------------------\n\nThe example above creates a boolean query:\n\n`(ny OR (new AND york)) city`\n\nthat matches documents with the term `ny` or the conjunction `new AND york`.\nBy default the parameter `auto_generate_synonyms_phrase_query` is set to `true`.\n\n[[query-string-min-should-match]]\n===== How `minimum_should_match` works\n\nThe `query_string` splits the query around each operator to create a boolean\nquery for the entire input. You can use `minimum_should_match` to control how\nmany \"should\" clauses in the resulting query should match.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\": {\n      \"fields\": [\n        \"title\"\n      ],\n      \"query\": \"this that thus\",\n      \"minimum_should_match\": 2\n    }\n  }\n}\n--------------------------------------------------\n\nThe example above creates a boolean query:\n\n`(title:this title:that title:thus)~2`\n\nthat matches documents with at least two of the terms `this`, `that` or `thus`\nin the single field `title`.\n\n[[query-string-min-should-match-multi]]\n===== How `minimum_should_match` works for multiple fields\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\": {\n      \"fields\": [\n        \"title\",\n        \"content\"\n      ],\n      \"query\": \"this that thus\",\n      \"minimum_should_match\": 2\n    }\n  }\n}\n--------------------------------------------------\n\nThe example above creates a boolean query:\n\n`((content:this content:that content:thus) | (title:this title:that title:thus))`\n\nthat matches documents with the disjunction max over the fields `title` and\n`content`. Here the `minimum_should_match` parameter can't be applied.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\": {\n      \"fields\": [\n        \"title\",\n        \"content\"\n      ],\n      \"query\": \"this OR that OR thus\",\n      \"minimum_should_match\": 2\n    }\n  }\n}\n--------------------------------------------------\n\nAdding explicit operators forces each term to be considered as a separate clause.\n\nThe example above creates a boolean query:\n\n`((content:this | title:this) (content:that | title:that) (content:thus | title:thus))~2`\n\nthat matches documents with at least two of the three \"should\" clauses, each of\nthem made of the disjunction max over the fields for each term.\n\n[[query-string-min-should-match-cross]]\n===== How `minimum_should_match` works for cross-field searches\n\nA `cross_fields` value in the `type` field indicates fields with the same\nanalyzer are grouped together when the input is analyzed.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"query_string\": {\n      \"fields\": [\n        \"title\",\n        \"content\"\n      ],\n      \"query\": \"this OR that OR thus\",\n      \"type\": \"cross_fields\",\n      \"minimum_should_match\": 2\n    }\n  }\n}\n--------------------------------------------------\n\nThe example above creates a boolean query:\n\n`(blended(terms:[field2:this, field1:this]) blended(terms:[field2:that, field1:that]) blended(terms:[field2:thus, field1:thus]))~2`\n\nthat matches documents with at least two of the three per-term blended queries.\n\n===== Allow expensive queries\nQuery string query can be internally be transformed to a <<query-dsl-prefix-query, `prefix query`>> which means\nthat if the prefix queries are disabled as explained <<prefix-query-allow-expensive-queries, here>> the query will not be\nexecuted and an exception will be thrown.\n"
}