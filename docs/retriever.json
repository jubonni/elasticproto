{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.246069",
        "size": 16666,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/retriever.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "retriever",
        "version": "8.15"
    },
    "doc": "[[retriever]]\n=== Retriever\n\nA retriever is a specification to describe top documents returned from a\nsearch. A retriever replaces other elements of the <<search-search, search API>>\nthat also return top documents such as <<query-dsl, `query`>> and\n<<search-api-knn, `knn`>>. A retriever may have child retrievers where a\nretriever with two or more children is considered a compound retriever. This\nallows for complex behavior to be depicted in a tree-like structure, called\nthe retriever tree, to better clarify the order of operations that occur\nduring a search.\n\n[TIP]\n====\nRefer to <<retrievers-overview>> for a high level overview of the retrievers abstraction.\n====\n\nThe following retrievers are available:\n\n`standard`::\nA <<standard-retriever, retriever>> that replaces the functionality of a traditional <<query-dsl, query>>.\n\n`knn`::\nA <<knn-retriever, retriever>> that replaces the functionality of a <<search-api-knn, knn search>>.\n\n`rrf`::\nA <<rrf-retriever, retriever>> that produces top documents from <<rrf, reciprocal rank fusion (RRF)>>.\n\n`text_similarity_reranker`::\nA <<text-similarity-reranker-retriever, retriever>> that enhances search results by re-ranking documents based on semantic similarity to a specified inference text, using a machine learning model.\n\n[[standard-retriever]]\n==== Standard Retriever\n\nA standard retriever returns top documents from a traditional <<query-dsl, query>>.\n\n===== Parameters:\n\n`query`::\n(Optional, <<query-dsl, query object>>)\n+\nDefines a query to retrieve a set of top documents.\n\n`filter`::\n(Optional, <<query-dsl, query object or list of query objects>>)\n+\nApplies a <<query-dsl-bool-query, boolean query filter>> to this retriever\nwhere all documents must match this query but do not contribute to the score.\n\n`search_after`::\n(Optional, <<search-after, search after object>>)\n+\nDefines a search after object parameter used for pagination.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=terminate_after]\n\n`sort`::\n+\n(Optional, <<sort-search-results, sort object>>)\nA sort object that that specifies the order of matching documents.\n\n`min_score`::\n(Optional, `float`)\n+\nMinimum <<relevance-scores, `_score`>> for matching documents. Documents with a\nlower `_score` are not included in the top documents.\n\n`collapse`::\n(Optional, <<collapse-search-results, collapse object>>)\n+\nCollapses the top documents by a specified key into a single top document per key.\n\n===== Restrictions\n\nWhen a retriever tree contains a compound retriever (a retriever with two or more child\nretrievers) the <<search-after, search after>> parameter is not supported.\n\n[discrete]\n[[standard-retriever-example]]\n==== Example\n\n////\n[source,console]\n----\nPUT /restaurants\n{\n  \"mappings\": {\n    \"properties\": {\n      \"region\": { \"type\": \"keyword\" },\n      \"year\": { \"type\": \"keyword\" },\n      \"vector\": {\n        \"type\": \"dense_vector\",\n        \"dims\": 3\n      }\n    }\n  }\n}\n\nPOST /restaurants/_bulk?refresh\n{\"index\":{}}\n{\"region\": \"Austria\", \"year\": \"2019\", \"vector\": [10, 22, 77]}\n{\"index\":{}}\n{\"region\": \"France\", \"year\": \"2019\", \"vector\": [10, 22, 78]}\n{\"index\":{}}\n{\"region\": \"Austria\", \"year\": \"2020\", \"vector\": [10, 22, 79]}\n{\"index\":{}}\n{\"region\": \"France\", \"year\": \"2020\", \"vector\": [10, 22, 80]}\n----\n// TESTSETUP\n\n[source,console]\n--------------------------------------------------\nDELETE /restaurants\n--------------------------------------------------\n// TEARDOWN\n////\n\n[source,console]\n----\nGET /restaurants/_search\n{\n  \"retriever\": { <1>\n    \"standard\": { <2>\n      \"query\": { <3>\n        \"bool\": { <4>\n          \"should\": [ <5>\n            {\n              \"match\": { <6>\n                \"region\": \"Austria\"\n              }\n            }\n          ],\n          \"filter\": [ <7>\n            {\n              \"term\": { <8>\n                \"year\": \"2019\" <9>\n              }\n            }\n          ]\n        }\n      }\n    }\n  }\n}\n----\n<1> Opens the `retriever` object.\n<2> The `standard` retriever is used for defining traditional {es} queries.\n<3> The entry point for defining the search query.\n<4> The `bool` object allows for combining multiple query clauses logically.\n<5> The `should` array indicates conditions under which a document will match. Documents matching these conditions will increase their relevancy score.\n<6> The `match` object finds documents where the `region` field contains the word \"Austria.\"\n<7> The `filter` array provides filtering conditions that must be met but do not contribute to the relevancy score.\n<8> The `term` object is used for exact matches, in this case, filtering documents by the `year` field.\n<9> The exact value to match in the `year` field.\n\n[[knn-retriever]]\n==== kNN Retriever\n\nA kNN retriever returns top documents from a <<knn-search, k-nearest neighbor search (kNN)>>.\n\n===== Parameters\n\n`field`::\n(Required, string)\n+\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=knn-field]\n\n`query_vector`::\n(Required if `query_vector_builder` is not defined, array of `float`)\n+\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=knn-query-vector]\n\n`query_vector_builder`::\n(Required if `query_vector` is not defined, query vector builder object)\n+\nDefines a <<knn-semantic-search, model>> to build a query vector.\n\n`k`::\n(Required, integer)\n+\nNumber of nearest neighbors to return as top hits. This value must be fewer than\nor equal to `num_candidates`.\n\n`num_candidates`::\n(Required, integer)\n+\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=knn-num-candidates]\n\n`filter`::\n(Optional, <<query-dsl, query object or list of query objects>>)\n+\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=knn-filter]\n\n`similarity`::\n(Optional, float)\n+\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=knn-similarity]\n\n===== Restrictions\n\nThe parameters `query_vector` and `query_vector_builder` cannot be used together.\n\n[discrete]\n[[knn-retriever-example]]\n==== Example\n\n[source,console]\n----\nGET /restaurants/_search\n{\n  \"retriever\": {\n    \"knn\": { <1>\n      \"field\": \"vector\", <2>\n      \"query_vector\": [10, 22, 77], <3>\n      \"k\": 10, <4>\n      \"num_candidates\": 10 <5>\n    }\n  }\n}\n----\n// TEST[continued]\n<1> Configuration for k-nearest neighbor (knn) search, which is based on vector similarity.\n<2> Specifies the field name that contains the vectors.\n<3> The query vector against which document vectors are compared in the `knn` search.\n<4> The number of nearest neighbors to return as top hits. This value must be fewer than or equal to `num_candidates`.\n<5> The size of the initial candidate set from which the final `k` nearest neighbors are selected.\n\n[[rrf-retriever]]\n==== RRF Retriever\n\nAn <<rrf, RRF>> retriever returns top documents based on the RRF formula,\nequally weighting two or more child retrievers.\nReciprocal rank fusion (RRF) is a method for combining multiple result\nsets with different relevance indicators into a single result set.\n\n===== Parameters\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=rrf-retrievers]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=rrf-rank-constant]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=rrf-rank-window-size]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=rrf-filter]\n\n[discrete]\n[[rrf-retriever-example-hybrid]]\n==== Example: Hybrid search\n\nA simple hybrid search example (lexical search + dense vector search) combining a `standard` retriever with a `knn` retriever using RRF:\n\n[source,console]\n----\nGET /restaurants/_search\n{\n  \"retriever\": {\n    \"rrf\": { <1>\n      \"retrievers\": [ <2>\n        {\n          \"standard\": { <3>\n            \"query\": {\n              \"multi_match\": {\n                \"query\": \"Austria\",\n                \"fields\": [\n                  \"city\",\n                  \"region\"\n                ]\n              }\n            }\n          }\n        },\n        {\n          \"knn\": { <4>\n            \"field\": \"vector\",\n            \"query_vector\": [10, 22, 77],\n            \"k\": 10,\n            \"num_candidates\": 10\n          }\n        }\n      ],\n      \"rank_constant\": 1, <5>\n      \"rank_window_size\": 50  <6>\n    }\n  }\n}\n----\n// TEST[continued]\n<1> Defines a retriever tree with an RRF retriever.\n<2> The sub-retriever array.\n<3> The first sub-retriever is a `standard` retriever.\n<4> The second sub-retriever is a `knn` retriever.\n<5> The rank constant for the RRF retriever.\n<6> The rank window size for the RRF retriever.\n\n[discrete]\n[[rrf-retriever-example-hybrid-sparse]]\n==== Example: Hybrid search with sparse vectors\n\nA more complex hybrid search example (lexical search + ELSER sparse vector search + dense vector search) using RRF:\n\n[source,console]\n----\nGET movies/_search\n{\n  \"retriever\": {\n    \"rrf\": {\n      \"retrievers\": [\n        {\n          \"standard\": {\n            \"query\": {\n              \"sparse_vector\": {\n                \"field\": \"plot_embedding\",\n                \"inference_id\": \"my-elser-model\",\n                \"query\": \"films that explore psychological depths\"\n              }\n            }\n          }\n        },\n        {\n          \"standard\": {\n            \"query\": {\n              \"multi_match\": {\n                \"query\": \"crime\",\n                \"fields\": [\n                  \"plot\",\n                  \"title\"\n                ]\n              }\n            }\n          }\n        },\n        {\n          \"knn\": {\n            \"field\": \"vector\",\n            \"query_vector\": [10, 22, 77],\n            \"k\": 10,\n            \"num_candidates\": 10\n          }\n        }\n      ]\n    }\n  }\n}\n----\n// TEST[skip:uses ELSER]\n\n[[text-similarity-reranker-retriever]]\n==== Text Similarity Re-ranker Retriever\n\nThe `text_similarity_reranker` retriever uses an NLP model to improve search results by reordering the top-k documents based on their semantic similarity to the query.\n\n[TIP]\n====\nRefer to <<semantic-reranking>> for a high level overview of semantic re-ranking.\n====\n\n===== Prerequisites\n\nTo use `text_similarity_reranker` you must first set up a `rerank` task using the <<put-inference-api, Create {infer} API>>.\nThe `rerank` task should be set up with a machine learning model that can compute text similarity. Refer to {ml-docs}/ml-nlp-model-ref.html#ml-nlp-model-ref-text-similarity[the Elastic NLP model reference] for a list of third-party text similarity models supported by {es}.\n\nCurrently you can:\n\n* Integrate directly with the <<infer-service-cohere,Cohere Rerank inference endpoint>> using the `rerank` task type\n* Integrate directly with the <<infer-service-google-vertex-ai,Google Vertex AI inference endpoint>> using the `rerank` task type\n* Upload a model to {es} with {eland-docs}/machine-learning.html#ml-nlp-pytorch[Eland] using the `text_similarity` NLP task type.\n** Then set up an <<inference-example-eland,{es} service inference endpoint>> with the `rerank` task type\n** Refer to the <<text-similarity-reranker-retriever-example-eland,example>> on this page for a step-by-step guide.\n\n===== Parameters\n`retriever`::\n(Required, <<retriever, retriever>>)\n+\nThe child retriever that generates the initial set of top documents to be re-ranked.\n\n`field`::\n(Required, `string`)\n+\nThe document field to be used for text similarity comparisons. This field should contain the text that will be evaluated against the `inferenceText`.\n\n`inference_id`::\n(Required, `string`)\n+\nUnique identifier of the inference endpoint created using the {infer} API.\n\n`inference_text`::\n(Required, `string`)\n+\nThe text snippet used as the basis for similarity comparison.\n\n`rank_window_size`::\n(Optional, `int`)\n+\nThe number of top documents to consider in the re-ranking process. Defaults to `10`.\n\n`min_score`::\n(Optional, `float`)\n+\nSets a minimum threshold score for including documents in the re-ranked results. Documents with similarity scores below this threshold will be excluded. Note that score calculations vary depending on the model used.\n\n`filter`::\n(Optional, <<query-dsl, query object or list of query objects>>)\n+\nApplies the specified <<query-dsl-bool-query, boolean query filter>> to the child  <<retriever, retriever>>.\nIf the child retriever already specifies any filters, then this top-level filter is applied in conjuction\nwith the filter defined in the child retriever.\n\n[discrete]\n[[text-similarity-reranker-retriever-example-cohere]]\n==== Example: Cohere Rerank\n\nThis example enables out-of-the-box semantic search by re-ranking top documents using the Cohere Rerank API. This approach eliminate the need to generate and store embeddings for all indexed documents.\nThis requires a <<infer-service-cohere,Cohere Rerank inference endpoint>> using the `rerank` task type.\n\n[source,console]\n----\nGET /index/_search\n{\n   \"retriever\": {\n      \"text_similarity_reranker\": {\n         \"retriever\": {\n            \"standard\": {\n               \"query\": {\n                  \"match_phrase\": {\n                     \"text\": \"landmark in Paris\"\n                  }\n               }\n            }\n         },\n         \"field\": \"text\",\n         \"inference_id\": \"my-cohere-rerank-model\",\n         \"inference_text\": \"Most famous landmark in Paris\",\n         \"rank_window_size\": 100,\n         \"min_score\": 0.5\n      }\n   }\n}\n----\n// TEST[skip:uses ML]\n\n[discrete]\n[[text-similarity-reranker-retriever-example-eland]]\n==== Example: Semantic re-ranking with a Hugging Face model\n\nThe following example uses the `cross-encoder/ms-marco-MiniLM-L-6-v2` model from Hugging Face to rerank search results based on semantic similarity.\nThe model must be uploaded to {es} using https://www.elastic.co/guide/en/elasticsearch/client/eland/current/machine-learning.html#ml-nlp-pytorch[Eland].\n\n[TIP]\n====\nRefer to {ml-docs}/ml-nlp-model-ref.html#ml-nlp-model-ref-text-similarity[the Elastic NLP model reference] for a list of third party text similarity models supported by {es}.\n====\n\nFollow these steps to load the model and create a semantic re-ranker.\n\n. Install Eland using `pip`\n+\n[source,sh]\n----\npython -m pip install eland[pytorch]\n----\n+\n. Upload the model to {es} using Eland. This example assumes you have an Elastic Cloud deployment and an API key. Refer to the https://www.elastic.co/guide/en/elasticsearch/client/eland/current/machine-learning.html#ml-nlp-pytorch-auth[Eland documentation] for more authentication options.\n+\n[source,sh]\n----\neland_import_hub_model \\\n  --cloud-id $CLOUD_ID \\\n  --es-api-key $ES_API_KEY \\\n  --hub-model-id cross-encoder/ms-marco-MiniLM-L-6-v2 \\\n  --task-type text_similarity \\\n  --clear-previous \\\n  --start\n----\n+\n. Create an inference endpoint for the `rerank` task\n+\n[source,console]\n----\nPUT _inference/rerank/my-msmarco-minilm-model\n{\n  \"service\": \"elasticsearch\",\n  \"service_settings\": {\n    \"num_allocations\": 1,\n    \"num_threads\": 1,\n    \"model_id\": \"cross-encoder__ms-marco-minilm-l-6-v2\"\n  }\n}\n----\n// TEST[skip:uses ML]\n+\n. Define a `text_similarity_rerank` retriever.\n+\n[source,console]\n----\nPOST movies/_search\n{\n  \"retriever\": {\n    \"text_similarity_reranker\": {\n      \"retriever\": {\n        \"standard\": {\n          \"query\": {\n            \"match\": {\n              \"genre\": \"drama\"\n            }\n          }\n        }\n      },\n      \"field\": \"plot\",\n      \"inference_id\": \"my-msmarco-minilm-model\",\n      \"inference_text\": \"films that explore psychological depths\"\n    }\n  }\n}\n----\n// TEST[skip:uses ML]\n+\nThis retriever uses a standard `match` query to search the `movie` index for films tagged with the genre \"drama\".\nIt then re-ranks the results based on semantic similarity to the text in the `inference_text` parameter, using the model we uploaded to {es}.\n\n==== Using `from` and `size` with a retriever tree\n\nThe <<search-from-param, `from`>> and <<search-size-param, `size`>>\nparameters are provided globally as part of the general\n<<search-search, search API>>. They are applied to all retrievers in a\nretriever tree unless a specific retriever overrides the `size` parameter\nusing a different parameter such as `rank_window_size`. Though, the final\nsearch hits are always limited to `size`.\n\n==== Using aggregations with a retriever tree\n\n<<search-aggregations, Aggregations>> are globally specified as part of a search request.\nThe query used for an aggregation is the combination of all leaf retrievers as `should`\nclauses in a <<query-dsl-bool-query, boolean query>>.\n\n==== Restrictions on search parameters when specifying a retriever\n\nWhen a retriever is specified as part of a search the following elements are not allowed\nat the top-level and instead are only allowed as elements of specific retrievers:\n\n* <<request-body-search-query, `query`>>\n* <<search-api-knn, `knn`>>\n* <<search-after, `search_after`>>\n* <<request-body-search-terminate-after, `terminate_after`>>\n* <<search-sort-param, `sort`>>\n* <<rescore, `rescore`>>\n"
}