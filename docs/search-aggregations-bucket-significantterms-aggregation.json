{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.444067",
        "size": 29812,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "search-aggregations-bucket-significantterms-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-significantterms-aggregation]]\n=== Significant terms aggregation\n++++\n<titleabbrev>Significant terms</titleabbrev>\n++++\n\nAn aggregation that returns interesting or unusual occurrences of terms in a set.\n\n.Example use cases:\n* Suggesting \"H5N1\" when users search for \"bird flu\" in text\n* Identifying the merchant that is the \"common point of compromise\" from the transaction history of credit card owners reporting loss\n* Suggesting keywords relating to stock symbol $ATI for an automated news classifier\n* Spotting the fraudulent doctor who is diagnosing more than their fair share of whiplash injuries\n* Spotting the tire manufacturer who has a disproportionate number of blow-outs\n\nIn all these cases the terms being selected are not simply the most popular terms in a set.\nThey are the terms that have undergone a significant change in popularity measured between a _foreground_ and _background_ set.\nIf the term \"H5N1\" only exists in 5 documents in a 10 million document index and yet is found in 4 of the 100 documents that make up a user's search results\nthat is significant and probably very relevant to their search. 5/10,000,000 vs 4/100 is a big swing in frequency.\n\n//////////////////////////\n\n[source,console]\n--------------------------------------------------\nPUT /reports\n{\n  \"mappings\": {\n    \"properties\": {\n      \"force\": {\n        \"type\": \"keyword\"\n      },\n      \"crime_type\": {\n        \"type\": \"keyword\"\n      }\n    }\n  }\n}\n\nPOST /reports/_bulk?refresh\n{\"index\":{\"_id\":0}}\n{\"force\": \"British Transport Police\", \"crime_type\": \"Bicycle theft\"}\n{\"index\":{\"_id\":1}}\n{\"force\": \"British Transport Police\", \"crime_type\": \"Bicycle theft\"}\n{\"index\":{\"_id\":2}}\n{\"force\": \"British Transport Police\", \"crime_type\": \"Bicycle theft\"}\n{\"index\":{\"_id\":3}}\n{\"force\": \"British Transport Police\", \"crime_type\": \"Robbery\"}\n{\"index\":{\"_id\":4}}\n{\"force\": \"Metropolitan Police Service\", \"crime_type\": \"Robbery\"}\n{\"index\":{\"_id\":5}}\n{\"force\": \"Metropolitan Police Service\", \"crime_type\": \"Bicycle theft\"}\n{\"index\":{\"_id\":6}}\n{\"force\": \"Metropolitan Police Service\", \"crime_type\": \"Robbery\"}\n{\"index\":{\"_id\":7}}\n{\"force\": \"Metropolitan Police Service\", \"crime_type\": \"Robbery\"}\n\n-------------------------------------------------\n// TESTSETUP\n\n//////////////////////////\n\n==== Single-set analysis\n\nIn the simplest case, the _foreground_ set of interest is the search results matched by a query and the _background_\nset used for statistical comparisons is the index or indices from which the results were gathered.\n\nExample:\n\n[source,console,id=significantterms-aggregation-example]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"terms\": { \"force\": [ \"British Transport Police\" ] }\n  },\n  \"aggregations\": {\n    \"significant_crime_types\": {\n      \"significant_terms\": { \"field\": \"crime_type\" }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"significant_crime_types\": {\n      \"doc_count\": 47347,\n      \"bg_count\": 5064554,\n      \"buckets\": [\n        {\n          \"key\": \"Bicycle theft\",\n          \"doc_count\": 3640,\n          \"score\": 0.371235374214817,\n          \"bg_count\": 66799\n        }\n              ...\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n// TESTRESPONSE[s/: (0\\.)?[0-9]+/: $body.$_path/]\n\nWhen querying an index of all crimes from all police forces, what these results show is that the British Transport Police force\nstand out as a force dealing with a disproportionately large number of bicycle thefts. Ordinarily, bicycle thefts represent only 1% of crimes (66799/5064554)\nbut for the British Transport Police, who handle crime on railways and stations, 7% of crimes (3640/47347) is\na bike theft. This is a significant seven-fold increase in frequency and so this anomaly was highlighted as the top crime type.\n\nThe problem with using a query to spot anomalies is it only gives us one subset to use for comparisons.\nTo discover all the other police forces' anomalies we would have to repeat the query for each of the different forces.\n\nThis can be a tedious way to look for unusual patterns in an index.\n\n\n\n==== Multi-set analysis\nA simpler way to perform analysis across multiple categories is to use a parent-level aggregation to segment the data ready for analysis.\n\n\nExample using a parent aggregation for segmentation:\n\n[source,console,id=significantterms-aggregation-multiset--example]\n--------------------------------------------------\nGET /_search\n{\n  \"aggregations\": {\n    \"forces\": {\n      \"terms\": { \"field\": \"force\" },\n      \"aggregations\": {\n        \"significant_crime_types\": {\n          \"significant_terms\": { \"field\": \"crime_type\" }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n ...\n \"aggregations\": {\n    \"forces\": {\n        \"doc_count_error_upper_bound\": 1375,\n        \"sum_other_doc_count\": 7879845,\n        \"buckets\": [\n            {\n                \"key\": \"Metropolitan Police Service\",\n                \"doc_count\": 894038,\n                \"significant_crime_types\": {\n                    \"doc_count\": 894038,\n                    \"bg_count\": 5064554,\n                    \"buckets\": [\n                        {\n                            \"key\": \"Robbery\",\n                            \"doc_count\": 27617,\n                            \"score\": 0.0599,\n                            \"bg_count\": 53182\n                        }\n                        ...\n                    ]\n                }\n            },\n            {\n                \"key\": \"British Transport Police\",\n                \"doc_count\": 47347,\n                \"significant_crime_types\": {\n                    \"doc_count\": 47347,\n                    \"bg_count\": 5064554,\n                    \"buckets\": [\n                        {\n                            \"key\": \"Bicycle theft\",\n                            \"doc_count\": 3640,\n                            \"score\": 0.371,\n                            \"bg_count\": 66799\n                        }\n                        ...\n                    ]\n                }\n            }\n        ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n// TESTRESPONSE[s/: (0\\.)?[0-9]+/: $body.$_path/]\n// TESTRESPONSE[s/: \"[^\"]*\"/: $body.$_path/]\n\nNow we have anomaly detection for each of the police forces using a single request.\n\nWe can use other forms of top-level aggregations to segment our data, for example segmenting by geographic\narea to identify unusual hot-spots of a particular crime type:\n\n[source,console,id=significantterms-aggregation-hotspot-example]\n--------------------------------------------------\nGET /_search\n{\n  \"aggs\": {\n    \"hotspots\": {\n      \"geohash_grid\": {\n        \"field\": \"location\",\n        \"precision\": 5\n      },\n      \"aggs\": {\n        \"significant_crime_types\": {\n          \"significant_terms\": { \"field\": \"crime_type\" }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThis example uses the `geohash_grid` aggregation to create result buckets that represent geographic areas, and inside each\nbucket we can identify anomalous levels of a crime type in these tightly-focused areas e.g.\n\n* Airports exhibit unusual numbers of weapon confiscations\n* Universities show uplifts of bicycle thefts\n\nAt a higher geohash_grid zoom-level with larger coverage areas we would start to see where an entire police-force may be\ntackling an unusual volume of a particular crime type.\n\n\nObviously a time-based top-level segmentation would help identify current trends for each point in time\nwhere a simple `terms` aggregation would typically show the very popular \"constants\" that persist across all time slots.\n\n\n\n.How are the scores calculated?\n**********************************\nThe numbers returned for scores are primarily intended for ranking different suggestions sensibly rather than something easily understood by end users. The scores are derived from the doc frequencies in _foreground_ and _background_ sets. In brief, a term is considered significant if there is a noticeable difference in the frequency in which a term appears in the subset and in the background. The way the terms are ranked can be configured, see \"Parameters\" section.\n\n**********************************\n\n\n==== Use on free-text fields\n\nThe significant_terms aggregation can be used effectively on tokenized free-text fields to suggest:\n\n* keywords for refining end-user searches\n* keywords for use in percolator queries\n\nWARNING: Picking a free-text field as the subject of a significant terms analysis can be expensive! It will attempt\nto load every unique word into RAM. It is recommended to only use this on smaller indices.\n\n.Use the _\"like this but not this\"_ pattern\n**********************************\nYou can spot mis-categorized content by first searching a structured field e.g. `category:adultMovie` and use significant_terms on the\nfree-text \"movie_description\" field. Take the suggested words (I'll leave them to your imagination) and then search for all movies NOT marked as category:adultMovie but containing these keywords.\nYou now have a ranked list of badly-categorized movies that you should reclassify or at least remove from the \"familyFriendly\" category.\n\nThe significance score from each term can also provide a useful `boost` setting to sort matches.\nUsing the `minimum_should_match` setting of the `terms` query with the keywords will help control the balance of precision/recall in the result set i.e\na high setting would have a small number of relevant results packed full of keywords and a setting of \"1\" would produce a more exhaustive results set with all documents containing _any_ keyword.\n\n**********************************\n\n[TIP]\n============\n.Show significant_terms in context\n\nFree-text significant_terms are much more easily understood when viewed in context. Take the results of `significant_terms` suggestions from a\nfree-text field and use them in a `terms` query on the same field with a `highlight` clause to present users with example snippets of documents. When the terms\nare presented unstemmed, highlighted, with the right case, in the right order and with some context, their significance/meaning is more readily apparent.\n============\n\n==== Custom background sets\n\nOrdinarily, the foreground set of documents is \"diffed\" against a background set of all the documents in your index.\nHowever, sometimes it may prove useful to use a narrower background set as the basis for comparisons.\nFor example, a query on documents relating to \"Madrid\" in an index with content from all over the world might reveal that \"Spanish\"\nwas a significant term. This may be true but if you want some more focused terms you could use a `background_filter`\non the term 'spain' to establish a narrower set of documents as context. With this as a background \"Spanish\" would now\nbe seen as commonplace and therefore not as significant as words like \"capital\" that relate more strongly with Madrid.\nNote that using a background filter will slow things down - each term's background frequency must now be derived on-the-fly from filtering posting lists rather than reading the index's pre-computed count for a term.\n\n==== Limitations\n\n===== Significant terms must be indexed values\nUnlike the terms aggregation it is currently not possible to use script-generated terms for counting purposes.\nBecause of the way the significant_terms aggregation must consider both _foreground_ and _background_ frequencies\nit would be prohibitively expensive to use a script on the entire index to obtain background frequencies for comparisons.\nAlso DocValues are not supported as sources of term data for similar reasons.\n\n===== No analysis of floating point fields\nFloating point fields are currently not supported as the subject of significant_terms analysis.\nWhile integer or long fields can be used to represent concepts like bank account numbers or category numbers which\ncan be interesting to track, floating point fields are usually used to represent quantities of something.\nAs such, individual floating point terms are not useful for this form of frequency analysis.\n\n===== Use as a parent aggregation\nIf there is the equivalent of a `match_all` query or no query criteria providing a subset of the index the significant_terms aggregation should not be used as the\ntop-most aggregation - in this scenario the _foreground_ set is exactly the same as the _background_ set and\nso there is no difference in document frequencies to observe and from which to make sensible suggestions.\n\nAnother consideration is that the significant_terms aggregation produces many candidate results at shard level\nthat are only later pruned on the reducing node once all statistics from all shards are merged. As a result,\nit can be inefficient and costly in terms of RAM to embed large child aggregations under a significant_terms\naggregation that later discards many candidate terms. It is advisable in these cases to perform two searches - the first to provide a rationalized list of\nsignificant_terms and then add this shortlist of terms to a second query to go back and fetch the required child aggregations.\n\n===== Approximate counts\nThe counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and\nas such may be:\n\n* low if certain shards did not provide figures for a given term in their top sample\n* high when considering the background frequency as it may count occurrences found in deleted documents\n\nLike most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.\nHowever, the `size` and `shard size` settings covered in the next section provide tools to help control the accuracy levels.\n\n[[significantterms-aggregation-parameters]]\n==== Parameters\n\n===== JLH score\nThe JLH score can be used as a significance score by adding the parameter\n\n[source,js]\n--------------------------------------------------\n\n\t \"jlh\": {\n\t }\n--------------------------------------------------\n// NOTCONSOLE\n\nThe scores are derived from the doc frequencies in _foreground_ and _background_ sets. The _absolute_ change in popularity (foregroundPercent - backgroundPercent) would favor common terms whereas the _relative_ change in popularity (foregroundPercent/ backgroundPercent) would favor rare terms. Rare vs common is essentially a precision vs recall balance and so the absolute and relative changes are multiplied to provide a sweet spot between precision and recall.\n\n===== Mutual information\nMutual information as described in \"Information Retrieval\", Manning et al., Chapter 13.5.1 can be used as significance score by adding the parameter\n\n[source,js]\n--------------------------------------------------\n\n\t \"mutual_information\": {\n\t      \"include_negatives\": true\n\t }\n--------------------------------------------------\n// NOTCONSOLE\n\nMutual information does not differentiate between terms that are descriptive for the subset or for documents outside the subset. The significant terms therefore can contain terms that appear more or less frequent in the subset than outside the subset. To filter out the terms that appear less often in the subset than in documents outside the subset, `include_negatives` can be set to `false`.\n\nPer default, the assumption is that the documents in the bucket are also contained in the background. If instead you defined a custom background filter that represents a different set of documents that you want to compare to, set\n\n[source,js]\n--------------------------------------------------\n\n\"background_is_superset\": false\n--------------------------------------------------\n// NOTCONSOLE\n\n===== Chi square\nChi square as described in \"Information Retrieval\", Manning et al., Chapter 13.5.2 can be used as significance score by adding the parameter\n\n[source,js]\n--------------------------------------------------\n\n\t \"chi_square\": {\n\t }\n--------------------------------------------------\n// NOTCONSOLE\nChi square behaves like mutual information and can be configured with the same parameters `include_negatives` and `background_is_superset`.\n\n\n===== Google normalized distance\nGoogle normalized distance as described in https://arxiv.org/pdf/cs/0412098v3.pdf[\"The Google Similarity Distance\", Cilibrasi and Vitanyi, 2007] can be used as significance score by adding the parameter\n\n[source,js]\n--------------------------------------------------\n\n\t \"gnd\": {\n\t }\n--------------------------------------------------\n// NOTCONSOLE\n`gnd` also accepts the `background_is_superset` parameter.\n\n[role=\"xpack\"]\n[[p-value-score]]\n===== p-value score\n\nThe p-value is the probability of obtaining test results at least as extreme as \nthe results actually observed, under the assumption that the null hypothesis is \ncorrect. The p-value is calculated assuming that the foreground set and the \nbackground set are independent \nhttps://en.wikipedia.org/wiki/Bernoulli_trial[Bernoulli trials], with the null \nhypothesis that the probabilities are the same.\n\n====== Example usage\n\nThis example calculates the p-value score for terms `user_agent.version` given \nthe foreground set of \"ended in failure\" versus \"NOT ended in failure\".\n\n`\"background_is_superset\": false` indicates that the background set does \nnot contain the counts of the foreground set as they are filtered out.\n\n`\"normalize_above\": 1000` facilitates returning consistent significance results\nat various scales. `1000` indicates that term counts greater than `1000` are\nscaled down by a factor of `1000/term_count`.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        {\n          \"term\": {\n            \"event.outcome\": \"failure\"\n          }\n        },\n        {\n          \"range\": {\n            \"@timestamp\": {\n              \"gte\": \"2021-02-01\",\n              \"lt\": \"2021-02-04\"\n            }\n          }\n        },\n        {\n          \"term\": {\n            \"service.name\": {\n              \"value\": \"frontend-node\"\n            }\n          }\n        }\n      ]\n    }\n  },\n  \"aggs\": {\n    \"failure_p_value\": {\n      \"significant_terms\": {\n        \"field\": \"user_agent.version\",\n        \"background_filter\": {\n          \"bool\": {\n            \"must_not\": [\n              {\n                \"term\": {\n                  \"event.outcome\": \"failure\"\n                }\n              }\n            ],\n            \"filter\": [\n              {\n                \"range\": {\n                  \"@timestamp\": {\n                    \"gte\": \"2021-02-01\",\n                    \"lt\": \"2021-02-04\"\n                  }\n                }\n              },\n              {\n                \"term\": {\n                  \"service.name\": {\n                    \"value\": \"frontend-node\"\n                  }\n                }\n              }\n            ]\n          }\n        },\n        \"p_value\": {\"background_is_superset\": false, \"normalize_above\": 1000}\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search?size=0/]\n\n===== Percentage\nA simple calculation of the number of documents in the foreground sample with a term divided by the number of documents in the background with the term.\nBy default this produces a score greater than zero and less than one.\n\nThe benefit of this heuristic is that the scoring logic is simple to explain to anyone familiar with a \"per capita\" statistic. However, for fields with high cardinality there is a tendency for this heuristic to select the rarest terms such as typos that occur only once because they score 1/1 = 100%.\n\nIt would be hard for a seasoned boxer to win a championship if the prize was awarded purely on the basis of percentage of fights won - by these rules a newcomer with only one fight under their belt would be impossible to beat.\nMultiple observations are typically required to reinforce a view so it is recommended in these cases to set both `min_doc_count` and `shard_min_doc_count` to a higher value such as 10 in order to filter out the low-frequency terms that otherwise take precedence.\n\n[source,js]\n--------------------------------------------------\n\n\t \"percentage\": {\n\t }\n--------------------------------------------------\n// NOTCONSOLE\n\n===== Which one is best?\n\n\nRoughly, `mutual_information` prefers high frequent terms even if they occur also frequently in the background. For example, in an analysis of natural language text this might lead to selection of stop words. `mutual_information` is unlikely to select very rare terms like misspellings. `gnd` prefers terms with a high co-occurrence and avoids selection of stopwords. It might be better suited for synonym detection. However, `gnd` has a tendency to select very rare terms that are, for example, a result of misspelling. `chi_square` and `jlh` are somewhat in-between.\n\nIt is hard to say which one of the different heuristics will be the best choice as it depends on what the significant terms are used for (see for example http://courses.ischool.berkeley.edu/i256/f06/papers/yang97comparative.pdf[Yang and Pedersen, \"A Comparative Study on Feature Selection in Text Categorization\", 1997] for a study on using significant terms for feature selection for text classification).\n\nIf none of the above measures suits your usecase than another option is to implement a custom significance measure:\n\n===== Scripted\nCustomized scores can be implemented via a script:\n\n[source,js]\n--------------------------------------------------\n\n\t    \"script_heuristic\": {\n              \"script\": {\n\t        \"lang\": \"painless\",\n\t        \"source\": \"params._subset_freq/(params._superset_freq - params._subset_freq + 1)\"\n\t      }\n            }\n--------------------------------------------------\n// NOTCONSOLE\nScripts can be inline (as in above example), indexed or stored on disk. For details on the options, see <<modules-scripting, script documentation>>.\n\nAvailable parameters in the script are\n\n[horizontal]\n`_subset_freq`:: Number of documents the term appears in the subset.\n`_superset_freq`:: Number of documents the term appears in the superset.\n`_subset_size`:: Number of documents in the subset.\n`_superset_size`:: Number of documents in the superset.\n\n[[sig-terms-shard-size]]\n===== Size & Shard Size\n\nThe `size` parameter can be set to define how many term buckets should be returned out of the overall terms list. By\ndefault, the node coordinating the search process will request each shard to provide its own top term buckets\nand once all shards respond, it will reduce the results to the final list that will then be returned to the client.\nIf the number of unique terms is greater than `size`, the returned list can be slightly off and not accurate\n(it could be that the term counts are slightly off and it could even be that a term that should have been in the top\nsize buckets was not returned).\n\nTo ensure better accuracy a multiple of the final `size` is used as the number of terms to request from each shard\n(`2 * (size * 1.5 + 10)`). To take manual control of this setting the `shard_size` parameter\ncan be used to control the volumes of candidate terms produced by each shard.\n\nLow-frequency terms can turn out to be the most interesting ones once all results are combined so the\nsignificant_terms aggregation can produce higher-quality results when the `shard_size` parameter is set to\nvalues significantly higher than the `size` setting. This ensures that a bigger volume of promising candidate terms are given\na consolidated review by the reducing node before the final selection. Obviously large candidate term lists\nwill cause extra network traffic and RAM usage so this is quality/cost trade off that needs to be balanced. If `shard_size` is set to -1 (the default) then `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.\n\n\nNOTE:   `shard_size` cannot be smaller than `size` (as it doesn't make much sense). When it is, Elasticsearch will\n        override it and reset it to be equal to `size`.\n\n===== Minimum document count\n\nIt is possible to only return terms that match more than a configured number of hits using the `min_doc_count` option:\n\n[source,console,id=significantterms-aggregation-min-document-example]\n--------------------------------------------------\nGET /_search\n{\n  \"aggs\": {\n    \"tags\": {\n      \"significant_terms\": {\n        \"field\": \"tag\",\n        \"min_doc_count\": 10\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThe above aggregation would only return tags which have been found in 10 hits or more. Default value is `3`.\n\n\n\n\nTerms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step. However, the shard does not have the information about the global term frequencies available. The decision if a term is added to a candidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word. The `min_doc_count` criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the term as a candidate is made without being very _certain_ about if the term will actually reach the required `min_doc_count`. This might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated the candidate lists. To avoid this, the `shard_size` parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.\n\n\n[[search-aggregations-bucket-significantterms-shard-min-doc-count]]\n===== `shard_min_doc_count`\n\ninclude::terms-aggregation.asciidoc[tag=min-doc-count]\n\nWARNING: Setting `min_doc_count` to `1` is generally not advised as it tends to return terms that\n         are typos or other bizarre curiosities. Finding more than one instance of a term helps\n         reinforce that, while still rare, the term was not the result of a one-off accident. The\n         default value of 3 is used to provide a minimum weight-of-evidence.\n         Setting `shard_min_doc_count` too high will cause significant candidate terms to be filtered out on a shard level. This value should be set much lower than `min_doc_count/#shards`.\n\n\n\n===== Custom background context\n\nThe default source of statistical information for background term frequencies is the entire index and this\nscope can be narrowed through the use of a `background_filter` to focus in on significant terms within a narrower\ncontext:\n\n[source,console,id=significantterms-aggregation-custom-background-example]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"match\": {\n      \"city\": \"madrid\"\n    }\n  },\n  \"aggs\": {\n    \"tags\": {\n      \"significant_terms\": {\n        \"field\": \"tag\",\n        \"background_filter\": {\n          \"term\": { \"text\": \"spain\" }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThe above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing\nterms like \"Spanish\" that are unusual in the full index's worldwide context but commonplace in the subset of documents containing the\nword \"Spain\".\n\nWARNING: Use of background filters will slow the query as each term's postings must be filtered to determine a frequency\n\n\n===== Filtering Values\n\nIt is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the `include` and\n`exclude` parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features\ndescribed in the <<search-aggregations-bucket-terms-aggregation,terms aggregation>> documentation.\n\n==== Collect mode\n\nTo avoid memory issues, the `significant_terms` aggregation always computes child aggregations in `breadth_first` mode.\nA description of the different collection modes can be found in the\n<<search-aggregations-bucket-terms-aggregation-collect, terms aggregation>> documentation.\n\n==== Execution hint\n\nThere are different mechanisms by which terms aggregations can be executed:\n\n - by using field values directly in order to aggregate data per-bucket (`map`)\n - by using <<eager-global-ordinals,global ordinals>> of the field and allocating one bucket per global ordinal (`global_ordinals`)\n\nElasticsearch tries to have sensible defaults so this is something that generally doesn't need to be configured.\n\n`global_ordinals` is the default option for `keyword` field, it uses global ordinals to allocates buckets dynamically\nso memory usage is linear to the number of values of the documents that are part of the aggregation scope.\n\n`map` should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode\nis significantly faster. By default, `map` is only used when running an aggregation on scripts, since they don't have\nordinals.\n\n\n[source,console,id=significantterms-aggregation-execution-hint-example]\n--------------------------------------------------\nGET /_search\n{\n  \"aggs\": {\n    \"tags\": {\n      \"significant_terms\": {\n        \"field\": \"tags\",\n        \"execution_hint\": \"map\" <1>\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> the possible values are `map`, `global_ordinals`\n\nPlease note that Elasticsearch will ignore this execution hint if it is not applicable.\n"
}