{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.155579",
        "size": 6163,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-replace-charfilter.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "analysis-pattern-replace-charfilter",
        "version": "8.15"
    },
    "doc": "[[analysis-pattern-replace-charfilter]]\n=== Pattern replace character filter\n++++\n<titleabbrev>Pattern replace</titleabbrev>\n++++\n\nThe `pattern_replace` character filter uses a regular expression to match\ncharacters which should be replaced with the specified replacement string.\nThe replacement string can refer to capture groups in the regular expression.\n\n[WARNING]\n.Beware of Pathological Regular Expressions\n========================================\n\nThe pattern replace character filter uses\nhttps://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html[Java Regular Expressions].\n\nA badly written regular expression could run very slowly or even throw a\nStackOverflowError and cause the node it is running on to exit suddenly.\n\nRead more about https://www.regular-expressions.info/catastrophic.html[pathological regular expressions and how to avoid them].\n\n========================================\n\n[discrete]\n=== Configuration\n\nThe `pattern_replace` character filter accepts the following parameters:\n\n[horizontal]\n`pattern`::\n\n    A https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html[Java regular expression]. Required.\n\n`replacement`::\n\n    The replacement string, which can reference capture groups using the\n    `$1`..`$9` syntax, as explained\n    https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#appendReplacement-java.lang.StringBuffer-java.lang.String-[here].\n\n`flags`::\n\n    Java regular expression https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#field.summary[flags].\n    Flags should be pipe-separated, eg `\"CASE_INSENSITIVE|COMMENTS\"`.\n\n[discrete]\n=== Example configuration\n\nIn this example, we configure the `pattern_replace` character filter to\nreplace any embedded dashes in numbers with underscores, i.e `123-456-789` ->\n`123_456_789`:\n\n[source,console]\n----------------------------\nPUT my-index-000001\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"my_analyzer\": {\n          \"tokenizer\": \"standard\",\n          \"char_filter\": [\n            \"my_char_filter\"\n          ]\n        }\n      },\n      \"char_filter\": {\n        \"my_char_filter\": {\n          \"type\": \"pattern_replace\",\n          \"pattern\": \"(\\\\d+)-(?=\\\\d)\",\n          \"replacement\": \"$1_\"\n        }\n      }\n    }\n  }\n}\n\nPOST my-index-000001/_analyze\n{\n  \"analyzer\": \"my_analyzer\",\n  \"text\": \"My credit card is 123-456-789\"\n}\n----------------------------\n// TEST[s/\\$1//]\n// the test framework doesn't like the $1 so we just throw it away rather than\n// try to get it to work properly. At least we are still testing the charfilter.\n\nThe above example produces the following terms:\n\n[source,text]\n---------------------------\n[ My, credit, card, is, 123_456_789 ]\n---------------------------\n\nWARNING: Using a replacement string that changes the length of the original\ntext will work for search purposes, but will result in incorrect highlighting,\nas can be seen in the following example.\n\nThis example inserts a space whenever it encounters a lower-case letter\nfollowed by an upper-case letter (i.e. `fooBarBaz` -> `foo Bar Baz`), allowing\ncamelCase words to be queried individually:\n\n[source,console]\n----------------------------\nPUT my-index-000001\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"my_analyzer\": {\n          \"tokenizer\": \"standard\",\n          \"char_filter\": [\n            \"my_char_filter\"\n          ],\n          \"filter\": [\n            \"lowercase\"\n          ]\n        }\n      },\n      \"char_filter\": {\n        \"my_char_filter\": {\n          \"type\": \"pattern_replace\",\n          \"pattern\": \"(?<=\\\\p{Lower})(?=\\\\p{Upper})\",\n          \"replacement\": \" \"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"text\": {\n        \"type\": \"text\",\n        \"analyzer\": \"my_analyzer\"\n      }\n    }\n  }\n}\n\nPOST my-index-000001/_analyze\n{\n  \"analyzer\": \"my_analyzer\",\n  \"text\": \"The fooBarBaz method\"\n}\n----------------------------\n\n/////////////////////\n\n[source,console-result]\n----------------------------\n{\n  \"tokens\": [\n    {\n      \"token\": \"the\",\n      \"start_offset\": 0,\n      \"end_offset\": 3,\n      \"type\": \"<ALPHANUM>\",\n      \"position\": 0\n    },\n    {\n      \"token\": \"foo\",\n      \"start_offset\": 4,\n      \"end_offset\": 6,\n      \"type\": \"<ALPHANUM>\",\n      \"position\": 1\n    },\n    {\n      \"token\": \"bar\",\n      \"start_offset\": 7,\n      \"end_offset\": 9,\n      \"type\": \"<ALPHANUM>\",\n      \"position\": 2\n    },\n    {\n      \"token\": \"baz\",\n      \"start_offset\": 10,\n      \"end_offset\": 13,\n      \"type\": \"<ALPHANUM>\",\n      \"position\": 3\n    },\n    {\n      \"token\": \"method\",\n      \"start_offset\": 14,\n      \"end_offset\": 20,\n      \"type\": \"<ALPHANUM>\",\n      \"position\": 4\n    }\n  ]\n}\n----------------------------\n\n/////////////////////\n\nThe above returns the following terms:\n\n[source,text]\n----------------------------\n[ the, foo, bar, baz, method ]\n----------------------------\n\nQuerying for `bar` will find the document correctly, but highlighting on the\nresult will produce incorrect highlights, because our character filter changed\nthe length of the original text:\n\n[source,console]\n----------------------------\nPUT my-index-000001/_doc/1?refresh\n{\n  \"text\": \"The fooBarBaz method\"\n}\n\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"match\": {\n      \"text\": \"bar\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"text\": {}\n    }\n  }\n}\n----------------------------\n// TEST[continued]\n\nThe output from the above is:\n\n[source,console-result]\n----------------------------\n{\n  \"timed_out\": false,\n  \"took\": $body.took,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.2876821,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"1\",\n        \"_score\": 0.2876821,\n        \"_source\": {\n          \"text\": \"The fooBarBaz method\"\n        },\n        \"highlight\": {\n          \"text\": [\n            \"The foo<em>Ba</em>rBaz method\" <1>\n          ]\n        }\n      }\n    ]\n  }\n}\n----------------------------\n// TESTRESPONSE[s/\"took\".*/\"took\": \"$body.took\",/]\n\n<1> Note the incorrect highlight.\n"
}