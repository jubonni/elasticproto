{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.098579",
        "size": 25588,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-datetime.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-datetime",
        "version": "8.15"
    },
    "doc": "[[painless-datetime]]\n=== Using Datetime in Painless\n\n==== Datetime API\n\nDatetimes in Painless use the standard Java libraries and are available through\nthe Painless <<painless-api-reference-shared, Shared API>>. Most of the classes\nfrom the following Java packages are available to use in Painless scripts:\n\n* <<painless-api-reference-shared-java-time, java.time>>\n* <<painless-api-reference-shared-java-time-chrono, java.time.chrono>>\n* <<painless-api-reference-shared-java-time-format, java.time.format>>\n* <<painless-api-reference-shared-java-time-temporal, java.time.temporal>>\n* <<painless-api-reference-shared-java-time-zone, java.time.zone>>\n\n==== Datetime Representation\n\nDatetimes in Painless are most commonly represented as a numeric value, a\nstring value, or a complex value.\n\nnumeric:: a datetime representation as a number from a starting offset called\nan epoch; in Painless this is typically a <<primitive-types, long>> as\nmilliseconds since an epoch of 1970-01-01 00:00:00 Zulu Time\nstring:: a datetime representation as a sequence of characters defined by\na standard format or a custom format; in Painless this is typically a\n<<string-type, String>> of the standard format\n{wikipedia}/ISO_8601[ISO 8601]\ncomplex:: a datetime representation as a complex type\n(<<reference-types, object>>) that abstracts away internal details of how the\ndatetime is stored and often provides utilities for modification and\ncomparison; in Painless this is typically a\n<<painless-api-reference-shared-ZonedDateTime, ZonedDateTime>>\n\nSwitching between different representations of datetimes is often necessary to\nachieve a script's objective(s). A typical pattern in a script is to switch a\nnumeric or string datetime to a complex datetime, modify or compare the complex\ndatetime, and then switch it back to a numeric or string datetime for storage\nor to return a result.\n\n==== Datetime Parsing and Formatting\n\nDatetime parsing is a switch from a string datetime to a complex datetime, and\ndatetime formatting is a switch from a complex datetime to a string datetime.\n\nA <<painless-api-reference-shared-DateTimeFormatter, DateTimeFormatter>> is a\ncomplex type (<<reference-types, object>>) that defines the allowed sequence\nof characters for a string datetime. Datetime parsing and formatting often\nrequire a DateTimeFormatter. For more information about how to use a\nDateTimeFormatter see the\n{java11-javadoc}/java.base/java/time/format/DateTimeFormatter.html[Java documentation].\n\n===== Datetime Parsing Examples\n\n* parse from milliseconds\n+\n[source,Painless]\n----\nString milliSinceEpochString = \"434931330000\";\nlong milliSinceEpoch = Long.parseLong(milliSinceEpochString);\nInstant instant = Instant.ofEpochMilli(milliSinceEpoch);\nZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.of('Z'));\n----\n+\n* parse from ISO 8601\n+\n[source,Painless]\n----\nString datetime = '1983-10-13T22:15:30Z';\nZonedDateTime zdt = ZonedDateTime.parse(datetime); <1>\n----\n<1> Note the parse method uses ISO 8601 by default.\n+\n* parse from RFC 1123\n+\n[source,Painless]\n----\nString datetime = 'Thu, 13 Oct 1983 22:15:30 GMT';\nZonedDateTime zdt = ZonedDateTime.parse(datetime,\n        DateTimeFormatter.RFC_1123_DATE_TIME); <1>\n----\n<1> Note the use of a built-in DateTimeFormatter.\n+\n* parse from a custom format\n+\n[source,Painless]\n----\nString datetime = 'custom y 1983 m 10 d 13 22:15:30 Z';\nDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\n        \"'custom' 'y' yyyy 'm' MM 'd' dd HH:mm:ss VV\");\nZonedDateTime zdt = ZonedDateTime.parse(datetime, dtf); <1>\n----\n<1> Note the use of a custom DateTimeFormatter.\n\n===== Datetime Formatting Examples\n\n* format to ISO 8601\n+\n[source,Painless]\n----\nZonedDateTime zdt =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nString datetime = zdt.format(DateTimeFormatter.ISO_INSTANT); <1>\n----\n<1> Note the use of a built-in DateTimeFormatter.\n+\n* format to a custom format\n+\n[source,Painless]\n----\nZonedDateTime zdt =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\n        \"'date:' yyyy/MM/dd 'time:' HH:mm:ss\");\nString datetime = zdt.format(dtf); <1>\n----\n<1> Note the use of a custom DateTimeFormatter.\n\n==== Datetime Conversion\n\nDatetime conversion is a switch from a numeric datetime to a complex datetime\nand vice versa.\n\n===== Datetime Conversion Examples\n\n* convert from milliseconds\n+\n[source,Painless]\n----\nlong milliSinceEpoch = 434931330000L;\nInstant instant = Instant.ofEpochMilli(milliSinceEpoch);\nZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.of('Z'));\n----\n+\n* convert to milliseconds\n+\n[source,Painless]\n-----\nZonedDateTime zdt =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nlong milliSinceEpoch = zdt.toInstant().toEpochMilli();\n-----\n\n==== Datetime Pieces\n\nDatetime representations often contain the data to extract individual datetime\npieces such as year, hour, timezone, etc. Use individual pieces of a datetime\nto create a complex datetime, and use a complex datetime to extract individual\npieces.\n\n===== Datetime Pieces Examples\n\n* create a complex datetime from pieces\n+\n[source,Painless]\n----\nint year = 1983;\nint month = 10;\nint day = 13;\nint hour = 22;\nint minutes = 15;\nint seconds = 30;\nint nanos = 0;\nZonedDateTime zdt = ZonedDateTime.of(\n        year, month, day, hour, minutes, seconds, nanos, ZoneId.of('Z'));\n----\n+\n* extract pieces from a complex datetime\n+\n[source,Painless]\n----\nZonedDateTime zdt =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 100, ZoneId.of(tz));\nint year = zdt.getYear();\nint month = zdt.getMonthValue();\nint day = zdt.getDayOfMonth();\nint hour = zdt.getHour();\nint minutes = zdt.getMinute();\nint seconds = zdt.getSecond();\nint nanos = zdt.getNano();\n----\n\n==== Datetime Modification\n\nUse either a numeric datetime or a complex datetime to do modification such as\nadding several seconds to a datetime or subtracting several days from a\ndatetime. Use standard <<painless-operators-numeric, numeric operators>> to\nmodify a numeric datetime. Use\n<<painless-api-reference-shared-ZonedDateTime, methods>> (or fields) to modify\na complex datetime. Note many complex datetimes are immutable so upon\nmodification a new complex datetime is created that requires\n<<variable-assignment, assignment>> or immediate use.\n\n===== Datetime Modification Examples\n\n* Subtract three seconds from a numeric datetime in milliseconds\n+\n[source,Painless]\n----\nlong milliSinceEpoch = 434931330000L;\nmilliSinceEpoch = milliSinceEpoch - 1000L*3L;\n----\n+\n* Add three days to a complex datetime\n+\n[source,Painless]\n----\nZonedDateTime zdt =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nZonedDateTime updatedZdt = zdt.plusDays(3);\n----\n+\n* Subtract 125 minutes from a complex datetime\n+\n[source,Painless]\n----\nZonedDateTime zdt =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nZonedDateTime updatedZdt = zdt.minusMinutes(125);\n----\n+\n* Set the year on a complex datetime\n+\n[source,Painless]\n----\nZonedDateTime zdt =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nZonedDateTime updatedZdt = zdt.withYear(1976);\n----\n\n==== Datetime Difference (Elapsed Time)\n\nUse either two numeric datetimes or two complex datetimes to calculate the\ndifference (elapsed time) between two different datetimes. Use\n<<subtraction-operator, subtraction>> to calculate the difference between two\nnumeric datetimes of the same time unit such as milliseconds. For\ncomplex datetimes there is often a method or another complex type\n(<<reference-types, object>>) available to calculate the difference. Use\n<<painless-api-reference-shared-ChronoUnit, ChronoUnit>>\nto calculate the difference between two complex datetimes if supported.\n\n===== Datetime Difference Examples\n\n* Difference in milliseconds between two numeric datetimes\n+\n[source,Painless]\n----\nlong startTimestamp = 434931327000L;\nlong endTimestamp = 434931330000L;\nlong differenceInMillis = endTimestamp - startTimestamp;\n----\n+\n* Difference in milliseconds between two complex datetimes\n+\n[source,Painless]\n----\nZonedDateTime zdt1 =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 11000000, ZoneId.of('Z'));\nZonedDateTime zdt2 =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 35, 0, ZoneId.of('Z'));\nlong differenceInMillis = ChronoUnit.MILLIS.between(zdt1, zdt2);\n----\n+\n* Difference in days between two complex datetimes\n+\n[source,Painless]\n----\nZonedDateTime zdt1 =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 11000000, ZoneId.of('Z'));\nZonedDateTime zdt2 =\n        ZonedDateTime.of(1983, 10, 17, 22, 15, 35, 0, ZoneId.of('Z'));\nlong differenceInDays = ChronoUnit.DAYS.between(zdt1, zdt2);\n----\n\n==== Datetime Comparison\n\nUse either two numeric datetimes or two complex datetimes to do a datetime\ncomparison. Use standard <<painless-operators-boolean, comparison operators>>\nto compare two numeric datetimes of the same time unit such as milliseconds.\nFor complex datetimes there is often a method or another complex type\n(<<reference-types, object>>) available to do the comparison.\n\n===== Datetime Comparison Examples\n\n* Greater than comparison of two numeric datetimes in milliseconds\n+\n[source,Painless]\n----\nlong timestamp1 = 434931327000L;\nlong timestamp2 = 434931330000L;\n\nif (timestamp1 > timestamp2) {\n   // handle condition\n}\n----\n+\n* Equality comparison of two complex datetimes\n+\n[source,Painless]\n----\nZonedDateTime zdt1 =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nZonedDateTime zdt2 =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\n\nif (zdt1.equals(zdt2)) {\n    // handle condition\n}\n----\n+\n* Less than comparison of two complex datetimes\n+\n[source,Painless]\n----\nZonedDateTime zdt1 =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nZonedDateTime zdt2 =\n        ZonedDateTime.of(1983, 10, 17, 22, 15, 35, 0, ZoneId.of('Z'));\n\nif (zdt1.isBefore(zdt2)) {\n    // handle condition\n}\n----\n+\n* Greater than comparison of two complex datetimes\n+\n[source,Painless]\n----\nZonedDateTime zdt1 =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nZonedDateTime zdt2 =\n        ZonedDateTime.of(1983, 10, 17, 22, 15, 35, 0, ZoneId.of('Z'));\n\nif (zdt1.isAfter(zdt2)) {\n    // handle condition\n}\n----\n\n==== Datetime Zone\n\nBoth string datetimes and complex datetimes have a timezone with a default of\n`UTC`. Numeric datetimes do not have enough explicit information to\nhave a timezone, so `UTC` is always assumed. Use\n<<painless-api-reference-shared-ZonedDateTime, methods>> (or fields) in\nconjunction with a <<painless-api-reference-shared-ZoneId, ZoneId>> to change\nthe timezone for a complex datetime. Parse a string datetime into a complex\ndatetime to change the timezone, and then format the complex datetime back into\na desired string datetime. Note many complex datetimes are immutable so upon\nmodification a new complex datetime is created that requires\n<<variable-assignment, assignment>> or immediate use.\n\n===== Datetime Zone Examples\n\n* Modify the timezone for a complex datetime\n+\n[source,Painless]\n----\nZonedDateTime utc =\n        ZonedDateTime.of(1983, 10, 13, 22, 15, 30, 0, ZoneId.of('Z'));\nZonedDateTime pst = utc.withZoneSameInstant(ZoneId.of('America/Los_Angeles'));\n----\n+\n* Modify the timezone for a string datetime\n+\n[source,Painless]\n----\nString gmtString = 'Thu, 13 Oct 1983 22:15:30 GMT';\nZonedDateTime gmtZdt = ZonedDateTime.parse(gmtString,\n        DateTimeFormatter.RFC_1123_DATE_TIME); <1>\nZonedDateTime pstZdt =\n        gmtZdt.withZoneSameInstant(ZoneId.of('America/Los_Angeles'));\nString pstString = pstZdt.format(DateTimeFormatter.RFC_1123_DATE_TIME);\n----\n<1> Note the use of a built-in DateTimeFormatter.\n\n==== Datetime Input\n\nThere are several common ways datetimes are used as input for a script\ndetermined by the <<painless-contexts, Painless context>>. Typically, datetime\ninput will be accessed from parameters specified by the user, from an original\nsource document, or from an indexed document.\n\n===== Datetime Input From User Parameters\n\nUse the {ref}/modules-scripting-using.html[params section]\nduring script specification to pass in a numeric datetime or string datetime as\na script input. Access to user-defined parameters within a script is dependent\non the Painless context, though, the parameters are most commonly accessible\nthrough an input called `params`.\n\n*Examples*\n\n* Parse a numeric datetime from user parameters to a complex datetime\n+\n** Input:\n+\n[source,JSON]\n----\n...\n\"script\": {\n    ...\n    \"params\": {\n        \"input_datetime\": 434931327000\n    }\n}\n...\n----\n+\n** Script:\n+\n[source,Painless]\n----\nlong inputDateTime = params['input_datetime'];\nInstant instant = Instant.ofEpochMilli(inputDateTime);\nZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.of('Z'));\n----\n+\n* Parse a string datetime from user parameters to a complex datetime\n+\n** Input:\n+\n[source,JSON]\n----\n...\n\"script\": {\n    ...\n    \"params\": {\n        \"input_datetime\": \"custom y 1983 m 10 d 13 22:15:30 Z\"\n    }\n}\n...\n----\n+\n** Script:\n+\n[source,Painless]\n----\nString datetime = params['input_datetime'];\nDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\n        \"'custom' 'y' yyyy 'm' MM 'd' dd HH:mm:ss VV\");\nZonedDateTime zdt = ZonedDateTime.parse(datetime, dtf); <1>\n----\n<1> Note the use of a custom DateTimeFormatter.\n\n===== Datetime Input From a Source Document\n\nUse an original {ref}/mapping-source-field.html[source] document as a script\ninput to access a numeric datetime or string datetime for a specific field\nwithin that document. Access to an original source document within a script is\ndependent on the Painless context and is not always available. An original\nsource document is most commonly accessible through an input called\n`ctx['_source']` or `params['_source']`.\n\n*Examples*\n\n* Parse a numeric datetime from a sourced document to a complex datetime\n+\n** Input:\n+\n[source,JSON]\n----\n{\n  ...\n  \"input_datetime\": 434931327000\n  ...\n}\n----\n+\n** Script:\n+\n[source,Painless]\n----\nlong inputDateTime = ctx['_source']['input_datetime']; <1>\nInstant instant = Instant.ofEpochMilli(inputDateTime);\nZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.of('Z'));\n----\n<1> Note access to `_source` is dependent on the Painless context.\n+\n* Parse a string datetime from a sourced document to a complex datetime\n+\n** Input:\n+\n[source,JSON]\n----\n{\n  ...\n  \"input_datetime\": \"1983-10-13T22:15:30Z\"\n  ...\n}\n----\n+\n** Script:\n+\n[source,Painless]\n----\nString datetime = params['_source']['input_datetime']; <1>\nZonedDateTime zdt = ZonedDateTime.parse(datetime); <2>\n----\n<1> Note access to `_source` is dependent on the Painless context.\n<2> Note the parse method uses ISO 8601 by default.\n\n===== Datetime Input From an Indexed Document\n\nUse an indexed document as a script input to access a complex datetime for a\nspecific field within that document where the field is mapped as a\n{ref}/date.html[standard date] or a {ref}/date_nanos.html[nanosecond date].\nNumeric datetime fields mapped as {ref}/number.html[numeric] and string\ndatetime fields mapped as {ref}/keyword.html[keyword] are accessible through an\nindexed document as well. Access to an indexed document within a script is\ndependent on the Painless context and is not always available. An indexed\ndocument is most commonly accessible through an input called `doc`.\n\n*Examples*\n\n* Format a complex datetime from an indexed document to a string datetime\n+\n** Assumptions:\n+\n*** The field `input_datetime` exists in all indexes as part of the query\n*** All indexed documents contain the field `input_datetime`\n+\n** Mappings:\n+\n[source,JSON]\n----\n{\n  \"mappings\": {\n    ...\n    \"properties\": {\n      ...\n      \"input_datetime\": {\n        \"type\": \"date\"\n      }\n      ...\n    }\n    ...\n  }\n}\n----\n+\n** Script:\n+\n[source,Painless]\n----\nZonedDateTime input = doc['input_datetime'].value;\nString output = input.format(DateTimeFormatter.ISO_INSTANT); <1>\n----\n<1> Note the use of a built-in DateTimeFormatter.\n+\n* Find the difference between two complex datetimes from an indexed document\n+\n** Assumptions:\n+\n*** The fields `start` and `end` may *not* exist in all indexes as part of the\nquery\n*** The fields `start` and `end` may *not* have values in all indexed documents\n+\n** Mappings:\n+\n[source,JSON]\n----\n{\n  \"mappings\": {\n    ...\n    \"properties\": {\n      ...\n      \"start\": {\n        \"type\": \"date\"\n      },\n      \"end\": {\n        \"type\": \"date\"\n      }\n      ...\n    }\n    ...\n  }\n}\n----\n+\n** Script:\n+\n[source,Painless]\n----\nif (doc.containsKey('start') && doc.containsKey('end')) { <1>\n\n    if (doc['start'].size() > 0 && doc['end'].size() > 0) { <2>\n\n        ZonedDateTime start = doc['start'].value;\n        ZonedDateTime end = doc['end'].value;\n        long differenceInMillis = ChronoUnit.MILLIS.between(start, end);\n\n        // handle difference in times\n    } else {\n        // handle fields without values\n    }\n} else {\n    // handle index with missing fields\n}\n----\n<1> When a query's results span multiple indexes, some indexes may not\ncontain a specific field. Use the `containsKey` method call on the `doc` input\nto ensure a field exists as part of the index for the current document.\n<2> Some fields within a document may have no values. Use the `size` method\ncall on a field within the `doc` input to ensure that field has at least one\nvalue for the current document.\n\n==== Datetime Now\n\nUnder most Painless contexts the current datetime, `now`, is not supported.\nThere are two primary reasons for this. The first is that scripts are often run once\nper document, so each time the script is run a different `now` is returned. The\nsecond is that scripts are often run in a distributed fashion without a way to\nappropriately synchronize `now`. Instead, pass in a user-defined parameter with\neither a string datetime or numeric datetime for `now`. A numeric datetime is\npreferred as there is no need to parse it for comparison.\n\n===== Datetime Now Examples\n\n* Use a numeric datetime as `now`\n+\n** Assumptions:\n+\n*** The field `input_datetime` exists in all indexes as part of the query\n*** All indexed documents contain the field `input_datetime`\n+\n** Mappings:\n+\n[source,JSON]\n----\n{\n  \"mappings\": {\n      ...\n      \"properties\": {\n        ...\n        \"input_datetime\": {\n        \"type\": \"date\"\n      }\n      ...\n    }\n    ...\n  }\n}\n----\n+\n** Input:\n+\n[source,JSON]\n----\n...\n\"script\": {\n    ...\n    \"params\": {\n        \"now\": <generated numeric datetime in milliseconds since epoch>\n    }\n}\n...\n----\n+\n** Script:\n+\n[source,Painless]\n----\nlong now = params['now'];\nZonedDateTime inputDateTime = doc['input_datetime'];\nlong millisDateTime = inputDateTime.toInstant().toEpochMilli();\nlong elapsedTime = now - millisDateTime;\n----\n+\n* Use a string datetime as `now`\n+\n** Assumptions:\n+\n*** The field `input_datetime` exists in all indexes as part of the query\n*** All indexed documents contain the field `input_datetime`\n+\n** Mappings:\n+\n[source,JSON]\n----\n{\n  \"mappings\": {\n    ...\n    \"properties\": {\n      ...\n      \"input_datetime\": {\n        \"type\": \"date\"\n      }\n      ...\n    }\n    ...\n  }\n}\n----\n+\n** Input:\n+\n[source,JSON]\n----\n...\n\"script\": {\n    ...\n    \"params\": {\n        \"now\": \"<generated string datetime in ISO-8601>\"\n    }\n}\n...\n----\n+\n** Script:\n+\n[source,Painless]\n----\nString nowString = params['now'];\nZonedDateTime nowZdt = ZonedDateTime.parse(nowString); <1>\nlong now = ZonedDateTime.toInstant().toEpochMilli();\nZonedDateTime inputDateTime = doc['input_datetime'];\nlong millisDateTime = zdt.toInstant().toEpochMilli();\nlong elapsedTime = now - millisDateTime;\n----\n<1> Note this parses the same string datetime every time the script runs. Use a\nnumeric datetime to avoid a significant performance hit.\n\n==== Datetime Examples in Contexts\n\n===== Load the Example Data\n\nRun the following curl commands to load the data necessary for the context\nexamples into an Elasticsearch cluster:\n\n. Create {ref}/mapping.html[mappings] for the sample data.\n+\n[source,console]\n----\nPUT /messages\n{\n  \"mappings\": {\n    \"properties\": {\n      \"priority\": {\n        \"type\": \"integer\"\n      },\n      \"datetime\": {\n        \"type\": \"date\"\n      },\n      \"message\": {\n        \"type\": \"text\"\n      }\n    }\n  }\n}\n----\n+\n. Load the sample data.\n+\n[source,console]\n----\nPOST /_bulk\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"1\" } }\n{ \"priority\": 1, \"datetime\": \"2019-07-17T12:13:14Z\", \"message\": \"m1\" }\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"2\" } }\n{ \"priority\": 1, \"datetime\": \"2019-07-24T01:14:59Z\", \"message\": \"m2\" }\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"3\" } }\n{ \"priority\": 2, \"datetime\": \"1983-10-14T00:36:42Z\", \"message\": \"m3\" }\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"4\" } }\n{ \"priority\": 3, \"datetime\": \"1983-10-10T02:15:15Z\", \"message\": \"m4\" }\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"5\" } }\n{ \"priority\": 3, \"datetime\": \"1983-10-10T17:18:19Z\", \"message\": \"m5\" }\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"6\" } }\n{ \"priority\": 1, \"datetime\": \"2019-08-03T17:19:31Z\", \"message\": \"m6\" }\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"7\" } }\n{ \"priority\": 3, \"datetime\": \"2019-08-04T17:20:00Z\", \"message\": \"m7\" }\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"8\" } }\n{ \"priority\": 2, \"datetime\": \"2019-08-04T18:01:01Z\", \"message\": \"m8\" }\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"9\" } }\n{ \"priority\": 3, \"datetime\": \"1983-10-10T19:00:45Z\", \"message\": \"m9\" }\n{ \"index\" : { \"_index\" : \"messages\", \"_id\" : \"10\" } }\n{ \"priority\": 2, \"datetime\": \"2019-07-23T23:39:54Z\", \"message\": \"m10\" }\n----\n// TEST[continued]\n\n===== Day-of-the-Week Bucket Aggregation Example\n\nThe following example uses a\n{ref}/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-script[terms aggregation]\nas part of the\n<<painless-bucket-script-agg-context, bucket script aggregation context>> to\ndisplay the number of messages from each day-of-the-week.\n\n[source,console]\n----\nGET /messages/_search?pretty=true\n{\n  \"aggs\": {\n    \"day-of-week-count\": {\n      \"terms\": {\n        \"script\": \"return doc[\\\"datetime\\\"].value.getDayOfWeekEnum();\"\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\n===== Morning/Evening Bucket Aggregation Example\n\nThe following example uses a\n{ref}/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-script[terms aggregation]\nas part of the\n<<painless-bucket-script-agg-context, bucket script aggregation context>> to\ndisplay the number of messages received in the morning versus the evening.\n\n[source,console]\n----\nGET /messages/_search?pretty=true\n{\n  \"aggs\": {\n    \"am-pm-count\": {\n      \"terms\": {\n        \"script\": \"return doc[\\\"datetime\\\"].value.getHour() < 12 ? \\\"AM\\\" : \\\"PM\\\";\"\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\n===== Age of a Message Script Field Example\n\nThe following example uses a\n{ref}/search-fields.html#script-fields[script field] as part of the\n<<painless-field-context, field context>> to display the elapsed time between\n\"now\" and when a message was received.\n\n[source,console]\n----\nGET /_search?pretty=true\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"script_fields\": {\n    \"message_age\": {\n      \"script\": {\n        \"source\": \"ZonedDateTime now = ZonedDateTime.ofInstant(Instant.ofEpochMilli(params[\\\"now\\\"]), ZoneId.of(\\\"Z\\\")); ZonedDateTime mdt = doc[\\\"datetime\\\"].value; String age; long years = mdt.until(now, ChronoUnit.YEARS); age = years + \\\"Y \\\"; mdt = mdt.plusYears(years); long months = mdt.until(now, ChronoUnit.MONTHS); age += months + \\\"M \\\"; mdt = mdt.plusMonths(months); long days = mdt.until(now, ChronoUnit.DAYS); age += days + \\\"D \\\"; mdt = mdt.plusDays(days); long hours = mdt.until(now, ChronoUnit.HOURS); age += hours + \\\"h \\\"; mdt = mdt.plusHours(hours); long minutes = mdt.until(now, ChronoUnit.MINUTES); age += minutes + \\\"m \\\"; mdt = mdt.plusMinutes(minutes); long seconds = mdt.until(now, ChronoUnit.SECONDS); age += hours + \\\"s\\\"; return age;\",\n        \"params\": {\n          \"now\": 1574005645830\n        }\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nThe following shows the script broken into multiple lines:\n\n[source,Painless]\n----\nZonedDateTime now = ZonedDateTime.ofInstant(\n        Instant.ofEpochMilli(params['now']), ZoneId.of('Z')); <1>\nZonedDateTime mdt = doc['datetime'].value; <2>\n\nString age;\n\nlong years = mdt.until(now, ChronoUnit.YEARS); <3>\nage = years + 'Y '; <4>\nmdt = mdt.plusYears(years); <5>\n\nlong months = mdt.until(now, ChronoUnit.MONTHS);\nage += months + 'M ';\nmdt = mdt.plusMonths(months);\n\nlong days = mdt.until(now, ChronoUnit.DAYS);\nage += days + 'D ';\nmdt = mdt.plusDays(days);\n\nlong hours = mdt.until(now, ChronoUnit.HOURS);\nage += hours + 'h ';\nmdt = mdt.plusHours(hours);\n\nlong minutes = mdt.until(now, ChronoUnit.MINUTES);\nage += minutes + 'm ';\nmdt = mdt.plusMinutes(minutes);\n\nlong seconds = mdt.until(now, ChronoUnit.SECONDS);\nage += hours + 's';\n\nreturn age; <6>\n----\n<1> Parse the datetime \"now\" as input from the user-defined params.\n<2> Store the datetime the message was received as a `ZonedDateTime`.\n<3> Find the difference in years between \"now\" and the datetime the message was\nreceived.\n<4> Add the difference in years later returned in the format\n`Y <years> ...` for the age of a message.\n<5> Add the years so only the remainder of the months, days, etc. remain as the\ndifference between \"now\" and the datetime the message was received. Repeat this\npattern until the desired granularity is reached (seconds in this example).\n<6> Return the age of the message in the format\n`Y <years> M <months> D <days> h <hours> m <minutes> s <seconds>`.\n"
}