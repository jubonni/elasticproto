{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.528277",
        "size": 30415,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/jwt-auth-realm.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "jwt-auth-realm",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[jwt-auth-realm]]\n=== JWT authentication\n\n{es} can be configured to trust JSON Web Tokens (JWTs) issued from an external service\nas bearer tokens for authentication.\n\nWhen a JWT realm is used to authenticate with {es}, a distinction is made\nbetween the _client_ that is connecting to {es}, and the _user_ on whose behalf\nthe request should run. The JWT authenticates the user, and a separate credential\nauthenticates the client.\n\nThe JWT realm supports two token types, `id_token` (the default) and `access_token`.\nThey are designed to work for the following two scenarios, respectively:\n\n1. `id_token` - An application authenticates and identifies a user with an authentication flow,\ne.g. OpenID Connect (OIDC), and then accesses {es} on behalf of the authenticated user using\na JSON Web Token (JWT) conforming to OIDC ID Token specification.\n2. `access_token` - An application accesses {es} using its own identity, encoded as a JWT,\ne.g. The application authenticates itself to a central identity platform using an\nOAuth2 Client Credentials Flow and then uses the resulting JWT-based access token to connect to {es}.\n\nNOTE: A single JWT realm can only work with a single token type. To handle both token types,\nyou must configure at least two JWT realms. You should choose the token type carefully based\non the use case because it impacts on how validations are performed.\n\nThe JWT realm validates the incoming JWT based on its configured token type.\nJSON Web Tokens (JWT) of both types must contain the following 5 pieces of information.\nWhile ID Tokens, based on the OIDC specification, have strict rules for what claims should provide these information,\naccess tokens allow some claims to be configurable.\n\n[cols=\"3\",frame=all]\n|====\nh|             2+^h| Claims\nh| Information     | ID Token   | Access Token\n | Issuer          | `iss`      | `iss`\n | Subject         | `sub`      | Defaults to `sub`, but can fall back to another claim if `sub` does not exist\n | Audiences       | `aud`      | Defaults to `aud`, but can fall back to another claim if `aud` does not exist\n | Issue Time      | `iat`      | `iat`\n | Expiration Time | `exp`      | `exp`\n|====\n\nIn addition, {es} also validates `nbf` and `auth_time` claims for ID Tokens if these claims are present.\nBut these claims are ignored for access tokens.\n\nOverall, the access token type has more relaxed validation rules and is suitable for more generic JWTs,\nincluding self-signed ones.\n\n[[jwt-realm-oidc]]\n==== ID Tokens from OIDC workflows\nJWT authentication in {es} is derived from OIDC user workflows, where different\ntokens can be issued by an OIDC Provider (OP), including ID Tokens.\nID Tokens from an OIDC provider are well-defined JSON Web Tokens (JWT) and should be always compatible with\na JWT realm of the `id_token` token type. The subject claim of an ID token represents the end-user.\nThis means that ID tokens will generally have many allowed subjects.\nTherefore, a JWT realm of `id_token` token type does _not_ mandate the `allowed_subjects`\n(or `allowed_subject_patterns`) validation.\n\nNOTE: Because JWTs are obtained external to {es}, you can define a custom workflow\ninstead of using the OIDC workflow. However, the JWT format must still be JSON\nWeb Signature (JWS). The JWS header and JWS signature are validated using OIDC\nID token validation rules.\n\n{es} supports a separate <<oidc-realm,OpenID Connect realm>>. It is preferred for any\nuse case where {es} can act as an OIDC RP. The OIDC realm is the only supported\nway to enable OIDC authentication in {kib}.\n\nTIP: Users authenticating with a JWT realm can optionally impersonate another user\nwith the <<run-as-privilege,`run_as`>> feature. See also <<jwt-realm-runas>>.\n\n[[jwt-realm-oauth2]]\n==== Access Tokens\nA common method to obtain access tokens is with the OAuth2 Client Credentials Flow.\nA typical usage of this flow is for an application to get a credential for itself.\nThis is the use case that the `access_token` token type is designed for.\nIt is likely that this application also obtains ID Tokens for its end-users.\nTo prevent end-user ID Tokens being used to authenticate with the JWT realm configured\nfor the application, we mandate `allowed_subjects` or `allowed_subject_patterns`\nvalidation when a JWT realm has token type `access_token`.\n\nNOTE: Not every access token is formatted as a JSON Web Token (JWT).\nFor it to be compatible with the JWT realm, it must at least use the JWT format and satisfies\nrelevant requirements in the above table.\n\n\n[[jwt-realm-configuration]]\n==== Configure {es} to use a JWT realm\n\nTo use JWT authentication, create the realm in the `elasticsearch.yml` file\nto configure it within the {es} authentication chain.\n\nThe JWT realm has a few mandatory settings, plus optional settings that are\ndescribed in <<ref-jwt-settings,JWT realm settings>>.\n\nNOTE: Client authentication is enabled by default for the JWT realms. Disabling\nclient authentication is possible, but strongly discouraged.\n\n. Add your JWT realm to the `elasticsearch.yml` file. The following example\nincludes the most common settings, which are not intended for every use case:\n+\n--\n[source,yaml]\n----\nxpack.security.authc.realms.jwt.jwt1:\n  order: 3\n  token_type: id_token\n  client_authentication.type: shared_secret\n  allowed_issuer: \"https://issuer.example.com/jwt/\"\n  allowed_audiences: [ \"8fb85eba-979c-496c-8ae2-a57fde3f12d0\" ]\n  allowed_signature_algorithms: [RS256,HS256]\n  pkc_jwkset_path: jwt/jwkset.json\n  claims.principal: sub\n----\n\n`order`::\nSpecifies a realm `order` of `3`, which indicates the order in which the\nconfigured realm is checked when authenticating a user. Realms are consulted in\nascending order, where the realm with the lowest order value is consulted first.\n\n`token_type`::\nInstructs the realm to treat and validate incoming JWTs as ID Tokens (`id_token`).\n\n`client_authentication.type`::\nSpecifies the client authentication type as `shared_secret`, which means that\nthe client is authenticated using an HTTP request header that must match a\npre-configured secret value. The client must provide this shared secret with\nevery request in the `ES-Client-Authentication` header and using the\n`SharedSecret` scheme. The header value must be a case-sensitive match\nto the realm's `client_authentication.shared_secret`.\n\n`allowed_issuer`::\nSets a verifiable identifier for your JWT issuer. This value is typically a\nURL, UUID, or some other case-sensitive string value.\n\n`allowed_audiences`::\nSpecifies a list of JWT audiences that the realm will allow.\nThese values are typically URLs, UUIDs, or other case-sensitive string values.\n\n`allowed_signature_algorithms`::\nIndicates that {es} should use the `RS256` or `HS256` signature algorithms to\nverify the signature of the JWT from the JWT issuer.\n\n`pkc_jwkset_path`::\nThe file name or URL to a JSON Web Key Set (JWKS) with the public key material that\nthe JWT Realm uses for verifying token signatures. A value is considered a file name\nif it does not begin with `https`. The file name\nis resolved relative to the {es} configuration directory. If a URL is provided, then\nit must begin with `https://` (`http://` is not supported).\n{es} automatically caches the JWK set and will attempt to refresh the\nJWK set upon signature verification failure, as this might indicate that the JWT Provider has\nrotated the signing keys.\n\n`claims.principal`::\nThe name of the JWT claim that contains the user's principal (username).\n\nThe following is an example snippet for configure a JWT realm for handling\naccess tokens:\n\n[source,yaml]\n----\nxpack.security.authc.realms.jwt.jwt2:\n  order: 4\n  token_type: access_token\n  client_authentication.type: shared_secret\n  allowed_issuer: \"https://issuer.example.com/jwt/\"\n  allowed_subjects: [ \"123456-compute@admin.example.com\" ]\n  allowed_subject_patterns: [ \"wild*@developer?.example.com\", \"/[a-z]+<1-10>\\\\@dev\\\\.example\\\\.com/\"]\n  allowed_audiences: [ \"elasticsearch\" ]\n  required_claims:\n    token_use: access\n    version: [\"1.0\", \"2.0\"]\n  allowed_signature_algorithms: [RS256,HS256]\n  pkc_jwkset_path: \"https://idp-42.example.com/.well-known/configuration\"\n  fallback_claims.sub: client_id\n  fallback_claims.aud: scope\n  claims.principal: sub\n----\n\n`token_type`::\nInstructs the realm to treat and validate incoming JWTs as access tokens (`access_token`).\n\n`allowed_subjects`::\nSpecifies a list of JWT subjects that the realm will allow.\nThese values are typically URLs, UUIDs, or other case-sensitive string values.\n\n`allowed_subject_patterns`::\nAnalogous to `allowed_subjects` but it accepts a list of <<regexp-syntax,Lucene regexp>>\nand wildcards for the allowed JWT subjects. Wildcards use the `*` and `?` special\ncharacters (which are escaped by `\\`) to mean \"any string\" and \"any single character\"\nrespectively, for example \"a?\\\\**\", matches \"a1*\" and \"ab*whatever\", but not \"a\", \"abc\", or \"abc*\"\n(in Java strings `\\` must itself be escaped by another `\\`).\n<<regexp-syntax,Lucene regexp>> must be enclosed between `/`,\nfor example \"/https?://[^/]+/?/\" matches any http or https URL with no path component\n(matches \"https://elastic.co/\" but not \"https://elastic.co/guide\").\n\nNOTE: At least one of the `allowed_subjects` or `allowed_subject_patterns` settings must be specified\n(and be non-empty) when `token_type` is `access_token`.\n\nNOTE: When both `allowed_subjects` and `allowed_subject_patterns` settings are specified\nan incoming JWT's `sub` claim is accepted if it matches any of the two lists.\n\n`required_claims`::\nSpecifies a list of key/value pairs for additional verifications to be performed\nagainst a JWT. The values are either a string or an array of strings.\n\n`fallback_claims.sub`::\nThe name of the JWT claim to extract the subject information if the `sub` claim does not exist.\nThis setting is only available when `token_type` is `access_token`.\nThe fallback is applied everywhere the `sub` claim is used.\nIn the above snippet, it means the `claims.principal` will also fallback to `client_id`\nif `sub` does not exist.\n\n`fallback_claims.aud`::\nThe name of the JWT claim to extract the audiences information if the `aud` claim does not exist.\nThis setting is only available when `token_type` is `access_token`.\nThe fallback is applied everywhere the `aud` claim is used.\n\n--\n\n. After defining settings, use the\n{ref}/elasticsearch-keystore.html[`elasticsearch-keystore`] tool to store\nvalues for secure settings in the {es} keystore.\n\n.. Store the `shared_secret` value for `client_authentication.type`:\n+\n[source,shell]\n----\nbin/elasticsearch-keystore add xpack.security.authc.realms.jwt.jwt1.client_authentication.shared_secret\n----\n\n.. Store the HMAC keys for `allowed_signature_algorithms`, which use the HMAC\nSHA-256 algorithm `HS256` in the example:\n+\n[source,shell]\n----\nbin/elasticsearch-keystore add-file xpack.security.authc.realms.jwt.jwt1.hmac_jwkset <path> <1>\n----\n<1> Path to a JWKS, which is a resource for a set of JSON-encoded secret keys.\nThe file can be removed after you load the contents into the {es} keystore.\n+\n[NOTE]\n====\nUsing the JWKS is preferred. However, you can add an HMAC key in string format\nusing the following command. This format is compatible with HMAC UTF-8 keys, but\nonly supports a single key with no attributes. You can only use one HMAC format\n(either `hmac_jwkset` or `hmac_key`) simultaneously.\n\n[source,shell]\n----\nbin/elasticsearch-keystore add xpack.security.authc.realms.jwt.jwt1.hmac_key\n----\n====\n\n[[jwt-validation]]\n==== JWT encoding and validation\nJWTs can be parsed into three pieces:\n\nHeader::\nProvides information about how to validate the token.\n\nClaims::\nContains data about the calling user or application.\n\nSignature::\nThe data that's used to validate the token.\n\n[source,js]\n----\nHeader: {\"typ\":\"JWT\",\"alg\":\"HS256\"}\nClaims: {\"aud\":\"aud8\",\"sub\":\"security_test_user\",\"iss\":\"iss8\",\"exp\":4070908800,\"iat\":946684800}\nSignature: UnnFmsoFKfNmKMsVoDQmKI_3-j95PCaKdgqqau3jPMY\n----\n// NOTCONSOLE\n\nThis example illustrates a partial decoding of a JWT. The validity period is\nfrom 2000 to 2099 (inclusive), as defined by the issue time (`iat`) and\nexpiration time (`exp`). JWTs typically have a validity period shorter than\n100 years, such as 1-2 hours or 1-7 days, not an entire human life.\n\nThe signature in this example is deterministic because the header, claims, and\nHMAC key are fixed. JWTs typically have a `nonce` claim to make the signature\nnon-deterministic. The supported JWT encoding is JSON Web Signature (JWS), and\nthe JWS `Header` and `Signature` are validated using OpenID Connect ID Token\nvalidation rules. Some validation is customizable through\n<<ref-jwt-settings,JWT realm settings>>.\n\n[[jwt-validation-header]]\n===== Header claims\nThe header claims indicate the token type and the algorithm used to sign the\ntoken.\n\n`alg`::\n(Required, String) Indicates the algorithm that was used to sign the token, such\nas `HS256`. The algorithm must be in the realm's allow list.\n\n`typ`::\n(Optional, String) Indicates the token type, which must be `JWT`.\n\n[[jwt-validation-payload]]\n===== Payload claims\nTokens contain several claims, which provide information about the user\nwho is issuing the token, and the token itself.\nDepending on the token type, these information can optionally be identified\nby different claims.\n\n====== JWT payload claims\nThe following claims are validated by a subset of OIDC ID token rules.\n\n{es} doesn't validate `nonce` claims, but a custom JWT issuer can add a\nrandom `nonce` claim to introduce entropy into the signature.\n\nNOTE: You can relax validation of any of the time-based claims by setting\n`allowed_clock_skew`. This value sets the maximum allowed clock skew before\nvalidating JWTs with respect to their authentication time (`auth_time`),\ncreation (`iat`), not before (`nbf`), and expiration times (`exp`).\n\n`iss`::\n(Required, String) Denotes the issuer that created the ID token. The value must\nbe an exact, case-sensitive match to the value in the `allowed_issuer` setting.\n\n`sub`::\n(Required*, String) Indicates the subject that the ID token is created for.\nIf the JWT realm is of the `id_token` type, this claim is mandatory.\nA JWT realm of the `id_token` type by defaults accepts all subjects.\nA JWT realm of the access_token type must specify the `allowed_subjects` setting and the subject value\nmust be an exact, case-sensitive match to any of the CSV values in the\nallowed_subjects setting.\nA JWT realm of the access_token type can specify a fallback claim that will\nbe used in place where the `sub` claim does not exist.\n\n`aud`::\n(Required*, String) Indicates the audiences that the ID token is for, expressed as a\ncomma-separated value (CSV). One of the values must be an exact, case-sensitive\nmatch to any of the CSV values in the `allowed_audiences` setting.\nIf the JWT realm is of the `id_token` type, this claim is mandatory.\nA JWT realm of the `access_token` type can specify a fallback claim that will\nbe used in place where the `aud` claim does not exist.\n\n`exp`::\n(Required, integer) Expiration time for the ID token, expressed in UTC\nseconds since epoch.\n\n`iat`::\n(Required, integer) Time that the ID token was issued, expressed in UTC\nseconds since epoch.\n\n`nbf`::\n(Optional, integer) Indicates the time before which the JWT must not be accepted,\nexpressed as UTC seconds since epoch.\nThis claim is optional. If it exists, a JWT realm of `id_token` type will verify\nit, while a JWT realm of `access_token` will just ignore it.\n\n`auth_time`::\n(Optional, integer) Time when the user authenticated to the JWT issuer,\nexpressed as UTC seconds since epoch.\nThis claim is optional. If it exists, a JWT realm of `id_token` type will verify\nit, while a JWT realm of `access_token` will just ignore it.\n\n\n[[jwt-validation-payload-es]]\n====== {es} settings for consuming JWT claims\n{es} uses JWT claims for the following settings.\n\n`principal`::\n(Required, String) Contains the user's principal (username). The value is\nconfigurable using the realm setting `claims.principal`.\nYou can configure an optional regular expression using the\n`claim_patterns.principal` to extract a substring.\n\n`groups`::\n(Optional, JSON array) Contains the user's group membership.\nThe value is configurable using the realm setting `claims.groups`. You can\nconfigure an optional regular expression using the realm setting\n`claim_patterns.groups` to extract a substring value.\n\n`name`::\n(Optional, String) Contains a human-readable identifier that identifies the\nsubject of the token. The value is configurable using the realm setting\n`claims.name`. You can configure an optional regular expression using the realm\nsetting `claim_patterns.name` to extract a substring value.\n\n`mail`::\n(Optional, String) Contains the e-mail address to associate with the user. The\nvalue is configurable using the realm setting `claims.mail`. You can configure an\noptional regular expression using the realm setting `claim_patterns.mail` to\nextract a substring value.\n\n`dn`::\n(Optional, String) Contains the user's Distinguished Name (DN), which uniquely\nidentifies a user or group. The value is configurable using the realm setting\n`claims.dn`. You can configure an optional regular expression using the realm\nsetting `claim_patterns.dn` to extract a substring value.\n\n[[jwt-authorization]]\n==== JWT realm authorization\nThe JWT realm supports authorization with the create or update role mappings API,\nor delegating authorization to another realm. You cannot use these methods\nsimultaneously, so choose whichever works best for your environment.\n\nIMPORTANT: You cannot map roles in the JWT realm using the `role_mapping.yml`\nfile.\n\n[[jwt-authorization-role-mapping]]\n===== Authorizing with the role mapping API\nYou can use the\n<<security-api-put-role-mapping,create or update role mappings API>> to define\nrole mappings that determine which roles should be assigned to each user based on\ntheir username, groups, or other metadata.\n\n[source,console]\n----\nPUT /_security/role_mapping/jwt1_users?refresh=true\n{\n  \"roles\" : [ \"user\" ],\n  \"rules\" : { \"all\" : [\n      { \"field\": { \"realm.name\": \"jwt1\" } },\n      { \"field\": { \"username\": \"principalname1\" } },\n      { \"field\": { \"dn\": \"CN=Principal Name 1,DC=example.com\" } },\n      { \"field\": { \"groups\": \"group1\" } },\n      { \"field\": { \"metadata.jwt_claim_other\": \"other1\" } }\n  ] },\n  \"enabled\": true\n}\n----\n\nIf you use this API in the JWT realm, the following claims are available for\nrole mapping:\n\n`principal`::\n(Required, String) Principal claim that is used as the {es} user's username.\n\n`dn`::\n(Optional, String) Distinguished Name (DN) that is used as the {es} user's DN.\n\n`groups`::\n(Optional, String) Comma-separated value (CSV) list that is used as the {es}\nuser's list of groups.\n\n`metadata`::\n(Optional, object) Additional metadata about the user, such as strings, integers,\nboolean values, and collections that are used as the {es} user's metadata.\nThese values are key value pairs formatted as\n`metadata.jwt_claim_<key>` = `<value>`.\n\n[[jwt-authorization-delegation]]\n===== Delegating JWT authorization to another realm\nIf you <<authorization_realms,delegate authorization>> to other realms from the\nJWT realm, only the `principal` claim is available for role lookup. When\ndelegating the assignment and lookup of roles to another realm from the JWT\nrealm, claims for `dn`, `groups`, `mail`, `metadata`, and `name` are not used\nfor the {es} user's values. Only the JWT `principal` claim is passed to the\ndelegated authorization realms. The realms that are delegated for authorization\n- not the JWT realm - become responsible for populating all of the {es} user's\nvalues.\n\nThe following example shows how you define delegation authorization in the\n`elasticsearch.yml` file to multiple other realms from the JWT realm. A JWT\nrealm named `jwt2` is delegating authorization to multiple realms:\n\n[source,yaml]\n----\nxpack.security.authc.realms.jwt.jwt2.authorization_realms: file1,native1,ldap1,ad1\n----\n\nYou can then use the\n<<security-api-put-role-mapping,create or update role mappings API>> to map\nroles to the authorizing realm. The following example maps roles in the `native1`\nrealm for the `principalname1` JWT principal.\n\n[source,console]\n----\nPUT /_security/role_mapping/native1_users?refresh=true\n{\n  \"roles\" : [ \"user\" ],\n  \"rules\" : { \"all\" : [\n      { \"field\": { \"realm.name\": \"native1\" } },\n      { \"field\": { \"username\": \"principalname1\" } }\n  ] },\n  \"enabled\": true\n}\n----\n\nIf realm `jwt2` successfully authenticates a client with a JWT for principal\n`principalname1`, and delegates authorization to one of the listed realms\n(such as `native1`), then that realm can look up the {es} user's values. With\nthis defined role mapping, the realm can also look up this role mapping rule\nlinked to realm `native1`.\n\n[[jwt-realm-runas]]\n===== Applying the `run_as` privilege to JWT realm users\n{es} can retrieve roles for a JWT user through either role mapping or\ndelegated authorization. Regardless of which option you choose, you can apply the\n<<run-as-privilege-apply,`run_as` privilege>> to a role so that a user can\nsubmit authenticated requests to \"run as\" a different user. To submit requests as\nanother user, include the `es-security-runas-user` header in your requests.\nRequests run as if they were issued from that user and {es} uses their roles.\n\nFor example, let's assume that there's a user with the username `user123_runas`.\nThe following request creates a user role named `jwt_role1`, which specifies a\n`run_as` user with the `user123_runas` username. Any user with the `jwt_role1`\nrole can issue requests as the specified `run_as` user.\n\n[source,console]\n----\nPOST /_security/role/jwt_role1?refresh=true\n{\n  \"cluster\": [\"manage\"],\n  \"indices\": [ { \"names\": [ \"*\" ], \"privileges\": [\"read\"] } ],\n  \"run_as\": [ \"user123_runas\" ],\n  \"metadata\" : { \"version\" : 1 }\n}\n----\n\nYou can then map that role to a user in a specific realm. The following request\nmaps the `jwt_role1` role to a user with the username `user2` in the `jwt2` JWT\nrealm. This means that {es} will use the `jwt2` realm to authenticate the user\nnamed `user2`. Because `user2` has a role (the `jwt_role1` role) that includes\nthe `run_as` privilege, {es} retrieves the role mappings for the `user123_runas`\nuser and uses the roles for that user to submit requests.\n\n[source,console]\n----\nPOST /_security/role_mapping/jwt_user1?refresh=true\n{\n  \"roles\": [ \"jwt_role1\"],\n  \"rules\" : { \"all\" : [\n      { \"field\": { \"realm.name\": \"jwt2\" } },\n      { \"field\": { \"username\": \"user2\" } }\n  ] },\n  \"enabled\": true,\n  \"metadata\" : { \"version\" : 1 }\n}\n----\n\nAfter mapping the roles, you can make an\n<<security-api-authenticate,authenticated call>> to {es} using a JWT and include\nthe `ES-Client-Authentication` header:\n\n[[jwt-auth-shared-secret-scheme-example]]\n[source,sh]\n----\ncurl -s -X GET -H \"Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOlsiZXMwMSIsImVzMDIiLCJlczAzIl0sInN1YiI6InVzZXIyIiwiaXNzIjoibXktaXNzdWVyIiwiZXhwIjo0MDcwOTA4ODAwLCJpYXQiOjk0NjY4NDgwMCwiZW1haWwiOiJ1c2VyMkBzb21ldGhpbmcuZXhhbXBsZS5jb20ifQ.UgO_9w--EoRyUKcWM5xh9SimTfMzl1aVu6ZBsRWhxQA\" -H \"ES-Client-Authentication: sharedsecret test-secret\" https://localhost:9200/_security/_authenticate\n----\n// NOTCONSOLE\n\nThe response includes the user who submitted the request (`user2`), including\nthe `jwt_role1` role that you mapped to this user in the JWT realm:\n\n[source,sh]\n----\n{\"username\":\"user2\",\"roles\":[\"jwt_role1\"],\"full_name\":null,\"email\":\"user2@something.example.com\",\n\"metadata\":{\"jwt_claim_email\":\"user2@something.example.com\",\"jwt_claim_aud\":[\"es01\",\"es02\",\"es03\"],\n\"jwt_claim_sub\":\"user2\",\"jwt_claim_iss\":\"my-issuer\"},\"enabled\":true,\"authentication_realm\":\n{\"name\":\"jwt2\",\"type\":\"jwt\"},\"lookup_realm\":{\"name\":\"jwt2\",\"type\":\"jwt\"},\"authentication_type\":\"realm\"}\n%\n----\n\nIf you want to specify a request as the `run_as` user, include the\n`es-security-runas-user` header with the name of the user that you want to\nsubmit requests as. The following request uses the `user123_runas` user:\n\n[source,sh]\n----\ncurl -s -X GET -H \"Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOlsiZXMwMSIsImVzMDIiLCJlczAzIl0sInN1YiI6InVzZXIyIiwiaXNzIjoibXktaXNzdWVyIiwiZXhwIjo0MDcwOTA4ODAwLCJpYXQiOjk0NjY4NDgwMCwiZW1haWwiOiJ1c2VyMkBzb21ldGhpbmcuZXhhbXBsZS5jb20ifQ.UgO_9w--EoRyUKcWM5xh9SimTfMzl1aVu6ZBsRWhxQA\" -H \"ES-Client-Authentication: sharedsecret test-secret\" -H \"es-security-runas-user: user123_runas\" https://localhost:9200/_security/_authenticate\n----\n// NOTCONSOLE\n\nIn the response, you'll see that the `user123_runas` user submitted the request,\nand {es} used the `jwt_role1` role:\n\n[source,sh]\n----\n{\"username\":\"user123_runas\",\"roles\":[\"jwt_role1\"],\"full_name\":null,\"email\":null,\"metadata\":{},\n\"enabled\":true,\"authentication_realm\":{\"name\":\"jwt2\",\"type\":\"jwt\"},\"lookup_realm\":{\"name\":\"native\",\n\"type\":\"native\"},\"authentication_type\":\"realm\"}%\n----\n\n[[jwt-realm-jwkset-reloading]]\n===== PKC JWKS reloading\nJWT authentication supports signature verification using PKC (Public Key Cryptography)\nor HMAC algorithms.\n\nPKC JSON Web Token Key Sets (JWKS) can contain public RSA and EC keys. HMAC JWKS\nor an HMAC UTF-8 JWK contain secret keys. JWT issuers typically rotate PKC JWKS\nmore frequently (such as daily), because RSA and EC public keys are designed to\nbe easier to distribute than secret keys like HMAC.\n\nJWT realms load a PKC JWKS and an HMAC JWKS or HMAC UTF-8 JWK at startup. JWT\nrealms can also reload PKC JWKS contents at runtime; a reload is triggered by\nsignature validation failures.\n\nNOTE: HMAC JWKS or HMAC UTF-8 JWK reloading is not supported at this time.\n\nLoad failures, parse errors, and configuration errors prevent a node from\nstarting (and restarting). However, runtime PKC reload errors and recoveries are\nhandled gracefully.\n\nAll other JWT realm validations are checked before a signature failure can\ntrigger a PKC JWKS reload. If multiple JWT authentication signature failures\noccur simultaneously with a single {es} node, reloads are combined to reduce\nthe reloads that are sent externally.\n\nSeparate reload requests cannot be combined if JWT signature failures trigger:\n\n* PKC JWKS reloads in different {es} nodes\n* PKC JWKS reloads in the same {es} node at different times\n\n[IMPORTANT]\n====\nEnabling client authentication (`client_authentication.type`) is strongly\nrecommended. Only trusted client applications and realm-specific JWT users can\ntrigger PKC reload attempts. Additionally, configuring the following\n<<ref-jwt-settings,JWT security settings>> is recommended:\n\n* `allowed_audiences`\n* `allowed_clock_skew`\n* `allowed_issuer`\n* `allowed_signature_algorithms`\n====\n\n[[hmac-oidc-example]]\n==== Authorizing to the JWT realm with an HMAC UTF-8 key\nThe following settings are for a JWT issuer, {es}, and a client of {es}. The\nexample HMAC key is in an OIDC format that's compatible with HMAC. The key bytes\nare the UTF-8 encoding of the UNICODE characters.\n\nIMPORTANT: HMAC UTF-8 keys need to be longer than HMAC random byte keys to\nachieve the same key strength.\n\n[[hmac-oidc-example-jwt-issuer]]\n===== JWT issuer\nThe following values are for the bespoke JWT issuer.\n\n[source,js]\n----\nIssuer:     iss8\nAudiences:  aud8\nAlgorithms: HS256\nHMAC UTF-8: hmac-oidc-key-string-for-hs256-algorithm\n----\n// NOTCONSOLE\n\n[[hmac-oidc-example-jwt-realm]]\n===== JWT realm settings\nTo define a JWT realm, add the following realm settings to `elasticsearch.yml`.\n\n[source,yaml]\n----\nxpack.security.authc.realms.jwt.jwt8.order: 8 <1>\nxpack.security.authc.realms.jwt.jwt8.allowed_issuer: iss8\nxpack.security.authc.realms.jwt.jwt8.allowed_audiences: [aud8]\nxpack.security.authc.realms.jwt.jwt8.allowed_signature_algorithms: [HS256]\nxpack.security.authc.realms.jwt.jwt8.claims.principal: sub\nxpack.security.authc.realms.jwt.jwt8.client_authentication.type: shared_secret\n----\n<1> In {ecloud}, the realm order starts at `2`. `0` and `1` are reserved in the\nrealm chain on {ecloud}.\n\n===== JWT realm secure settings\nAfter defining the realm settings, use the\n{ref}/elasticsearch-keystore.html[`elasticsearch-keystore`] tool to add the\nfollowing secure settings to the {es} keystore. In {ecloud}, you define settings\nfor the {es} keystore under **Security** in your deployment.\n\n[source,yaml]\n----\nxpack.security.authc.realms.jwt.jwt8.hmac_key: hmac-oidc-key-string-for-hs256-algorithm\nxpack.security.authc.realms.jwt.jwt8.client_authentication.shared_secret: client-shared-secret-string\n----\n\n===== JWT realm role mapping rule\nThe following request creates role mappings for {es} in the `jwt8` realm for\nthe user `principalname1`:\n\n[source,console]\n----\nPUT /_security/role_mapping/jwt8_users?refresh=true\n{\n  \"roles\" : [ \"user\" ],\n  \"rules\" : { \"all\" : [\n      { \"field\": { \"realm.name\": \"jwt8\" } },\n      { \"field\": { \"username\": \"principalname1\" } }\n  ] },\n  \"enabled\": true\n}\n----\n\n[[hmac-oidc-example-request-headers]]\n===== Request headers\nThe following header settings are for an {es} client.\n\n[source,js]\n----\nAuthorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJpc3M4IiwiYXVkIjoiYXVkOCIsInN1YiI6InNlY3VyaXR5X3Rlc3RfdXNlciIsImV4cCI6NDA3MDkwODgwMCwiaWF0Ijo5NDY2ODQ4MDB9.UnnFmsoFKfNmKMsVoDQmKI_3-j95PCaKdgqqau3jPMY\nES-Client-Authentication: SharedSecret client-shared-secret-string\n----\n// NOTCONSOLE\n\nYou can use this header in a `curl` request to make an authenticated call to\n{es}. Both the bearer token and the client authorization token must be\nspecified as separate headers with the `-H` option:\n\n[source,sh]\n----\ncurl -s -X GET -H \"Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJpc3M4IiwiYXVkIjoiYXVkOCIsInN1YiI6InNlY3VyaXR5X3Rlc3RfdXNlciIsImV4cCI6NDA3MDkwODgwMCwiaWF0Ijo5NDY2ODQ4MDB9.UnnFmsoFKfNmKMsVoDQmKI_3-j95PCaKdgqqau3jPMY\" -H \"ES-Client-Authentication: SharedSecret client-shared-secret-string\" https://localhost:9200/_security/_authenticate\n----\n// NOTCONSOLE\n\nIf you used role mapping in the JWT realm, the response includes the user's\n`username`, their `roles`, metadata about the user, and the details about the\nJWT realm itself.\n\n[source,sh]\n----\n{\"username\":\"user2\",\"roles\":[\"jwt_role1\"],\"full_name\":null,\"email\":\"user2@something.example.com\",\n\"metadata\":{\"jwt_claim_email\":\"user2@something.example.com\",\"jwt_claim_aud\":[\"es01\",\"es02\",\"es03\"],\n\"jwt_claim_sub\":\"user2\",\"jwt_claim_iss\":\"my-issuer\"},\"enabled\":true,\"authentication_realm\":\n{\"name\":\"jwt2\",\"type\":\"jwt\"},\"lookup_realm\":{\"name\":\"jwt2\",\"type\":\"jwt\"},\"authentication_type\":\"realm\"}\n----\n"
}