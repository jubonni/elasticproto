{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.865067",
        "size": 24763,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-operators-reference.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-operators-reference",
        "version": "8.15"
    },
    "doc": "[[painless-operators-reference]]\n=== Operators: Reference\n\n[[method-call-operator]]\n==== Method Call\n\nUse the `method call operator '()'` to call a member method on a\n<<reference-types, reference type>> value. Implicit\n<<boxing-unboxing, boxing/unboxing>> is evaluated as necessary per argument\nduring the method call. When a method call is made on a target `def` type value,\nthe parameters and return type value are considered to also be of the `def` type\nand are evaluated at run-time.\n\nAn overloaded method is one that shares the same name with two or more methods.\nA method is overloaded based on arity where the same name is re-used for\nmultiple methods as long as the number of parameters differs.\n\n*Errors*\n\n* If the reference type value is `null`.\n* If the member method name doesn't exist for a given reference type value.\n* If the number of arguments passed in is different from the number of specified\n  parameters.\n* If the arguments cannot be implicitly cast or implicitly boxed/unboxed to the\n  correct type values for the parameters.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nmethod_call: '.' ID arguments;\narguments: '(' (expression (',' expression)*)? ')';\n----\n\n*Examples*\n\n* Method calls on different reference types.\n+\n[source,Painless]\n----\nMap m = new HashMap();                         <1>\nm.put(1, 2);                                   <2>\nint z = m.get(1);                              <3>\ndef d = new ArrayList();                       <4>\nd.add(1);                                      <5>\nint i = Integer.parseInt(d.get(0).toString()); <6>\n----\n+\n<1> declare `Map m`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    store `HashMap reference` to `m`\n<2> load from `m` -> `Map reference`;\n    implicit cast `int 1` to `def` -> `def`;\n    implicit cast `int 2` to `def` -> `def`;\n    call `put` on `Map reference` with arguments (`int 1`, `int 2`)\n<3> declare `int z`;\n    load from `m` -> `Map reference`;\n    call `get` on `Map reference` with arguments (`int 1`) -> `def`;\n    implicit cast `def` to `int 2` -> `int 2`;\n    store `int 2` to `z`\n<4> declare `def d`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList` to `def` -> `def`;\n    store `def` to `d`\n<5> load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`\n    call `add` on `ArrayList reference` with arguments (`int 1`);\n<6> declare `int i`;\n    load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`\n    call `get` on `ArrayList reference` with arguments (`int 1`) -> `def`;\n    implicit cast `def` to `Integer 1 reference` -> `Integer 1 reference`;\n    call `toString` on `Integer 1 reference` -> `String '1'`;\n    call `parseInt` on `Integer` with arguments (`String '1'`) -> `int 1`;\n    store `int 1` in `i`;\n\n[[field-access-operator]]\n==== Field Access\n\nUse the `field access operator '.'` to store a value to or load a value from a\n<<reference-types, reference type>> member field.\n\n*Errors*\n\n* If the reference type value is `null`.\n* If the member field name doesn't exist for a given reference type value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nfield_access: '.' ID;\n----\n\n*Examples*\n\nThe examples use the following reference type definition:\n\n[source,Painless]\n----\nname:\n  Example\n\nnon-static member fields:\n  * int x\n  * def y\n  * List z\n----\n\n* Field access with the `Example` type.\n+\n[source,Painless]\n----\nExample example = new Example(); <1>\nexample.x = 1;                   <2>\nexample.y = example.x;           <3>\nexample.z = new ArrayList();     <4>\nexample.z.add(1);                <5>\nexample.x = example.z.get(0);    <6>\n----\n+\n<1> declare `Example example`;\n    allocate `Example` instance -> `Example reference`;\n    store `Example reference` to `example`\n<2> load from `example` -> `Example reference`;\n    store `int 1` to `x` of `Example reference`\n<3> load from `example` -> `Example reference @0`;\n    load from `example` -> `Example reference @1`;\n    load from `x` of `Example reference @1` -> `int 1`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `y` of `Example reference @0`;\n    (note `Example reference @0` and `Example reference @1` are the same)\n<4> load from `example` -> `Example reference`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `z` of `Example reference`\n<5> load from `example` -> `Example reference`;\n    load from `z` of `Example reference` -> `List reference`;\n    call `add` on `List reference` with arguments (`int 1`)\n<6> load from `example` -> `Example reference @0`;\n    load from `example` -> `Example reference @1`;\n    load from `z` of `Example reference @1` -> `List reference`;\n    call `get` on `List reference` with arguments (`int 0`) -> `int 1`;\n    store `int 1` in `x` of `List reference @0`;\n    (note `Example reference @0` and `Example reference @1` are the same)\n\n[[null-safe-operator]]\n==== Null Safe\n\nUse the `null safe operator '?.'` instead of the method call operator or field\naccess operator to ensure a reference type value is `non-null` before\na method call or field access. A `null` value will be returned if the reference\ntype value is `null`, otherwise the method call or field access is evaluated.\n\n*Errors*\n\n* If the method call return type value or the field access type value is not\n  a reference type value and is not implicitly castable to a reference type\n  value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nnull_safe: null_safe_method_call\n         | null_safe_field_access\n         ;\n\nnull_safe_method_call: '?.' ID arguments;\narguments: '(' (expression (',' expression)*)? ')';\n\nnull_safe_field_access: '?.' ID;\n----\n\n*Examples*\n\nThe examples use the following reference type definition:\n\n[source,Painless]\n----\nname:\n  Example\n\nnon-static member methods:\n  * List factory()\n\nnon-static member fields:\n  * List x\n----\n\n* Null safe without a `null` value.\n+\n[source,Painless]\n----\nExample example = new Example(); <1>\nList x = example?.factory();     <2>\n----\n+\n<1> declare `Example example`;\n    allocate `Example` instance -> `Example reference`;\n    store `Example reference` to `example`\n<2> declare `List x`;\n    load from `example` -> `Example reference`;\n    null safe call `factory` on `Example reference` -> `List reference`;\n    store `List reference` to `x`;\n+\n* Null safe with a `null` value;\n+\n[source,Painless]\n----\nExample example = null; <1>\nList x = example?.x;    <2>\n----\n<1> declare `Example example`;\n    store `null` to `example`\n<2> declare `List x`;\n    load from `example` -> `Example reference`;\n    null safe access `x` on `Example reference` -> `null`;\n    store `null` to `x`;\n    (note the *null safe operator* returned `null` because `example` is `null`)\n\n[[list-initialization-operator]]\n==== List Initialization\n\nUse the `list initialization operator '[]'` to allocate an `List` type instance\nto the heap with a set of pre-defined values. Each value used to initialize the\n`List` type instance is cast to a `def` type value upon insertion into the\n`List` type instance using the `add` method. The order of the specified values\nis maintained.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nlist_initialization: '[' expression (',' expression)* ']'\n                   | '[' ']';\n----\n\n*Examples*\n\n* List initialization of an empty `List` type value.\n+\n[source,Painless]\n----\nList empty = []; <1>\n----\n+\n<1> declare `List empty`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `empty`\n+\n* List initialization with static values.\n+\n[source,Painless]\n----\nList list = [1, 2, 3]; <1>\n----\n+\n<1> declare `List list`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    call `add` on `ArrayList reference` with arguments(`int 1`);\n    call `add` on `ArrayList reference` with arguments(`int 2`);\n    call `add` on `ArrayList reference` with arguments(`int 3`);\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `list`\n+\n* List initialization with non-static values.\n+\n[source,Painless]\n----\nint i = 1;                  <1>\nlong l = 2L;                <2>\nfloat f = 3.0F;             <3>\ndouble d = 4.0;             <4>\nString s = \"5\";             <5>\nList list = [i, l, f*d, s]; <6>\n----\n+\n<1> declare `int i`;\n    store `int 1` to `i`\n<2> declare `long l`;\n    store `long 2` to `l`\n<3> declare `float f`;\n    store `float 3.0` to `f`\n<4> declare `double d`;\n    store `double 4.0` to `d`\n<5> declare `String s`;\n    store `String \"5\"` to `s`\n<6> declare `List list`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    load from `i` -> `int 1`;\n    call `add` on `ArrayList reference` with arguments(`int 1`);\n    load from `l` -> `long 2`;\n    call `add` on `ArrayList reference` with arguments(`long 2`);\n    load from `f` -> `float 3.0`;\n    load from `d` -> `double 4.0`;\n    promote `float 3.0` and `double 4.0`: result `double`;\n    implicit cast `float 3.0` to `double 3.0` -> `double 3.0`;\n    multiply `double 3.0` and `double 4.0` -> `double 12.0`;\n    call `add` on `ArrayList reference` with arguments(`double 12.0`);\n    load from `s` -> `String \"5\"`;\n    call `add` on `ArrayList reference` with arguments(`String \"5\"`);\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `list`\n\n[[list-access-operator]]\n==== List Access\n\nUse the `list access operator '[]'` as a shortcut for a `set` method call or\n`get` method call made on a `List` type value.\n\n*Errors*\n\n* If a value other than a `List` type value is accessed.\n* If a non-integer type value is used as an index for a `set` method call or\n  `get` method call.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nlist_access: '[' expression ']'\n----\n\n*Examples*\n\n* List access with the `List` type.\n+\n[source,Painless]\n----\nList list = new ArrayList(); <1>\nlist.add(1);                 <2>\nlist.add(2);                 <3>\nlist.add(3);                 <4>\nlist[0] = 2;                 <5>\nlist[1] = 5;                 <6>\nint x = list[0] + list[1];   <7>\nint y = 1;                   <8>\nint z = list[y];             <9>\n----\n+\n<1> declare `List list`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `list`\n<2> load from `list` -> `List reference`;\n    call `add` on `List reference` with arguments(`int 1`)\n<3> load from `list` -> `List reference`;\n    call `add` on `List reference` with arguments(`int 2`)\n<4> load from `list` -> `List reference`;\n    call `add` on `List reference` with arguments(`int 3`)\n<5> load from `list` -> `List reference`;\n    call `set` on `List reference` with arguments(`int 0`, `int 2`)\n<6> load from `list` -> `List reference`;\n    call `set` on `List reference` with arguments(`int 1`, `int 5`)\n<7> declare `int x`;\n    load from `list` -> `List reference`;\n    call `get` on `List reference` with arguments(`int 0`) -> `def`;\n    implicit cast `def` to `int 2` -> `int 2`;\n    load from `list` -> `List reference`;\n    call `get` on `List reference` with arguments(`int 1`) -> `def`;\n    implicit cast `def` to `int 5` -> `int 5`;\n    add `int 2` and `int 5` -> `int 7`;\n    store `int 7` to `x`\n<8> declare `int y`;\n    store `int 1` int `y`\n<9> declare `int z`;\n    load from `list` -> `List reference`;\n    load from `y` -> `int 1`;\n    call `get` on `List reference` with arguments(`int 1`) -> `def`;\n    implicit cast `def` to `int 5` -> `int 5`;\n    store `int 5` to `z`\n+\n* List access with the `def` type.\n+\n[source,Painless]\n----\ndef d = new ArrayList(); <1>\nd.add(1);                <2>\nd.add(2);                <3>\nd.add(3);                <4>\nd[0] = 2;                <5>\nd[1] = 5;                <6>\ndef x = d[0] + d[1];     <7>\ndef y = 1;               <8>\ndef z = d[y];            <9>\n----\n+\n<1> declare `List d`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `def` -> `def`;\n    store `def` to `d`\n<2> load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `add` on `ArrayList reference` with arguments(`int 1`)\n<3> load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `add` on `ArrayList reference` with arguments(`int 2`)\n<4> load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `add` on `ArrayList reference` with arguments(`int 3`)\n<5> load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `set` on `ArrayList reference` with arguments(`int 0`, `int 2`)\n<6> load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `set` on `ArrayList reference` with arguments(`int 1`, `int 5`)\n<7> declare `def x`;\n    load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `get` on `ArrayList reference` with arguments(`int 0`) -> `def`;\n    implicit cast `def` to `int 2` -> `int 2`;\n    load from `d` -> `def`;\n    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;\n    call `get` on `ArrayList reference` with arguments(`int 1`) -> `def`;\n    implicit cast `def` to `int 2` -> `int 2`;\n    add `int 2` and `int 5` -> `int 7`;\n    store `int 7` to `x`\n<8> declare `int y`;\n    store `int 1` int `y`\n<9> declare `int z`;\n    load from `d` -> `ArrayList reference`;\n    load from `y` -> `def`;\n    implicit cast `def` to `int 1` -> `int 1`;\n    call `get` on `ArrayList reference` with arguments(`int 1`) -> `def`;\n    store `def` to `z`\n\n[[map-initialization-operator]]\n==== Map Initialization\n\nUse the `map initialization operator '[:]'` to allocate a `Map` type instance to\nthe heap with a set of pre-defined values. Each pair of values used to\ninitialize the `Map` type instance are cast to `def` type values upon insertion\ninto the `Map` type instance using the `put` method.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nmap_initialization: '[' key_pair (',' key_pair)* ']'\n                  | '[' ':' ']';\nkey_pair: expression ':' expression\n----\n\n*Examples*\n\n* Map initialization of an empty `Map` type value.\n+\n[source,Painless]\n----\nMap empty = [:]; <1>\n----\n+\n<1> declare `Map empty`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `Map reference` -> `Map reference`;\n    store `Map reference` to `empty`\n+\n* Map initialization with static values.\n+\n[source,Painless]\n----\nMap map = [1:2, 3:4, 5:6]; <1>\n----\n+\n<1> declare `Map map`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    call `put` on `HashMap reference` with arguments(`int 1`, `int 2`);\n    call `put` on `HashMap reference` with arguments(`int 3`, `int 4`);\n    call `put` on `HashMap reference` with arguments(`int 5`, `int 6`);\n    implicit cast `HashMap reference` to `Map reference` -> `Map reference`;\n    store `Map reference` to `map`\n+\n* Map initialization with non-static values.\n+\n[source,Painless]\n----\nbyte b = 0;                  <1>\nint i = 1;                   <2>\nlong l = 2L;                 <3>\nfloat f = 3.0F;              <4>\ndouble d = 4.0;              <5>\nString s = \"5\";              <6>\nMap map = [b:i, l:f*d, d:s]; <7>\n----\n+\n<1> declare `byte b`;\n    store `byte 0` to `b`\n<2> declare `int i`;\n    store `int 1` to `i`\n<3> declare `long l`;\n    store `long 2` to `l`\n<4> declare `float f`;\n    store `float 3.0` to `f`\n<5> declare `double d`;\n    store `double 4.0` to `d`\n<6> declare `String s`;\n    store `String \"5\"` to `s`\n<7> declare `Map map`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    load from `b` -> `byte 0`;\n    load from `i` -> `int 1`;\n    call `put` on `HashMap reference` with arguments(`byte 0`, `int 1`);\n    load from `l` -> `long 2`;\n    load from `f` -> `float 3.0`;\n    load from `d` -> `double 4.0`;\n    promote `float 3.0` and `double 4.0`: result `double`;\n    implicit cast `float 3.0` to `double 3.0` -> `double 3.0`;\n    multiply `double 3.0` and `double 4.0` -> `double 12.0`;\n    call `put` on `HashMap reference` with arguments(`long 2`, `double 12.0`);\n    load from `d` -> `double 4.0`;\n    load from `s` -> `String \"5\"`;\n    call `put` on `HashMap reference` with\n            arguments(`double 4.0`, `String \"5\"`);\n    implicit cast `HashMap reference` to `Map reference` -> `Map reference`;\n    store `Map reference` to `map`\n\n[[map-access-operator]]\n==== Map Access\n\nUse the `map access operator '[]'` as a shortcut for a `put` method call or\n`get` method call made on a `Map` type value.\n\n*Errors*\n\n* If a value other than a `Map` type value is accessed.\n\n*Grammar*\n[source,ANTLR4]\n----\nmap_access: '[' expression ']'\n----\n\n*Examples*\n\n* Map access with the `Map` type.\n+\n[source,Painless]\n----\nMap map = new HashMap();               <1>\nmap['value2'] = 2;                     <2>\nmap['value5'] = 5;                     <3>\nint x = map['value2'] + map['value5']; <4>\nString y = 'value5';                   <5>\nint z = x[z];                          <6>\n----\n+\n<1> declare `Map map`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `Map reference` -> `Map reference`;\n    store `Map reference` to `map`\n<2> load from `map` -> `Map reference`;\n    call `put` on `Map reference` with arguments(`String 'value2'`, `int 2`)\n<3> load from `map` -> `Map reference`;\n    call `put` on `Map reference` with arguments(`String 'value5'`, `int 5`)\n<4> declare `int x`;\n    load from `map` -> `Map reference`;\n    call `get` on `Map reference` with arguments(`String 'value2'`) -> `def`;\n    implicit cast `def` to `int 2` -> `int 2`;\n    load from `map` -> `Map reference`;\n    call `get` on `Map reference` with arguments(`String 'value5'`) -> `def`;\n    implicit cast `def` to `int 5` -> `int 5`;\n    add `int 2` and `int 5` -> `int 7`;\n    store `int 7` to `x`\n<5> declare `String y`;\n    store `String 'value5'` to `y`\n<6> declare `int z`;\n    load from `map` -> `Map reference`;\n    load from `y` -> `String 'value5'`;\n    call `get` on `Map reference` with arguments(`String 'value5'`) -> `def`;\n    implicit cast `def` to `int 5` -> `int 5`;\n    store `int 5` to `z`\n+\n* Map access with the `def` type.\n+\n[source,Painless]\n----\ndef d = new HashMap();             <1>\nd['value2'] = 2;                   <2>\nd['value5'] = 5;                   <3>\nint x = d['value2'] + d['value5']; <4>\nString y = 'value5';               <5>\ndef z = d[y];                      <6>\n----\n+\n<1> declare `def d`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `def` -> `def`;\n    store `def` to `d`\n<2> load from `d` -> `def`;\n    implicit cast `def` to `HashMap reference` -> `HashMap reference`;\n    call `put` on `HashMap reference` with arguments(`String 'value2'`, `int 2`)\n<3> load from `d` -> `def`;\n    implicit cast `def` to `HashMap reference` -> `HashMap reference`;\n    call `put` on `HashMap reference` with arguments(`String 'value5'`, `int 5`)\n<4> declare `int x`;\n    load from `d` -> `def`;\n    implicit cast `def` to `HashMap reference` -> `HashMap reference`;\n    call `get` on `HashMap reference` with arguments(`String 'value2'`)\n            -> `def`;\n    implicit cast `def` to `int 2` -> `int 2`;\n    load from `d` -> `def`;\n    call `get` on `HashMap reference` with arguments(`String 'value5'`)\n            -> `def`;\n    implicit cast `def` to `int 5` -> `int 5`;\n    add `int 2` and `int 5` -> `int 7`;\n    store `int 7` to `x`\n<5> declare `String y`;\n    store `String 'value5'` to `y`\n<6> declare `def z`;\n    load from `d` -> `def`;\n    load from `y` -> `String 'value5'`;\n    call `get` on `HashMap reference` with arguments(`String 'value5'`)\n            -> `def`;\n    store `def` to `z`\n\n[[new-instance-operator]]\n==== New Instance\n\nUse the `new instance operator 'new ()'` to allocate a\n<<reference-types, reference type>> instance to the heap and call a specified\nconstructor. Implicit <<boxing-unboxing, boxing/unboxing>> is evaluated as\nnecessary per argument during the constructor call.\n\nAn overloaded constructor is one that shares the same name with two or more\nconstructors. A constructor is overloaded based on arity where the same\nreference type name is re-used for multiple constructors as long as the number\nof parameters differs.\n\n*Errors*\n\n* If the reference type name doesn't exist for instance allocation.\n* If the number of arguments passed in is different from the number of specified\n  parameters.\n* If the arguments cannot be implicitly cast or implicitly boxed/unboxed to the\n  correct type values for the parameters.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nnew_instance: 'new' TYPE '(' (expression (',' expression)*)? ')';\n----\n\n*Examples*\n\n* Allocation of new instances with different types.\n\n[source,Painless]\n----\nMap m = new HashMap();   <1>\ndef d = new ArrayList(); <2>\ndef e = new HashMap(m);  <3>\n----\n<1> declare `Map m`;\n    allocate `HashMap` instance -> `HashMap reference`;\n    implicit cast `HashMap reference` to `Map reference` -> `Map reference`;\n    store `Map reference` to `m`;\n<2> declare `def d`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `def` -> `def`;\n    store `def` to `d`;\n<3> declare `def e`;\n    load from `m` -> `Map reference`;\n    allocate `HashMap` instance with arguments (`Map reference`)\n            -> `HashMap reference`;\n    implicit cast `HashMap reference` to `def` -> `def`;\n    store `def` to `e`;\n\n[[string-concatenation-operator]]\n==== String Concatenation\n\nUse the `string concatenation operator '+'` to concatenate two values together\nwhere at least one of the values is a <<string-type, `String` type>>.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nconcatenate: expression '+' expression;\n----\n\n*Examples*\n\n* String concatenation with different primitive types.\n+\n[source,Painless]\n----\nString x = \"con\";     <1>\nString y = x + \"cat\"; <2>\nString z = 4 + 5 + x; <3>\n----\n+\n<1> declare `String x`;\n    store `String \"con\"` to `x`;\n<2> declare `String y`;\n    load from `x` -> `String \"con\"`;\n    concat `String \"con\"` and `String \"cat\"` -> `String \"concat\"`;\n    store `String \"concat\"` to `y`\n<3> declare `String z`;\n    add `int 4` and `int 5` -> `int 9`;\n    concat `int 9` and `String \"9concat\"`;\n    store `String \"9concat\"` to `z`;\n    (note the addition is done prior to the concatenation due to precedence and\n            associativity of the specific operations)\n+\n* String concatenation with the `def` type.\n+\n[source,Painless]\n----\ndef d = 2;             <1>\nd = \"con\" + d + \"cat\"; <2>\n----\n+\n<1> declare `def`;\n    implicit cast `int 2` to `def` -> `def`;\n    store `def` in `d`;\n<2> concat `String \"con\"` and `int 2` -> `String \"con2\"`;\n    concat `String \"con2\"` and `String \"cat\"` -> `String \"con2cat\"`\n    implicit cast `String \"con2cat\"` to `def` -> `def`;\n    store `def` to `d`;\n    (note the switch in type of `d` from `int` to `String`)\n\n[[elvis-operator]]\n==== Elvis\n\nAn elvis consists of two expressions. The first expression is evaluated\nwith to check for a `null` value. If the first expression evaluates to\n`null` then the second expression is evaluated and its value used. If the first\nexpression evaluates to `non-null` then the resultant value of the first\nexpression is used. Use the `elvis operator '?:'` as a shortcut for the\nconditional operator.\n\n*Errors*\n\n* If the first expression or second expression cannot produce a `null` value.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nelvis: expression '?:' expression;\n----\n\n*Examples*\n\n* Elvis with different reference types.\n+\n[source,Painless]\n----\nList x = new ArrayList();      <1>\nList y = x ?: new ArrayList(); <2>\ny = null;                      <3>\nList z = y ?: new ArrayList(); <4>\n----\n+\n<1> declare `List x`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `x`;\n<2> declare `List y`;\n    load `x` -> `List reference`;\n    `List reference` equals `null` -> `false`;\n    evaluate 1st expression: `List reference` -> `List reference`;\n    store `List reference` to `y`\n<3> store `null` to `y`;\n<4> declare `List z`;\n    load `y` -> `List reference`;\n    `List reference` equals `null` -> `true`;\n    evaluate 2nd expression:\n            allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `z`;\n"
}