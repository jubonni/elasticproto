{
    "meta": {
        "timestamp": "2024-11-01T02:49:24.710066",
        "size": 11661,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/pki-realm-for-direct-clients.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "pki-realm-for-direct-clients",
        "version": "8.15"
    },
    "doc": "[[pki-realm-for-direct-clients]]\n==== PKI authentication for clients connecting directly to {es}\n\nTo use PKI in {es}, you configure a PKI realm, enable client authentication on\nthe desired network layers (transport or http), and map the Distinguished Names\n(DNs) from the Subject field in the user certificates to roles. You create the\nmappings in a role mapping file or use the role mappings API.\n\n. Add a realm configuration for a `pki` realm to `elasticsearch.yml` under the\n`xpack.security.authc.realms.pki` namespace. You must explicitly set the `order`\nattribute. See <<ref-pki-settings>> for all of the options you can set for a\n`pki` realm.\n+\n--\nFor example, the following snippet shows the most basic `pki` realm configuration:\n\n[source, yaml]\n------------------------------------------------------------\nxpack:\n  security:\n    authc:\n      realms:\n        pki:\n          pki1:\n            order: 1\n------------------------------------------------------------\n\nWith this configuration, any certificate trusted by the {es} SSL/TLS layer is\naccepted for authentication. The username is the common name (CN) extracted\nfrom the DN in the Subject field of the end-entity certificate. This\nconfiguration is not sufficient to permit PKI authentication to {kib};\nadditional steps are required.\n\nIMPORTANT: When you configure realms in `elasticsearch.yml`, only the\nrealms you specify are used for authentication. If you also want to use the\n`native` or `file` realms, you must include them in the realm chain.\n\n--\n\n. Optional: The username is defined by the <<ref-pki-settings, username_pattern>>.\nIf you want to use something other than the CN of the Subject DN as\nthe username, you can specify a regex to extract the desired username. The regex\nis applied on the Subject DN.\n+\n--\nFor example, the regex in the following\nconfiguration extracts the email address from the Subject DN:\n\n[source, yaml]\n------------------------------------------------------------\nxpack:\n  security:\n    authc:\n      realms:\n        pki:\n          pki1:\n            order: 1\n            username_pattern: \"EMAILADDRESS=(.*?)(?:,|$)\"\n------------------------------------------------------------\n\nNOTE: If the regex is too restrictive and does not match the Subject DN of the\nclient's certificate, then the realm does not authenticate the certificate.\n\n--\n\n. Optional: If you want the same users to also be authenticated using\ncertificates when they connect to {kib}, you must configure the {es} PKI realm\nto allow delegation. See <<pki-realm-for-proxied-clients>>.\n\n. Restart {es} because realm configuration is not reloaded automatically. If\nyou're following through with the next steps, you might wish to hold the\nrestart for last.\n\n. <<encrypt-internode-communication,Enable SSL/TLS>>.\n\n. Enable client authentication on the desired network layers (transport or http).\n+\n--\nIMPORTANT: To use PKI when clients connect directly to {es}, you must enable\nSSL/TLS with client authentication. That is to say, you must set   `xpack.security.transport.ssl.client_authentication` and\n`xpack.security.http.ssl.client_authentication` to `optional` or `required`. If\nthe setting value is `optional`, clients without certificates can authenticate\nwith other credentials.\n\nWhen clients connect directly to {es} and are not proxy-authenticated, the PKI\nrealm relies on the TLS settings of the node's network interface. The realm can\nbe configured to be more restrictive than the underlying network connection.\nThat is, it is possible to configure the node such that some connections\nare accepted by the network interface but then fail to be authenticated by the\nPKI realm. However, the reverse is not possible. The PKI realm cannot\nauthenticate a connection that has been refused by the network interface.\n\nIn particular this means:\n\n* The transport or http interface must request client certificates by setting\n  `client_authentication` to `optional` or `required`.\n* The interface must _trust_ the certificate that is presented by the client\n  by configuring either the `truststore` or `certificate_authorities` paths,\n  or by setting `verification_mode` to `none`.\n* The _protocols_ supported by the interface must be compatible with those\n  used by the client.\n\nFor an explanation of these settings, see <<ssl-tls-settings>>.\n\nThe relevant network interface (transport or http) must be configured to trust\nany certificate that is to be used within the PKI realm. However, it is possible\nto configure the PKI realm to trust only a _subset_ of the certificates accepted\nby the network interface. This is useful when the SSL/TLS layer trusts clients\nwith certificates that are signed by a different CA than the one that signs your\nusers' certificates.\n\nTo configure the PKI realm with its own truststore, specify the\n`truststore.path` option. The path must be located within the Elasticsearch\nconfiguration directory (`ES_PATH_CONF`). For example:\n\n[source, yaml]\n------------------------------------------------------------\nxpack:\n  security:\n    authc:\n      realms:\n        pki:\n          pki1:\n            order: 1\n            truststore:\n              path: \"pki1_truststore.jks\"\n------------------------------------------------------------\n\nIf the truststore is password protected, the password should be configured by\nadding the appropriate `secure_password` setting to the {es} keystore. For\nexample, the following command adds the password for the example realm above:\n\n[source, shell]\n------------------------------------------------------------\nbin/elasticsearch-keystore add \\\nxpack.security.authc.realms.pki.pki1.truststore.secure_password\n------------------------------------------------------------\n\nThe `certificate_authorities` option can be used as an alternative to the\n`truststore.path` setting, when the certificate files are PEM formatted. The\nsetting accepts a list. The two options are exclusive, they cannot be both used\nsimultaneously.\n--\n\n. Map roles for PKI users.\n+\n--\nYou map roles for PKI users through the\n<<security-role-mapping-apis,role mapping APIs>> or by using a file stored on\neach node. Both configuration options are merged together. When a user\nauthenticates against a PKI realm, the privileges for that user are the union of\nall privileges defined by the roles to which the user is mapped.\n\nYou identify a user by the distinguished name in their certificate.\nFor example, the following mapping configuration maps `John Doe` to the\n`user` role using the role mapping API:\n\n[source,console]\n--------------------------------------------------\nPUT /_security/role_mapping/users\n{\n  \"roles\" : [ \"user\" ],\n  \"rules\" : { \"field\" : {\n    \"dn\" : \"cn=John Doe,ou=example,o=com\" <1>\n  } },\n  \"enabled\": true\n}\n--------------------------------------------------\n\n<1> The distinguished name (DN) of a PKI user.\n\nAlternatively, use a role-mapping file. For example:\n\n[source, yaml]\n------------------------------------------------------------\nuser: <1>\n  - \"cn=John Doe,ou=example,o=com\" <2>\n------------------------------------------------------------\n<1> The name of a role.\n<2> The distinguished name (DN) of a PKI user.\n\nThe file's path defaults to `ES_PATH_CONF/role_mapping.yml`. You can specify a\ndifferent path (which must be within `ES_PATH_CONF`) by using the\n`files.role_mapping` realm setting (e.g.\n`xpack.security.authc.realms.pki.pki1.files.role_mapping`).\n\nThe distinguished name for a PKI user follows X.500 naming conventions which\nplace the most specific fields (like `cn` or `uid`) at the beginning of the\nname and the most general fields (like `o` or `dc`) at the end of the name.\nSome tools, such as _openssl_, may print out the subject name in a different\nformat.\n\nOne way that you can determine the correct DN for a certificate is to use the\n<<security-api-authenticate,authenticate API>> (use the relevant PKI\ncertificate as the means of authentication) and inspect the metadata field in\nthe result. The user's distinguished name will be populated under the `pki_dn`\nkey. You can also use the authenticate API to validate your role mapping.\n\nFor more information, see <<mapping-roles>>.\n\nNOTE: The PKI realm supports <<authorization_realms,authorization realms>> as an\nalternative to role mapping.\n\n--\n\n[[pki-realm-for-proxied-clients]]\n==== PKI authentication for clients connecting to {kib}\n\nBy default, the PKI realm relies on the node's network interface to perform the\nSSL/TLS handshake and extract the client certificate. This behaviour requires\nthat clients connect directly to {es} so that their SSL connection is terminated\nby the {es} node. If SSL/TLS authentication is to be performed by {kib}, the\nPKI realm must be configured to permit delegation.\n\nSpecifically, when clients presenting X.509 certificates connect to {kib},\n{kib} performs the SSL/TLS authentication. {kib} then forwards the client's\ncertificate chain (by calling an {es} API) to have them further validated by\nthe PKI realms that have been configured for delegation.\n\nTo permit authentication delegation for a specific {es} PKI realm, start by\nconfiguring the realm for the usual case, as detailed in the\n<<pki-realm-for-direct-clients>> section. In this scenario, when you enable TLS,\nit is mandatory that you <<encrypt-http-communication,encrypt HTTP client communications>>.\n\nYou must also explicitly configure a `truststore` (or, equivalently\n`certificate_authorities`) even though it is the same trust configuration that\nyou have configured on the network layer. The\n`xpack.security.authc.token.enabled` and `delegation.enabled` settings must also\nbe `true`. For example:\n\n[source, yaml]\n------------------------------------------------------------\nxpack:\n  security:\n    authc:\n      token.enabled: true\n      realms:\n        pki:\n          pki1:\n            order: 1\n            delegation.enabled: true\n            truststore:\n              path: \"pki1_truststore.jks\"\n------------------------------------------------------------\n\nAfter you restart {es}, this realm can validate delegated PKI authentication.\nYou must then\n{kibana-ref}/kibana-authentication.html#pki-authentication[configure {kib} to allow PKI certificate authentication].\n\nA PKI realm with `delegation.enabled` still works unchanged for clients\nconnecting directly to {es}. Directly authenticated users and users that are PKI\nauthenticated by delegation to {kib} both follow the same\n<<mapping-roles,role mapping rules>> or\n<<authorization_realms,authorization realms configurations>>.\n\nIf you use the <<security-role-mapping-apis,role mapping APIs>>, however, you\ncan distinguish between users that are authenticated by delegation and users\nthat are authenticated directly. The former have the extra fields\n`pki_delegated_by_user` and `pki_delegated_by_realm` in the user's metadata. In\nthe common setup, where authentication is delegated to {kib}, the values of\nthese fields are `kibana` and `reserved`, respectively. For example, the\nfollowing role mapping rule assigns the `role_for_pki1_direct` role to all users\nthat have been authenticated directly by the `pki1` realm, by connecting to {es}\ninstead of going through {kib}:\n\n[source,console]\n--------------------------------------------------\nPUT /_security/role_mapping/direct_pki_only\n{\n  \"roles\" : [ \"role_for_pki1_direct\" ],\n  \"rules\" : {\n    \"all\": [\n      {\n        \"field\": {\"realm.name\": \"pki1\"}\n      },\n      {\n        \"field\": {\n          \"metadata.pki_delegated_by_user\": null <1>\n        }\n      }\n    ]\n  },\n  \"enabled\": true\n}\n--------------------------------------------------\n\n<1> If this metadata field is set (that is to say, it is *not* `null`), the user\nhas been authenticated in the delegation scenario.\n"
}