{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.114074",
        "size": 7283,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/remote-clusters-settings.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "remote-clusters-settings",
        "version": "8.15"
    },
    "doc": "[[remote-clusters-settings]]\n=== Remote cluster settings\nThe following settings apply to both <<sniff-mode,sniff mode>> and\n<<proxy-mode,proxy mode>>. Settings that are specific to sniff mode and proxy\nmode are described separately.\n\n`cluster.remote.<cluster_alias>.mode`::\n  The mode used for a remote cluster connection. The only supported modes are\n  `sniff` and `proxy`. The default is `sniff`. See <<sniff-proxy-modes>> for\n  further information about these modes, and <<remote-cluster-sniff-settings>>\n  and <<remote-cluster-proxy-settings>> for further information about their\n  settings.\n\n`cluster.remote.initial_connect_timeout`::\n\n  The time to wait for remote connections to be established when the node\n  starts. The default is `30s`.\n\n`remote_cluster_client` <<node-roles,role>>::\n\n  By default, any node in the cluster can act as a cross-cluster client and\n  connect to remote clusters. To prevent a node from connecting to remote\n  clusters, specify the <<node-roles,node.roles>> setting in `elasticsearch.yml`\n  and exclude `remote_cluster_client` from the listed roles. Search requests\n  targeting remote clusters must be sent to a node that is allowed to act as a\n  cross-cluster client. Other features such as {ml} <<general-ml-settings,data\n  feeds>>, <<general-transform-settings,transforms>>, and\n  <<ccr-getting-started-tutorial,{ccr}>> require the `remote_cluster_client` role.\n\n`cluster.remote.<cluster_alias>.skip_unavailable`::\n\n  Per cluster boolean setting that allows to skip specific clusters when no\n  nodes belonging to them are available and they are the target of a remote\n  cluster request.\n\nIMPORTANT: In Elasticsearch 8.15, the default value for `skip_unavailable` was\nchanged from `false` to `true`. Before Elasticsearch 8.15, if you want a cluster\nto be treated as optional for a {ccs}, then you need to set that configuration.\nFrom Elasticsearch 8.15 forward, you need to set the configuration in order to\nmake a cluster required for the {ccs}. Once you upgrade the local (\"querying\")\ncluster search coordinator node (the node you send CCS requests to) to 8.15 or later,\nany remote clusters that do not have an explicit setting for `skip_unavailable` will\nimmediately change over to using the new default of true. This is true regardless of\nwhether you have upgraded the remote clusters to 8.15, as the `skip_unavailable`\nsearch behavior is entirely determined by the setting on the local cluster where\nyou configure the remotes.\n\n\n`cluster.remote.<cluster_alias>.transport.ping_schedule`::\n\n  Sets the time interval between regular application-level ping messages that\n  are sent to try and keep remote cluster connections alive. If set to `-1`,\n  application-level ping messages to this remote cluster are not sent. If\n  unset, application-level ping messages are sent according to the global\n  `transport.ping_schedule` setting, which defaults to `-1` meaning that pings\n  are not sent. It is preferable to correctly configure TCP keep-alives instead\n  of configuring a `ping_schedule`, because TCP keep-alives are handled by the\n  operating system and not by {es}. By default {es} enables TCP keep-alives on\n  remote cluster connections. Remote cluster connections are transport\n  connections so the `transport.tcp.*` <<transport-settings,advanced settings>>\n  regarding TCP keep-alives apply to them.\n\n`cluster.remote.<cluster_alias>.transport.compress`::\n\n  Per-cluster setting that enables you to configure compression for requests to\n  a specific remote cluster. The handling cluster will automatically compress\n  responses to compressed requests. The setting options are `true`,\n  `indexing_data`, and `false`. If unset, defaults to the behaviour specified\n  by the node-wide `transport.compress` setting. See the\n  <<transport-settings-compress,documentation for the `transport.compress`\n  setting>> for further information.\n\n`cluster.remote.<cluster_alias>.transport.compression_scheme`::\n\n  Per-cluster setting that enables you to configure the compression scheme for\n  requests to a specific cluster if those requests are selected to be\n  compressed by to the `cluster.remote.<cluster_alias>.transport.compress`\n  setting. The handling cluster will automatically use the same compression\n  scheme for responses as for the corresponding requests. The setting options\n  are `deflate` and `lz4`. If unset, defaults to the behaviour specified by the\n  node-wide `transport.compression_scheme` setting. See the\n  <<transport-settings-compression-scheme,documentation for the\n  `transport.compression_scheme` setting>> for further information.\n\n[[remote-cluster-credentials-setting]]\n`cluster.remote.<cluster_alias>.credentials`::\n\n  (<<secure-settings,Secure>>, <<reloadable-secure-settings,Reloadable>>)\n  Per-cluster setting for configuring <<remote-clusters-api-key,remote clusters\n  with the API Key based model>>. This setting takes the encoded value of a\n  <<security-api-create-cross-cluster-api-key,cross-cluster API key>> and must\n  be set in the <<secure-settings,{es} keystore>> on each node in the cluster.\n  The presence (or not) of this setting determines which model a remote cluster\n  uses. If present, the remote cluster uses the API key based model. Otherwise,\n  it uses the certificate based model. If the setting is added, removed, or\n  updated in the <<secure-settings,{es} keystore>> and reloaded via the\n  <<cluster-nodes-reload-secure-settings>> API, the cluster will automatically\n  rebuild its connection to the remote.\n\n[[remote-cluster-sniff-settings]]\n==== Sniff mode remote cluster settings\n\nTo use <<sniff-mode,sniff mode>> to connect to a remote cluster, set\n`cluster.remote.<cluster_alias>.mode: sniff` and then configure the following\nsettings. You may also leave `cluster.remote.<cluster_alias>.mode` unset since\n`sniff` is the default mode.\n\n`cluster.remote.<cluster_alias>.seeds`::\n\n  The list of seed nodes used to sniff the remote cluster state.\n\n`cluster.remote.<cluster_alias>.node_connections`::\n\n  The number of gateway nodes to connect to for this remote cluster. The default\n  is `3`.\n\n[[cluster-remote-node-attr]]\n`cluster.remote.node.attr`::\n\n  A node attribute to filter out nodes that are eligible as a gateway node in\n  the remote cluster. For instance a node can have a node attribute\n  `node.attr.gateway: true` such that only nodes with this attribute will be\n  connected to if `cluster.remote.node.attr` is set to `gateway`.\n\n[[remote-cluster-proxy-settings]]\n==== Proxy mode remote cluster settings\n\nTo use <<proxy-mode,proxy mode>> to connect to a remote cluster, set\n`cluster.remote.<cluster_alias>.mode: proxy` and then configure the following\nsettings.\n\n`cluster.remote.<cluster_alias>.proxy_address`::\n\n  The address used for all remote connections.\n\n`cluster.remote.<cluster_alias>.proxy_socket_connections`::\n\n  The number of socket connections to open per remote cluster. The default is\n  `18`.\n\n[role=\"xpack\"]\n`cluster.remote.<cluster_alias>.server_name`::\n\n  An optional hostname string which is sent in the `server_name` field of\n  the TLS Server Name Indication extension if\n  <<encrypt-internode-communication,TLS is enabled>>. The TLS transport will fail to open\n  remote connections if this field is not a valid hostname as defined by the\n  TLS SNI specification.\n"
}