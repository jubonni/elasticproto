{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.543069",
        "size": 5150,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mixing-exact-search-with-stemming.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "mixing-exact-search-with-stemming",
        "version": "8.15"
    },
    "doc": "[[mixing-exact-search-with-stemming]]\n=== Mixing exact search with stemming\n\nWhen building a search application, stemming is often a must as it is desirable\nfor a query on `skiing` to match documents that contain `ski` or `skis`. But\nwhat if a user wants to search for `skiing` specifically? The typical way to do\nthis would be to use a <<multi-fields,multi-field>> in order to have the same\ncontent indexed in two different ways:\n\n[source,console]\n--------------------------------------------------\nPUT index\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"english_exact\": {\n          \"tokenizer\": \"standard\",\n          \"filter\": [\n            \"lowercase\"\n          ]\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"body\": {\n        \"type\": \"text\",\n        \"analyzer\": \"english\",\n        \"fields\": {\n          \"exact\": {\n            \"type\": \"text\",\n            \"analyzer\": \"english_exact\"\n          }\n        }\n      }\n    }\n  }\n}\n\nPUT index/_doc/1\n{\n  \"body\": \"Ski resort\"\n}\n\nPUT index/_doc/2\n{\n  \"body\": \"A pair of skis\"\n}\n\nPOST index/_refresh\n--------------------------------------------------\n\nWith such a setup, searching for `ski` on `body` would return both documents:\n\n[source,console]\n--------------------------------------------------\nGET index/_search\n{\n  \"query\": {\n    \"simple_query_string\": {\n      \"fields\": [ \"body\" ],\n      \"query\": \"ski\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 2,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.18232156,\n    \"hits\": [\n      {\n        \"_index\": \"index\",\n        \"_id\": \"1\",\n        \"_score\": 0.18232156,\n        \"_source\": {\n          \"body\": \"Ski resort\"\n        }\n      },\n      {\n        \"_index\": \"index\",\n        \"_id\": \"2\",\n        \"_score\": 0.18232156,\n        \"_source\": {\n          \"body\": \"A pair of skis\"\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 2,/\"took\": \"$body.took\",/]\n\nOn the other hand, searching for `ski` on `body.exact` would only return\ndocument `1` since the analysis chain of `body.exact` does not perform\nstemming.\n\n[source,console]\n--------------------------------------------------\nGET index/_search\n{\n  \"query\": {\n    \"simple_query_string\": {\n      \"fields\": [ \"body.exact\" ],\n      \"query\": \"ski\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 1,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.8025915,\n    \"hits\": [\n      {\n        \"_index\": \"index\",\n        \"_id\": \"1\",\n        \"_score\": 0.8025915,\n        \"_source\": {\n          \"body\": \"Ski resort\"\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 1,/\"took\": \"$body.took\",/]\n\nThis is not something that is easy to expose to end users, as we would need to\nhave a way to figure out whether they are looking for an exact match or not and\nredirect to the appropriate field accordingly. Also what to do if only parts of\nthe query need to be matched exactly while other parts should still take\nstemming into account?\n\nFortunately, the `query_string` and `simple_query_string` queries have a feature\nthat solves this exact problem: `quote_field_suffix`. This tells Elasticsearch\nthat the words that appear in between quotes are to be redirected to a different\nfield, see below:\n\n[source,console]\n--------------------------------------------------\nGET index/_search\n{\n  \"query\": {\n    \"simple_query_string\": {\n      \"fields\": [ \"body\" ],\n      \"quote_field_suffix\": \".exact\",\n      \"query\": \"\\\"ski\\\"\"\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\" : 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\" : {\n        \"value\": 1,\n        \"relation\": \"eq\"\n    },\n    \"max_score\": 0.8025915,\n    \"hits\": [\n      {\n        \"_index\": \"index\",\n        \"_id\": \"1\",\n        \"_score\": 0.8025915,\n        \"_source\": {\n          \"body\": \"Ski resort\"\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 2,/\"took\": \"$body.took\",/]\n\nIn the above case, since `ski` was in-between quotes, it was searched on the\n`body.exact` field due to the `quote_field_suffix` parameter, so only document\n`1` matched. This allows users to mix exact search with stemmed search as they\nlike.\n\nNOTE: If the choice of field passed in `quote_field_suffix` does not exist \nthe search will fall back to using the default field for the query string.\n"
}