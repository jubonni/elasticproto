{
    "meta": {
        "size": 5267,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-range-field-note.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-bucket-range-field-note",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-range-field-note]]\n=== Subtleties of bucketing range fields\n\n==== Documents are counted for each bucket they land in\n\nSince a range represents multiple values, running a bucket aggregation over a\nrange field can result in the same document landing in multiple buckets. This\ncan lead to surprising behavior, such as the sum of bucket counts being higher\nthan the number of matched documents. For example, consider the following\nindex: \n[source, console]\n--------------------------------------------------\nPUT range_index\n{\n  \"settings\": {\n    \"number_of_shards\": 2\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"expected_attendees\": {\n        \"type\": \"integer_range\"\n      },\n      \"time_frame\": {\n        \"type\": \"date_range\",\n        \"format\": \"yyyy-MM-dd||epoch_millis\"\n      }\n    }\n  }\n}\n\nPUT range_index/_doc/1?refresh\n{\n  \"expected_attendees\" : {\n    \"gte\" : 10,\n    \"lte\" : 20\n  },\n  \"time_frame\" : {\n    \"gte\" : \"2019-10-28\",\n    \"lte\" : \"2019-11-04\"\n  }\n}\n--------------------------------------------------\n// TESTSETUP\n\nThe range is wider than the interval in the following aggregation, and thus the\ndocument will land in multiple buckets.\n\n[source, console,id=range-field-aggregation-example]\n--------------------------------------------------\nPOST /range_index/_search?size=0\n{\n  \"aggs\": {\n    \"range_histo\": {\n      \"histogram\": {\n        \"field\": \"expected_attendees\",\n        \"interval\": 5\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nSince the interval is `5` (and the offset is `0` by default), we expect buckets `10`,\n`15`, and `20`. Our range document will fall in all three of these buckets.\n\n[source, console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\" : {\n    \"range_histo\" : {\n      \"buckets\" : [\n        {\n          \"key\" : 10.0,\n          \"doc_count\" : 1\n        },\n        {\n          \"key\" : 15.0,\n          \"doc_count\" : 1\n        },\n        {\n          \"key\" : 20.0,\n          \"doc_count\" : 1\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\nA document cannot exist partially in a bucket; For example, the above document\ncannot count as one-third in each of the above three buckets. In this example,\nsince the document's range landed in multiple buckets, the full value of that\ndocument would also be counted in any sub-aggregations for each bucket as well.\n\n==== Query bounds are not aggregation filters\n\nAnother unexpected behavior can arise when a query is used to filter on the\nfield being aggregated. In this case, a document could match the query but\nstill have one or both of the endpoints of the range outside the query.\nConsider the following aggregation on the above document:\n\n[source, console,id=range-field-aggregation-query-bounds-example]\n--------------------------------------------------\nPOST /range_index/_search?size=0\n{\n  \"query\": {\n    \"range\": {\n      \"time_frame\": {\n        \"gte\": \"2019-11-01\",\n        \"format\": \"yyyy-MM-dd\"\n      }\n    }\n  },\n  \"aggs\": {\n    \"november_data\": {\n      \"date_histogram\": {\n        \"field\": \"time_frame\",\n        \"calendar_interval\": \"day\",\n        \"format\": \"yyyy-MM-dd\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nEven though the query only considers days in November, the aggregation\ngenerates 8 buckets (4 in October, 4 in November) because the aggregation is\ncalculated over the ranges of all matching documents.\n\n[source, console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\" : {\n    \"november_data\" : {\n      \"buckets\" : [\n              {\n          \"key_as_string\" : \"2019-10-28\",\n          \"key\" : 1572220800000,\n          \"doc_count\" : 1\n        },\n        {\n          \"key_as_string\" : \"2019-10-29\",\n          \"key\" : 1572307200000,\n          \"doc_count\" : 1\n        },\n        {\n          \"key_as_string\" : \"2019-10-30\",\n          \"key\" : 1572393600000,\n          \"doc_count\" : 1\n        },\n        {\n          \"key_as_string\" : \"2019-10-31\",\n          \"key\" : 1572480000000,\n          \"doc_count\" : 1\n        },\n        {\n          \"key_as_string\" : \"2019-11-01\",\n          \"key\" : 1572566400000,\n          \"doc_count\" : 1\n        },\n        {\n          \"key_as_string\" : \"2019-11-02\",\n          \"key\" : 1572652800000,\n          \"doc_count\" : 1\n        },\n        {\n          \"key_as_string\" : \"2019-11-03\",\n          \"key\" : 1572739200000,\n          \"doc_count\" : 1\n        },\n        {\n          \"key_as_string\" : \"2019-11-04\",\n          \"key\" : 1572825600000,\n          \"doc_count\" : 1\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\nDepending on the use case, a `CONTAINS` query could limit the documents to only\nthose that fall entirely in the queried range. In this example, the one\ndocument would not be included and the aggregation would be empty. Filtering\nthe buckets after the aggregation is also an option, for use cases where the\ndocument should be counted but the out of bounds data can be safely ignored.\n"
}