{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.902580",
        "size": 5265,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "mapping",
        "version": "8.15"
    },
    "doc": "[[mapping]]\n= Mapping\n\n[partintro]\n--\n\nMapping is the process of defining how a document, and the fields it contains,\nare stored and indexed.\n\nEach document is a collection of fields, which each have their own\n<<mapping-types,data type>>. When mapping your data, you create a mapping\ndefinition, which contains a list of fields that are pertinent to the document.\nA mapping definition also includes <<mapping-fields,metadata fields>>, like the\n`_source` field, which customize how a document's associated metadata is\nhandled.\n\nUse _dynamic mapping_ and _explicit mapping_ to define your data. Each method\nprovides different benefits based on where you are in your data journey. For\nexample, explicitly map fields where you don't want to use the defaults, or to\ngain greater control over which fields are created. You can then allow {es} to\nadd other fields dynamically.\n\nNOTE: Before 7.0.0, the mapping definition included a type name.\n{es} 7.0.0 and later no longer accept a _default_ mapping. See <<removal-of-types>>.\n\n.Experiment with mapping options\n****\n<<runtime-search-request,Define runtime fields in a search request>> to\nexperiment with different mapping options, and also fix mistakes in your index\nmapping values by overriding values in the mapping during the search request.\n****\n\n[discrete]\n[[mapping-dynamic]]\n== Dynamic mapping\n\nWhen you use <<dynamic-field-mapping,dynamic mapping>>, {es} automatically\nattempts to detect the data type of fields in your documents. This allows \nyou to get started quickly by just adding data to an index. If you index\nadditional documents with new fields, {es} will add these fields automatically. \nYou can add fields to the top-level mapping, and to inner <<object,`object`>> \nand <<nested,`nested`>> fields.\n\nUse <<dynamic-templates,dynamic templates>> to define custom mappings that are\napplied to dynamically added fields based on the matching condition.\n\n[discrete]\n[[mapping-explicit]]\n== Explicit mapping\n\nUse <<explicit-mapping,explicit mapping>> to define exactly how data types\nare mapped to fields, customized to your specific use case.\n\nDefining your own mappings enables you to:\n\n* Define which string fields should be treated as full-text fields.\n* Define which fields contain numbers, dates, or geolocations.\n* Use data types that cannot be automatically detected (such as `geo_point` and `geo_shape`.)\n* Choose date value <<mapping-date-format,formats>>, including custom date formats.\n* Create custom rules to control the mapping for <<dynamic-mapping,dynamically added fields>>.\n* Optimize fields for partial matching.\n* Perform language-specific text analysis.\n\n[TIP]\n====\nIt\u2019s often useful to index the same field in different ways for different purposes.\nFor example, you might want to index a string field as both a text field for full-text \nsearch and as a keyword field for sorting or aggregating your data. Or, you might \nchoose to use more than one language analyzer to process the contents of a string field \nthat contains user input.\n====\n\nUse <<runtime-mapping-fields,runtime fields>> to make schema changes without\nreindexing. You can use runtime fields in conjunction with indexed fields to\nbalance resource usage and performance. Your index will be smaller, but with\nslower search performance.\n\n[discrete]\n[[mapping-manage-update]]\n== Managing and updating mappings\n\nExplicit mappings should be defined at index creation for fields you know in advance. \nYou can still add _new fields_ to mappings at any time, as your data evolves.\n\nUse the <<indices-put-mapping,Update mapping API>> to update an existing mapping.\n\nIn most cases, you can't change mappings for fields that are already mapped.\nThese changes require <<docs-reindex,reindexing>>.\n\nHowever, you can _update_ mappings under certain conditions:\n\n* You can add new fields to an existing mapping at any time, explicitly or dynamically.\n* You can add new <<multi-fields,multi-fields>> for existing fields.\n** Documents indexed before the mapping update will not have values for the new multi-fields until they are updated or reindexed. Documents indexed after the mapping change will automatically have values for the new multi-fields.\n* Some <<mapping-params,mapping parameters>> can be updated for existing fields of certain <<mapping-types,data types>>.\n\n[discrete]\n[[mapping-limit-settings]]\n== Prevent mapping explosions\n\nDefining too many fields in an index can lead to a mapping explosion, which can\ncause out of memory errors and difficult situations to recover from.\n\nConsider a situation where every new document inserted\nintroduces new fields, such as with <<dynamic-mapping,dynamic mapping>>.\nEach new field is added to the index mapping, which can become a\nproblem as the mapping grows.\n\nUse the <<mapping-settings-limit,mapping limit settings>> to limit the number\nof field mappings (created manually or dynamically) and prevent documents from\ncausing a mapping explosion.\n\n--\n\ninclude::mapping/dynamic-mapping.asciidoc[]\n\ninclude::mapping/explicit-mapping.asciidoc[]\n\ninclude::mapping/runtime.asciidoc[]\n\ninclude::mapping/types.asciidoc[]\n\ninclude::mapping/fields.asciidoc[]\n\ninclude::mapping/params.asciidoc[]\n\ninclude::mapping/mapping-settings-limit.asciidoc[]\n\ninclude::mapping/removal_of_types.asciidoc[]\n"
}