{
    "meta": {
        "size": 5559,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-disk-usage.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "tune-for-disk-usage",
        "version": "8.15"
    },
    "doc": "[[tune-for-disk-usage]]\n== Tune for disk usage\n\n[discrete]\n=== Disable the features you do not need\n\nBy default, {es} indexes and adds doc values to most fields so that they\ncan be searched and aggregated out of the box. For instance, if you have a numeric\nfield called `foo` that you need to run histograms on but that you never need to\nfilter on, you can safely disable indexing on this field in your\n<<mappings,mappings>>:\n\n[source,console]\n----\nPUT index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"foo\": {\n        \"type\": \"integer\",\n        \"index\": false\n      }\n    }\n  }\n}\n----\n\n<<text,`text`>> fields store normalization factors in the index to facilitate\ndocument scoring. If you only need matching capabilities on a `text`\nfield but do not care about the produced scores, you can use the\n<<match-only-text-field-type,`match_only_text`>> type instead. This field type\nsaves significant space by dropping scoring and positional information.\n\n[discrete]\n[[default-dynamic-string-mapping]]\n=== Don't use default dynamic string mappings\n\nThe default <<dynamic-mapping,dynamic string mappings>> will index string fields\nboth as <<text,`text`>> and <<keyword,`keyword`>>. This is wasteful if you only\nneed one of them. Typically an `id` field will only need to be indexed as a\n`keyword` while a `body` field will only need to be indexed as a `text` field.\n\nThis can be disabled by either configuring explicit mappings on string fields\nor setting up dynamic templates that will map string fields as either `text`\nor `keyword`.\n\nFor instance, here is a template that can be used in order to only map string\nfields as `keyword`:\n\n[source,console]\n--------------------------------------------------\nPUT index\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"strings\": {\n          \"match_mapping_type\": \"string\",\n          \"mapping\": {\n            \"type\": \"keyword\"\n          }\n        }\n      }\n    ]\n  }\n}\n--------------------------------------------------\n\n[discrete]\n=== Watch your shard size\n\nLarger shards are going to be more efficient at storing data. To increase the size of your shards, you can decrease the number of primary shards in an index by <<indices-create-index,creating indices>> with fewer primary shards, creating fewer indices (e.g. by leveraging the <<indices-rollover-index,Rollover API>>), or modifying an existing index using the <<indices-shrink-index,Shrink API>>.\n\nKeep in mind that large shard sizes come with drawbacks, such as long full recovery times.\n\n[discrete]\n[[disable-source]]\n=== Disable `_source`\n\nThe <<mapping-source-field,`_source`>> field stores the original JSON body of the document. If you don\u2019t need access to it you can disable it. However, APIs that needs access to `_source` such as update, highlight and reindex won\u2019t work.\n\n[discrete]\n[[best-compression]]\n=== Use `best_compression`\n\nThe `_source` and stored fields can easily take a non negligible amount of disk\nspace. They can be compressed more aggressively by using the `best_compression`\n<<index-codec,codec>>.\n\n[discrete]\n=== Force merge\n\nIndices in Elasticsearch are stored in one or more shards. Each shard is a Lucene index and made up of one or more segments - the actual files on disk. Larger segments are more efficient for storing data.\n\nThe <<indices-forcemerge,force merge API>> can be used to reduce the number of segments per shard. In many cases, the number of segments can be reduced to one per shard by setting `max_num_segments=1`.\n\ninclude::{es-ref-dir}/indices/forcemerge.asciidoc[tag=force-merge-read-only-warn]\n\n[discrete]\n=== Shrink index\n\nThe <<indices-shrink-index,shrink API>> allows you to reduce the number of shards in an index. Together with the force merge API above, this can significantly reduce the number of shards and segments of an index.\n\n[discrete]\n=== Use the smallest numeric type that is sufficient\n\nThe type that you pick for <<number,numeric data>> can have a significant impact\non disk usage. In particular, integers should be stored using an integer type\n(`byte`, `short`, `integer` or `long`) and floating points should either be\nstored in a `scaled_float` if appropriate or in the smallest type that fits the\nuse-case: using `float` over `double`, or `half_float` over `float` will help\nsave storage.\n\n[discrete]\n=== Use index sorting to colocate similar documents\n\nWhen Elasticsearch stores `_source`, it compresses multiple documents at once\nin order to improve the overall compression ratio. For instance it is very\ncommon that documents share the same field names, and quite common that they\nshare some field values, especially on fields that have a low cardinality or\na {wikipedia}/Zipf%27s_law[zipfian] distribution.\n\nBy default documents are compressed together in the order that they are added\nto the index. If you enabled <<index-modules-index-sorting,index sorting>>\nthen instead they are compressed in sorted order. Sorting documents with similar\nstructure, fields, and values together should improve the compression ratio.\n\n[discrete]\n=== Put fields in the same order in documents\n\nDue to the fact that multiple documents are compressed together into blocks,\nit is more likely to find longer duplicate strings in those `_source` documents\nif fields always occur in the same order.\n\n[discrete]\n[[roll-up-historical-data]]\n=== Roll up historical data\n\nKeeping older data can be useful for later analysis but is often avoided due to\nstorage costs. You can use downsampling to summarize and store historical data\nat a fraction of the raw data's storage cost. See <<downsampling>>.\n"
}