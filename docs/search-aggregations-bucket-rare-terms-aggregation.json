{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.058069",
        "size": 13559,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-rare-terms-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-bucket-rare-terms-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-rare-terms-aggregation]]\n=== Rare terms aggregation\n++++\n<titleabbrev>Rare terms</titleabbrev>\n++++\n\nA multi-bucket value source based aggregation which finds \"rare\" terms -- terms that are at the long-tail\nof the distribution and are not frequent. Conceptually, this is like a `terms` aggregation that is\nsorted by `_count` ascending. As noted in the <<search-aggregations-bucket-terms-aggregation-order,terms aggregation docs>>,\nactually ordering a `terms` agg by count ascending has unbounded error. Instead, you should use the `rare_terms`\naggregation\n\n//////////////////////////\n\n[source,js]\n--------------------------------------------------\nPUT /products\n{\n  \"mappings\": {\n    \"properties\": {\n      \"genre\": {\n        \"type\": \"keyword\"\n      },\n      \"product\": {\n        \"type\": \"keyword\"\n      }\n    }\n  }\n}\n\nPOST /products/_bulk?refresh\n{\"index\":{\"_id\":0}}\n{\"genre\": \"rock\", \"product\": \"Product A\"}\n{\"index\":{\"_id\":1}}\n{\"genre\": \"rock\"}\n{\"index\":{\"_id\":2}}\n{\"genre\": \"rock\"}\n{\"index\":{\"_id\":3}}\n{\"genre\": \"jazz\", \"product\": \"Product Z\"}\n{\"index\":{\"_id\":4}}\n{\"genre\": \"jazz\"}\n{\"index\":{\"_id\":5}}\n{\"genre\": \"electronic\"}\n{\"index\":{\"_id\":6}}\n{\"genre\": \"electronic\"}\n{\"index\":{\"_id\":7}}\n{\"genre\": \"electronic\"}\n{\"index\":{\"_id\":8}}\n{\"genre\": \"electronic\"}\n{\"index\":{\"_id\":9}}\n{\"genre\": \"electronic\"}\n{\"index\":{\"_id\":10}}\n{\"genre\": \"swing\"}\n\n-------------------------------------------------\n// NOTCONSOLE\n// TESTSETUP\n\n//////////////////////////\n\n==== Syntax\n\nA `rare_terms` aggregation looks like this in isolation:\n\n[source,js]\n--------------------------------------------------\n{\n  \"rare_terms\": {\n    \"field\": \"the_field\",\n    \"max_doc_count\": 1\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n.`rare_terms` Parameters\n|===\n|Parameter Name |Description |Required |Default Value\n|`field` |The field we wish to find rare terms in |Required |\n|`max_doc_count` |The maximum number of documents a term should appear in. |Optional |`1`\n|`precision` |The precision of the internal CuckooFilters. Smaller precision leads to\nbetter approximation, but higher memory usage. Cannot be smaller than `0.00001` |Optional |`0.001`\n|`include` |Terms that should be included in the aggregation|Optional |\n|`exclude` |Terms that should be excluded from the aggregation|Optional |\n|`missing` |The value that should be used if a document does not have the field being aggregated|Optional |\n|===\n\n\nExample:\n\n[source,console,id=rare-terms-aggregation-example]\n--------------------------------------------------\nGET /_search\n{\n  \"aggs\": {\n    \"genres\": {\n      \"rare_terms\": {\n        \"field\": \"genre\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"genres\": {\n      \"buckets\": [\n        {\n          \"key\": \"swing\",\n          \"doc_count\": 1\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n\nIn this example, the only bucket that we see is the \"swing\" bucket, because it is the only term that appears in\none document. If we increase the `max_doc_count` to `2`, we'll see some more buckets:\n\n[source,console,id=rare-terms-aggregation-max-doc-count-example]\n--------------------------------------------------\nGET /_search\n{\n  \"aggs\": {\n    \"genres\": {\n      \"rare_terms\": {\n        \"field\": \"genre\",\n        \"max_doc_count\": 2\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[s/_search/_search\\?filter_path=aggregations/]\n\nThis now shows the \"jazz\" term which has a `doc_count` of 2\":\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"genres\": {\n      \"buckets\": [\n        {\n          \"key\": \"swing\",\n          \"doc_count\": 1\n        },\n        {\n          \"key\": \"jazz\",\n          \"doc_count\": 2\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\.//]\n\n[[search-aggregations-bucket-rare-terms-aggregation-max-doc-count]]\n==== Maximum document count\n\nThe `max_doc_count` parameter is used to control the upper bound of document counts that a term can have. There\nis not a size limitation on the `rare_terms` agg like `terms` agg has. This means that terms\nwhich match the `max_doc_count` criteria will be returned. The aggregation functions in this manner to avoid\nthe order-by-ascending issues that afflict the `terms` aggregation.\n\nThis does, however, mean that a large number of results can be returned if chosen incorrectly.\nTo limit the danger of this setting, the maximum `max_doc_count` is 100.\n\n[[search-aggregations-bucket-rare-terms-aggregation-max-buckets]]\n==== Max Bucket Limit\n\nThe Rare Terms aggregation is more liable to trip the `search.max_buckets` soft limit than other aggregations due\nto how it works. The `max_bucket` soft-limit is evaluated on a per-shard basis while the aggregation is collecting\nresults. It is possible for a term to be \"rare\" on a shard but become \"not rare\" once all the shard results are\nmerged together. This means that individual shards tend to collect more buckets than are truly rare, because\nthey only have their own local view. This list is ultimately pruned to the correct, smaller list of rare\nterms on the coordinating node... but a shard may have already tripped the `max_buckets` soft limit and aborted\nthe request.\n\nWhen aggregating on fields that have potentially many \"rare\" terms, you may need to increase the `max_buckets` soft\nlimit. Alternatively, you might need to find a way to filter the results to return fewer rare values (smaller time\nspan, filter by category, etc), or re-evaluate your definition of \"rare\" (e.g. if something\nappears 100,000 times, is it truly \"rare\"?)\n\n[[search-aggregations-bucket-rare-terms-aggregation-approximate-counts]]\n==== Document counts are approximate\n\nThe naive way to determine the \"rare\" terms in a dataset is to place all the values in a map, incrementing counts\nas each document is visited, then return the bottom `n` rows. This does not scale beyond even modestly sized data\nsets. A sharded approach where only the \"top n\" values are retained from each shard (ala the `terms` aggregation)\nfails because the long-tail nature of the problem means it is impossible to find the \"top n\" bottom values without\nsimply collecting all the values from all shards.\n\nInstead, the Rare Terms aggregation uses a different approximate algorithm:\n\n1. Values are placed in a map the first time they are seen.\n2. Each addition occurrence of the term increments a counter in the map\n3. If the counter > the `max_doc_count` threshold, the term is removed from the map and placed in a\nhttps://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf[CuckooFilter]\n4. The CuckooFilter is consulted on each term. If the value is inside the filter, it is known to be above the\nthreshold already and skipped.\n\nAfter execution, the map of values is the map of \"rare\" terms under the `max_doc_count` threshold. This map and CuckooFilter\nare then merged with all other shards. If there are terms that are greater than the threshold (or appear in\na different shard's CuckooFilter) the term is removed from the merged list. The final map of values is returned\nto the user as the \"rare\" terms.\n\nCuckooFilters have the possibility of returning false positives (they can say a value exists in their collection when\nit actually does not). Since the CuckooFilter is being used to see if a term is over threshold, this means a false positive\nfrom the CuckooFilter will mistakenly say a value is common when it is not (and thus exclude it from it final list of buckets).\nPractically, this means the aggregations exhibits false-negative behavior since the filter is being used \"in reverse\"\nof how people generally think of approximate set membership sketches.\n\nCuckooFilters are described in more detail in the paper:\n\nhttps://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf[Fan, Bin, et al. \"Cuckoo filter: Practically better than bloom.\"]\nProceedings of the 10th ACM International on Conference on emerging Networking Experiments and Technologies. ACM, 2014.\n\n==== Precision\n\nAlthough the internal CuckooFilter is approximate in nature, the false-negative rate can be controlled with a\n`precision` parameter. This allows the user to trade more runtime memory for more accurate results.\n\nThe default precision is `0.001`, and the smallest (e.g. most accurate and largest memory overhead) is `0.00001`.\nBelow are some charts which demonstrate how the accuracy of the aggregation is affected by precision and number\nof distinct terms.\n\nThe X-axis shows the number of distinct values the aggregation has seen, and the Y-axis shows the percent error.\nEach line series represents one \"rarity\" condition (ranging from one rare item to 100,000 rare items). For example,\nthe orange \"10\" line means ten of the values were \"rare\" (`doc_count == 1`), out of 1-20m distinct values (where the\nrest of the values had `doc_count > 1`)\n\nThis first chart shows precision `0.01`:\n\nimage:images/rare_terms/accuracy_01.png[]\n\nAnd precision `0.001` (the default):\n\nimage:images/rare_terms/accuracy_001.png[]\n\nAnd finally `precision 0.0001`:\n\nimage:images/rare_terms/accuracy_0001.png[]\n\nThe default precision of `0.001` maintains an accuracy of < 2.5% for the tested conditions, and accuracy slowly\ndegrades in a controlled, linear fashion as the number of distinct values increases.\n\nThe default precision of `0.001` has a memory profile of `1.748\u207b\u2076 * n` bytes, where `n` is the number\nof distinct values the aggregation has seen (it can also be roughly eyeballed, e.g. 20 million unique values is about\n30mb of memory). The memory usage is linear to the number of distinct values regardless of which precision is chosen,\nthe precision only affects the slope of the memory profile as seen in this chart:\n\nimage:images/rare_terms/memory.png[]\n\nFor comparison, an equivalent terms aggregation at 20 million buckets would be roughly\n`20m * 69b == ~1.38gb` (with 69 bytes being a very optimistic estimate of an empty bucket cost, far lower than what\nthe circuit breaker accounts for). So although the `rare_terms` agg is relatively heavy, it is still orders of\nmagnitude smaller than the equivalent terms aggregation\n\n==== Filtering Values\n\nIt is possible to filter the values for which buckets will be created. This can be done using the `include` and\n`exclude` parameters which are based on regular expression strings or arrays of exact values. Additionally,\n`include` clauses can filter using `partition` expressions.\n\n===== Filtering Values with regular expressions\n\n[source,console,id=rare-terms-aggregation-regex-example]\n--------------------------------------------------\nGET /_search\n{\n  \"aggs\": {\n    \"genres\": {\n      \"rare_terms\": {\n        \"field\": \"genre\",\n        \"include\": \"swi*\",\n        \"exclude\": \"electro*\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nIn the above example, buckets will be created for all the tags that starts with `swi`, except those starting\nwith `electro` (so the tag `swing` will be aggregated but not `electro_swing`). The `include` regular expression will determine what\nvalues are \"allowed\" to be aggregated, while the `exclude` determines the values that should not be aggregated. When\nboth are defined, the `exclude` has precedence, meaning, the `include` is evaluated first and only then the `exclude`.\n\nThe syntax is the same as <<regexp-syntax,regexp queries>>.\n\n===== Filtering Values with exact values\n\nFor matching based on exact values the `include` and `exclude` parameters can simply take an array of\nstrings that represent the terms as they are found in the index:\n\n[source,console,id=rare-terms-aggregation-exact-value-example]\n--------------------------------------------------\nGET /_search\n{\n  \"aggs\": {\n    \"genres\": {\n      \"rare_terms\": {\n        \"field\": \"genre\",\n        \"include\": [ \"swing\", \"rock\" ],\n        \"exclude\": [ \"jazz\" ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n\n==== Missing value\n\nThe `missing` parameter defines how documents that are missing a value should be treated.\nBy default they will be ignored but it is also possible to treat them as if they\nhad a value.\n\n[source,console,id=rare-terms-aggregation-missing-example]\n--------------------------------------------------\nGET /_search\n{\n  \"aggs\": {\n    \"genres\": {\n      \"rare_terms\": {\n        \"field\": \"genre\",\n        \"missing\": \"N/A\" <1>\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> Documents without a value in the `tags` field will fall into the same bucket as documents that have the value `N/A`.\n\n==== Nested, RareTerms, and scoring sub-aggregations\n\nThe RareTerms aggregation has to operate in `breadth_first` mode, since it needs to prune terms as doc count thresholds\nare breached. This requirement means the RareTerms aggregation is incompatible with certain combinations of aggregations\nthat require `depth_first`. In particular, scoring sub-aggregations that are inside a `nested` force the entire aggregation tree to run\nin `depth_first` mode. This will throw an exception since RareTerms is unable to process `depth_first`.\n\nAs a concrete example, if `rare_terms` aggregation is the child of a `nested` aggregation, and one of the child aggregations of `rare_terms`\nneeds document scores (like a `top_hits` aggregation), this will throw an exception.\n"
}