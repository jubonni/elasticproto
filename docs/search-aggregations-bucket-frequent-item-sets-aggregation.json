{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.147078",
        "size": 13087,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-frequent-item-sets-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-bucket-frequent-item-sets-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-frequent-item-sets-aggregation]]\n=== Frequent item sets aggregation\n++++\n<titleabbrev>Frequent item sets</titleabbrev>\n++++\n\nA bucket aggregation which finds frequent item sets. It is a form of association\nrules mining that identifies items that often occur together. Items that are\nfrequently purchased together or log events that tend to co-occur are examples\nof frequent item sets. Finding frequent item sets helps to discover\nrelationships between different data points (items).\n\nThe aggregation reports closed item sets. A frequent item set is called closed\nif no superset exists with the same ratio of documents (also known as its\n<<frequent-item-sets-minimum-support,support value>>). For example, we have the two\nfollowing candidates for a frequent item set, which have the same support value:\n1. `apple, orange, banana`\n2. `apple, orange, banana, tomato`.\nOnly the second item set (`apple, orange, banana, tomato`) is returned, and the\nfirst set \u2013 which is a subset of the second one \u2013 is skipped. Both item sets\nmight be returned if their support values are different.\n\nThe runtime of the aggregation depends on the data and the provided parameters.\nIt might take a significant time for the aggregation to complete. For this\nreason, it is recommended to use <<async-search,async search>> to run your\nrequests asynchronously.\n\n\n==== Syntax\n\nA `frequent_item_sets` aggregation looks like this in isolation:\n\n[source,js]\n--------------------------------------------------\n\"frequent_item_sets\": {\n  \"minimum_set_size\": 3,\n  \"fields\": [\n    {\"field\": \"my_field_1\"},\n    {\"field\": \"my_field_2\"}\n  ]\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n.`frequent_item_sets` Parameters\n|===\n|Parameter Name |Description |Required |Default Value\n|`fields` |(array) Fields to analyze. | Required |\n|`minimum_set_size` | (integer) The <<frequent-item-sets-minimum-set-size,minimum size>> of one item set. | Optional | `1`\n|`minimum_support` | (integer) The <<frequent-item-sets-minimum-support,minimum support>> of one item set. | Optional | `0.1`\n|`size` | (integer) The number of top item sets to return. | Optional | `10`\n|`filter` | (object) Query that filters documents from the analysis | Optional | `match_all`\n|===\n\n\n[discrete]\n[[frequent-item-sets-fields]]\n==== Fields\n\nSupported field types for the analyzed fields are keyword, numeric, ip, date,\nand arrays of these types. You can also add runtime fields to your analyzed\nfields.\n\nIf the combined cardinality of the analyzed fields are high, the aggregation\nmight require a significant amount of system resources.\n\nYou can filter the values for each field by using the `include` and `exclude`\nparameters. The parameters can be regular expression strings or arrays of\nstrings of exact terms. The filtered values are removed from the analysis and\ntherefore reduce the runtime. If both `include` and `exclude` are defined,\n`exclude` takes precedence; it means `include` is evaluated first and then\n`exclude`.\n\n[discrete]\n[[frequent-item-sets-minimum-set-size]]\n==== Minimum set size\n\nThe minimum set size is the minimum number of items the set needs to contain. A\nvalue of 1 returns the frequency of single items. Only item sets that contain at\nleast the number of `minimum_set_size` items are returned. For example, the item\nset `orange, banana, apple` is returned only if the minimum set size is 3 or\nlower.\n\n[discrete]\n[[frequent-item-sets-minimum-support]]\n==== Minimum support\n\nThe minimum support value is the ratio of documents that an item set must exist\nin to be considered \"frequent\". In particular, it is a normalized value between\n0 and 1. It is calculated by dividing the number of documents containing the\nitem set by the total number of documents.\n\nFor example, if a given item set is contained by five documents and the total\nnumber of documents is 20, then the support of the item set is 5/20 = 0.25.\nTherefore, this set is returned only if the minimum support is 0.25 or lower.\nAs a higher minimum support prunes more items, the calculation is less resource\nintensive. The `minimum_support` parameter has an effect on the required memory\nand the runtime of the aggregation.\n\n\n[discrete]\n[[frequent-item-sets-size]]\n==== Size\n\nThis parameter defines the maximum number of item sets to return. The result\ncontains top-k item sets; the item sets with the highest support values. This\nparameter has a significant effect on the required memory and the runtime of the\naggregation.\n\n\n[discrete]\n[[frequent-item-sets-filter]]\n==== Filter\n\nA query to filter documents to use as part of the analysis. Documents that\ndon't match the filter are ignored when generating the item sets, however still\ncount when calculating the support of an item set.\n\nUse the filter if you want to narrow the item set analysis to fields of interest.\nUse a top-level query to filter the data set.\n\n\n[discrete]\n[[frequent-item-sets-example]]\n==== Examples\n\nIn the following examples, we use the e-commerce {kib} sample data set.\n\n\n[discrete]\n==== Aggregation with two analyzed fields and an `exclude` parameter\n\nIn the first example, the goal is to find out based on transaction data (1.)\nfrom what product categories the customers purchase products frequently together\nand (2.) from which cities they make those purchases. We want to exclude results\nwhere location information is not available (where the city name is `other`).\nFinally, we are interested in sets with three or more items, and want to see the\nfirst three frequent item sets with the highest support.\n\nNote that we use the <<async-search,async search>> endpoint in this first\nexample.\n\n[source,console]\n-------------------------------------------------\nPOST /kibana_sample_data_ecommerce/_async_search\n{\n   \"size\":0,\n   \"aggs\":{\n      \"my_agg\":{\n         \"frequent_item_sets\":{\n            \"minimum_set_size\":3,\n            \"fields\":[\n               {\n                  \"field\":\"category.keyword\"\n               },\n               {\n                  \"field\":\"geoip.city_name\",\n                  \"exclude\":\"other\"\n               }\n            ],\n            \"size\":3\n         }\n      }\n   }\n}\n-------------------------------------------------\n// TEST[skip:setup kibana sample data]\n\nThe response of the API call above contains an identifier (`id`) of the async\nsearch request. You can use the identifier to retrieve the search results:\n\n[source,console]\n-------------------------------------------------\nGET /_async_search/<id>\n-------------------------------------------------\n// TEST[skip:setup kibana sample data]\n\nThe API returns a response similar to the following one:\n\n[source,console-result]\n-------------------------------------------------\n(...)\n\"aggregations\" : {\n    \"my_agg\" : {\n      \"buckets\" : [ <1>\n        {\n          \"key\" : { <2>\n            \"category.keyword\" : [\n              \"Women's Clothing\",\n              \"Women's Shoes\"\n            ],\n            \"geoip.city_name\" : [\n              \"New York\"\n            ]\n          },\n          \"doc_count\" : 217, <3>\n          \"support\" : 0.04641711229946524 <4>\n        },\n        {\n          \"key\" : {\n            \"category.keyword\" : [\n              \"Women's Clothing\",\n              \"Women's Accessories\"\n            ],\n            \"geoip.city_name\" : [\n              \"New York\"\n            ]\n          },\n          \"doc_count\" : 135,\n          \"support\" : 0.028877005347593583\n        },\n        {\n          \"key\" : {\n            \"category.keyword\" : [\n              \"Men's Clothing\",\n              \"Men's Shoes\"\n            ],\n            \"geoip.city_name\" : [\n              \"Cairo\"\n            ]\n          },\n          \"doc_count\" : 123,\n          \"support\" : 0.026310160427807486\n        }\n      ],\n    (...)\n  }\n}\n-------------------------------------------------\n// TEST[skip:setup kibana sample data]\n\n<1> The array of returned item sets.\n<2> The `key` object contains one item set. In this case, it consists of two\nvalues of the `category.keyword` field and one value of the `geoip.city_name`.\n<3> The number of documents that contain the item set.\n<4> The support value of the item set. It is calculated by dividing the number\nof documents containing the item set by the total number of documents.\n\nThe response shows that the categories customers purchase from most frequently\ntogether are `Women's Clothing` and `Women's Shoes` and customers from New York\ntend to buy items from these categories frequently together. In other words,\ncustomers who buy products labelled `Women's Clothing` more likely buy products\nalso from the `Women's Shoes` category and customers from New York most likely\nbuy products from these categories together. The item set with the second\nhighest support is `Women's Clothing` and `Women's Accessories` with customers\nmostly from New York. Finally, the item set with the third highest support is\n`Men's Clothing` and `Men's Shoes` with customers mostly from Cairo.\n\n\n[discrete]\n==== Aggregation with two analyzed fields and a filter\n\nWe take the first example, but want to narrow the item sets to places in Europe.\nFor that, we add a filter, and this time, we don't use the `exclude` parameter:\n\n[source,console]\n-------------------------------------------------\nPOST /kibana_sample_data_ecommerce/_async_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_agg\": {\n      \"frequent_item_sets\": {\n        \"minimum_set_size\": 3,\n        \"fields\": [\n          { \"field\": \"category.keyword\" },\n          { \"field\": \"geoip.city_name\" }\n        ],\n        \"size\": 3,\n        \"filter\": {\n          \"term\": {\n            \"geoip.continent_name\": \"Europe\"\n          }\n        }\n      }\n    }\n  }\n}\n-------------------------------------------------\n// TEST[skip:setup kibana sample data]\n\nThe result will only show item sets that created from documents matching the\nfilter, namely purchases in Europe. Using `filter`, the calculated `support`\nstill takes all purchases into acount. That's different than specifying a query\nat the top-level, in which case `support` gets calculated only from purchases in\nEurope.\n\n\n[discrete]\n==== Analyzing numeric values by using a runtime field\n\nThe frequent items aggregation enables you to bucket numeric values by using\n<<runtime,runtime fields>>. The next example demonstrates how to use a script to\nadd a runtime field to your documents called `price_range`, which is\ncalculated from the taxful total price of the individual transactions. The\nruntime field then can be used in the frequent items aggregation as a field to\nanalyze.\n\n\n[source,console]\n-------------------------------------------------\nGET kibana_sample_data_ecommerce/_search\n{\n  \"runtime_mappings\": {\n    \"price_range\": {\n      \"type\": \"keyword\",\n      \"script\": {\n        \"source\": \"\"\"\n           def bucket_start = (long) Math.floor(doc['taxful_total_price'].value / 50) * 50;\n           def bucket_end = bucket_start + 50;\n           emit(bucket_start.toString() + \"-\" + bucket_end.toString());\n        \"\"\"\n      }\n    }\n  },\n  \"size\": 0,\n  \"aggs\": {\n    \"my_agg\": {\n      \"frequent_item_sets\": {\n        \"minimum_set_size\": 4,\n        \"fields\": [\n          {\n            \"field\": \"category.keyword\"\n          },\n          {\n            \"field\": \"price_range\"\n          },\n          {\n            \"field\": \"geoip.city_name\"\n          }\n        ],\n        \"size\": 3\n      }\n    }\n  }\n}\n-------------------------------------------------\n// TEST[skip:setup kibana sample data]\n\nThe API returns a response similar to the following one:\n\n[source,console-result]\n-------------------------------------------------\n(...)\n\"aggregations\" : {\n    \"my_agg\" : {\n      \"buckets\" : [\n        {\n          \"key\" : {\n            \"category.keyword\" : [\n              \"Women's Clothing\",\n              \"Women's Shoes\"\n            ],\n            \"price_range\" : [\n              \"50-100\"\n            ],\n            \"geoip.city_name\" : [\n              \"New York\"\n            ]\n          },\n          \"doc_count\" : 100,\n          \"support\" : 0.0213903743315508\n        },\n        {\n          \"key\" : {\n            \"category.keyword\" : [\n              \"Women's Clothing\",\n              \"Women's Shoes\"\n            ],\n            \"price_range\" : [\n              \"50-100\"\n            ],\n            \"geoip.city_name\" : [\n              \"Dubai\"\n            ]\n          },\n          \"doc_count\" : 59,\n          \"support\" : 0.012620320855614974\n        },\n        {\n          \"key\" : {\n            \"category.keyword\" : [\n              \"Men's Clothing\",\n              \"Men's Shoes\"\n            ],\n            \"price_range\" : [\n              \"50-100\"\n            ],\n            \"geoip.city_name\" : [\n              \"Marrakesh\"\n            ]\n          },\n          \"doc_count\" : 53,\n          \"support\" : 0.011336898395721925\n        }\n      ],\n    (...)\n    }\n  }\n-------------------------------------------------\n// TEST[skip:setup kibana sample data]\n\nThe response shows the categories that customers purchase from most frequently\ntogether, the location of the customers who tend to buy items from these\ncategories, and the most frequent price ranges of these purchases.\n"
}