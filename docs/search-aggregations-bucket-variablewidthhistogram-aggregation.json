{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.834070",
        "size": 4344,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-variablewidthhistogram-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-bucket-variablewidthhistogram-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-variablewidthhistogram-aggregation]]\n=== Variable width histogram aggregation\n++++\n<titleabbrev>Variable width histogram</titleabbrev>\n++++\n\nThis is a multi-bucket aggregation similar to <<search-aggregations-bucket-histogram-aggregation>>.\nHowever, the width of each bucket is not specified. Rather, a target number of buckets is provided and bucket intervals\nare dynamically determined based on the document distribution. This is done using a simple one-pass document clustering algorithm\nthat aims to obtain low distances between bucket centroids. Unlike other multi-bucket aggregations, the intervals will not\nnecessarily have a uniform width.\n\nTIP: The number of buckets returned will always be less than or equal to the target number.\n\nRequesting a target of 2 buckets.\n\n[source,console]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"prices\": {\n      \"variable_width_histogram\": {\n        \"field\": \"price\",\n        \"buckets\": 2\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"prices\": {\n      \"buckets\": [\n        {\n          \"min\": 10.0,\n          \"key\": 30.0,\n          \"max\": 50.0,\n          \"doc_count\": 2\n        },\n        {\n          \"min\": 150.0,\n          \"key\": 185.0,\n          \"max\": 200.0,\n          \"doc_count\": 5\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\nIMPORTANT: This aggregation cannot currently be nested under any aggregation that collects from more than a single bucket.\n\n==== Clustering Algorithm\nEach shard fetches the first `initial_buffer` documents and stores them in memory. Once the buffer is full, these documents\nare sorted and linearly separated into `3/4 * shard_size buckets`.\nNext each remaining documents is either collected into the nearest bucket, or placed into a new bucket if it is distant\nfrom all the existing ones. At most `shard_size` total buckets are created.\n\nIn the reduce step, the coordinating node sorts the buckets from all shards by their centroids. Then, the two buckets\nwith the nearest centroids are repeatedly merged until the target number of buckets is achieved.\nThis merging procedure is a form of {wikipedia}/Hierarchical_clustering[agglomerative hierarchical clustering].\n\nTIP: A shard can return fewer than `shard_size` buckets, but it cannot return more.\n\n==== Shard size\nThe `shard_size` parameter specifies the number of buckets that the coordinating node will request from each shard.\nA higher `shard_size` leads each shard to produce smaller buckets. This reduces the likelihood of buckets overlapping\nafter the reduction step. Increasing the `shard_size` will improve the accuracy of the histogram, but it will\nalso make it more expensive to compute the final result because bigger priority queues will have to be managed on a\nshard level, and the data transfers between the nodes and the client will be larger.\n\nTIP: Parameters `buckets`, `shard_size`, and `initial_buffer` are optional. By default, `buckets = 10`, `shard_size = buckets * 50`, and `initial_buffer = min(10 * shard_size, 50000)`.\n\n==== Initial Buffer\nThe `initial_buffer` parameter can be used to specify the number of individual documents that will be stored in memory\non a shard before the initial bucketing algorithm is run. Bucket distribution is determined using this sample\nof `initial_buffer` documents. So, although a higher `initial_buffer` will use more memory, it will lead to more representative\nclusters.\n\n==== Bucket bounds are approximate\nDuring the reduce step, the master node continuously merges the two buckets with the nearest centroids. If two buckets have\noverlapping bounds but distant centroids, then it is possible that they will not be merged. Because of this, after\nreduction the maximum value in some interval (`max`) might be greater than the minimum value in the subsequent\nbucket (`min`). To reduce the impact of this error, when such an overlap occurs the bound between these intervals is adjusted to be `(max + min) / 2`.\n\nTIP: Bucket bounds are very sensitive to outliers\n"
}