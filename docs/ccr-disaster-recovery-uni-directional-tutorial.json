{
    "meta": {
        "size": 5993,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-disaster-recovery-uni-directional-tutorial.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "ccr-disaster-recovery-uni-directional-tutorial",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[ccr-disaster-recovery-uni-directional-tutorial]]\n=== Tutorial: Disaster recovery based on uni-directional {ccr}\n++++\n<titleabbrev>Uni-directional disaster recovery</titleabbrev>\n++++\n\n////\n[source,console]\n----\nPUT kibana_sample_data_ecommerce\n----\n// TESTSETUP \n\n[source,console]\n----\nDELETE kibana_sample_data_ecommerce\n----\n// TEARDOWN\n////\n\n\nLearn how to failover and failback between two clusters based on uni-directional {ccr}. You can also visit <<ccr-disaster-recovery-bi-directional-tutorial>> to set up replicating data streams that automatically failover and failback without human intervention.\n\n* Setting up uni-directional {ccr} replicated from `clusterA`\nto `clusterB`.\n* Failover - If `clusterA` goes offline, `clusterB` needs to \"promote\" follower\nindices to regular indices to allow write operations. All ingestion will need to\nbe redirected to `clusterB`, this is controlled by the clients ({ls}, {beats},\n{agents}, etc). \n* Failback - When `clusterA` is back online, it assumes the role of a follower\nand replicates the leader indices from `clusterB`.\n\nimage::images/ccr-uni-directional-disaster-recovery.png[Uni-directional cross cluster replication failover and failback]\n\nNOTE: {ccr-cap} provides functionality to replicate user-generated indices only.\n{ccr-cap} isn't designed for replicating system-generated indices or snapshot\nsettings, and can't replicate {ilm-init} or {slm-init} policies across clusters.\nLearn more in {ccr} <<ccr-limitations,limitations>>.\n\n==== Prerequisites\nBefore completing this tutorial,\n<<ccr-getting-started-tutorial,set up cross-cluster replication>> to connect two \nclusters and configure a follower index. \n\nIn this tutorial, `kibana_sample_data_ecommerce` is replicated from `clusterA` to `clusterB`.\n\n[source,console]\n----\n### On clusterB ###\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"cluster\": {\n      \"remote\": {\n        \"clusterA\": {\n          \"mode\": \"proxy\",\n          \"skip_unavailable\": \"true\",\n          \"server_name\": \"clustera.es.region-a.gcp.elastic-cloud.com\",\n          \"proxy_socket_connections\": \"18\",\n          \"proxy_address\": \"clustera.es.region-a.gcp.elastic-cloud.com:9400\"\n        }\n      }\n    }\n  }\n}\n----\n// TEST[setup:host]\n// TEST[s/\"server_name\": \"clustera.es.region-a.gcp.elastic-cloud.com\",//]\n// TEST[s/\"proxy_socket_connections\": 18,//]\n// TEST[s/clustera.es.region-a.gcp.elastic-cloud.com:9400/\\${transport_host}/]\n// TEST[s/clusterA/remote_cluster/]\n\n[source,console]\n----\n### On clusterB ###\nPUT /kibana_sample_data_ecommerce2/_ccr/follow?wait_for_active_shards=1\n{\n  \"remote_cluster\": \"clusterA\",\n  \"leader_index\": \"kibana_sample_data_ecommerce\"\n}\n----\n// TEST[continued]\n// TEST[s/clusterA/remote_cluster/]\n\nIMPORTANT: Writes (such as ingestion or updates) should occur only on the leader\nindex. Follower indices are read-only and will reject any writes.\n\n\n==== Failover when `clusterA` is down\n\n. Promote the follower indices in `clusterB` into regular indices so \nthat they accept writes. This can be achieved by:\n* First, pause indexing following for the follower index.\n* Next, close the follower index.\n* Unfollow the leader index.\n* Finally, open the follower index (which at this point is a regular index).\n\n+\n[source,console]\n----\n### On clusterB ###\nPOST /kibana_sample_data_ecommerce2/_ccr/pause_follow\nPOST /kibana_sample_data_ecommerce2/_close           \nPOST /kibana_sample_data_ecommerce2/_ccr/unfollow    \nPOST /kibana_sample_data_ecommerce2/_open\n----\n// TEST[continued]\n\n. On the client side ({ls}, {beats}, {agent}), manually re-enable ingestion of\n`kibana_sample_data_ecommerce2` and redirect traffic to the `clusterB`. You should\nalso redirect all search traffic to the `clusterB` cluster during\nthis time. You can simulate this by ingesting documents into this index. You should\nnotice this index is now writable.\n+\n[source,console]\n----\n### On clusterB ###\nPOST kibana_sample_data_ecommerce2/_doc/\n{\n  \"user\": \"kimchy\"\n}\n----\n// TEST[continued]\n\n==== Failback when `clusterA` comes back\n\nWhen `clusterA` comes back, `clusterB` becomes the new leader and `clusterA` becomes the follower. \n\n. Set up remote cluster `clusterB` on `clusterA`.\n+\n[source,console]\n----\n### On clusterA ###\nPUT _cluster/settings\n{\n  \"persistent\": {\n    \"cluster\": {\n      \"remote\": {\n        \"clusterB\": {\n          \"mode\": \"proxy\",\n          \"skip_unavailable\": \"true\",\n          \"server_name\": \"clusterb.es.region-b.gcp.elastic-cloud.com\",\n          \"proxy_socket_connections\": \"18\",\n          \"proxy_address\": \"clusterb.es.region-b.gcp.elastic-cloud.com:9400\"\n        }\n      }\n    }\n  }\n}\n----\n// TEST[setup:host]\n// TEST[s/\"server_name\": \"clusterb.es.region-b.gcp.elastic-cloud.com\",//]\n// TEST[s/\"proxy_socket_connections\": 18,//]\n// TEST[s/clusterb.es.region-b.gcp.elastic-cloud.com:9400/\\${transport_host}/]\n// TEST[s/clusterB/remote_cluster/]\n\n. Existing data needs to be discarded before you can turn any index into a\nfollower. Ensure the most up-to-date data is available on `clusterB` prior to\ndeleting any indices on `clusterA`.  \n+\n[source,console]\n----\n### On clusterA ###\nDELETE kibana_sample_data_ecommerce\n----\n// TEST[skip:need dual cluster setup]\n\n\n. Create a follower index on `clusterA`, now following the leader index in\n`clusterB`.  \n+\n[source,console]\n----\n### On clusterA ###\nPUT /kibana_sample_data_ecommerce/_ccr/follow?wait_for_active_shards=1\n{ \n  \"remote_cluster\": \"clusterB\", \n  \"leader_index\": \"kibana_sample_data_ecommerce2\" \n}\n----\n// TEST[continued]\n// TEST[s/clusterB/remote_cluster/]\n\n. The index on the follower cluster now contains the updated documents.\n+\n[source,console]\n----\n### On clusterA ###\nGET kibana_sample_data_ecommerce/_search?q=kimchy\n----\n// TEST[continued]\n+ \nTIP: If a soft delete is merged away before it can be replicated to a follower the following process will fail due to incomplete history on the leader, see <<ccr-index-soft-deletes-retention-period, index.soft_deletes.retention_lease.period>> for more details.\n"
}