{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.835070",
        "size": 22337,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-execute-api.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-execute-api",
        "version": "8.15"
    },
    "doc": "[[painless-execute-api]]\n=== Painless execute API\nexperimental::[]\n\nThe Painless execute API runs a script and returns a result.\n\n[[painless-execute-api-request]]\n==== {api-request-title}\n`POST /_scripts/painless/_execute`\n\n[[painless-execute-api-desc]]\n==== {api-description-title}\nUse this API to build and test scripts, such as when defining a script for a\n{ref}/runtime.html[runtime field]. This API requires very few dependencies, and is\nespecially useful if you don't have permissions to write documents on a cluster.\n\nThe API uses several _contexts_, which control how scripts are executed, what\nvariables are available at runtime, and what the return type is.\n\nEach context requires a script, but additional parameters depend on the context\nyou're using for that script.\n\n[[painless-execute-api-request-body]]\n==== {api-request-body-title}\n`script`:: (Required, object)\nThe Painless script to execute.\n+\n.Properties of `script`\n--\ninclude::../painless-contexts/painless-runtime-fields-context.asciidoc[tag=runtime-field-emit]\n--\n\n[[_contexts]]\n`context`:: (Optional, string)\nThe context that the script should run in. Defaults to `painless_test` if no\ncontext is specified.\n+\n.Properties of `context`\n[%collapsible%open]\n====\n`painless_test`::\nThe default context if no other context is specified. See\n<<painless-execute-test,test context>>.\n\n`filter`::\nTreats scripts as if they were run inside a `script` query. See\n<<painless-execute-filter-context,filter context>>.\n\n`score`::\nTreats scripts as if they were run inside a `script_score` function in a\n`function_score` query. See <<painless-execute-core-context,score context>>.\n\n[[painless-execute-runtime-context]]\n.Field contexts\n[%collapsible%open]\n=====\n--\nThe following options are specific to the field contexts.\n\nNOTE: Result ordering in the field contexts is not guaranteed.\n--\n\n****\n`boolean_field`::\nThe context for {ref}/boolean.html[`boolean` fields]. The script returns a `true`\nor `false` response. See\n<<painless-runtime-boolean,boolean_field context>>.\n\n`date_field`::\nThe context for {ref}/date.html[`date` fields]. `emit` takes a `long` value and\nthe script returns a sorted list of dates. See\n<<painless-runtime-datetime,date_time context>>.\n\n`double_field`::\nThe context for `double` {ref}/number.html[numeric fields]. The script returns a\nsorted list of `double` values. See\n<<painless-runtime-double,double_field context>>.\n\n`geo_point_field`::\nThe context for {ref}/geo-point.html[`geo-point` fields]. `emit` takes two double\nparameters, the latitude and longitude values, and the script returns an object in\nGeoJSON format containing the coordinates for the geo point. See\n<<painless-runtime-geo,geo_point_field context>>.\n\n`ip_field`::\nThe context for {ref}/ip.html[`ip` fields]. The script returns a sorted list of IP\naddresses. See\n<<painless-runtime-ip,ip_field context>>.\n\n`keyword_field`::\nThe context for {ref}/keyword.html[`keyword` fields]. The script returns a sorted\nlist of `string` values. See\n<<painless-runtime-keyword,keyword_field context>>.\n\n`long_field`::\nThe context for `long` {ref}/number.html[numeric fields]. The script returns a\nsorted list of `long` values. See <<painless-runtime-long,long_field context>>.\n\n`composite_field`::\nThe context for `composite` {ref}/runtime.html[runtime fields]. The script returns a\nmap of values. See <<painless-runtime-composite,composite_field context>>.\n\n****\n=====\n====\n\n`context_setup`:: (Required, object)\nAdditional parameters for the `context`.\n+\nNOTE: This parameter is required for all contexts except `painless_test`,\nwhich is the default if no value is provided for `context`.\n+\n.Properties of `context_setup`\n[%collapsible%open]\n====\n`document`:: (Required, string)\nDocument that's temporarily indexed in-memory and accessible from the script.\n\n`index`:: (Required, string)\nIndex containing a mapping that's compatible with the indexed document.\nYou may specify a remote index by prefixing the index with the remote cluster\nalias. For example, `remote1:my_index` indicates that you want to execute\nthe painless script against the \"my_index\" index on the \"remote1\" cluster. This\nrequest will be forwarded to the \"remote1\" cluster if you have\n{ref}/remote-clusters-connect.html[configured a connection] to that remote cluster.\n\nNOTE: Wildcards are not accepted in the index expression for this endpoint. The\nexpression `*:myindex` will return the error \"No such remote cluster\" and the\nexpression `logs*` or `remote1:logs*` will return the error \"index not found\".\n====\n\n`params`:: (`Map`, read-only)\nSpecifies any named parameters that are passed into the script as variables.\n\n`query`:: (Optional, object)\nNOTE: This parameter only applies when `score` is specified as the script\n`context`.\n+\nUse this parameter to specify a query for computing a score. Besides deciding\nwhether or not the document matches, the\n{ref}/query-filter-context.html#query-context[query clause] also calculates a\nrelevance score in the `_score` metadata field.\n\n[[painless-execute-test]]\n==== Test context\nThe `painless_test` context runs scripts without additional parameters. The only\nvariable that is available is `params`, which can be used to access user defined\nvalues. The result of the script is always converted to a string.\n\nBecause the default context is `painless_test`, you don't need to specify the\n`context` or `context_setup`.\n\n===== Request\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"params.count / params.total\",\n    \"params\": {\n      \"count\": 100.0,\n      \"total\": 1000.0\n    }\n  }\n}\n----\n\n===== Response\n\n[source,console-result]\n----\n{\n  \"result\": \"0.1\"\n}\n----\n\n[[painless-execute-filter-context]]\n==== Filter context\nThe `filter` context treats scripts as if they were run inside a `script` query.\nFor testing purposes, a document must be provided so that it will be temporarily\nindexed in-memory and is accessible from the script. More precisely, the\n`_source`, stored fields and doc values of such a document are available to the\nscript being tested.\n\n===== Request\n\n[source,console]\n----\nPUT /my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"field\": {\n        \"type\": \"keyword\"\n      }\n    }\n  }\n}\n----\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"doc['field'].value.length() <= params.max_length\",\n    \"params\": {\n      \"max_length\": 4\n    }\n  },\n  \"context\": \"filter\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"field\": \"four\"\n    }\n  }\n}\n----\n// TEST[continued]\n\n===== Response\n\n[source,console-result]\n----\n{\n  \"result\": true\n}\n----\n\n[[painless-execute-core-context]]\n==== Score context\nThe `score` context treats scripts as if they were run inside a `script_score`\nfunction in a `function_score` query.\n\n===== Request\n\n[source,console]\n----\nPUT /my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"field\": {\n        \"type\": \"keyword\"\n      },\n      \"rank\": {\n        \"type\": \"long\"\n      }\n    }\n  }\n}\n----\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"doc['rank'].value / params.max_rank\",\n    \"params\": {\n      \"max_rank\": 5.0\n    }\n  },\n  \"context\": \"score\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"rank\": 4\n    }\n  }\n}\n----\n// TEST[continued]\n\n===== Response\n\n[source,console-result]\n----\n{\n  \"result\": 0.8\n}\n----\n\n[[painless-execute-runtime-field-context]]\n==== Field contexts\nThe field contexts treat scripts as if they were run inside the\n{ref}/runtime-search-request.html[`runtime_mappings` section] of a search query.\nYou can use field contexts to test scripts for different field types, and then\ninclude those scripts anywhere that they're supported, such as  <<painless-runtime-fields,runtime fields>>.\n\nChoose a field context based on the data type you want to return.\n\n[[painless-runtime-boolean]]\n===== `boolean_field`\nUse the `boolean_field` field context when you want to return a `true`\nor `false` value from a script valuation. {ref}/boolean.html[Boolean fields]\naccept `true` and `false` values, but can also accept strings that are\ninterpreted as either true or false.\n\nLet's say you have data for the top 100 science fiction books of all time. You\nwant to write scripts that return a boolean response such as whether books\nexceed a certain page count, or if a book was published after a specific year.\n\nConsider that your data is structured like this:\n\n[source,console]\n----\nPUT /my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"name\": {\n        \"type\": \"keyword\"\n      },\n      \"author\": {\n        \"type\": \"keyword\"\n      },\n      \"release_date\": {\n        \"type\": \"date\"\n      },\n      \"page_count\": {\n        \"type\": \"double\"\n      }\n    }\n  }\n}\n----\n\nYou can then write a script in the `boolean_field` context that indicates\nwhether a book was published before the year 1972:\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"\"\"\n      emit(doc['release_date'].value.year < 1972);\n    \"\"\"\n  },\n  \"context\": \"boolean_field\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"name\": \"Dune\",\n      \"author\": \"Frank Herbert\",\n      \"release_date\": \"1965-06-01\",\n      \"page_count\": 604\n    }\n  }\n}\n----\n// TEST[continued]\n\nBecause _Dune_ was published in 1965, the result returns as `true`:\n\n[source,console-result]\n----\n{\n  \"result\" : [\n    true\n  ]\n}\n----\n\nSimilarly, you could write a script that determines whether the first name of\nan author exceeds a certain number of characters. The following script operates\non the `author` field to determine whether the author's first name contains at\nleast one character, but is less than five characters:\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"\"\"\n      int space = doc['author'].value.indexOf(' ');\n      emit(space > 0 && space < 5);\n    \"\"\"\n  },\n  \"context\": \"boolean_field\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"name\": \"Dune\",\n      \"author\": \"Frank Herbert\",\n      \"release_date\": \"1965-06-01\",\n      \"page_count\": 604\n    }\n  }\n}\n----\n// TEST[continued]\n\nBecause `Frank` is five characters, the response returns `false` for the script\nvaluation:\n\n[source,console-result]\n----\n{\n  \"result\" : [\n    false\n  ]\n}\n----\n\n[[painless-runtime-datetime]]\n===== `date_time`\nSeveral options are available for using\n<<painless-datetime,using datetime in Painless>>. In this example, you'll\nestimate when a particular author starting writing a book based on its release\ndate and the writing speed of that author. The example makes some assumptions,\nbut shows to write a script that operates on a date while incorporating\nadditional information.\n\nAdd the following fields to your index mapping to get started:\n\n[source,console]\n----\nPUT /my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"name\": {\n        \"type\": \"keyword\"\n      },\n      \"author\": {\n        \"type\": \"keyword\"\n      },\n      \"release_date\": {\n        \"type\": \"date\"\n      },\n      \"page_count\": {\n        \"type\": \"long\"\n      }\n    }\n  }\n}\n----\n\nThe following script makes the incredible assumption that when writing a book,\nauthors just write each page and don't do research or revisions. Further, the\nscript assumes that the average time it takes to write a page is eight hours.\n\nThe script retrieves the `author` and makes another fantastic assumption to\neither divide or multiply the `pageTime` value based on the author's perceived\nwriting speed (yet another wild assumption).\n\nThe script subtracts the release date value (in milliseconds) from the\ncalculation of `pageTime` times the `page_count` to determine approximately\n(based on numerous assumptions) when the author began writing the book.\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"\"\"\n      String author = doc['author'].value;\n      long pageTime = 28800000;  <1>\n      if (author == 'Robert A. Heinlein') {\n        pageTime /= 2;           <2>\n      } else if (author == 'Alastair Reynolds') {\n        pageTime *= 2;           <3>\n      }\n      emit(doc['release_date'].value.toInstant().toEpochMilli() - pageTime * doc['page_count'].value);\n    \"\"\"\n  },\n  \"context\": \"date_field\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"name\": \"Revelation Space\",\n      \"author\": \"Alastair Reynolds\",\n      \"release_date\": \"2000-03-15\",\n      \"page_count\": 585\n    }\n  }\n}\n----\n//TEST[continued]\n<1> Eight hours, represented in milliseconds\n<2> Incredibly fast writing from Robert A. Heinlein\n<3> Alastair Reynolds writes space operas at a much slower speed\n\nIn this case, the author is Alastair Reynolds. Based on a release date of\n`2000-03-15`, the script calculates that the author started writing\n`Revelation Space` on 19 February 1999. Writing a 585 page book in just over one\nyear is pretty impressive!\n\n[source,console-result]\n----\n{\n  \"result\" : [\n    \"1999-02-19T00:00:00.000Z\"\n  ]\n}\n----\n\n[[painless-runtime-double]]\n===== `double_field`\nUse the `double_field` context for {ref}/number.html[numeric data] of type\n`double`. For example, let's say you have sensor data that includes a `voltage`\nfield with values like 5.6. After indexing millions of documents, you discover\nthat the sensor with model number `QVKC92Q` is under reporting its voltage by a\nfactor of 1.7. Rather than reindex your data, you can fix it with a\nruntime field.\n\nYou need to multiply this value, but only for\nsensors that match a specific model number.\n\nAdd the following fields to your index mapping. The `voltage` field is a\nsub-field of the `measures` object.\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"@timestamp\": {\n        \"type\": \"date\"\n      },\n      \"model_number\": {\n        \"type\": \"keyword\"\n      },\n      \"measures\": {\n        \"properties\": {\n          \"voltage\": {\n            \"type\": \"double\"\n          }\n        }\n      }\n    }\n  }\n}\n----\n\nThe following script matches on any documents where the `model_number` equals\n`QVKC92Q`, and then multiplies the `voltage` value by `1.7`. This script is\nuseful when you want to select specific documents and only operate on values\nthat match the specified criteria.\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"\"\"\n      if (doc['model_number'].value.equals('QVKC92Q'))\n      {emit(1.7 * params._source['measures']['voltage']);}\n      else{emit(params._source['measures']['voltage']);}\n    \"\"\"\n  },\n  \"context\": \"double_field\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"@timestamp\": 1516470094000,\n      \"model_number\": \"QVKC92Q\",\n      \"measures\": {\n        \"voltage\": 5.6\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nThe result includes the calculated voltage, which was determined by multiplying\nthe original value of `5.6` by `1.7`:\n\n[source,console-result]\n----\n{\n  \"result\" : [\n    9.52\n  ]\n}\n----\n\n[[painless-runtime-geo]]\n===== `geo_point_field`\n{ref}/geo-point.html[Geo-point] fields accept latitude-longitude pairs. You can\ndefine a geo-point field in several ways, and include values for latitude and\nlongitude in the document for your script.\n\nIf you already have a known geo-point, it's simpler to clearly state the\npositions of `lat` and `lon` in your index mappings.\n\n[source,console]\n----\nPUT /my-index-000001/\n{\n  \"mappings\": {\n    \"properties\": {\n      \"lat\": {\n        \"type\": \"double\"\n      },\n      \"lon\": {\n        \"type\": \"double\"\n      }\n    }\n  }\n}\n----\n\nYou can then use the `geo_point_field` runtime field context to write a script\nthat retrieves the `lat` and `lon` values.\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"\"\"\n      emit(doc['lat'].value, doc['lon'].value);\n    \"\"\"\n  },\n  \"context\": \"geo_point_field\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"lat\": 41.12,\n      \"lon\": -71.34\n    }\n  }\n}\n----\n// TEST[continued]\n\nBecause you're working with a geo-point field type, the response includes\nresults that are formatted as `coordinates`.\n\n[source,console-result]\n----\n{\n  \"result\" : [\n    {\n      \"coordinates\" : [\n        -71.34,\n        41.12\n      ],\n      \"type\" : \"Point\"\n    }\n  ]\n}\n----\n\n[NOTE]\nThe emit function for {ref}/geo-point.html[geo-point] fields takes two parameters ordered with\n`lat` before `lon`, but the output GeoJSON format orders the `coordinates` as `[ lon, lat ]`.\n\n[[painless-runtime-ip]]\n===== `ip_field`\nThe `ip_field` context is useful for data that includes IP addresses of type\n{ref}/ip.html[`ip`]. For example, let's say you have a `message` field from an Apache\nlog. This field contains an IP address, but also other data that you don't need.\n\nYou can add the `message` field to your index mappings as a `wildcard` to accept\npretty much any data you want to put in that field.\n\n[source,console]\n----\nPUT /my-index-000001/\n{\n  \"mappings\": {\n    \"properties\": {\n      \"message\": {\n        \"type\": \"wildcard\"\n      }\n    }\n  }\n}\n----\n\nYou can then define a runtime script with a grok pattern that extracts\nstructured fields out of the `message` field.\n\nThe script matches on the `%{COMMONAPACHELOG}` log pattern, which understands\nthe structure of Apache logs. If the pattern matches, the script emits the\nvalue matching the IP address. If the pattern doesn\u2019t match\n(`clientip != null`), the script just returns the field value without crashing.\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"\"\"\n      String clientip=grok('%{COMMONAPACHELOG}').extract(doc[\"message\"].value)?.clientip;\n      if (clientip != null) emit(clientip);\n    \"\"\"\n  },\n  \"context\": \"ip_field\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"message\": \"40.135.0.0 - - [30/Apr/2020:14:30:17 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nThe response includes only the IP address, ignoring all of the other data in the\n`message` field.\n\n[source,console-result]\n----\n{\n  \"result\" : [\n    \"40.135.0.0\"\n  ]\n}\n----\n\n[[painless-runtime-keyword]]\n===== `keyword_field`\n{ref}/keyword.html[Keyword fields] are often used in sorting, aggregations, and\nterm-level queries.\n\nLet's say you have a timestamp. You want to calculate the day of the week based\non that value and return it, such as `Thursday`. The following request adds a\n`@timestamp` field of type `date` to the index mappings:\n\n[source,console]\n----\nPUT /my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"@timestamp\": {\n        \"type\": \"date\"\n      }\n    }\n  }\n}\n----\n\nTo return the equivalent day of week based on your timestamp, you can create a\nscript in the `keyword_field` runtime field context:\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"\"\"\n      emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ENGLISH));\n    \"\"\"\n  },\n  \"context\": \"keyword_field\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"@timestamp\": \"2020-04-30T14:31:43-05:00\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nThe script operates on the value provided for the `@timestamp` field to\ncalculate and return the day of the week:\n\n[source,console-result]\n----\n{\n  \"result\" : [\n    \"Thursday\"\n  ]\n}\n----\n\n[[painless-runtime-long]]\n===== `long_field`\nLet's say you have sensor data that a `measures` object. This object includes\na `start` and `end` field, and you want to calculate the difference between\nthose values.\n\nThe following request adds a `measures` object to the mappings with two fields,\nboth of type `long`:\n\n[source,console]\n----\nPUT /my-index-000001/\n{\n  \"mappings\": {\n    \"properties\": {\n      \"measures\": {\n        \"properties\": {\n          \"start\": {\n            \"type\": \"long\"\n          },\n          \"end\": {\n           \"type\": \"long\"\n          }\n        }\n      }\n    }\n  }\n}\n----\n\nYou can then define a script that assigns values to the `start` and `end` fields\nand operate on them. The following script extracts the value for the `end`\nfield from the `measures` object and subtracts it from the `start` field:\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"\"\"\n      emit(doc['measures.end'].value - doc['measures.start'].value);\n    \"\"\"\n  },\n  \"context\": \"long_field\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"measures\": {\n        \"voltage\": \"4.0\",\n        \"start\": \"400\",\n        \"end\": \"8625309\"\n      }\n    }\n  }\n}\n----\n// TEST[continued]\n\nThe response includes the calculated value from the script valuation:\n\n[source,console-result]\n----\n{\n  \"result\" : [\n    8624909\n  ]\n}\n----\n\n[[painless-runtime-composite]]\n===== `composite_field`\nLet's say you have logging data with a raw `message` field which you want to split\nin multiple sub-fields that can be accessed separately.\n\nThe following request adds a `message` field to the mappings of type `keyword`:\n\n[source,console]\n----\nPUT /my-index-000001/\n{\n  \"mappings\": {\n    \"properties\": {\n      \"message\": {\n        \"type\" : \"keyword\"\n      }\n    }\n  }\n}\n----\n\nYou can then define a script that splits such message field into subfields using\nthe grok function:\n\n[source,console]\n----\nPOST /_scripts/painless/_execute\n{\n  \"script\": {\n    \"source\": \"emit(grok(\\\"%{COMMONAPACHELOG}\\\").extract(doc[\\\"message\\\"].value));\"\n  },\n  \"context\": \"composite_field\",\n  \"context_setup\": {\n    \"index\": \"my-index-000001\",\n    \"document\": {\n      \"timestamp\":\"2020-04-30T14:31:27-05:00\",\n      \"message\":\"252.0.0.0 - - [30/Apr/2020:14:31:27 -0500] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"\n    }\n  }\n}\n----\n// TEST[continued]\n\nThe response includes the values that the script emitted:\n\n[source,console-result]\n----\n{\n  \"result\" : {\n    \"composite_field.timestamp\" : [\n      \"30/Apr/2020:14:31:27 -0500\"\n    ],\n    \"composite_field.auth\" : [\n      \"-\"\n    ],\n    \"composite_field.response\" : [\n      \"200\"\n    ],\n    \"composite_field.ident\" : [\n      \"-\"\n    ],\n    \"composite_field.httpversion\" : [\n      \"1.0\"\n    ],\n    \"composite_field.verb\" : [\n      \"GET\"\n    ],\n    \"composite_field.bytes\" : [\n      \"24736\"\n    ],\n    \"composite_field.clientip\" : [\n      \"252.0.0.0\"\n    ],\n    \"composite_field.request\" : [\n      \"/images/hm_bg.jpg\"\n    ]\n  }\n}\n----\n"
}