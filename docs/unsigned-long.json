{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.766089",
        "size": 5105,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/unsigned-long.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "unsigned-long",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n\n[[unsigned-long]]\n=== Unsigned long field type\n++++\n<titleabbrev>Unsigned long</titleabbrev>\n++++\nUnsigned long is a numeric field type that represents an unsigned 64-bit\ninteger with a minimum value of 0 and a maximum value of +2^64^-1+\n(from 0 to 18446744073709551615 inclusive).\n\n[source,console]\n--------------------------------------------------\nPUT my_index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my_counter\": {\n        \"type\": \"unsigned_long\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nUnsigned long can be indexed in a numeric or string form,\nrepresenting integer values in the range [0, 18446744073709551615].\nThey can't have a decimal part.\n\n[source,console]\n--------------------------------\nPOST /my_index/_bulk?refresh\n{\"index\":{\"_id\":1}}\n{\"my_counter\": 0}\n{\"index\":{\"_id\":2}}\n{\"my_counter\": 9223372036854775808}\n{\"index\":{\"_id\":3}}\n{\"my_counter\": 18446744073709551614}\n{\"index\":{\"_id\":4}}\n{\"my_counter\": 18446744073709551615}\n--------------------------------\n//TEST[continued]\n\nTerm queries accept any numbers in a numeric or string form.\n\n[source,console]\n--------------------------------\nGET /my_index/_search\n{\n    \"query\": {\n        \"term\" : {\n            \"my_counter\" : 18446744073709551615\n        }\n    }\n}\n--------------------------------\n//TEST[continued]\n\nRange query terms can contain values with decimal parts.\nIn this case {es} converts them to integer values:\n`gte` and `gt` terms are converted to the nearest integer up inclusive,\nand `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n\nIt is recommended to pass ranges as strings to ensure they are parsed\nwithout any loss of precision.\n\n[source,console]\n--------------------------------\nGET /my_index/_search\n{\n    \"query\": {\n        \"range\" : {\n            \"my_counter\" : {\n                \"gte\" : \"9223372036854775808\",\n                \"lte\" : \"18446744073709551615\"\n            }\n        }\n    }\n}\n--------------------------------\n//TEST[continued]\n\n==== Sort values\nFor queries with sort on an `unsigned_long` field,\nfor a particular document {es} returns a sort value of the type `long`\nif the value of this document is within the range of long values,\nor of the type `BigInteger` if the value exceeds this range.\n\nNOTE: REST clients need to be able to handle big integer values\nin JSON to support this field type correctly.\n\n[source,console]\n--------------------------------\nGET /my_index/_search\n{\n    \"query\": {\n        \"match_all\" : {}\n    },\n    \"sort\" : {\"my_counter\" : \"desc\"}\n}\n--------------------------------\n//TEST[continued]\n\n\n==== Stored fields\nA stored field of `unsigned_long` is stored and returned as `String`.\n\n==== Aggregations\nFor `terms` aggregations, similarly to sort values, `Long` or\n`BigInteger` values are used. For other aggregations,\nvalues are converted to the `double` type.\n\n==== Script values\nBy default, script values of an `unsigned_long` field are returned as\nJava signed `Long`, which means that values that are greater than\n`Long.MAX_VALUE` are shown as negative values. You can use\n`Long.compareUnsigned(long, long)`, `Long.divideUnsigned(long, long)`\nand `Long.remainderUnsigned(long, long)` to correctly work with\nthese values.\n\nFor example, the script below returns a value of the counter\ndivided by 10.\n\n[source,console]\n--------------------------------\nGET /my_index/_search\n{\n    \"query\": {\n        \"match_all\" : {}\n    },\n    \"script_fields\": {\n        \"count10\" : {\n          \"script\": {\n            \"source\": \"Long.divideUnsigned(doc['my_counter'].value, 10)\"\n          }\n        }\n    }\n}\n--------------------------------\n//TEST[continued]\n\n\nAlternatively, you can treat the unsigned long type as `BigInteger`\nin your scripts by using the field API. For example, this script\ntreats `my_counter` as `BigInteger` with a default value of `BigInteger.ZERO`:\n\n[source,js]\n--------------------------------------------------\n\"script\": {\n    \"source\": \"field('my_counter').asBigInteger(BigInteger.ZERO)\"\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nFor scripts that need to return float or double values, you\ncan further convert `BigInteger` values to double or float:\n\n[source,console]\n--------------------------------\nGET /my_index/_search\n{\n    \"query\": {\n        \"script_score\": {\n          \"query\": {\"match_all\": {}},\n          \"script\": {\n            \"source\": \"field('my_counter').asBigInteger(BigInteger.ZERO).floatValue()\"\n          }\n        }\n    }\n}\n--------------------------------\n//TEST[continued]\n\n==== Queries with mixed numeric types\n\nSearches with mixed numeric types one of which is `unsigned_long` are\nsupported, except queries with sort. Thus, a sort query across two indexes\nwhere the same field name has an `unsigned_long` type in one index,\nand `long` type in another, doesn't produce correct results and must\nbe avoided. If there is a need for such kind of sorting, script based sorting\ncan be used instead.\n\nAggregations across several numeric types one of which is `unsigned_long` are\nsupported. In this case, values are converted to the `double` type.\n"
}