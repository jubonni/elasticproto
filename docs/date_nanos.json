{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.047269",
        "size": 4774,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/date_nanos.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "date_nanos",
        "version": "8.15"
    },
    "doc": "[[date_nanos]]\n=== Date nanoseconds field type\n++++\n<titleabbrev>Date nanoseconds</titleabbrev>\n++++\n\nThis data type is an addition to the `date` data type. However there is an\nimportant distinction between the two. The existing `date` data type stores\ndates in millisecond resolution. The `date_nanos` data type stores dates\nin nanosecond resolution, which limits its range of dates from roughly\n1970 to 2262, as dates are still stored as a long representing nanoseconds\nsince the epoch.\n\nQueries on nanoseconds are internally converted to range queries on this long\nrepresentation, and the result of aggregations and stored fields is converted\nback to a string depending on the date format that is associated with the field.\n\nDate formats can be customised, but if no `format` is specified then it uses\nthe default:\n\n[source,js]\n----\n    \"strict_date_optional_time_nanos||epoch_millis\"\n----\n// NOTCONSOLE\n\nFor instance:\n\n[source,console]\n----\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"date\": {\n        \"type\": \"date_nanos\" <1>\n      }\n    }\n  }\n}\n\nPUT my-index-000001/_bulk?refresh\n{ \"index\" : { \"_id\" : \"1\" } }\n{ \"date\": \"2015-01-01\" } <2>\n{ \"index\" : { \"_id\" : \"2\" } }\n{ \"date\": \"2015-01-01T12:10:30.123456789Z\" } <3>\n{ \"index\" : { \"_id\" : \"3\" } }\n{ \"date\": 1420070400000 } <4>\n\nGET my-index-000001/_search\n{\n  \"sort\": { \"date\": \"asc\"}, <5>\n  \"runtime_mappings\": {\n    \"date_has_nanos\": {\n      \"type\": \"boolean\",\n      \"script\": \"emit(doc['date'].value.nano != 0)\" <6>\n    }\n  },\n  \"fields\": [\n    {\n      \"field\": \"date\",\n      \"format\": \"strict_date_optional_time_nanos\" <7>\n    },\n    {\n      \"field\": \"date_has_nanos\"\n    }\n  ]\n}\n----\n// TEST[s/_search/_search?filter_path=hits.hits/]\n<1> The `date` field uses the default `format`.\n<2> This document uses a plain date.\n<3> This document includes a time.\n<4> This document uses milliseconds-since-the-epoch.\n<5> Note that the `sort` values that are returned are all in\nnanoseconds-since-the-epoch.\n<6> Use `.nano` in scripts to return the nanosecond component of the date.\n<7> You can specify the format when fetching data using the <<search-fields-param,`fields` parameter>>.\nUse <<strict-date-time-nanos,`strict_date_optional_time_nanos`>> or you'll get a rounded result.\n\n////\n[source,console-result]\n----\n{\n  \"hits\": {\n    \"hits\": [\n      {\n        \"_id\": \"1\",\n        \"_index\": \"my-index-000001\",\n        \"_score\": null,\n        \"_source\": {\"date\": \"2015-01-01\"},\n        \"fields\": {\n          \"date\": [\"2015-01-01T00:00:00.000Z\"],\n          \"date_has_nanos\": [false]\n        },\n        \"sort\": [1420070400000000000]\n      },\n      {\n        \"_id\": \"3\",\n        \"_index\": \"my-index-000001\",\n        \"_score\": null,\n        \"_source\": {\"date\": 1420070400000},\n        \"fields\": {\n          \"date\": [\"2015-01-01T00:00:00.000Z\"],\n          \"date_has_nanos\": [false]\n        },\n        \"sort\": [1420070400000000000]\n      },\n      {\n        \"_id\": \"2\",\n        \"_index\": \"my-index-000001\",\n        \"_score\": null,\n        \"_source\": {\"date\": \"2015-01-01T12:10:30.123456789Z\"},\n        \"fields\": {\n          \"date\": [\"2015-01-01T12:10:30.123456789Z\"],\n          \"date_has_nanos\": [true]\n        },\n        \"sort\": [1420114230123456789]\n      }\n    ]\n  }\n}\n----\n////\n\nYou can also specify multiple date formats separated by `||`. The\nsame mapping parameters than with the `date` field can be used.\n\n[WARNING]\n====\nDate nanoseconds\ninclude::date.asciidoc[tag=decimal-warning]\n====\n\n[[date-nanos-limitations]]\n==== Limitations\n\nAggregations are still on millisecond resolution, even when using a `date_nanos`\nfield. This limitation also affects <<transforms,{transforms}>>.\n\n---\n\n[[date-nanos-synthetic-source]]\n==== Synthetic `_source`\n\nIMPORTANT: Synthetic `_source` is Generally Available only for TSDB indices\n(indices that have `index.mode` set to `time_series`). For other indices\nsynthetic `_source` is in technical preview. Features in technical preview may\nbe changed or removed in a future release. Elastic will work to fix\nany issues, but features in technical preview are not subject to the support SLA\nof official GA features.\n\nSynthetic source may sort `date_nanos` field values. For example:\n[source,console,id=synthetic-source-date-nanos-example]\n----\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"date\": { \"type\": \"date_nanos\" }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"date\": [\"2015-01-01T12:10:30.000Z\", \"2014-01-01T12:10:30.000Z\"]\n}\n----\n// TEST[s/$/\\nGET idx\\/_doc\\/1?filter_path=_source\\n/]\n\nWill become:\n[source,console-result]\n----\n{\n  \"date\": [\"2014-01-01T12:10:30.000Z\", \"2015-01-01T12:10:30.000Z\"]\n}\n----\n// TEST[s/^/{\"_source\":/ s/\\n$/}/]\n\n"
}