{
    "meta": {
        "size": 3451,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-history-retention.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "index-modules-history-retention",
        "version": "8.15"
    },
    "doc": "[[index-modules-history-retention]]\n== History retention\n\n{es} sometimes needs to replay some of the operations that were performed on a\nshard. For instance, if a replica is briefly offline then it may be much more\nefficient to replay the few operations it missed while it was offline than to\nrebuild it from scratch. Similarly, {ccr} works by performing operations on the\nleader cluster and then replaying those operations on the follower cluster.\n\nAt the Lucene level there are really only two write operations that {es}\nperforms on an index: a new document may be indexed, or an existing document may\nbe deleted. Updates are implemented by atomically deleting the old document and\nthen indexing the new document. A document indexed into Lucene already contains\nall the information needed to replay that indexing operation, but this is not\ntrue of document deletions. To solve this, {es} uses a feature called _soft\ndeletes_ to preserve recent deletions in the Lucene index so that they can be\nreplayed.\n\n{es} only preserves certain recently-deleted documents in the index because a\nsoft-deleted document still takes up some space. Eventually {es} will fully\ndiscard these soft-deleted documents to free up that space so that the index\ndoes not grow larger and larger over time. Fortunately {es} does not need to be\nable to replay every operation that has ever been performed on a shard, because\nit is always possible to make a full copy of a shard on a remote node. However,\ncopying the whole shard may take much longer than replaying a few missing\noperations, so {es} tries to retain all of the operations it expects to need to\nreplay in future.\n\n{es} keeps track of the operations it expects to need to replay in future using\na mechanism called _shard history retention leases_. Each shard copy that might\nneed operations to be replayed must first create a shard history retention lease\nfor itself. For example, this shard copy might be a replica of a shard or it\nmight be a shard of a follower index when using {ccr}. Each retention lease\nkeeps track of the sequence number of the first operation that the corresponding\nshard copy has not received. As the shard copy receives new operations, it\nincreases the sequence number contained in its retention lease to indicate that\nit will not need to replay those operations in future. {es} discards\nsoft-deleted operations once they are not being held by any retention lease.\n\nIf a shard copy fails then it stops updating its shard history retention lease,\nwhich means that {es} will preserve all new operations so they can be replayed\nwhen the failed shard copy recovers. However, retention leases only last for a\nlimited amount of time. If the shard copy does not recover quickly enough then\nits retention lease may expire. This protects {es} from retaining history\nforever if a shard copy fails permanently, because once a retention lease has\nexpired {es} can start to discard history again. If a shard copy recovers after\nits retention lease has expired then {es} will fall back to copying the whole\nindex since it can no longer simply replay the missing history. The expiry time\nof a retention lease defaults to `12h` which should be long enough for most\nreasonable recovery scenarios.\n\n[discrete]\n=== History retention settings\n\ninclude::{es-ref-dir}/index-modules.asciidoc[tag=ccr-index-soft-deletes-tag]\n\ninclude::{es-ref-dir}/index-modules.asciidoc[tag=ccr-index-soft-deletes-retention-tag]\n"
}