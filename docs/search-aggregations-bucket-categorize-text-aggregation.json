{
    "meta": {
        "timestamp": "2024-11-01T02:49:24.599066",
        "size": 18034,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-categorize-text-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-bucket-categorize-text-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-categorize-text-aggregation]]\n=== Categorize text aggregation\n++++\n<titleabbrev>Categorize text</titleabbrev>\n++++\n\nA multi-bucket aggregation that groups semi-structured text into buckets. Each `text` field is re-analyzed\nusing a custom analyzer. The resulting tokens are then categorized creating buckets of similarly formatted\ntext values. This aggregation works best with machine generated text like system logs. Only the first 100 analyzed\ntokens are used to categorize the text.\n\nNOTE: If you have considerable memory allocated to your JVM but are receiving circuit breaker exceptions from this\n      aggregation, you may be attempting to categorize text that is poorly formatted for categorization. Consider\n      adding `categorization_filters` or running under <<search-aggregations-bucket-sampler-aggregation,sampler>>,\n      <<search-aggregations-bucket-diversified-sampler-aggregation,diversified sampler>>, or\n      <<search-aggregations-random-sampler-aggregation,random sampler>> to explore the created categories.\n\nNOTE: The algorithm used for categorization was completely changed in version 8.3.0. As a result this aggregation\n      will not work in a mixed version cluster where some nodes are on version 8.3.0 or higher and others are\n      on a version older than 8.3.0. Upgrade all nodes in your cluster to the same version if you experience\n      an error related to this change.\n\n[[bucket-categorize-text-agg-syntax]]\n==== Parameters\n\n`categorization_analyzer`::\n(Optional, object or string)\nThe categorization analyzer specifies how the text is analyzed and tokenized before\nbeing categorized. The syntax is very similar to that used to define the `analyzer` in the\n<<indices-analyze,Analyze endpoint>>. This\nproperty cannot be used at the same time as `categorization_filters`.\n+\nThe `categorization_analyzer` field can be specified either as a string or as an\nobject. If it is a string it must refer to a\n<<analysis-analyzers,built-in analyzer>> or one added by another plugin. If it\nis an object it has the following properties:\n+\n.Properties of `categorization_analyzer`\n[%collapsible%open]\n=====\n`char_filter`::::\n(array of strings or objects)\ninclude::{es-ref-dir}/ml/ml-shared.asciidoc[tag=char-filter]\n\n`tokenizer`::::\n(string or object)\ninclude::{es-ref-dir}/ml/ml-shared.asciidoc[tag=tokenizer]\n\n`filter`::::\n(array of strings or objects)\ninclude::{es-ref-dir}/ml/ml-shared.asciidoc[tag=filter]\n=====\n\n`categorization_filters`::\n(Optional, array of strings)\nThis property expects an array of regular expressions. The expressions\nare used to filter out matching sequences from the categorization field values.\nYou can use this functionality to fine tune the categorization by excluding\nsequences from consideration when categories are defined. For example, you can\nexclude SQL statements that appear in your log files. This\nproperty cannot be used at the same time as `categorization_analyzer`. If you\nonly want to define simple regular expression filters that are applied prior to\ntokenization, setting this property is the easiest method. If you also want to\ncustomize the tokenizer or post-tokenization filtering, use the\n`categorization_analyzer` property instead and include the filters as\n`pattern_replace` character filters.\n\n`field`::\n(Required, string)\nThe semi-structured text field to categorize.\n\n`max_matched_tokens`::\n(Optional, integer)\nThis parameter does nothing now, but is permitted for compatibility with the original\npre-8.3.0 implementation.\n\n`max_unique_tokens`::\n(Optional, integer)\nThis parameter does nothing now, but is permitted for compatibility with the original\npre-8.3.0 implementation.\n\n`min_doc_count`::\n(Optional, integer)\nThe minimum number of documents for a bucket to be returned to the results.\n\n`shard_min_doc_count`::\n(Optional, integer)\nThe minimum number of documents for a bucket to be returned from the shard before\nmerging.\n\n`shard_size`::\n(Optional, integer)\nThe number of categorization buckets to return from each shard before merging\nall the results.\n\n`similarity_threshold`::\n(Optional, integer, default: `70`)\nThe minimum percentage of token weight that must match for text to be added to the\ncategory bucket.\nMust be between 1 and 100. The larger the value the narrower the categories.\nLarger values will increase memory usage and create narrower categories.\n\n`size`::\n(Optional, integer, default: `10`)\nThe number of buckets to return.\n\n[[bucket-categorize-text-agg-response]]\n==== Response body\n\n`key`::\n(string)\nConsists of the tokens (extracted by the `categorization_analyzer`)\nthat are common to all values of the input field included in the category.\n\n`doc_count`::\n(integer)\nNumber of documents matching the category.\n\n`max_matching_length`::\n(integer)\nCategories from short messages containing few tokens may also match\ncategories containing many tokens derived from much longer messages.\n`max_matching_length` is an indication of the maximum length of messages\nthat should be considered to belong to the category. When searching for\nmessages that match the category, any messages longer than\n`max_matching_length` should be excluded. Use this field to prevent a\nsearch for members of a category of short messages from matching much longer\nones.\n\n`regex`::\n(string)\nA regular expression that will match all values of the input field included\nin the category. It is possible that the `regex` does not incorporate every\nterm in `key`, if ordering varies between the values included in the\ncategory. However, in simple cases the `regex` will be the ordered terms\nconcatenated into a regular expression that allows for arbitrary sections\nin between them. It is not recommended to use the `regex` as the primary\nmechanism for searching for the original documents that were categorized.\nSearch using a regular expression is very slow. Instead the terms in the\n`key` field should be used to search for matching documents, as a terms\nsearch can use the inverted index and hence be much faster. However, there\nmay be situations where it is useful to use the `regex` field to test whether\na small set of messages that have not been indexed match the category, or to\nconfirm that the terms in the `key` occur in the correct order in all the\nmatched documents.\n\n==== Basic use\n\nWARNING: Re-analyzing _large_ result sets will require a lot of time and memory. This aggregation should be\n         used in conjunction with <<async-search, Async search>>. Additionally, you may consider\n         using the aggregation as a child of either the <<search-aggregations-bucket-sampler-aggregation,sampler>> or\n         <<search-aggregations-bucket-diversified-sampler-aggregation,diversified sampler>> aggregation.\n         This will typically improve speed and memory use.\n\nExample:\n\n[source,console]\n--------------------------------------------------\nPOST log-messages/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"categories\": {\n      \"categorize_text\": {\n        \"field\": \"message\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:categorize_text]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"aggregations\" : {\n    \"categories\" : {\n      \"buckets\" : [\n        {\n          \"doc_count\" : 3,\n          \"key\" : \"Node shutting down\",\n          \"regex\" : \".*?Node.+?shutting.+?down.*?\",\n          \"max_matching_length\" : 49\n        },\n        {\n          \"doc_count\" : 1,\n          \"key\" : \"Node starting up\",\n          \"regex\" : \".*?Node.+?starting.+?up.*?\",\n          \"max_matching_length\" : 47\n        },\n        {\n          \"doc_count\" : 1,\n          \"key\" : \"User foo_325 logging on\",\n          \"regex\" : \".*?User.+?foo_325.+?logging.+?on.*?\",\n          \"max_matching_length\" : 52\n        },\n        {\n          \"doc_count\" : 1,\n          \"key\" : \"User foo_864 logged off\",\n          \"regex\" : \".*?User.+?foo_864.+?logged.+?off.*?\",\n          \"max_matching_length\" : 52\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n\nHere is an example using `categorization_filters`\n\n[source,console]\n--------------------------------------------------\nPOST log-messages/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"categories\": {\n      \"categorize_text\": {\n        \"field\": \"message\",\n        \"categorization_filters\": [\"\\\\w+\\\\_\\\\d{3}\"] <1>\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:categorize_text]\n\n<1> The filters to apply to the analyzed tokens. It filters\n    out tokens like `bar_123`.\n\nNote how the `foo_<number>` tokens are not part of the\ncategory results\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"aggregations\" : {\n    \"categories\" : {\n      \"buckets\" : [\n        {\n          \"doc_count\" : 3,\n          \"key\" : \"Node shutting down\",\n          \"regex\" : \".*?Node.+?shutting.+?down.*?\",\n          \"max_matching_length\" : 49\n        },\n        {\n          \"doc_count\" : 1,\n          \"key\" : \"Node starting up\",\n          \"regex\" : \".*?Node.+?starting.+?up.*?\",\n          \"max_matching_length\" : 47\n        },\n        {\n          \"doc_count\" : 1,\n          \"key\" : \"User logged off\",\n          \"regex\" : \".*?User.+?logged.+?off.*?\",\n          \"max_matching_length\" : 52\n        },\n        {\n          \"doc_count\" : 1,\n          \"key\" : \"User logging on\",\n          \"regex\" : \".*?User.+?logging.+?on.*?\",\n          \"max_matching_length\" : 52\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n\nHere is an example using `categorization_filters`.\nThe default analyzer uses the `ml_standard` tokenizer which is similar to a whitespace tokenizer\nbut filters out tokens that could be interpreted as hexadecimal numbers. The default analyzer\nalso uses the `first_line_with_letters` character filter, so that only the first meaningful line\nof multi-line messages is considered.\nBut, it may be that a token is a known highly-variable token (formatted usernames, emails, etc.). In that case, it is good to supply\ncustom `categorization_filters` to filter out those tokens for better categories. These filters may also reduce memory usage as fewer\ntokens are held in memory for the categories. (If there are sufficient examples of different usernames, emails, etc., then\ncategories will form that naturally discard them as variables, but for small input data where only one example exists this won't\nhappen.)\n\n[source,console]\n--------------------------------------------------\nPOST log-messages/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"categories\": {\n      \"categorize_text\": {\n        \"field\": \"message\",\n        \"categorization_filters\": [\"\\\\w+\\\\_\\\\d{3}\"], <1>\n        \"similarity_threshold\": 11 <2>\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:categorize_text]\n<1> The filters to apply to the analyzed tokens. It filters\nout tokens like `bar_123`.\n<2> Require 11% of token weight to match before adding a message to an\n    existing category rather than creating a new one.\n\nThe resulting categories are now very broad, merging the log groups.\n(A `similarity_threshold` of 11% is generally too low. Settings over\n50% are usually better.)\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"aggregations\" : {\n    \"categories\" : {\n      \"buckets\" : [\n        {\n          \"doc_count\" : 4,\n          \"key\" : \"Node\",\n          \"regex\" : \".*?Node.*?\",\n          \"max_matching_length\" : 49\n        },\n        {\n          \"doc_count\" : 2,\n          \"key\" : \"User\",\n          \"regex\" : \".*?User.*?\",\n          \"max_matching_length\" : 52\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n\nThis aggregation can have both sub-aggregations and itself be a sub-aggregation. This allows gathering the top daily categories and the\ntop sample doc as below.\n\n[source,console]\n--------------------------------------------------\nPOST log-messages/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"daily\": {\n      \"date_histogram\": {\n        \"field\": \"time\",\n        \"fixed_interval\": \"1d\"\n      },\n      \"aggs\": {\n        \"categories\": {\n          \"categorize_text\": {\n            \"field\": \"message\",\n            \"categorization_filters\": [\"\\\\w+\\\\_\\\\d{3}\"]\n          },\n          \"aggs\": {\n            \"hit\": {\n              \"top_hits\": {\n                \"size\": 1,\n                \"sort\": [\"time\"],\n                \"_source\": \"message\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:categorize_text]\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"aggregations\" : {\n    \"daily\" : {\n      \"buckets\" : [\n        {\n          \"key_as_string\" : \"2016-02-07T00:00:00.000Z\",\n          \"key\" : 1454803200000,\n          \"doc_count\" : 3,\n          \"categories\" : {\n            \"buckets\" : [\n              {\n                \"doc_count\" : 2,\n                \"key\" : \"Node shutting down\",\n                \"regex\" : \".*?Node.+?shutting.+?down.*?\",\n                \"max_matching_length\" : 49,\n                \"hit\" : {\n                  \"hits\" : {\n                    \"total\" : {\n                      \"value\" : 2,\n                      \"relation\" : \"eq\"\n                    },\n                    \"max_score\" : null,\n                    \"hits\" : [\n                      {\n                        \"_index\" : \"log-messages\",\n                        \"_id\" : \"1\",\n                        \"_score\" : null,\n                        \"_source\" : {\n                          \"message\" : \"2016-02-07T00:00:00+0000 Node 3 shutting down\"\n                        },\n                        \"sort\" : [\n                          1454803260000\n                        ]\n                      }\n                    ]\n                  }\n                }\n              },\n              {\n                \"doc_count\" : 1,\n                \"key\" : \"Node starting up\",\n                \"regex\" : \".*?Node.+?starting.+?up.*?\",\n                \"max_matching_length\" : 47,\n                \"hit\" : {\n                  \"hits\" : {\n                    \"total\" : {\n                      \"value\" : 1,\n                      \"relation\" : \"eq\"\n                    },\n                    \"max_score\" : null,\n                    \"hits\" : [\n                      {\n                        \"_index\" : \"log-messages\",\n                        \"_id\" : \"2\",\n                        \"_score\" : null,\n                        \"_source\" : {\n                          \"message\" : \"2016-02-07T00:00:00+0000 Node 5 starting up\"\n                        },\n                        \"sort\" : [\n                          1454803320000\n                        ]\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"key_as_string\" : \"2016-02-08T00:00:00.000Z\",\n          \"key\" : 1454889600000,\n          \"doc_count\" : 3,\n          \"categories\" : {\n            \"buckets\" : [\n              {\n                \"doc_count\" : 1,\n                \"key\" : \"Node shutting down\",\n                \"regex\" : \".*?Node.+?shutting.+?down.*?\",\n                \"max_matching_length\" : 49,\n                \"hit\" : {\n                  \"hits\" : {\n                    \"total\" : {\n                      \"value\" : 1,\n                      \"relation\" : \"eq\"\n                    },\n                    \"max_score\" : null,\n                    \"hits\" : [\n                      {\n                        \"_index\" : \"log-messages\",\n                        \"_id\" : \"4\",\n                        \"_score\" : null,\n                        \"_source\" : {\n                          \"message\" : \"2016-02-08T00:00:00+0000 Node 5 shutting down\"\n                        },\n                        \"sort\" : [\n                          1454889660000\n                        ]\n                      }\n                    ]\n                  }\n                }\n              },\n              {\n                \"doc_count\" : 1,\n                \"key\" : \"User logged off\",\n                \"regex\" : \".*?User.+?logged.+?off.*?\",\n                \"max_matching_length\" : 52,\n                \"hit\" : {\n                  \"hits\" : {\n                    \"total\" : {\n                      \"value\" : 1,\n                      \"relation\" : \"eq\"\n                    },\n                    \"max_score\" : null,\n                    \"hits\" : [\n                      {\n                        \"_index\" : \"log-messages\",\n                        \"_id\" : \"6\",\n                        \"_score\" : null,\n                        \"_source\" : {\n                          \"message\" : \"2016-02-08T00:00:00+0000 User foo_864 logged off\"\n                        },\n                        \"sort\" : [\n                          1454889840000\n                        ]\n                      }\n                    ]\n                  }\n                }\n              },\n              {\n                \"doc_count\" : 1,\n                \"key\" : \"User logging on\",\n                \"regex\" : \".*?User.+?logging.+?on.*?\",\n                \"max_matching_length\" : 52,\n                \"hit\" : {\n                  \"hits\" : {\n                    \"total\" : {\n                      \"value\" : 1,\n                      \"relation\" : \"eq\"\n                    },\n                    \"max_score\" : null,\n                    \"hits\" : [\n                      {\n                        \"_index\" : \"log-messages\",\n                        \"_id\" : \"5\",\n                        \"_score\" : null,\n                        \"_source\" : {\n                          \"message\" : \"2016-02-08T00:00:00+0000 User foo_325 logging on\"\n                        },\n                        \"sort\" : [\n                          1454889720000\n                        ]\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n"
}