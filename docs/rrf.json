{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.389596",
        "size": 23658,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/rrf.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "rrf",
        "version": "8.15"
    },
    "doc": "[[rrf]]\n=== Reciprocal rank fusion\n\nhttps://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf[Reciprocal rank fusion (RRF)]\nis a method for combining multiple result sets with different relevance indicators into a single result set.\nRRF requires no tuning, and the different relevance indicators do not have to be related to each other to achieve high-quality results.\n\nRRF uses the following formula to determine the score for ranking each document:\n\n[source,python]\n----\nscore = 0.0\nfor q in queries:\n    if d in result(q):\n        score += 1.0 / ( k + rank( result(q), d ) )\nreturn score\n\n# where\n# k is a ranking constant\n# q is a query in the set of queries\n# d is a document in the result set of q\n# result(q) is the result set of q\n# rank( result(q), d ) is d's rank within the result(q) starting from 1\n----\n// NOTCONSOLE\n\n[[rrf-api]]\n==== Reciprocal rank fusion API\n\nYou can use RRF as part of a <<search-search, search>> to combine and rank documents using separate sets of top documents (result sets) from a combination of <<retriever, child retrievers>> using an\n<<rrf-retriever, RRF retriever>>.\nA minimum of *two* child retrievers is required for ranking.\n\nAn RRF retriever is an optional object defined as part of a search request's\n<<request-body-retriever, retriever parameter>>.\nThe RRF retriever object contains the following parameters:\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=rrf-retrievers]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=rrf-rank-constant]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=rrf-rank-window-size]\n\nAn example request using RRF:\n\n[source,console]\n----\nGET example-index/_search\n{\n    \"retriever\": {\n        \"rrf\": { <3>\n            \"retrievers\": [\n                {\n                    \"standard\": { <2>\n                        \"query\": {\n                            \"term\": {\n                                \"text\": \"shoes\"\n                            }\n                        }\n                    }\n                },\n                {\n                    \"knn\": { <1>\n                        \"field\": \"vector\",\n                        \"query_vector\": [1.25, 2, 3.5],\n                        \"k\": 50,\n                        \"num_candidates\": 100\n                    }\n                }\n            ],\n            \"rank_window_size\": 50,\n            \"rank_constant\": 20\n        }\n    }\n}\n----\n// TEST[skip:example fragment]\n\nIn the above example, we execute the `knn` and `standard` retrievers independently of each other.\nThen we use the `rrf` retriever to combine the results.\n\n<1> First, we execute the kNN search specified by the `knn` retriever to get its global top 50 results.\n<2> Second, we execute the query specified by the `standard` retriever to get its global top 50 results.\n<3> Then, on a coordinating node, we combine the kNN search top documents with the query top documents and rank them based on the RRF formula using parameters from the `rrf` retriever to get the combined top documents using the default `size` of `10`.\n\nNote that if `k` from a knn search is larger than `rank_window_size`, the results are truncated to `rank_window_size`.\nIf `k` is smaller than `rank_window_size`, the results are `k` size.\n\n[[rrf-supported-features]]\n==== Reciprocal rank fusion supported features\n\nThe `rrf` retriever supports:\n\n* <<search-aggregations, aggregations>>\n* <<search-from-param, from>>\n* <<search-suggesters, suggesters>>\n* <<highlighting, highlighting>>\n* <<collapse-search-results, collapse>>\n* <<profiling-queries, profiling>>\n\nThe `rrf` retriever does not currently support:\n\n* <<search-api-scroll-query-param, scroll>>\n* <<search-sort-param, sort>>\n* <<rescore, rescore>>\n\nUsing unsupported features as part of a search with an `rrf` retriever results in an exception.\n+\nIMPORTANT: It is best to avoid providing a <<search-api-pit, point in time>> as part of the request, as\nRRF creates one internally that is shared by all sub-retrievers to ensure consistent results.\n\n[[rrf-using-multiple-standard-retrievers]]\n==== Reciprocal rank fusion using multiple standard retrievers\n\nThe `rrf` retriever provides a way to combine and rank multiple `standard` retrievers.\nA primary use case is combining top documents from a traditional BM25 query and an <<semantic-search-elser, ELSER>> query to achieve improved relevance.\n\nAn example request using RRF with multiple standard retrievers:\n\n[source,console]\n----\nGET example-index/_search\n{\n    \"retriever\": {\n        \"rrf\": { <3>\n            \"retrievers\": [\n                {\n                    \"standard\": { <1>\n                        \"query\": {\n                            \"term\": {\n                                \"text\": \"blue shoes sale\"\n                            }\n                        }\n                    }\n                },\n                {\n                    \"standard\": { <2>\n                        \"query\": {\n                            \"sparse_vector\":{\n                                \"field\": \"ml.tokens\",\n                                \"inference_id\": \"my_elser_model\",\n                                \"query\": \"What blue shoes are on sale?\"\n                            }\n                        }\n                    }\n                }\n            ],\n            \"rank_window_size\": 50,\n            \"rank_constant\": 20\n        }\n    }\n}\n----\n// TEST[skip:example fragment]\n\nIn the above example, we execute each of the two `standard` retrievers independently of each other.\nThen we use the `rrf` retriever to combine the results.\n\n<1> First we run the `standard` retriever specifying a term query for `blue shoes sales` using the standard BM25 scoring algorithm.\n<2> Next we run the `standard` retriever specifying a sparse_vector query for `What blue shoes are on sale?`\nusing our <<semantic-search-elser, ELSER>> scoring algorithm.\n<3> The `rrf` retriever allows us to combine the two top documents sets generated by completely independent scoring algorithms with equal weighting.\n\nNot only does this remove the need to figure out what the appropriate weighting is using linear combination, but RRF is also shown to give improved relevance over either query individually.\n\n[[rrf-using-sub-searches]]\n==== Reciprocal rank fusion using sub searches\n\nRRF using sub searches is no longer supported.\nUse the <<retriever, retriever API>> instead.\nSee <<rrf-using-multiple-standard-retrievers, using multiple standard retrievers>> for an example.\n\n[[rrf-full-example]]\n==== Reciprocal rank fusion full example\n\nWe begin by creating a mapping for an index with a text field, a vector field, and an integer field along with indexing several documents.\nFor this example we are going to use a vector with only a single dimension to make the ranking easier to explain.\n\n[source,console]\n----\nPUT example-index\n{\n    \"mappings\": {\n        \"properties\": {\n            \"text\" : {\n                \"type\" : \"text\"\n            },\n            \"vector\": {\n                \"type\": \"dense_vector\",\n                \"dims\": 1,\n                \"index\": true,\n                \"similarity\": \"l2_norm\",\n                 \"index_options\": {\n                     \"type\": \"hnsw\"\n                 }\n            },\n            \"integer\" : {\n                \"type\" : \"integer\"\n            }\n        }\n    }\n}\n\nPUT example-index/_doc/1\n{\n    \"text\" : \"rrf\",\n    \"vector\" : [5],\n    \"integer\": 1\n}\n\nPUT example-index/_doc/2\n{\n    \"text\" : \"rrf rrf\",\n    \"vector\" : [4],\n    \"integer\": 2\n}\n\nPUT example-index/_doc/3\n{\n    \"text\" : \"rrf rrf rrf\",\n    \"vector\" : [3],\n    \"integer\": 1\n}\n\nPUT example-index/_doc/4\n{\n    \"text\" : \"rrf rrf rrf rrf\",\n    \"integer\": 2\n}\n\nPUT example-index/_doc/5\n{\n    \"vector\" : [0],\n    \"integer\": 1\n}\n\nPOST example-index/_refresh\n----\n// TEST\n\nWe now execute a search using an `rrf` retriever with a `standard` retriever specifying a BM25 query, a `knn` retriever specifying a kNN search, and a terms aggregation.\n\n[source,console]\n----\nGET example-index/_search\n{\n    \"retriever\": {\n        \"rrf\": {\n            \"retrievers\": [\n                {\n                    \"standard\": {\n                        \"query\": {\n                            \"term\": {\n                                \"text\": \"rrf\"\n                            }\n                        }\n                    }\n                },\n                {\n                    \"knn\": {\n                        \"field\": \"vector\",\n                        \"query_vector\": [3],\n                        \"k\": 5,\n                        \"num_candidates\": 5\n                    }\n                }\n            ],\n            \"rank_window_size\": 5,\n            \"rank_constant\": 1\n        }\n    },\n    \"size\": 3,\n    \"aggs\": {\n        \"int_count\": {\n            \"terms\": {\n                \"field\": \"integer\"\n            }\n        }\n    }\n}\n----\n// TEST[continued]\n\nAnd we receive the response with ranked `hits` and the terms aggregation result.\nWe have both the ranker's `score` and the `_rank` option to show our top-ranked documents.\n\n[source,console-response]\n----\n{\n    \"took\": ...,\n    \"timed_out\" : false,\n    \"_shards\" : {\n        \"total\" : 1,\n        \"successful\" : 1,\n        \"skipped\" : 0,\n        \"failed\" : 0\n    },\n    \"hits\" : {\n        \"total\" : {\n            \"value\" : 5,\n            \"relation\" : \"eq\"\n        },\n        \"max_score\" : ...,\n        \"hits\" : [\n            {\n                \"_index\" : \"example-index\",\n                \"_id\" : \"3\",\n                \"_score\" : 0.8333334,\n                \"_source\" : {\n                    \"integer\" : 1,\n                    \"vector\" : [\n                        3\n                    ],\n                    \"text\" : \"rrf rrf rrf\"\n                }\n            },\n            {\n                \"_index\" : \"example-index\",\n                \"_id\" : \"2\",\n                \"_score\" : 0.5833334,\n                \"_source\" : {\n                    \"integer\" : 2,\n                    \"vector\" : [\n                        4\n                    ],\n                    \"text\" : \"rrf rrf\"\n                }\n            },\n            {\n                \"_index\" : \"example-index\",\n                \"_id\" : \"4\",\n                \"_score\" : 0.5,\n                \"_source\" : {\n                    \"integer\" : 2,\n                    \"text\" : \"rrf rrf rrf rrf\"\n                }\n            }\n        ]\n    },\n    \"aggregations\" : {\n        \"int_count\" : {\n            \"doc_count_error_upper_bound\" : 0,\n            \"sum_other_doc_count\" : 0,\n            \"buckets\" : [\n                {\n                    \"key\" : 1,\n                    \"doc_count\" : 3\n                },\n                {\n                    \"key\" : 2,\n                    \"doc_count\" : 2\n                }\n            ]\n        }\n    }\n}\n----\n// TESTRESPONSE[s/: \\.\\.\\./: $body.$_path/]\n\nLet's break down how these hits were ranked.\nWe start by running the `standard` retriever specifying a query and the `knn` retriever specifying a kNN search separately to collect what their individual hits are.\n\nFirst, we look at the hits for the query from the `standard` retriever.\n\n[source,console-result]\n----\n\"hits\" : [\n    {\n        \"_index\" : \"example-index\",\n        \"_id\" : \"4\",\n        \"_score\" : 0.16152832,              <1>\n        \"_source\" : {\n            \"integer\" : 2,\n            \"text\" : \"rrf rrf rrf rrf\"\n        }\n    },\n    {\n        \"_index\" : \"example-index\",\n        \"_id\" : \"3\",                        <2>\n        \"_score\" : 0.15876243,\n        \"_source\" : {\n            \"integer\" : 1,\n            \"vector\" : [3],\n            \"text\" : \"rrf rrf rrf\"\n        }\n    },\n    {\n        \"_index\" : \"example-index\",\n        \"_id\" : \"2\",                        <3>\n        \"_score\" : 0.15350538,\n        \"_source\" : {\n            \"integer\" : 2,\n            \"vector\" : [4],\n            \"text\" : \"rrf rrf\"\n        }\n    },\n    {\n        \"_index\" : \"example-index\",\n        \"_id\" : \"1\",                        <4>\n        \"_score\" : 0.13963442,\n        \"_source\" : {\n            \"integer\" : 1,\n            \"vector\" : [5],\n            \"text\" : \"rrf\"\n        }\n    }\n]\n----\n// TEST[skip:example fragment]\n<1> rank 1, `_id` 4\n<2> rank 2, `_id` 3\n<3> rank 3, `_id` 2\n<4> rank 4, `_id` 1\n\nNote that our first hit doesn't have a value for the `vector` field.\nNow, we look at the results for the kNN search from the `knn` retriever.\n\n[source,console-result]\n----\n\"hits\" : [\n    {\n        \"_index\" : \"example-index\",\n        \"_id\" : \"3\",                   <1>\n        \"_score\" : 1.0,\n        \"_source\" : {\n            \"integer\" : 1,\n            \"vector\" : [3],\n            \"text\" : \"rrf rrf rrf\"\n        }\n    },\n    {\n        \"_index\" : \"example-index\",\n        \"_id\" : \"2\",                   <2>\n        \"_score\" : 0.5,\n        \"_source\" : {\n            \"integer\" : 2,\n            \"vector\" : [4],\n            \"text\" : \"rrf rrf\"\n        }\n    },\n    {\n        \"_index\" : \"example-index\",\n        \"_id\" : \"1\",                   <3>\n        \"_score\" : 0.2,\n        \"_source\" : {\n            \"integer\" : 1,\n            \"vector\" : [5],\n            \"text\" : \"rrf\"\n        }\n    },\n    {\n        \"_index\" : \"example-index\",\n        \"_id\" : \"5\",                   <4>\n        \"_score\" : 0.1,\n        \"_source\" : {\n            \"integer\" : 1,\n            \"vector\" : [0]\n        }\n    }\n]\n----\n// TEST[skip:example fragment]\n<1> rank 1, `_id` 3\n<2> rank 2, `_id` 2\n<3> rank 3, `_id` 1\n<4> rank 4, `_id` 5\n\nWe can now take the two individually ranked result sets and apply the RRF formula to them using parameters from the `rrf` retriever to get our final ranking.\n\n[source,python]\n----\n# doc  | query     | knn       | score\n_id: 1 = 1.0/(1+4) + 1.0/(1+3) = 0.4500\n_id: 2 = 1.0/(1+3) + 1.0/(1+2) = 0.5833\n_id: 3 = 1.0/(1+2) + 1.0/(1+1) = 0.8333\n_id: 4 = 1.0/(1+1)             = 0.5000\n_id: 5 =             1.0/(1+4) = 0.2000\n----\n// NOTCONSOLE\n\nWe rank the documents based on the RRF formula with a `rank_window_size` of `5` truncating the bottom `2` docs in our RRF result set with a `size` of `3`.\nWe end with `_id: 3` as `_rank: 1`, `_id: 2` as `_rank: 2`, and `_id: 4` as `_rank: 3`.\nThis ranking matches the result set from the original RRF search as expected.\n\n==== Explain in RRF\n\nIn addition to individual query scoring details, we can make use of the `explain=true` parameter to get information on how the RRF scores for each document were computed.\nWorking with the example above, and by adding `explain=true` to the search request, we'd now have a response that looks like the following:\n\n[source,js]\n----\n{\n    \"hits\":\n    [\n        {\n            \"_index\": \"example-index\",\n            \"_id\": \"3\",\n            \"_score\": 0.8333334,\n            \"_explanation\":\n            {\n                \"value\": 0.8333334,                                                                                                                                               <1>\n                \"description\": \"rrf score: [0.8333334] computed for initial ranks [2, 1] with rankConstant: [1] as sum of [1 / (rank + rankConstant)] for each query\",            <2>\n                \"details\":                                                                                                                                                        <3>\n                [\n                    {\n                        \"value\": 2,                                                                                                                                               <4>\n                        \"description\": \"rrf score: [0.33333334], for rank [2] in query at index [0] computed as [1 / (2 + 1]), for matching query with score: \",\n                        \"details\":                                                                                                                                                <5>\n                        [\n                            {\n                                \"value\": 0.15876243,\n                                \"description\": \"weight(text:rrf in 0) [PerFieldSimilarity], result of:\",\n                                \"details\":\n                                [\n                                    ...\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        \"value\": 1,                                                                                                                                              <6>\n                        \"description\": \"rrf score: [0.5], for rank [1] in query at index [1] computed as [1 / (1 + 1]), for matching query with score: \",\n                        \"details\":\n                        [\n                            {\n                                \"value\": 1,\n                                \"description\": \"within top k documents\",\n                                \"details\":\n                                []\n                            }\n                        ]\n                    }\n                ]\n            }\n        }\n        ...\n    ]\n}\n----\n// NOTCONSOLE\n\n<1> the final RRF score for document with `_id=3`\n<2> a description on how this score was computed based on the ranks of this document in each individual query\n<3> details on how the RRF score was computed for each of the queries\n<4> the `value` heres specifies the `rank` of this document in the specific query\n<5> standard `explain` output of the underlying query, describing matching terms and weights\n<6> the `value` heres specifies the `rank` of this document for the second (`knn`) query\n\nIn addition to the above, explain in RRF also supports <<named-queries,named queries>> using the `_name` parameter.\nUsing named queries allows for easier and more intuitive understanding of the RRF score computation, especially when dealing with multiple queries.\nSo, we would now have:\n\n[source,js]\n----\nGET example-index/_search\n{\n    \"retriever\": {\n        \"rrf\": {\n            \"retrievers\": [\n                {\n                    \"standard\": {\n                        \"query\": {\n                            \"term\": {\n                                \"text\": \"rrf\"\n                            }\n                        }\n                    }\n                },\n                {\n                    \"knn\": {\n                        \"field\": \"vector\",\n                        \"query_vector\": [3],\n                        \"k\": 5,\n                        \"num_candidates\": 5,\n                        \"_name\": \"my_knn_query\"                           <1>\n                    }\n                }\n            ],\n            \"rank_window_size\": 5,\n            \"rank_constant\": 1\n        }\n    },\n    \"size\": 3,\n    \"aggs\": {\n        \"int_count\": {\n            \"terms\": {\n                \"field\": \"integer\"\n            }\n        }\n    }\n}\n----\n// NOTCONSOLE\n<1> Here we specify a `_name` for the `knn` retriever\n\nThe response would now include the named query in the explanation:\n\n[source,js]\n----\n{\n    \"hits\":\n    [\n        {\n            \"_index\": \"example-index\",\n            \"_id\": \"3\",\n            \"_score\": 0.8333334,\n            \"_explanation\":\n            {\n                \"value\": 0.8333334,\n                \"description\": \"rrf score: [0.8333334] computed for initial ranks [2, 1] with rankConstant: [1] as sum of [1 / (rank + rankConstant)] for each query\",\n                \"details\":\n                [\n                    {\n                        \"value\": 2,\n                        \"description\": \"rrf score: [0.33333334], for rank [2] in query at index [0] computed as [1 / (2 + 1]), for matching query with score: \",\n                        \"details\":\n                        [\n                            ...\n                        ]\n                    },\n                    {\n                        \"value\": 1,\n                        \"description\": \"rrf score: [0.5], for rank [1] in query [my_knn_query] computed as [1 / (1 + 1]), for matching query with score: \",                      <1>\n                        \"details\":\n                        [\n                           ...\n                        ]\n                    }\n                ]\n            }\n        }\n        ...\n    ]\n}\n----\n// NOTCONSOLE\n<1> Instead of the anonymous `at index n` , we now have a reference to the named query `my_knn_query`.\n\n==== Pagination in RRF\n\nWhen using `rrf` you can paginate through the results using the `from` parameter.\nAs the final ranking is solely dependent on the original query ranks, to ensure consistency when paginating, we have to make sure that while `from` changes, the order of what we have already seen remains intact.\nTo that end, we're using a fixed `rank_window_size` as the whole available result set upon which we can paginate.\nThis essentially means that if:\n\n* `from + size` &le; `rank_window_size` : we could get  `results[from: from+size]` documents back from the final `rrf` ranked result set\n\n* `from + size` &gt; `rank_window_size` : we would get 0 results back, as the request would fall outside the available `rank_window_size`-sized result set.\n\nAn important thing to note here is that since `rank_window_size` is all the results that we'll get to see from the individual query components, pagination guarantees consistency, i.e. no documents are skipped or duplicated in multiple pages, iff `rank_window_size` remains the same.\nIf `rank_window_size` changes, then the order of the results might change as well, even for the same ranks.\n\nTo illustrate all of the above, let's consider the following simplified example where we have two queries, `queryA` and `queryB` and their ranked documents:\n\n[source,python]\n----\n     |  queryA   |  queryB    |\n_id: |  1        |  5         |\n_id: |  2        |  4         |\n_id: |  3        |  3         |\n_id: |  4        |  1         |\n_id: |           |  2         |\n----\n// NOTCONSOLE\n\nFor `rank_window_size=5` we would get to see all documents from both `queryA` and `queryB`.\nAssuming a `rank_constant=1`, the `rrf` scores would be:\n\n[source,python]\n----\n# doc   | queryA     | queryB       | score\n_id: 1 =  1.0/(1+1)  + 1.0/(1+4)      = 0.7\n_id: 2 =  1.0/(1+2)  + 1.0/(1+5)      = 0.5\n_id: 3 =  1.0/(1+3)  + 1.0/(1+3)      = 0.5\n_id: 4 =  1.0/(1+4)  + 1.0/(1+2)      = 0.533\n_id: 5 =    0        + 1.0/(1+1)      = 0.5\n----\n// NOTCONSOLE\n\nSo the final ranked result set would be [`1`, `4`, `2`, `3`, `5`] and we would paginate over that, since `rank_window_size == len(results)`.\nIn this scenario, we would have:\n\n* `from=0, size=2` would return documents [`1`, `4`] with ranks `[1, 2]`\n* `from=2, size=2` would return documents [`2`, `3`] with ranks `[3, 4]`\n* `from=4, size=2` would return document [`5`] with rank `[5]`\n* `from=6, size=2` would return an empty result set as it there are no more results to iterate over\n\nNow, if we had a `rank_window_size=2`, we would only get to see `[1, 2]` and `[5, 4]` documents for queries `queryA` and `queryB` respectively.\nWorking out the math, we would see that the results would now be slightly different, because we would have no knowledge of the documents in positions `[3: end]` for either query.\n\n[source,python]\n----\n# doc   | queryA     | queryB         | score\n_id: 1 =  1.0/(1+1)  + 0              = 0.5\n_id: 2 =  1.0/(1+2)  + 0              = 0.33\n_id: 4 =    0        + 1.0/(1+2)      = 0.33\n_id: 5 =    0        + 1.0/(1+1)      = 0.5\n----\n// NOTCONSOLE\n\nThe final ranked result set would be [`1`, `5`, `2`, `4`], and we would be able to paginate on the top `rank_window_size` results, i.e. [`1`, `5`].\nSo for the same params as above, we would now have:\n\n* `from=0, size=2` would return [`1`, `5`] with ranks `[1, 2]`\n* `from=2, size=2` would return an empty result set as it would fall outside the available `rank_window_size` results.\n"
}