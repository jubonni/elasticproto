{
    "meta": {
        "timestamp": "2024-11-01T02:49:26.212069",
        "size": 4823,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/shard-request-cache.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "shard-request-cache",
        "version": "8.15"
    },
    "doc": "[[shard-request-cache]]\n=== Shard request cache settings\n\nWhen a search request is run against an index or against many indices, each\ninvolved shard executes the search locally and returns its local results to\nthe _coordinating node_, which combines these shard-level results into a\n``global'' result set.\n\nThe shard-level request cache module caches the local results on each shard.\nThis allows frequently used (and potentially heavy) search requests to return\nresults almost instantly. The requests cache is a very good fit for the logging\nuse case, where only the most recent index is being actively updated --\nresults from older indices will be served directly from the cache.\n\n[IMPORTANT]\n===================================\n\nBy default, the requests cache will only cache the results of search requests\nwhere `size=0`, so it will not cache `hits`,\nbut it will cache `hits.total`,  <<search-aggregations,aggregations>>, and\n<<search-suggesters,suggestions>>.\n\nMost queries that use `now` (see <<date-math>>) cannot be cached.\n\nScripted queries that use the API calls which are non-deterministic, such as\n`Math.random()` or `new Date()` are not cached.\n===================================\n\n[discrete]\n==== Cache invalidation\n\nThe cache is smart -- it keeps the same _near real-time_ promise as uncached\nsearch.\n\nCached results are invalidated automatically whenever the shard refreshes to\npick up changes to the documents or when you update the mapping. In other\nwords you will always get the same results from the cache as you would for an\nuncached search request.\n\nThe longer the refresh interval, the longer that cached entries will remain\nvalid even if there are changes to the documents. If the cache is full, the\nleast recently used cache keys will be evicted.\n\nThe cache can be expired manually with the <<indices-clearcache,`clear-cache` API>>:\n\n[source,console]\n------------------------\nPOST /my-index-000001,my-index-000002/_cache/clear?request=true\n------------------------\n// TEST[s/^/PUT my-index-000001\\nPUT my-index-000002\\n/]\n\n[discrete]\n==== Enabling and disabling caching\n\nThe cache is enabled by default, but can be disabled when creating a new\nindex as follows:\n\n[source,console]\n-----------------------------\nPUT /my-index-000001\n{\n  \"settings\": {\n    \"index.requests.cache.enable\": false\n  }\n}\n-----------------------------\n\nIt can also be enabled or disabled dynamically on an existing index with the\n<<indices-update-settings,`update-settings`>> API:\n\n[source,console]\n-----------------------------\nPUT /my-index-000001/_settings\n{ \"index.requests.cache.enable\": true }\n-----------------------------\n// TEST[continued]\n\n\n[discrete]\n==== Enabling and disabling caching per request\n\nThe `request_cache` query-string parameter can be used to enable or disable\ncaching on a *per-request* basis. If set, it overrides the index-level setting:\n\n[source,console]\n-----------------------------\nGET /my-index-000001/_search?request_cache=true\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"popular_colors\": {\n      \"terms\": {\n        \"field\": \"colors\"\n      }\n    }\n  }\n}\n-----------------------------\n// TEST[continued]\n\nRequests where `size` is greater than 0 will not be cached even if the request cache is\nenabled in the index settings. To cache these requests you will need to use the\nquery-string parameter detailed here.\n\n[discrete]\n==== Cache key\n\nA hash of the whole JSON body is used as the cache key. This means that if the JSON\nchanges -- for instance if keys are output in a different order -- then the\ncache key will not be recognised.\n\nTIP: Most JSON libraries support a _canonical_ mode which ensures that JSON\nkeys are always emitted in the same order. This canonical mode can be used in\nthe application to ensure that a request is always serialized in the same way.\n\n[discrete]\n==== Cache settings\n\nThe cache is managed at the node level, and has a default maximum size of `1%`\nof the heap. This can be changed in the `config/elasticsearch.yml` file with:\n\n[source,yaml]\n--------------------------------\nindices.requests.cache.size: 2%\n--------------------------------\n\nAlso, you can use the +indices.requests.cache.expire+ setting to specify a TTL\nfor cached results, but there should be no reason to do so. Remember that\nstale results are automatically invalidated when the index is refreshed. This\nsetting is provided for completeness' sake only.\n\n[discrete]\n==== Monitoring cache usage\n\nThe size of the cache (in bytes) and the number of evictions can be viewed\nby index, with the <<indices-stats,`indices-stats`>> API:\n\n[source,console]\n------------------------\nGET /_stats/request_cache?human\n------------------------\n\nor by node with the <<cluster-nodes-stats,`nodes-stats`>> API:\n\n[source,console]\n------------------------\nGET /_nodes/stats/indices/request_cache?human\n------------------------\n"
}