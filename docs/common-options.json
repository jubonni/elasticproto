{
    "meta": {
        "timestamp": "2024-11-01T02:49:24.675077",
        "size": 13044,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "common-options",
        "version": "8.15"
    },
    "doc": "[[common-options]]\n== Common options\n\nAll {es} REST APIs support the following options.\n\n[discrete]\n=== Pretty Results\n\nWhen appending `?pretty=true` to any request made, the JSON returned\nwill be pretty formatted (use it for debugging only!). Another option is\nto set `?format=yaml` which will cause the result to be returned in the\n(sometimes) more readable yaml format.\n\n\n[discrete]\n=== Human readable output\n\nStatistics are returned in a format suitable for humans\n(e.g. `\"exists_time\": \"1h\"` or `\"size\": \"1kb\"`) and for computers\n(e.g. `\"exists_time_in_millis\": 3600000` or `\"size_in_bytes\": 1024`).\nThe human readable values can be turned off by adding `?human=false`\nto the query string. This makes sense when the stats results are\nbeing consumed by a monitoring tool, rather than intended for human\nconsumption. The default for the `human` flag is\n`false`.\n\n[[date-math]]\n[discrete]\n=== Date Math\n\nMost parameters which accept a formatted date value -- such as `gt` and `lt`\nin <<query-dsl-range-query,`range` queries>>, or `from` and `to`\nin <<search-aggregations-bucket-daterange-aggregation,`daterange`\naggregations>> -- understand date maths.\n\nThe expression starts with an anchor date, which can either be `now`, or a\ndate string ending with `||`. This anchor date can optionally be followed by\none or more maths expressions:\n\n* `+1h`: Add one hour\n* `-1d`: Subtract one day\n* `/d`: Round down to the nearest day\n\nThe supported time units differ from those supported by <<time-units, time units>> for durations.\nThe supported units are:\n\n[horizontal]\n`y`:: Years\n`M`:: Months\n`w`:: Weeks\n`d`:: Days\n`h`:: Hours\n`H`:: Hours\n`m`:: Minutes\n`s`:: Seconds\n\nAssuming `now` is `2001-01-01 12:00:00`, some examples are:\n\n[horizontal]\n`now+1h`:: `now` in milliseconds plus one hour. Resolves to: `2001-01-01 13:00:00`\n`now-1h`:: `now` in milliseconds minus one hour. Resolves to: `2001-01-01 11:00:00`\n`now-1h/d`:: `now` in milliseconds minus one hour, rounded down to UTC 00:00. Resolves to: `2001-01-01 00:00:00`\n `2001.02.01\\|\\|+1M/d`:: `2001-02-01` in milliseconds plus one month. Resolves to: `2001-03-01 00:00:00`\n\n[discrete]\n[[common-options-response-filtering]]\n=== Response Filtering\n\nAll REST APIs accept a `filter_path` parameter that can be used to reduce\nthe response returned by Elasticsearch. This parameter takes a comma\nseparated list of filters expressed with the dot notation:\n\n[source,console]\n--------------------------------------------------\nGET /_search?q=kimchy&filter_path=took,hits.hits._id,hits.hits._score\n--------------------------------------------------\n// TEST[setup:my_index]\n\nResponds:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"took\" : 3,\n  \"hits\" : {\n    \"hits\" : [\n      {\n        \"_id\" : \"0\",\n        \"_score\" : 1.6375021\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\" : 3/\"took\" : $body.took/]\n// TESTRESPONSE[s/1.6375021/$body.hits.hits.0._score/]\n\nIt also supports the `*` wildcard character to match any field or part\nof a field's name:\n\n[source,console]\n--------------------------------------------------\nGET /_cluster/state?filter_path=metadata.indices.*.stat*\n--------------------------------------------------\n// TEST[s/^/PUT my-index-000001\\n/]\n\nResponds:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"metadata\" : {\n    \"indices\" : {\n      \"my-index-000001\": {\"state\": \"open\"}\n    }\n  }\n}\n--------------------------------------------------\n\nAnd the `**` wildcard can be used to include fields without knowing the\nexact path of the field. For example, we can return the state\nof every shard with this request:\n\n[source,console]\n--------------------------------------------------\nGET /_cluster/state?filter_path=routing_table.indices.**.state\n--------------------------------------------------\n// TEST[s/^/PUT my-index-000001\\n/]\n\nResponds:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"routing_table\": {\n    \"indices\": {\n      \"my-index-000001\": {\n        \"shards\": {\n          \"0\": [{\"state\": \"STARTED\"}, {\"state\": \"UNASSIGNED\"}]\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nIt is also possible to exclude one or more fields by prefixing the filter with the char `-`:\n\n[source,console]\n--------------------------------------------------\nGET /_count?filter_path=-_shards\n--------------------------------------------------\n// TEST[setup:my_index]\n\nResponds:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"count\" : 5\n}\n--------------------------------------------------\n\nAnd for more control, both inclusive and exclusive filters can be combined in the same expression. In\nthis case, the exclusive filters will be applied first and the result will be filtered again using the\ninclusive filters:\n\n[source,console]\n--------------------------------------------------\nGET /_cluster/state?filter_path=metadata.indices.*.state,-metadata.indices.logstash-*\n--------------------------------------------------\n// TEST[s/^/PUT my-index-000001\\nPUT my-index-000002\\nPUT my-index-000003\\nPUT logstash-2016.01\\n/]\n\nResponds:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"metadata\" : {\n    \"indices\" : {\n      \"my-index-000001\" : {\"state\" : \"open\"},\n      \"my-index-000002\" : {\"state\" : \"open\"},\n      \"my-index-000003\" : {\"state\" : \"open\"}\n    }\n  }\n}\n--------------------------------------------------\n\nNote that Elasticsearch sometimes returns directly the raw value of a field,\nlike the `_source` field. If you want to filter `_source` fields, you should\nconsider combining the already existing `_source` parameter (see\n<<get-source-filtering,Get API>> for more details) with the `filter_path`\nparameter like this:\n\n[source,console]\n--------------------------------------------------\nPOST /library/_doc?refresh\n{\"title\": \"Book #1\", \"rating\": 200.1}\nPOST /library/_doc?refresh\n{\"title\": \"Book #2\", \"rating\": 1.7}\nPOST /library/_doc?refresh\n{\"title\": \"Book #3\", \"rating\": 0.1}\nGET /_search?filter_path=hits.hits._source&_source=title&sort=rating:desc\n--------------------------------------------------\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"hits\" : {\n    \"hits\" : [ {\n      \"_source\":{\"title\":\"Book #1\"}\n    }, {\n      \"_source\":{\"title\":\"Book #2\"}\n    }, {\n      \"_source\":{\"title\":\"Book #3\"}\n    } ]\n  }\n}\n--------------------------------------------------\n\n\n[discrete]\n=== Flat Settings\n\nThe `flat_settings` flag affects rendering of the lists of settings. When the\n`flat_settings` flag is `true`, settings are returned in a flat format:\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_settings?flat_settings=true\n--------------------------------------------------\n// TEST[setup:my_index]\n\nReturns:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"my-index-000001\" : {\n    \"settings\": {\n      \"index.number_of_replicas\": \"1\",\n      \"index.number_of_shards\": \"1\",\n      \"index.creation_date\": \"1474389951325\",\n      \"index.uuid\": \"n6gzFZTgS664GUfx0Xrpjw\",\n      \"index.version.created\": ...,\n      \"index.routing.allocation.include._tier_preference\" : \"data_content\",\n      \"index.provided_name\" : \"my-index-000001\"\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/1474389951325/$body.my-index-000001.settings.index\\\\\\\\.creation_date/]\n// TESTRESPONSE[s/n6gzFZTgS664GUfx0Xrpjw/$body.my-index-000001.settings.index\\\\\\\\.uuid/]\n// TESTRESPONSE[s/\"index.version.created\": \\.\\.\\./\"index.version.created\": $body.my-index-000001.settings.index\\\\\\\\.version\\\\\\\\.created/]\n\nWhen the `flat_settings` flag is `false`, settings are returned in a more\nhuman readable structured format:\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_settings?flat_settings=false\n--------------------------------------------------\n// TEST[setup:my_index]\n\nReturns:\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"my-index-000001\" : {\n    \"settings\" : {\n      \"index\" : {\n        \"number_of_replicas\": \"1\",\n        \"number_of_shards\": \"1\",\n        \"creation_date\": \"1474389951325\",\n        \"uuid\": \"n6gzFZTgS664GUfx0Xrpjw\",\n        \"version\": {\n          \"created\": ...\n        },\n        \"routing\": {\n          \"allocation\": {\n            \"include\": {\n              \"_tier_preference\": \"data_content\"\n            }\n          }\n        },\n        \"provided_name\" : \"my-index-000001\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/1474389951325/$body.my-index-000001.settings.index.creation_date/]\n// TESTRESPONSE[s/n6gzFZTgS664GUfx0Xrpjw/$body.my-index-000001.settings.index.uuid/]\n// TESTRESPONSE[s/\"created\": \\.\\.\\./\"created\": $body.my-index-000001.settings.index.version.created/]\n\nBy default `flat_settings` is set to `false`.\n\n[[fuzziness]]\n[discrete]\n=== Fuzziness\n\nSome queries and APIs support parameters to allow inexact _fuzzy_ matching,\nusing the `fuzziness` parameter.\n\nWhen querying `text` or `keyword` fields, `fuzziness` is interpreted as a\n{wikipedia}/Levenshtein_distance[Levenshtein Edit Distance]\n-- the number of one character changes that need to be made to one string to\nmake it the same as another string.\n\nThe `fuzziness` parameter can be specified as:\n\n[horizontal]\n`0`, `1`, `2`::\n\nThe maximum allowed Levenshtein Edit Distance (or number of edits)\n\n`AUTO`::\n+\n--\nGenerates an edit distance based on the length of the term.\nLow and high distance arguments may be optionally provided `AUTO:[low],[high]`. If not specified,\nthe default values are 3 and 6, equivalent to `AUTO:3,6` that make for lengths:\n\n`0..2`:: Must match exactly\n`3..5`:: One edit allowed\n`>5`:: Two edits allowed\n\n`AUTO` should generally be the preferred value for `fuzziness`.\n--\n\n[discrete]\n[[common-options-error-options]]\n=== Enabling stack traces\n\nBy default when a request returns an error Elasticsearch doesn't include the\nstack trace of the error. You can enable that behavior by setting the\n`error_trace` url parameter to `true`. For example, by default when you send an\ninvalid `size` parameter to the `_search` API:\n\n[source,console]\n----------------------------------------------------------------------\nPOST /my-index-000001/_search?size=surprise_me\n----------------------------------------------------------------------\n// TEST[s/surprise_me/surprise_me&error_trace=false/ catch:bad_request]\n// Since the test system sends error_trace=true by default we have to override\n\nThe response looks like:\n\n[source,console-result]\n----------------------------------------------------------------------\n{\n  \"error\" : {\n    \"root_cause\" : [\n      {\n        \"type\" : \"illegal_argument_exception\",\n        \"reason\" : \"Failed to parse int parameter [size] with value [surprise_me]\"\n      }\n    ],\n    \"type\" : \"illegal_argument_exception\",\n    \"reason\" : \"Failed to parse int parameter [size] with value [surprise_me]\",\n    \"caused_by\" : {\n      \"type\" : \"number_format_exception\",\n      \"reason\" : \"For input string: \\\"surprise_me\\\"\"\n    }\n  },\n  \"status\" : 400\n}\n----------------------------------------------------------------------\n\nBut if you set `error_trace=true`:\n\n[source,console]\n----------------------------------------------------------------------\nPOST /my-index-000001/_search?size=surprise_me&error_trace=true\n----------------------------------------------------------------------\n// TEST[catch:bad_request]\n\nThe response looks like:\n\n[source,console-result]\n----------------------------------------------------------------------\n{\n  \"error\": {\n    \"root_cause\": [\n      {\n        \"type\": \"illegal_argument_exception\",\n        \"reason\": \"Failed to parse int parameter [size] with value [surprise_me]\",\n        \"stack_trace\": \"Failed to parse int parameter [size] with value [surprise_me]]; nested: IllegalArgumentException...\"\n      }\n    ],\n    \"type\": \"illegal_argument_exception\",\n    \"reason\": \"Failed to parse int parameter [size] with value [surprise_me]\",\n    \"stack_trace\": \"java.lang.IllegalArgumentException: Failed to parse int parameter [size] with value [surprise_me]\\n    at org.elasticsearch.rest.RestRequest.paramAsInt(RestRequest.java:175)...\",\n    \"caused_by\": {\n      \"type\": \"number_format_exception\",\n      \"reason\": \"For input string: \\\"surprise_me\\\"\",\n      \"stack_trace\": \"java.lang.NumberFormatException: For input string: \\\"surprise_me\\\"\\n    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)...\"\n    }\n  },\n  \"status\": 400\n}\n----------------------------------------------------------------------\n// TESTRESPONSE[s/\"stack_trace\": \"Failed to parse int parameter.+\\.\\.\\.\"/\"stack_trace\": $body.error.root_cause.0.stack_trace/]\n// TESTRESPONSE[s/\"stack_trace\": \"java.lang.IllegalArgum.+\\.\\.\\.\"/\"stack_trace\": $body.error.stack_trace/]\n// TESTRESPONSE[s/\"stack_trace\": \"java.lang.Number.+\\.\\.\\.\"/\"stack_trace\": $body.error.caused_by.stack_trace/]\n"
}