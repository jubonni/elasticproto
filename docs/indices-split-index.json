{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.596581",
        "size": 9748,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-split-index.html",
        "type": "documentation",
        "role": [
            "child_attributes"
        ],
        "has_code": true,
        "title": "indices-split-index",
        "version": "8.15"
    },
    "doc": "[[indices-split-index]]\n=== Split index API\n++++\n<titleabbrev>Split index</titleabbrev>\n++++\n\nSplits an existing index into a new index with more primary shards.\n\n[source,console]\n----\nPOST /my-index-000001/_split/split-my-index-000001\n{\n  \"settings\": {\n    \"index.number_of_shards\": 2\n  }\n}\n----\n// TEST[s/^/PUT my-index-000001\\n{\"settings\":{\"blocks.write\":true}}\\n/]\n\n\n[[split-index-api-request]]\n==== {api-request-title}\n\n`POST /<index>/_split/<target-index>`\n\n`PUT /<index>/_split/<target-index>`\n\n\n[[split-index-api-prereqs]]\n==== {api-prereq-title}\n\n* If the {es} {security-features} are enabled, you must have the `manage`\n<<privileges-list-indices,index privilege>> for the index.\n\n* Before you can split an index:\n\n** The index must be read-only.\n** The <<cluster-health, cluster health>> status must be green.\n\nYou can do make an index read-only with the following request using the\n<<add-index-block,add index block>> API:\n\n[source,console]\n--------------------------------------------------\nPUT /my_source_index/_block/write\n--------------------------------------------------\n// TEST[s/^/PUT my_source_index\\n/]\n\nThe current write index on a data stream cannot be split. In order to split\nthe current write index, the data stream must first be\n<<data-streams-rollover,rolled over>> so that a new write index is created\nand then the previous write index can be split.\n\n[[split-index-api-desc]]\n==== {api-description-title}\n\nThe split index API allows you to split an existing index into a new index,\nwhere each original primary shard is split into two or more primary shards in\nthe new index.\n\nThe number of times the index can be split (and the number of shards that each\noriginal shard can be split into) is determined by the\n`index.number_of_routing_shards` setting. The number of routing shards\nspecifies the hashing space that is used internally to distribute documents\nacross shards with consistent hashing. For instance, a 5 shard index with\n`number_of_routing_shards` set to `30` (`5 x 2 x 3`) could be split by a\nfactor of `2` or `3`. In other words, it could be split as follows:\n\n* `5` -> `10` -> `30`  (split by 2, then by 3)\n* `5` -> `15` -> `30` (split by 3, then by 2)\n* `5` -> `30` (split by 6)\n\n`index.number_of_routing_shards` is a <<index-modules-settings,static index\nsetting>>. You can only set `index.number_of_routing_shards` at index creation\ntime or on a <<indices-open-close,closed index>>.\n\n.*Index creation example*\n[%collapsible]\n====\nThe following <<indices-create-index,create index API>> creates the\n`my-index-000001` index with an `index.number_of_routing_shards` setting of `30`.\n\n[source,console]\n----\nPUT /my-index-000001\n{\n  \"settings\": {\n    \"index\": {\n      \"number_of_routing_shards\": 30\n    }\n  }\n}\n----\n// TEST[continued]\n====\n\nThe `index.number_of_routing_shards` setting's default value depends \non the number of primary shards in the original index.\nThe default is designed to allow you to split\nby factors of 2 up to a maximum of 1024 shards. However, the original number\nof primary shards must taken into account. For instance, an index created\nwith 5 primary shards could be split into 10, 20, 40, 80, 160, 320, or a\nmaximum of 640 shards (with a single split action or multiple split actions).\n\nIf the original index contains one primary shard (or a multi-shard index has\nbeen <<indices-shrink-index,shrunk>> down to a single primary shard), then the\nindex may by split into an arbitrary number of shards greater than 1. The\nproperties of the default number of routing shards will then apply to the\nnewly split index.\n\n\n[[how-split-works]]\n===== How splitting works\n\nA split operation:\n\n. Creates a new target index with the same definition as the source\n  index, but with a larger number of primary shards.\n\n. Hard-links segments from the source index into the target index. (If\n  the file system doesn't support hard-linking, then all segments are copied\n  into the new index, which is a much more time consuming process.)\n\n. Hashes all documents again, after low level files are created, to delete\n  documents that belong to a different shard.\n\n. Recovers the target index as though it were a closed index which\n  had just been re-opened.\n\n\n[[incremental-resharding]]\n===== Why doesn't Elasticsearch support incremental resharding?\n\nGoing from `N` shards to `N+1` shards, aka. incremental resharding, is indeed a\nfeature that is supported by many key-value stores. Adding a new shard and\npushing new data to this new shard only is not an option: this would likely be\nan indexing bottleneck, and figuring out which shard a document belongs to\ngiven its `_id`, which is necessary for get, delete and update requests, would\nbecome quite complex. This means that we need to rebalance existing data using\na different hashing scheme.\n\nThe most common way that key-value stores do this efficiently is by using\nconsistent hashing. Consistent hashing only requires `1/N`-th of the keys to\nbe relocated when growing the number of shards from `N` to `N+1`. However\nElasticsearch's unit of storage, shards, are Lucene indices. Because of their\nsearch-oriented data structure, taking a significant portion of a Lucene index,\nbe it only 5% of documents, deleting them and indexing them on another shard\ntypically comes with a much higher cost than with a key-value store. This cost\nis kept reasonable when growing the number of shards by a multiplicative factor\nas described in the above section: this allows Elasticsearch to perform the\nsplit locally, which in-turn allows to perform the split at the index level\nrather than reindexing documents that need to move, as well as using hard links\nfor efficient file copying.\n\nIn the case of append-only data, it is possible to get more flexibility by\ncreating a new index and pushing new data to it, while adding an alias that\ncovers both the old and the new index for read operations. Assuming that the\nold and new indices have respectively +M+ and +N+ shards, this has no overhead\ncompared to searching an index that would have +M+N+ shards.\n\n\n[[split-index]]\n===== Split an index\n\nTo split `my_source_index` into a new index called `my_target_index`, issue\nthe following request:\n\n[source,console]\n--------------------------------------------------\nPOST /my_source_index/_split/my_target_index\n{\n  \"settings\": {\n    \"index.number_of_shards\": 2\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nThe above request returns immediately once the target index has been added to\nthe cluster state -- it doesn't wait for the split operation to start.\n\n[IMPORTANT]\n=====================================\n\nIndices can only be split if they satisfy the following requirements:\n\n* The target index must not exist\n\n* The source index must have fewer primary shards than the target index.\n\n* The number of primary shards in the target index must be a multiple of the\n  number of primary shards in the source index.\n\n* The node handling the split process must have sufficient free disk space to\n  accommodate a second copy of the existing index.\n\n=====================================\n\nThe `_split` API is similar to the <<indices-create-index, `create index` API>>\nand accepts `settings` and `aliases` parameters for the target index:\n\n[source,console]\n--------------------------------------------------\nPOST /my_source_index/_split/my_target_index\n{\n  \"settings\": {\n    \"index.number_of_shards\": 5 <1>\n  },\n  \"aliases\": {\n    \"my_search_indices\": {}\n  }\n}\n--------------------------------------------------\n// TEST[s/^/PUT my_source_index\\n{\"settings\": {\"index.blocks.write\": true, \"index.number_of_shards\": \"1\"}}\\n/]\n\n<1> The number of shards in the target index. This must be a multiple of the\n    number of shards in the source index.\n\n\nNOTE: Mappings may not be specified in the `_split` request.\n\n\n[[monitor-split]]\n===== Monitor the split process\n\nThe split process can be monitored with the <<cat-recovery,`_cat recovery`\nAPI>>, or the <<cluster-health, `cluster health` API>> can be used to wait\nuntil all primary shards have been allocated by setting the  `wait_for_status`\nparameter to `yellow`.\n\nThe `_split` API returns as soon as the target index has been added to the\ncluster state, before any shards have been allocated. At this point, all\nshards are in the state `unassigned`. If, for any reason, the target index\ncan't be allocated, its primary shard will remain `unassigned` until it\ncan be allocated on that node.\n\nOnce the primary shard is allocated, it moves to state `initializing`, and the\nsplit process begins. When the split operation completes, the shard will\nbecome `active`. At that point, Elasticsearch will try to allocate any\nreplicas and may decide to relocate the primary shard to another node.\n\n\n[[split-wait-active-shards]]\n===== Wait for active shards\n\nBecause the split operation creates a new index to split the shards to,\nthe <<create-index-wait-for-active-shards,wait for active shards>> setting\non index creation applies to the split index action as well.\n\n\n[[split-index-api-path-params]]\n==== {api-path-parms-title}\n\n`<index>`::\n(Required, string)\nName of the source index to split.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=target-index]\n\n\n[[split-index-api-query-params]]\n==== {api-query-parms-title}\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=wait_for_active_shards]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=timeoutparms]\n\n[role=\"child_attributes\"]\n[[split-index-api-request-body]]\n==== {api-request-body-title}\n\n`aliases`::\n(Optional, object of objects) Aliases for the resulting index.\n+\ninclude::{es-ref-dir}/indices/create-index.asciidoc[tag=aliases-props]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=target-index-settings]\n"
}