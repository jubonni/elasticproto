{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.924070",
        "size": 15768,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/phrase-suggester.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "phrase-suggester",
        "version": "8.15"
    },
    "doc": "[[phrase-suggester]]\n==== Phrase Suggester\n\nThe `term` suggester provides a very convenient API to access word\nalternatives on a per token basis within a certain string distance. The API\nallows accessing each token in the stream individually while\nsuggest-selection is left to the API consumer. Yet, often pre-selected\nsuggestions are required in order to present to the end-user. The\n`phrase` suggester adds additional logic on top of the `term` suggester\nto select entire corrected phrases instead of individual tokens weighted\nbased on `ngram-language` models. In practice this suggester will be\nable to make better decisions about which tokens to pick based on\nco-occurrence and frequencies.\n\n===== API Example\n\nIn general the `phrase` suggester requires special mapping up front to work.\nThe `phrase` suggester examples on this page need the following mapping to\nwork. The `reverse` analyzer is used only in the last example.\n\n[source,console]\n--------------------------------------------------\nPUT test\n{\n  \"settings\": {\n    \"index\": {\n      \"number_of_shards\": 1,\n      \"analysis\": {\n        \"analyzer\": {\n          \"trigram\": {\n            \"type\": \"custom\",\n            \"tokenizer\": \"standard\",\n            \"filter\": [\"lowercase\",\"shingle\"]\n          },\n          \"reverse\": {\n            \"type\": \"custom\",\n            \"tokenizer\": \"standard\",\n            \"filter\": [\"lowercase\",\"reverse\"]\n          }\n        },\n        \"filter\": {\n          \"shingle\": {\n            \"type\": \"shingle\",\n            \"min_shingle_size\": 2,\n            \"max_shingle_size\": 3\n          }\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"title\": {\n        \"type\": \"text\",\n        \"fields\": {\n          \"trigram\": {\n            \"type\": \"text\",\n            \"analyzer\": \"trigram\"\n          },\n          \"reverse\": {\n            \"type\": \"text\",\n            \"analyzer\": \"reverse\"\n          }\n        }\n      }\n    }\n  }\n}\nPOST test/_doc?refresh=true\n{\"title\": \"noble warriors\"}\nPOST test/_doc?refresh=true\n{\"title\": \"nobel prize\"}\n--------------------------------------------------\n// TESTSETUP\n\nOnce you have the analyzers and mappings set up you can use the `phrase`\nsuggester in the same spot you'd use the `term` suggester:\n\n[source,console]\n--------------------------------------------------\nPOST test/_search\n{\n  \"suggest\": {\n    \"text\": \"noble prize\",\n    \"simple_phrase\": {\n      \"phrase\": {\n        \"field\": \"title.trigram\",\n        \"size\": 1,\n        \"gram_size\": 3,\n        \"direct_generator\": [ {\n          \"field\": \"title.trigram\",\n          \"suggest_mode\": \"always\"\n        } ],\n        \"highlight\": {\n          \"pre_tag\": \"<em>\",\n          \"post_tag\": \"</em>\"\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThe response contains suggestions scored by the most likely spelling correction first. In this case we received the expected correction \"nobel prize\".\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"_shards\": ...\n  \"hits\": ...\n  \"timed_out\": false,\n  \"took\": 3,\n  \"suggest\": {\n    \"simple_phrase\" : [\n      {\n        \"text\" : \"noble prize\",\n        \"offset\" : 0,\n        \"length\" : 11,\n        \"options\" : [ {\n          \"text\" : \"nobel prize\",\n          \"highlighted\": \"<em>nobel</em> prize\",\n          \"score\" : 0.48614594\n        }]\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"_shards\": .../\"_shards\": \"$body._shards\",/]\n// TESTRESPONSE[s/\"hits\": .../\"hits\": \"$body.hits\",/]\n// TESTRESPONSE[s/\"took\": 3,/\"took\": \"$body.took\",/]\n\n===== Basic Phrase suggest API parameters\n\n[horizontal]\n`field`::\n    The name of the field used to do n-gram lookups for the\n    language model, the suggester will use this field to gain statistics to\n    score corrections. This field is mandatory.\n\n`gram_size`::\n    Sets max size of the n-grams (shingles) in the `field`.\n    If the field doesn't contain n-grams (shingles), this should be omitted\n    or set to `1`. Note that Elasticsearch tries to detect the gram size\n    based on the specified `field`. If the field uses a `shingle` filter, the\n    `gram_size` is set to the `max_shingle_size` if not explicitly set.\n\n`real_word_error_likelihood`::\n    The likelihood of a term being\n    misspelled even if the term exists in the dictionary. The default is\n    `0.95`, meaning 5% of the real words are misspelled.\n\n\n`confidence`::\n    The confidence level defines a factor applied to the\n    input phrases score which is used as a threshold for other suggest\n    candidates. Only candidates that score higher than the threshold will be\n    included in the result. For instance a confidence level of `1.0` will\n    only return suggestions that score higher than the input phrase. If set\n    to `0.0` the top N candidates are returned. The default is `1.0`.\n\n`max_errors`::\n    The maximum percentage of the terms \n    considered to be misspellings in order to form a correction. This method\n    accepts a float value in the range `[0..1)` as a fraction of the actual\n    query terms or a number `>=1` as an absolute number of query terms. The\n    default is set to `1.0`, meaning only corrections with\n    at most one misspelled term are returned. Note that setting this too high\n    can negatively impact performance. Low values like `1` or `2` are recommended;\n    otherwise the time spend in suggest calls might exceed the time spend in\n    query execution.\n\n`separator`::\n    The separator that is used to separate terms in the\n    bigram field. If not set the whitespace character is used as a\n    separator.\n\n`size`::\n    The number of candidates that are generated for each\n    individual query term. Low numbers like `3` or `5` typically produce good\n    results. Raising this can bring up terms with higher edit distances. The\n    default is `5`.\n\n`analyzer`::\n    Sets the analyzer to analyze to suggest text with.\n    Defaults to the search analyzer of the suggest field passed via `field`.\n\n`shard_size`::\n    Sets the maximum number of suggested terms to be\n    retrieved from each individual shard. During the reduce phase, only the\n    top N suggestions are returned based on the `size` option. Defaults to\n    `5`.\n\n`text`::\n    Sets the text / query to provide suggestions for.\n\n`highlight`::\n    Sets up suggestion highlighting. If not provided then\n    no `highlighted` field is returned. If provided must\n    contain exactly `pre_tag` and `post_tag`, which are\n    wrapped around the changed tokens. If multiple tokens\n    in a row are changed the entire phrase of changed tokens\n    is wrapped rather than each token.\n\n`collate`::\n    Checks each suggestion against the specified `query` to prune suggestions\n    for which no matching docs exist in the index. The collate query for a\n    suggestion is run only on the local shard from which the suggestion has\n    been generated from. The `query` must be specified and it can be templated.\n    See <<search-template>>.\n    The current suggestion is automatically made available as the `{{suggestion}}`\n    variable, which should be used in your query. You can still specify\n    your own template `params` -- the `suggestion` value will be added to the\n    variables you specify. Additionally, you can specify a `prune` to control\n    if all phrase suggestions will be returned; when set to `true` the suggestions\n    will have an additional option `collate_match`, which will be `true` if\n    matching documents for the phrase was found, `false` otherwise.\n    The default value for `prune` is `false`.\n\n[source,console]\n--------------------------------------------------\nPOST test/_search\n{\n  \"suggest\": {\n    \"text\" : \"noble prize\",\n    \"simple_phrase\" : {\n      \"phrase\" : {\n        \"field\" :  \"title.trigram\",\n        \"size\" :   1,\n        \"direct_generator\" : [ {\n          \"field\" :            \"title.trigram\",\n          \"suggest_mode\" :     \"always\",\n          \"min_word_length\" :  1\n        } ],\n        \"collate\": {\n          \"query\": { <1>\n            \"source\" : {\n              \"match\": {\n                \"{{field_name}}\" : \"{{suggestion}}\" <2>\n              }\n            }\n          },\n          \"params\": {\"field_name\" : \"title\"}, <3>\n          \"prune\": true <4>\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> This query will be run once for every suggestion.\n<2> The `{{suggestion}}` variable will be replaced by the text\n    of each suggestion.\n<3> An additional `field_name` variable has been specified in\n    `params` and is used by the `match` query.\n<4> All suggestions will be returned with an extra `collate_match`\n    option indicating whether the generated phrase matched any\n    document.\n\n===== Smoothing Models\n\nThe `phrase` suggester supports multiple smoothing models to balance\nweight between infrequent grams (grams (shingles) are not existing in\nthe index) and frequent grams (appear at least once in the index). The\nsmoothing model can be selected by setting the `smoothing` parameter\nto one of the following options. Each smoothing model supports specific\nproperties that can be configured.\n\n[horizontal]\n`stupid_backoff`::\n    A simple backoff model that backs off to lower\n    order n-gram models if the higher order count is `0` and discounts the\n    lower order n-gram model by a constant factor. The default `discount` is\n    `0.4`. Stupid Backoff is the default model.\n\n`laplace`::\n    A smoothing model that uses an additive smoothing where a\n    constant (typically `1.0` or smaller) is added to all counts to balance\n    weights. The default `alpha` is `0.5`.\n\n`linear_interpolation`::\n    A smoothing model that takes the weighted\n    mean of the unigrams, bigrams, and trigrams based on user supplied\n    weights (lambdas). Linear Interpolation doesn't have any default values.\n    All parameters (`trigram_lambda`, `bigram_lambda`, `unigram_lambda`)\n    must be supplied.\n\n[source,console]\n--------------------------------------------------\nPOST test/_search\n{\n  \"suggest\": {\n    \"text\" : \"obel prize\",\n    \"simple_phrase\" : {\n      \"phrase\" : {\n        \"field\" : \"title.trigram\",\n        \"size\" : 1,\n        \"smoothing\" : {\n          \"laplace\" : {\n            \"alpha\" : 0.7\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n===== Candidate Generators\n\nThe `phrase` suggester uses candidate generators to produce a list of\npossible terms per term in the given text. A single candidate generator\nis similar to a `term` suggester called for each individual term in the\ntext. The output of the generators is subsequently scored in combination\nwith the candidates from the other terms for suggestion candidates.\n\nCurrently only one type of candidate generator is supported, the\n`direct_generator`. The Phrase suggest API accepts a list of generators\nunder the key `direct_generator`; each of the generators in the list is\ncalled per term in the original text.\n\n===== Direct Generators\n\nThe direct generators support the following parameters:\n\n[horizontal]\n`field`::\n    The field to fetch the candidate suggestions from. This is\n    a required option that either needs to be set globally or per\n    suggestion.\n\n`size`::\n    The maximum corrections to be returned per suggest text token.\n\n`suggest_mode`::\n    The suggest mode controls what suggestions are included on the suggestions\n    generated on each shard. All values other than `always` can be thought of\n    as an optimization to generate fewer suggestions to test on each shard and\n    are not rechecked when combining the suggestions generated on each\n    shard. Thus `missing` will generate suggestions for terms on shards that do\n    not contain them even if other shards do contain them. Those should be\n    filtered out using `confidence`. Three possible values can be specified:\n    ** `missing`: Only generate suggestions for terms that are not in the\n                 shard. This is the default.\n    ** `popular`: Only suggest terms that occur in more docs on the shard than\n                 the original term.\n    ** `always`: Suggest any matching suggestions based on terms in the\n                 suggest text.\n\n`max_edits`::\n    The maximum edit distance candidate suggestions can have\n    in order to be considered as a suggestion. Can only be a value between 1\n    and 2. Any other value results in a bad request error being thrown.\n    Defaults to 2.\n\n`prefix_length`::\n    The number of minimal prefix characters that must\n    match in order be a candidate suggestions. Defaults to 1. Increasing\n    this number improves spellcheck performance. Usually misspellings don't\n    occur in the beginning of terms.\n\n`min_word_length`::\n    The minimum length a suggest text term must have in\n    order to be included. Defaults to 4.\n\n`max_inspections`::\n    A factor that is used to multiply with the\n    `shard_size` in order to inspect more candidate spelling corrections on\n    the shard level. Can improve accuracy at the cost of performance.\n    Defaults to 5.\n\n`min_doc_freq`::\n    The minimal threshold in number of documents a\n    suggestion should appear in. This can be specified as an absolute number\n    or as a relative percentage of number of documents. This can improve\n    quality by only suggesting high frequency terms. Defaults to 0f and is\n    not enabled. If a value higher than 1 is specified, then the number\n    cannot be fractional. The shard level document frequencies are used for\n    this option.\n\n`max_term_freq`::\n    The maximum threshold in number of documents in which a\n    suggest text token can exist in order to be included. Can be a relative\n    percentage number (e.g., 0.4) or an absolute number to represent document\n    frequencies. If a value higher than 1 is specified, then fractional can\n    not be specified. Defaults to 0.01f. This can be used to exclude high\n    frequency terms -- which are usually spelled correctly -- from being spellchecked. This also improves the spellcheck\n    performance. The shard level document frequencies are used for this\n    option.\n\n`pre_filter`::\n    A filter (analyzer) that is applied to each of the\n    tokens passed to this candidate generator. This filter is applied to the\n    original token before candidates are generated.\n\n`post_filter`::\n    A filter (analyzer) that is applied to each of the\n    generated tokens before they are passed to the actual phrase scorer.\n\nThe following example shows a `phrase` suggest call with two generators:\nthe first one is using a field containing ordinary indexed terms, and the\nsecond one uses a field that uses terms indexed with a `reverse` filter\n(tokens are index in reverse order). This is used to overcome the limitation\nof the direct generators to require a constant prefix to provide\nhigh-performance suggestions. The `pre_filter` and `post_filter` options\naccept ordinary analyzer names.\n\n[source,console]\n--------------------------------------------------\nPOST test/_search\n{\n  \"suggest\": {\n    \"text\" : \"obel prize\",\n    \"simple_phrase\" : {\n      \"phrase\" : {\n        \"field\" : \"title.trigram\",\n        \"size\" : 1,\n        \"direct_generator\" : [ {\n          \"field\" : \"title.trigram\",\n          \"suggest_mode\" : \"always\"\n        }, {\n          \"field\" : \"title.reverse\",\n          \"suggest_mode\" : \"always\",\n          \"pre_filter\" : \"reverse\",\n          \"post_filter\" : \"reverse\"\n        } ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n`pre_filter` and `post_filter` can also be used to inject synonyms after\ncandidates are generated. For instance for the query `captain usq` we\nmight generate a candidate `usa` for the term `usq`, which is a synonym for\n`america`. This allows us to present `captain america` to the user if this\nphrase scores high enough.\n"
}