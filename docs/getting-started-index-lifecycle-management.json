{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.748582",
        "size": 15729,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-index-lifecycle-management.html",
        "type": "documentation",
        "role": [
            "xpack",
            "screenshot",
            "screenshot"
        ],
        "has_code": true,
        "title": "getting-started-index-lifecycle-management",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[getting-started-index-lifecycle-management]]\n== Tutorial: Automate rollover with {ilm-init}\n\n++++\n<titleabbrev>Tutorial: Automate rollover</titleabbrev>\n++++\n\nWhen you continuously index timestamped documents into {es},\nyou typically use a <<data-streams,data stream>> so you can periodically <<index-rollover,roll over>> to a\nnew index.\nThis enables you to implement a <<data-tiers,hot-warm-cold architecture>> to meet your performance\nrequirements for your newest data, control costs over time, enforce retention policies,\nand still get the most out of your data.\n\nTIP: <<data-streams,Data streams>> are best suited for\n<<data-streams-append-only,append-only>> use cases. If you need to update or delete existing time\nseries data, you can perform update or delete operations directly on the data stream backing index.\nIf you frequently send multiple documents using the same `_id` expecting last-write-wins, you may\nwant to use an index alias with a write index instead. You can still use <<index-lifecycle-management,ILM>> to manage and <<index-rollover,roll over>> \nthe alias's indices. Skip to <<manage-time-series-data-without-data-streams>>.\n\n[discrete]\n[[manage-time-series-data-with-data-streams]]\n=== Manage time series data with data streams\n\nTo automate rollover and management of a data stream with {ilm-init}, you:\n\n. <<ilm-gs-create-policy, Create a lifecycle policy>> that defines the appropriate\n<<ilm-index-lifecycle,phases>> and <<ilm-actions,actions>>.\n. <<ilm-gs-apply-policy, Create an index template>> to <<ilm-gs-create-the-data-stream,create the data stream>> and\napply the ILM policy and the indices settings and mappings configurations for the backing\nindices.\n. <<ilm-gs-check-progress, Verify indices are moving through the lifecycle phases>>\nas expected.\n\nIMPORTANT: When you enable {ilm} for {beats} or the {ls} {es} output plugin,\nlifecycle policies are set up automatically.\nYou do not need to take any other actions.\nYou can modify the default policies through\n<<example-using-index-lifecycle-policy,{kib} Management>>\nor the {ilm-init} APIs.\n\n[discrete]\n[[ilm-gs-create-policy]]\n==== Create a lifecycle policy\n\nA lifecycle policy specifies the phases in the index lifecycle\nand the actions to perform in each phase. A lifecycle can have up to five phases:\n`hot`, `warm`, `cold`, `frozen`, and `delete`.\n\nFor example, you might define a `timeseries_policy` that has two phases:\n\n* A `hot` phase that defines a rollover action to specify that an index rolls over when it\nreaches either a `max_primary_shard_size` of 50 gigabytes or a `max_age` of 30 days.\n* A `delete` phase that sets `min_age` to remove the index 90 days after rollover.\n\n[NOTE]\n====\nThe `min_age` value is relative to the rollover time, not the index creation time. <<min-age-calculation,Learn more>>.\n====\n\nYou can create the policy through {kib} or with the\n<<ilm-put-lifecycle,create or update policy>> API.\nTo create the policy from {kib}, open the menu and go to *Stack Management >\nIndex Lifecycle Policies*. Click *Create policy*.\n\n[role=\"screenshot\"]\nimage::images/ilm/create-policy.png[Create policy page]\n\n.API example\n[%collapsible]\n====\n[source,console]\n------------------------\nPUT _ilm/policy/timeseries_policy\n{\n  \"policy\": {\n    \"phases\": {\n      \"hot\": {                                <1>\n        \"actions\": {\n          \"rollover\": {\n            \"max_primary_shard_size\": \"50GB\", <2>\n            \"max_age\": \"30d\"\n          }\n        }\n      },\n      \"delete\": {\n        \"min_age\": \"90d\",                     <3>\n        \"actions\": {\n          \"delete\": {}                        <4>\n        }\n      }\n    }\n  }\n}\n------------------------\n<1> The `min_age` defaults to `0ms`, so new indices enter the `hot` phase immediately.\n<2> Trigger the `rollover` action when either of the conditions are met.\n<3> Move the index into the `delete` phase 90 days after rollover.\n<4> Trigger the `delete` action when the index enters the delete phase.\n====\n\n[discrete]\n[[ilm-gs-apply-policy]]\n==== Create an index template to create the data stream and apply the lifecycle policy\n\nTo set up a data stream, first create an index template to specify the lifecycle policy. Because\nthe template is for a data stream, it must also include a `data_stream` definition.\n\nFor example, you might create a `timeseries_template` to use for a future data stream\nnamed `timeseries`.\n\nTo enable the {ilm-init} to manage the data stream, the template configures one {ilm-init} setting:\n\n* `index.lifecycle.name` specifies the name of the lifecycle policy to apply to the data stream.\n\nYou can use the {kib} Create template wizard to add the template. From Kibana,\nopen the menu and go to *Stack Management > Index Management*. In the *Index\nTemplates* tab, click *Create template*.\n\nimage::images/data-streams/create-index-template.png[Create template page]\n\nThis wizard invokes the <<indices-put-template,create or update index template\nAPI>> to create the index template with the options you specify.\n\n.API example\n[%collapsible]\n====\n[source,console]\n-----------------------\nPUT _index_template/timeseries_template\n{\n  \"index_patterns\": [\"timeseries\"],                   <1>\n  \"data_stream\": { },\n  \"template\": {\n    \"settings\": {\n      \"number_of_shards\": 1,\n      \"number_of_replicas\": 1,\n      \"index.lifecycle.name\": \"timeseries_policy\"     <2>\n    }\n  }\n}\n-----------------------\n// TEST[continued]\n\n<1> Apply the template when a document is indexed into the `timeseries` target.\n<2> The name of the {ilm-init} policy used to manage the data stream.\n====\n\n[discrete]\n[[ilm-gs-create-the-data-stream]]\n==== Create the data stream\n\nTo get things started, index a document into the name or wildcard pattern defined\nin the `index_patterns` of the <<index-templates,index template>>. As long\nas an existing data stream, index, or index alias does not already use the name, the index\nrequest automatically creates a corresponding data stream with a single backing index.\n{es} automatically indexes the request's documents into this backing index, which also\nacts as the stream's <<data-stream-write-index,write index>>.\n\nFor example, the following request creates the `timeseries` data stream and the\nfirst generation backing index called `.ds-timeseries-2099.03.08-000001`.\n\n[source,console]\n-----------------------\nPOST timeseries/_doc\n{\n  \"message\": \"logged the request\",\n  \"@timestamp\": \"1591890611\"\n}\n\n-----------------------\n// TEST[continued]\n\nWhen a rollover condition in the lifecycle policy is met, the `rollover` action:\n\n* Creates the second generation backing index, named\n`.ds-timeseries-2099.03.08-000002`. Because it is a backing index of the\n`timeseries` data stream, the configuration from the `timeseries_template` index\ntemplate is applied to the new index.\n* As it is the latest generation index of the `timeseries` data stream, the\nnewly created backing index `.ds-timeseries-2099.03.08-000002` becomes the data\nstream's write index.\n\nThis process repeats each time a rollover condition is met.\nYou can search across all of the data stream's backing indices, managed by the `timeseries_policy`,\nwith the `timeseries` data stream name.\nWrite operations should be sent to the data stream name, which will route them to its current write index. \nRead operations against the data stream will be handled by all its backing indices.\n\n[discrete]\n[[ilm-gs-check-progress]]\n==== Check lifecycle progress\n\nTo get status information for managed indices, you use the {ilm-init} explain API.\nThis lets you find out things like:\n\n* What phase an index is in and when it entered that phase.\n* The current action and what step is being performed.\n* If any errors have occurred or progress is blocked.\n\nFor example, the following request gets information about the `timeseries` data stream's\nbacking indices:\n\n[source,console]\n--------------------------------------------------\nGET .ds-timeseries-*/_ilm/explain\n--------------------------------------------------\n// TEST[continued]\n\nThe following response shows the data stream's first generation backing index is waiting for the `hot`\nphase's `rollover` action.\nIt remains in this state and {ilm-init} continues to call `check-rollover-ready` until a rollover condition\nis met.\n\n// [[36818c6d9f434d387819c30bd9addb14]]\n[source,console-result]\n--------------------------------------------------\n{\n  \"indices\": {\n    \".ds-timeseries-2099.03.07-000001\": {\n      \"index\": \".ds-timeseries-2099.03.07-000001\",\n      \"index_creation_date_millis\": 1538475653281,\n      \"time_since_index_creation\": \"30s\",        <1>\n      \"managed\": true,\n      \"policy\": \"timeseries_policy\",             <2>\n      \"lifecycle_date_millis\": 1538475653281,\n      \"age\": \"30s\",                              <3>\n      \"phase\": \"hot\",\n      \"phase_time_millis\": 1538475653317,\n      \"action\": \"rollover\",\n      \"action_time_millis\": 1538475653317,\n      \"step\": \"check-rollover-ready\",            <4>\n      \"step_time_millis\": 1538475653317,\n      \"phase_execution\": {\n        \"policy\": \"timeseries_policy\",\n        \"phase_definition\": {                    <5>\n          \"min_age\": \"0ms\",\n          \"actions\": {\n            \"rollover\": {\n              \"max_primary_shard_size\": \"50gb\",\n              \"max_age\": \"30d\"\n            }\n          }\n        },\n        \"version\": 1,\n        \"modified_date_in_millis\": 1539609701576\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[skip:no way to know if we will get this response immediately]\n\n<1> The age of the index used for calculating when to rollover the index via the `max_age`\n<2> The policy used to manage the index\n<3> The age of the indexed used to transition to the next phase (in this case it is the same with the age of the index).\n<4> The step {ilm-init} is performing on the index\n<5> The definition of the current phase (the `hot` phase)\n\n//////////////////////////\n\n[source,console]\n--------------------------------------------------\nDELETE /_data_stream/timeseries\n--------------------------------------------------\n// TEST[continued]\n\n//////////////////////////\n\n\n//////////////////////////\n\n[source,console]\n--------------------------------------------------\nDELETE /_index_template/timeseries_template\n--------------------------------------------------\n// TEST[continued]\n\n//////////////////////////\n\n[discrete]\n[[manage-time-series-data-without-data-streams]]\n=== Manage time series data without data streams\n\nEven though <<data-streams, data streams>> are a convenient way to scale and manage time series\ndata, they are designed to be append-only. We recognise there might be use-cases where data needs to\nbe updated or deleted in place and the data streams don't support delete and update requests\ndirectly, so the index APIs would need to be used directly on the data stream's backing indices. In\nthese cases we still recommend using a data stream.\n\nIf you frequently send multiple documents using the same `_id` expecting last-write-wins, you can\nuse an index alias instead of a data stream to manage indices containing the time series data and\nperiodically roll over to a new index.\n\nTo automate rollover and management of time series indices with {ilm-init} using an index\nalias, you:\n\n. Create a lifecycle policy that defines the appropriate phases and actions.\nSee <<ilm-gs-create-policy, Create a lifecycle policy>> above.\n. <<ilm-gs-alias-apply-policy, Create an index template>> to apply the policy to each new index.\n. <<ilm-gs-alias-bootstrap, Bootstrap an index>> as the initial write index.\n. <<ilm-gs-alias-check-progress, Verify indices are moving through the lifecycle phases>>\nas expected.\n\n[discrete]\n[[ilm-gs-alias-apply-policy]]\n==== Create an index template to apply the lifecycle policy\n\nTo automatically apply a lifecycle policy to the new write index on rollover,\nspecify the policy in the index template used to create new indices.\n\nFor example, you might create a `timeseries_template` that is applied to new indices\nwhose names match the `timeseries-*` index pattern.\n\nTo enable automatic rollover, the template configures two {ilm-init} settings:\n\n* `index.lifecycle.name` specifies the name of the lifecycle policy to apply to new indices\nthat match the index pattern.\n* `index.lifecycle.rollover_alias` specifies the index alias to be rolled over\nwhen the rollover action is triggered for an index.\n\nYou can use the {kib} Create template wizard to add the template. To access the\nwizard, open the menu and go to *Stack Management > Index Management*. In the\n*Index Templates* tab, click *Create template*.\n\n[role=\"screenshot\"]\nimage:images/ilm/create-template-wizard.png[Create template page]\n\nThe create template request for the example template looks like this:\n\n[source,console]\n-----------------------\nPUT _index_template/timeseries_template\n{\n  \"index_patterns\": [\"timeseries-*\"],                 <1>\n  \"template\": {\n    \"settings\": {\n      \"number_of_shards\": 1,\n      \"number_of_replicas\": 1,\n      \"index.lifecycle.name\": \"timeseries_policy\",      <2>\n      \"index.lifecycle.rollover_alias\": \"timeseries\"    <3>\n    }\n  }\n}\n-----------------------\n// TEST[continued]\n\n<1> Apply the template to a new index if its name starts with `timeseries-`.\n<2> The name of the lifecycle policy to apply to each new index.\n<3> The name of the alias used to reference these indices.\nRequired for policies that use the rollover action.\n\n//////////////////////////\n\n[source,console]\n--------------------------------------------------\nDELETE _index_template/timeseries_template\n--------------------------------------------------\n// TEST[continued]\n\n//////////////////////////\n\n[discrete]\n[[ilm-gs-alias-bootstrap]]\n==== Bootstrap the initial time series index with a write index alias\n\nTo get things started, you need to bootstrap an initial index and\ndesignate it as the write index for the rollover alias specified in your index template.\nThe name of this index must match the template's index pattern and end with a number.\nOn rollover, this value is incremented to generate a name for the new index.\n\nFor example, the following request creates an index called `timeseries-000001`\nand makes it the write index for the `timeseries` alias.\n\n[source,console]\n-----------------------\nPUT timeseries-000001\n{\n  \"aliases\": {\n    \"timeseries\": {\n      \"is_write_index\": true\n    }\n  }\n}\n-----------------------\n// TEST[continued]\n\nWhen the rollover conditions are met, the `rollover` action:\n\n* Creates a new index called `timeseries-000002`.\nThis matches the `timeseries-*` pattern, so the settings from `timeseries_template` are applied to the new index.\n* Designates the new index as the write index and makes the bootstrap index read-only.\n\nThis process repeats each time rollover conditions are met.\nYou can search across all of the indices managed by the `timeseries_policy` with the `timeseries` alias.\nWrite operations should be sent towards the alias, which will route them to its current write index. \n\n[discrete]\n[[ilm-gs-alias-check-progress]]\n==== Check lifecycle progress\n\nRetrieving the status information for managed indices is very similar to the data stream case.\nSee the data stream <<ilm-gs-check-progress, check progress section>> for more information.\nThe only difference is the indices namespace, so retrieving the progress will entail the following\napi call:\n\n[source,console]\n--------------------------------------------------\nGET timeseries-*/_ilm/explain\n--------------------------------------------------\n// TEST[continued]\n\n//////////////////////////\n\n[source,console]\n--------------------------------------------------\nDELETE /timeseries-000001\n--------------------------------------------------\n// TEST[continued]\n//////////////////////////\n"
}