{
    "meta": {
        "timestamp": "2024-11-01T03:07:09.777275",
        "size": 19200,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "modules-node",
        "version": "8.15"
    },
    "doc": "[[modules-node]]\n=== Nodes\n\nAny time that you start an instance of {es}, you are starting a _node_. A\ncollection of connected nodes is called a <<modules-cluster,cluster>>. If you\nare running a single node of {es}, then you have a cluster of one node.\n\nEvery node in the cluster can handle <<modules-network,HTTP and transport>>\ntraffic by default. The transport layer is used exclusively for communication\nbetween nodes; the HTTP layer is used by REST clients.\n[[modules-node-description]]\n// tag::modules-node-description-tag[]\nAll nodes know about all the other nodes in the cluster and can forward client\nrequests to the appropriate node.\n// end::modules-node-description-tag[]\n\nTIP: The performance of an {es} node is often limited by the performance of the underlying storage. \nReview our recommendations for optimizing your storage for <<indexing-use-faster-hardware,indexing>> and \n<<search-use-faster-hardware,search>>.\n\n[[node-roles]]\n==== Node roles\n\nYou define a node's roles by setting `node.roles` in `elasticsearch.yml`. If you\nset `node.roles`, the node is only assigned the roles you specify. If you don't\nset `node.roles`, the node is assigned the following roles:\n\n* `master`\n* `data`\n* `data_content`\n* `data_hot`\n* `data_warm`\n* `data_cold`\n* `data_frozen`\n* `ingest`\n* `ml`\n* `remote_cluster_client`\n* `transform`\n\n[IMPORTANT]\n====\nIf you set `node.roles`, ensure you specify every node role your cluster needs.\nEvery cluster requires the following node roles:\n\n* `master`\n* {blank}\n+\n--\n`data_content` and `data_hot` +\nOR +\n`data`\n--\n\nSome {stack} features also require specific node roles:\n\n- {ccs-cap} and {ccr} require the `remote_cluster_client` role.\n- {stack-monitor-app} and ingest pipelines require the `ingest` role.\n- {fleet}, the {security-app}, and {transforms} require the `transform` role.\n  The `remote_cluster_client` role is also required to use {ccs} with these\n  features.\n- {ml-cap} features, such as {anomaly-detect}, require the `ml` role.\n====\n\nAs the cluster grows and in particular if you have large {ml} jobs or\n{ctransforms}, consider separating dedicated master-eligible nodes from\ndedicated data nodes, {ml} nodes, and {transform} nodes.\n\n<<master-node,Master-eligible node>>::\n\nA node that has the `master` role, which makes it eligible to be\n<<modules-discovery,elected as the _master_ node>>, which controls the cluster.\n\n<<data-node,Data node>>::\n\nA node that has one of several data roles. Data nodes hold data and perform data\nrelated operations such as CRUD, search, and aggregations. A node with a generic `data` role can fill any of the specialized data node roles.\n\n<<node-ingest-node,Ingest node>>::\n\nA node that has the `ingest` role. Ingest nodes are able to apply an\n<<ingest,ingest pipeline>> to a document in order to transform and enrich the\ndocument before indexing. With a heavy ingest load, it makes sense to use\ndedicated ingest nodes and to not include the `ingest` role from nodes that have\nthe `master` or `data` roles.\n\n<<remote-node,Remote-eligible node>>::\n\nA node that has the `remote_cluster_client` role, which makes it eligible to act\nas a remote client.\n\n<<ml-node,Machine learning node>>::\n\nA node that has the `ml` role. If you want to use {ml-features}, there must be\nat least one {ml} node in your cluster. For more information, see\n<<ml-settings>> and {ml-docs}/index.html[Machine learning in the {stack}].\n\n<<transform-node,{transform-cap} node>>::\n\nA node that has the `transform` role. If you want to use {transforms}, there\nmust be at least one {transform} node in your cluster. For more information, see\n<<transform-settings>> and <<transforms>>.\n\n[NOTE]\n[[coordinating-node]]\n.Coordinating node\n===============================================\n\nRequests like search requests or bulk-indexing requests may involve data held\non different data nodes. A search request, for example, is executed in two\nphases which are coordinated by the node which receives the client request --\nthe _coordinating node_.\n\nIn the _scatter_ phase, the coordinating node forwards the request to the data\nnodes which hold the data. Each data node executes the request locally and\nreturns its results to the coordinating node. In the _gather_ phase, the\ncoordinating node reduces each data node's results into a single global\nresult set.\n\nEvery node is implicitly a coordinating node. This means that a node that has\nan explicit empty list of roles via `node.roles` will only act as a coordinating\nnode, which cannot be disabled. As a result, such a node needs to have enough\nmemory and CPU in order to deal with the gather phase.\n\n===============================================\n\n[[master-node]]\n==== Master-eligible node\n\nThe master node is responsible for lightweight cluster-wide actions such as\ncreating or deleting an index, tracking which nodes are part of the cluster,\nand deciding which shards to allocate to which nodes. It is important for\ncluster health to have a stable master node.\n\nAny master-eligible node that is not a <<voting-only-node,voting-only node>> may\nbe elected to become the master node by the <<modules-discovery,master election\nprocess>>.\n\nIMPORTANT: Master nodes must have a `path.data` directory whose contents\npersist across restarts, just like data nodes, because this is where the\ncluster metadata is stored. The cluster metadata describes how to read the data\nstored on the data nodes, so if it is lost then the data stored on the data\nnodes cannot be read.\n\n[[dedicated-master-node]]\n===== Dedicated master-eligible node\n\nIt is important for the health of the cluster that the elected master node has\nthe resources it needs to fulfill its responsibilities. If the elected master\nnode is overloaded with other tasks then the cluster will not operate well. The\nmost reliable way to avoid overloading the master with other tasks is to\nconfigure all the master-eligible nodes to be _dedicated master-eligible nodes_\nwhich only have the `master` role, allowing them to focus on managing the\ncluster. Master-eligible nodes will still also behave as\n<<coordinating-node,coordinating nodes>> that route requests from clients to\nthe other nodes in the cluster, but you should _not_ use dedicated master nodes\nfor this purpose.\n\nA small or lightly-loaded cluster may operate well if its master-eligible nodes\nhave other roles and responsibilities, but once your cluster comprises more\nthan a handful of nodes it usually makes sense to use dedicated master-eligible\nnodes.\n\nTo create a dedicated master-eligible node, set:\n\n[source,yaml]\n-------------------\nnode.roles: [ master ]\n-------------------\n\n[[voting-only-node]]\n===== Voting-only master-eligible node\n\nA voting-only master-eligible node is a node that participates in\n<<modules-discovery,master elections>> but which will not act as the cluster's\nelected master node. In particular, a voting-only node can serve as a tiebreaker\nin elections.\n\nIt may seem confusing to use the term \"master-eligible\" to describe a\nvoting-only node since such a node is not actually eligible to become the master\nat all. This terminology is an unfortunate consequence of history:\nmaster-eligible nodes are those nodes that participate in elections and perform\ncertain tasks during cluster state publications, and voting-only nodes have the\nsame responsibilities even if they can never become the elected master.\n\nTo configure a master-eligible node as a voting-only node, include `master` and\n`voting_only` in the list of roles. For example to create a voting-only data\nnode:\n\n[source,yaml]\n-------------------\nnode.roles: [ data, master, voting_only ]\n-------------------\n\nIMPORTANT: Only nodes with the `master` role can be marked as having the\n`voting_only` role.\n\nHigh availability (HA) clusters require at least three master-eligible nodes, at\nleast two of which are not voting-only nodes. Such a cluster will be able to\nelect a master node even if one of the nodes fails.\n\nVoting-only master-eligible nodes may also fill other roles in your cluster.\nFor instance, a node may be both a data node and a voting-only master-eligible\nnode. A _dedicated_ voting-only master-eligible nodes is a voting-only\nmaster-eligible node that fills no other roles in the cluster. To create a\ndedicated voting-only master-eligible node, set:\n\n[source,yaml]\n-------------------\nnode.roles: [ master, voting_only ]\n-------------------\n\nSince dedicated voting-only nodes never act as the cluster's elected master,\nthey may require less heap and a less powerful CPU than the true master nodes.\nHowever all master-eligible nodes, including voting-only nodes, are on the\ncritical path for <<cluster-state-publishing,publishing cluster state\nupdates>>. Cluster state updates are usually independent of\nperformance-critical workloads such as indexing or searches, but they are\ninvolved in management activities such as index creation and rollover, mapping\nupdates, and recovery after a failure. The performance characteristics of these\nactivities are a function of the speed of the storage on each master-eligible\nnode, as well as the reliability and latency of the network interconnections\nbetween the elected master node and the other nodes in the cluster. You must\ntherefore ensure that the storage and networking available to the nodes in your\ncluster are good enough to meet your performance goals.\n\n[[data-node]]\n==== Data nodes\n\nData nodes hold the shards that contain the documents you have indexed. Data\nnodes handle data related operations like CRUD, search, and aggregations.\nThese operations are I/O-, memory-, and CPU-intensive. It is important to\nmonitor these resources and to add more data nodes if they are overloaded.\n\nThe main benefit of having dedicated data nodes is the separation of the master\nand data roles.\n\nIn a multi-tier deployment architecture, you use specialized data roles to\nassign data nodes to specific tiers: `data_content`,`data_hot`, `data_warm`,\n`data_cold`, or `data_frozen`. A node can belong to multiple tiers. \n\nIf you want to include a node in all tiers, or if your cluster does not use multiple tiers, then you can use the generic `data` role.\n\ninclude::../how-to/shard-limits.asciidoc[]\n\nWARNING: If you assign a node to a specific tier using a specialized data role, then you shouldn't also assign it the generic `data` role. The generic `data` role takes precedence over specialized data roles.\n\n[[generic-data-node]]\n===== Generic data node\n\nGeneric data nodes are included in all content tiers. \n\nTo create a dedicated generic data node, set:\n[source,yaml]\n----\nnode.roles: [ data ]\n----\n\n[[data-content-node]]\n===== Content data node\n\nContent data nodes are part of the content tier.\ninclude::{es-ref-dir}/datatiers.asciidoc[tag=content-tier]\n\nTo create a dedicated content node, set:\n[source,yaml]\n----\nnode.roles: [ data_content ]\n----\n\n[[data-hot-node]]\n===== Hot data node\n\nHot data nodes are part of the hot tier.\ninclude::{es-ref-dir}/datatiers.asciidoc[tag=hot-tier]\n\nTo create a dedicated hot node, set:\n[source,yaml]\n----\nnode.roles: [ data_hot ]\n----\n\n[[data-warm-node]]\n===== Warm data node\n\nWarm data nodes are part of the warm tier.\ninclude::{es-ref-dir}/datatiers.asciidoc[tag=warm-tier]\n\nTo create a dedicated warm node, set:\n[source,yaml]\n----\nnode.roles: [ data_warm ]\n----\n\n[[data-cold-node]]\n===== Cold data node\n\nCold data nodes are part of the cold tier.\ninclude::{es-ref-dir}/datatiers.asciidoc[tag=cold-tier]\n\nTo create a dedicated cold node, set:\n[source,yaml]\n----\nnode.roles: [ data_cold ]\n----\n\n[[data-frozen-node]]\n===== Frozen data node\n\nFrozen data nodes are part of the frozen tier.\ninclude::{es-ref-dir}/datatiers.asciidoc[tag=frozen-tier]\n\nTo create a dedicated frozen node, set:\n[source,yaml]\n----\nnode.roles: [ data_frozen ]\n----\n\n[[node-ingest-node]]\n==== Ingest node\n\nIngest nodes can execute pre-processing pipelines, composed of one or more\ningest processors. Depending on the type of operations performed by the ingest\nprocessors and the required resources, it may make sense to have dedicated\ningest nodes, that will only perform this specific task.\n\nTo create a dedicated ingest node, set:\n\n[source,yaml]\n----\nnode.roles: [ ingest ]\n----\n\n[[coordinating-only-node]]\n==== Coordinating only node\n\nIf you take away the ability to be able to handle master duties, to hold data,\nand pre-process documents, then you are left with a _coordinating_ node that\ncan only route requests, handle the search reduce phase, and distribute bulk\nindexing. Essentially, coordinating only nodes behave as smart load balancers.\n\nCoordinating only nodes can benefit large clusters by offloading the\ncoordinating node role from data and master-eligible nodes. They join the\ncluster and receive the full <<cluster-state,cluster state>>, like every other\nnode, and they use the cluster state to route requests directly to the\nappropriate place(s).\n\nWARNING: Adding too many coordinating only nodes to a cluster can increase the\nburden on the entire cluster because the elected master node must await\nacknowledgement of cluster state updates from every node! The benefit of\ncoordinating only nodes should not be overstated -- data nodes can happily\nserve the same purpose.\n\nTo create a dedicated coordinating node, set:\n\n[source,yaml]\n----\nnode.roles: [ ]\n----\n\n[[remote-node]]\n==== Remote-eligible node\n\nA remote-eligible node acts as a cross-cluster client and connects to\n<<remote-clusters,remote clusters>>. Once connected, you can search\nremote clusters using <<modules-cross-cluster-search,{ccs}>>. You can also sync\ndata between clusters using <<xpack-ccr,{ccr}>>.\n\n[source,yaml]\n----\nnode.roles: [ remote_cluster_client ]\n----\n\n[[ml-node]]\n==== [xpack]#Machine learning node#\n\n{ml-cap} nodes run jobs and handle {ml} API requests. For more information, see\n<<ml-settings>>.\n\nTo create a dedicated {ml} node, set:\n\n[source,yaml]\n----\nnode.roles: [ ml, remote_cluster_client]\n----\n\nThe `remote_cluster_client` role is optional but strongly recommended.\nOtherwise, {ccs} fails when used in {ml} jobs or {dfeeds}. If you use {ccs} in\nyour {anomaly-jobs}, the `remote_cluster_client` role is also required on all\nmaster-eligible nodes. Otherwise, the {dfeed} cannot start. See <<remote-node>>.\n\n[[transform-node]]\n==== [xpack]#{transform-cap} node#\n\n{transform-cap} nodes run {transforms} and handle {transform} API requests. For\nmore information, see <<transform-settings>>.\n\nTo create a dedicated {transform} node, set:\n\n[source,yaml]\n----\nnode.roles: [ transform, remote_cluster_client ]\n----\n\nThe `remote_cluster_client` role is optional but strongly recommended.\nOtherwise, {ccs} fails when used in {transforms}. See <<remote-node>>.\n\n[[change-node-role]]\n==== Changing the role of a node\n\nEach data node maintains the following data on disk:\n\n* the shard data for every shard allocated to that node,\n* the index metadata corresponding with every shard allocated to that node, and\n* the cluster-wide metadata, such as settings and index templates.\n\nSimilarly, each master-eligible node maintains the following data on disk:\n\n* the index metadata for every index in the cluster, and\n* the cluster-wide metadata, such as settings and index templates.\n\nEach node checks the contents of its data path at startup. If it discovers\nunexpected data then it will refuse to start. This is to avoid importing\nunwanted <<dangling-indices,dangling indices>> which can lead\nto a red cluster health. To be more precise, nodes without the `data` role will\nrefuse to start if they find any shard data on disk at startup, and nodes\nwithout both the `master` and `data` roles will refuse to start if they have any\nindex metadata on disk at startup.\n\nIt is possible to change the roles of a node by adjusting its\n`elasticsearch.yml` file and restarting it. This is known as _repurposing_ a\nnode. In order to satisfy the checks for unexpected data described above, you\nmust perform some extra steps to prepare a node for repurposing when starting\nthe node without the `data` or `master` roles.\n\n* If you want to repurpose a data node by removing the `data` role then you\n  should first use an <<cluster-shard-allocation-filtering,allocation filter>> to safely\n  migrate all the shard data onto other nodes in the cluster.\n\n* If you want to repurpose a node to have neither the `data` nor `master` roles\n  then it is simplest to start a brand-new node with an empty data path and the\n  desired roles. You may find it safest to use an\n  <<cluster-shard-allocation-filtering,allocation filter>> to migrate the shard data elsewhere\n  in the cluster first.\n\nIf it is not possible to follow these extra steps then you may be able to use\nthe <<node-tool-repurpose,`elasticsearch-node repurpose`>> tool to delete any\nexcess data that prevents a node from starting.\n\n[discrete]\n=== Node data path settings\n\n[[data-path]]\n==== `path.data`\n\nEvery data and master-eligible node requires access to a data directory where\nshards and index and cluster metadata will be stored. The `path.data` defaults\nto `$ES_HOME/data` but can be configured in the `elasticsearch.yml` config\nfile an absolute path or a path relative to `$ES_HOME` as follows:\n\n[source,yaml]\n----\npath.data:  /var/elasticsearch/data\n----\n\nLike all node settings, it can also be specified on the command line as:\n\n[source,sh]\n----\n./bin/elasticsearch -Epath.data=/var/elasticsearch/data\n----\n\nThe contents of the `path.data` directory must persist across restarts, because\nthis is where your data is stored. {es} requires the filesystem to act as if it\nwere backed by a local disk, but this means that it will work correctly on\nproperly-configured remote block devices (e.g. a SAN) and remote filesystems\n(e.g. NFS) as long as the remote storage behaves no differently from local\nstorage. You can run multiple {es} nodes on the same filesystem, but each {es}\nnode must have its own data path.\n\nTIP: When using the `.zip` or `.tar.gz` distributions, the `path.data` setting\nshould be configured to locate the data directory outside the {es} home\ndirectory, so that the home directory can be deleted without deleting your data!\nThe RPM and Debian distributions do this for you already.\n\n// tag::modules-node-data-path-warning-tag[]\nWARNING: Don't modify anything within the data directory or run processes that\nmight interfere with its contents. If something other than {es} modifies the\ncontents of the data directory, then {es} may fail, reporting corruption or\nother data inconsistencies, or may appear to work correctly having silently\nlost some of your data. Don't attempt to take filesystem backups of the data\ndirectory; there is no supported way to restore such a backup. Instead, use\n<<snapshot-restore>> to take backups safely. Don't run virus scanners on the\ndata directory. A virus scanner can prevent {es} from working correctly and may\nmodify the contents of the data directory. The data directory contains no\nexecutables so a virus scan will only find false positives.\n// end::modules-node-data-path-warning-tag[]\n\n[discrete]\n[[other-node-settings]]\n=== Other node settings\n\nMore node settings can be found in <<settings>> and <<important-settings>>,\nincluding:\n\n* <<cluster-name,`cluster.name`>>\n* <<node-name,`node.name`>>\n* <<modules-network,network settings>>\n"
}