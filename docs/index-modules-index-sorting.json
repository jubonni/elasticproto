{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.774579",
        "size": 6797,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-index-sorting.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "index-modules-index-sorting",
        "version": "8.15"
    },
    "doc": "[[index-modules-index-sorting]]\n== Index Sorting\n\nWhen creating a new index in Elasticsearch it is possible to configure how the Segments\ninside each Shard will be sorted. By default Lucene does not apply any sort.\nThe `index.sort.*` settings define which fields should be used to sort the documents inside each Segment.\n\n[WARNING]\nIt is allowed to apply index sorting to mappings with nested objects, so long as the\n`index.sort.*` setting contains no nested fields.\n\nFor instance the following example shows how to define a sort on a single field:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"settings\": {\n    \"index\": {\n      \"sort.field\": \"date\", <1>\n      \"sort.order\": \"desc\"  <2>\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"date\": {\n        \"type\": \"date\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> This index is sorted by the `date` field\n<2> ... in descending order.\n\nIt is also possible to sort the index by more than one field:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"settings\": {\n    \"index\": {\n      \"sort.field\": [ \"username\", \"date\" ], <1>\n      \"sort.order\": [ \"asc\", \"desc\" ]       <2>\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"username\": {\n        \"type\": \"keyword\",\n        \"doc_values\": true\n      },\n      \"date\": {\n        \"type\": \"date\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> This index is sorted by `username` first then by `date`\n<2> ... in ascending order for the `username` field and in descending order for the `date` field.\n\n\nIndex sorting supports the following settings:\n\n`index.sort.field`::\n\n    The list of fields used to sort the index.\n    Only `boolean`, `numeric`, `date` and `keyword` fields with `doc_values` are allowed here.\n\n`index.sort.order`::\n\n    The sort order to use for each field.\n    The order option can have the following values:\n        * `asc`:  For ascending order\n        * `desc`: For descending order.\n\n`index.sort.mode`::\n\n    Elasticsearch supports sorting by multi-valued fields.\n    The mode option controls what value is picked to sort the document.\n    The mode option can have the following values:\n        * `min`: \tPick the lowest value.\n        * `max`: \tPick the highest value.\n\n`index.sort.missing`::\n\n    The missing parameter specifies how docs which are missing the field should be treated.\n     The missing value can have the following values:\n        * `_last`: Documents without value for the field are sorted last.\n        * `_first`: Documents without value for the field are sorted first.\n\n[WARNING]\nIndex sorting can be defined only once at index creation. It is not allowed to add or update\na sort on an existing index. Index sorting also has a cost in terms of indexing throughput since\ndocuments must be sorted at flush and merge time. You should test the impact on your application\nbefore activating this feature.\n\n[discrete]\n[[early-terminate]]\n=== Early termination of search request\n\nBy default in Elasticsearch a search request must visit every document that matches a query to\nretrieve the top documents sorted by a specified sort.\nThough when the index sort and the search sort are the same it is possible to limit\nthe number of documents that should be visited per segment to retrieve the N top ranked documents globally.\nFor example, let's say we have an index that contains events sorted by a timestamp field:\n\n[source,console]\n--------------------------------------------------\nPUT events\n{\n  \"settings\": {\n    \"index\": {\n      \"sort.field\": \"timestamp\",\n      \"sort.order\": \"desc\" <1>\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"timestamp\": {\n        \"type\": \"date\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> This index is sorted by timestamp in descending order (most recent first)\n\nYou can search for the last 10 events with:\n\n[source,console]\n--------------------------------------------------\nGET /events/_search\n{\n  \"size\": 10,\n  \"sort\": [\n    { \"timestamp\": \"desc\" }\n  ]\n}\n--------------------------------------------------\n// TEST[continued]\n\nElasticsearch will detect that the top docs of each segment are already sorted in the index\nand will only compare the first N documents per segment.\nThe rest of the documents matching the query are collected to count the total number of results\nand to build aggregations.\n\nIf you're only looking for the last 10 events and have no interest in\nthe total number of documents that match the query you can set `track_total_hits`\nto false:\n\n[source,console]\n--------------------------------------------------\nGET /events/_search\n{\n  \"size\": 10,\n  \"sort\": [ <1>\n      { \"timestamp\": \"desc\" }\n  ],\n  \"track_total_hits\": false\n}\n--------------------------------------------------\n// TEST[continued]\n\n<1> The index sort will be used to rank the top documents and each segment will early terminate the collection after the first 10 matches.\n\nThis time, Elasticsearch will not try to count the number of documents and will be able to terminate the query\nas soon as N documents have been collected per segment.\n\n[source,console-result]\n--------------------------------------------------\n{\n  \"_shards\": ...\n   \"hits\" : {  <1>\n      \"max_score\" : null,\n      \"hits\" : []\n  },\n  \"took\": 20,\n  \"timed_out\": false\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"_shards\": \\.\\.\\./\"_shards\": \"$body._shards\",/]\n// TESTRESPONSE[s/\"took\": 20,/\"took\": \"$body.took\",/]\n\n<1> The total number of hits matching the query is unknown because of early termination.\n\nNOTE: Aggregations will collect all documents that match the query regardless\nof the value of `track_total_hits`\n\n[[index-modules-index-sorting-conjunctions]]\n=== Use index sorting to speed up conjunctions\n\nIndex sorting can be useful in order to organize Lucene doc ids (not to be\nconflated with `_id`) in a way that makes conjunctions (a AND b AND ...) more\nefficient. In order to be efficient, conjunctions rely on the fact that if any\nclause does not match, then the entire conjunction does not match. By using\nindex sorting, we can put documents that do not match together, which will\nhelp skip efficiently over large ranges of doc IDs that do not match the\nconjunction.\n\nThis trick only works with low-cardinality fields. A rule of thumb is that\nyou should sort first on fields that both have a low cardinality and are\nfrequently used for filtering. The sort order (`asc` or `desc`) does not\nmatter as we only care about putting values that would match the same clauses\nclose to each other.\n\nFor instance if you were indexing cars for sale, it might be interesting to\nsort by fuel type, body type, make, year of registration and finally mileage.\n"
}