{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.343578",
        "size": 14624,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-bucket-daterange-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-bucket-daterange-aggregation]]\n=== Date range aggregation\n++++\n<titleabbrev>Date range</titleabbrev>\n++++\n\nA range aggregation that is dedicated for date values. The main difference\nbetween this aggregation and the normal\n<<search-aggregations-bucket-range-aggregation,range>>\naggregation is that the `from` and `to` values can be expressed in\n<<date-math,Date Math>> expressions, and it is also possible to specify a date\nformat by which the `from` and `to` response fields will be returned.\nNote that this aggregation includes the `from` value and excludes the `to` value\nfor each range.\n\nExample:\n\n[source,console,id=daterange-aggregation-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"range\": {\n      \"date_range\": {\n        \"field\": \"date\",\n        \"format\": \"MM-yyyy\",\n        \"ranges\": [\n          { \"to\": \"now-10M/M\" },  <1>\n          { \"from\": \"now-10M/M\" } <2>\n        ]\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales s/now-10M\\/M/10-2015/]\n\n<1> < now minus 10 months, rounded down to the start of the month.\n<2> >= now minus 10 months, rounded down to the start of the month.\n\nIn the example above, we created two range buckets, the first will \"bucket\" all\ndocuments dated prior to 10 months ago and the second will \"bucket\" all\ndocuments dated since 10 months ago\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"range\": {\n      \"buckets\": [\n        {\n          \"to\": 1.4436576E12,\n          \"to_as_string\": \"10-2015\",\n          \"doc_count\": 7,\n          \"key\": \"*-10-2015\"\n        },\n        {\n          \"from\": 1.4436576E12,\n          \"from_as_string\": \"10-2015\",\n          \"doc_count\": 0,\n          \"key\": \"10-2015-*\"\n        }\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\nWARNING: If a format or date value is incomplete, the date range aggregation\nreplaces any missing components with default values. See\n<<missing-date-components>>.\n\n==== Missing Values\n\nThe `missing` parameter defines how documents that are missing a value should\nbe treated. By default they will be ignored but it is also possible to treat\nthem as if they had a value. This is done by adding a set of fieldname :\nvalue mappings to specify default values per field.\n\n[source,console,id=daterange-aggregation-missing-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n   \"aggs\": {\n       \"range\": {\n           \"date_range\": {\n               \"field\": \"date\",\n               \"missing\": \"1976/11/30\",\n               \"ranges\": [\n                  { \n                    \"key\": \"Older\",\n                    \"to\": \"2016/02/01\" \n                  }, <1>\n                  { \n                    \"key\": \"Newer\",\n                    \"from\": \"2016/02/01\", \n                    \"to\" : \"now/d\" \n                  }\n              ]\n          }\n      }\n   }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n<1> Documents without a value in the `date` field will be added to the \"Older\"\nbucket, as if they had a date value of \"1976-11-30\". \n\n[[date-format-pattern]]\n==== Date Format/Pattern\n\nNOTE: this information was copied from\nhttps://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[DateTimeFormatter]\n\nAll ASCII letters are reserved as format pattern letters, which are defined\nas follows:\n\n[options=\"header\"]\n|=======\n|Symbol |Meaning                    |Presentation |Examples\n|G      |era                        |text         |AD; Anno Domini; A\n|u      |year                       |year         |2004; 04\n|y      |year-of-era                |year         |2004; 04\n|D      |day-of-year                |number       |189\n|M/L    |month-of-year              |number/text  |7; 07; Jul; July; J\n|d      |day-of-month               |number       |10\n\n|Q/q    |quarter-of-year            |number/text  |3; 03; Q3; 3rd quarter\n|Y      |week-based-year            |year         |1996; 96\n|w      |week-of-week-based-year    |number       |27\n|W      |week-of-month              |number       |4\n|E      |day-of-week                |text         |Tue; Tuesday; T\n|e/c    |localized day-of-week      |number/text  |2; 02; Tue; Tuesday; T\n|F      |week-of-month              |number       |3\n\n|a      |am-pm-of-day               |text         |PM\n|h      |clock-hour-of-am-pm (1-12) |number       |12\n|K      |hour-of-am-pm (0-11)       |number       |0\n|k      |clock-hour-of-am-pm (1-24) |number       |0\n\n|H      |hour-of-day (0-23)         |number       |0\n|m      |minute-of-hour             |number       |30\n|s      |second-of-minute           |number       |55\n|S      |fraction-of-second         |fraction     |978\n|A      |milli-of-day               |number       |1234\n|n      |nano-of-second             |number       |987654321\n|N      |nano-of-day                |number       |1234000000\n\n|V      |time-zone ID               |zone-id      |America/Los_Angeles; Z; -08:30\n|z      |time-zone name             |zone-name    |Pacific Standard Time; PST\n|O      |localized zone-offset      |offset-O     |GMT+8; GMT+08:00; UTC-08:00;\n|X      |zone-offset 'Z' for zero   |offset-X     |Z; -08; -0830; -08:30; -083015; -08:30:15;\n|x      |zone-offset                |offset-x     |+0000; -08; -0830; -08:30; -083015; -08:30:15;\n|Z      |zone-offset                |offset-Z     |+0000; -0800; -08:00;\n\n|p      |pad next                   |pad modifier |1\n|'      |escape for text            |delimiter\n|''     |single quote               |literal      |'\n|[      |optional section start\n|]      |optional section end\n|#      |reserved for future use\n|{      |reserved for future use\n|}      |reserved for future use\n|=======\n\nThe count of pattern letters determines the format.\n\nText:: The text style is determined based on the number of pattern letters\nused. Less than 4 pattern letters will use the short form. Exactly 4\npattern letters will use the full form. Exactly 5 pattern letters will use\nthe narrow form. Pattern letters `L`, `c`, and `q` specify the stand-alone\nform of the text styles.\n\nNumber:: If the count of letters is one, then the value is output using\nthe minimum number of digits and without padding. Otherwise, the count of\ndigits is used as the width of the output field, with the value\nzero-padded as necessary. The following pattern letters have constraints\non the count of letters. Only one letter of `c` and `F` can be specified.\nUp to two letters of `d`, `H`, `h`, `K`, `k`, `m`, and `s` can be\nspecified. Up to three letters of `D` can be specified.\n\nNumber/Text:: If the count of pattern letters is 3 or greater, use the\nText rules above. Otherwise use the Number rules above.\n\nFraction:: Outputs the nano-of-second field as a fraction-of-second. The\nnano-of-second value has nine digits, thus the count of pattern letters is\nfrom 1 to 9. If it is less than 9, then the nano-of-second value is\ntruncated, with only the most significant digits being output.\n\nYear:: The count of letters determines the minimum field width below which\npadding is used. If the count of letters is two, then a reduced two digit\nform is used. For printing, this outputs the rightmost two digits. For\nparsing, this will parse using the base value of 2000, resulting in a year\nwithin the range 2000 to 2099 inclusive. If the count of letters is less\nthan four (but not two), then the sign is only output for negative years\nas per `SignStyle.NORMAL`. Otherwise, the sign is output if the pad width is\nexceeded, as per `SignStyle.EXCEEDS_PAD`.\n\nZoneId:: This outputs the time-zone ID, such as `Europe/Paris`. If the\ncount of letters is two, then the time-zone ID is output. Any other count\nof letters throws `IllegalArgumentException`.\n\nZone names:: This outputs the display name of the time-zone ID. If the\ncount of letters is one, two or three, then the short name is output. If\nthe count of letters is four, then the full name is output. Five or more\nletters throws `IllegalArgumentException`.\n\nOffset X and x:: This formats the offset based on the number of pattern\nletters. One letter outputs just the hour, such as `+01`, unless the\nminute is non-zero in which case the minute is also output, such as\n`+0130`. Two letters outputs the hour and minute, without a colon, such as\n`+0130`. Three letters outputs the hour and minute, with a colon, such as\n`+01:30`. Four letters outputs the hour and minute and optional second,\nwithout a colon, such as `+013015`. Five letters outputs the hour and\nminute and optional second, with a colon, such as `+01:30:15`. Six or\nmore letters throws `IllegalArgumentException`. Pattern letter `X` (upper\ncase) will output `Z` when the offset to be output would be zero,\nwhereas pattern letter `x` (lower case) will output `+00`, `+0000`, or\n`+00:00`.\n\nOffset O:: This formats the localized offset based on the number of\npattern letters. One letter outputs the short form of the localized\noffset, which is localized offset text, such as `GMT`, with hour without\nleading zero, optional 2-digit minute and second if non-zero, and colon,\nfor example `GMT+8`. Four letters outputs the full form, which is\nlocalized offset text, such as `GMT, with 2-digit hour and minute\nfield, optional second field if non-zero, and colon, for example\n`GMT+08:00`. Any other count of letters throws\n`IllegalArgumentException`.\n\nOffset Z:: This formats the offset based on the number of pattern letters.\nOne, two or three letters outputs the hour and minute, without a colon,\nsuch as `+0130`. The output will be `+0000` when the offset is zero.\nFour letters outputs the full form of localized offset, equivalent to\nfour letters of Offset-O. The output will be the corresponding localized\noffset text if the offset is zero. Five letters outputs the hour,\nminute, with optional second if non-zero, with colon. It outputs `Z` if\nthe offset is zero. Six or more letters throws IllegalArgumentException.\n\nOptional section:: The optional section markers work exactly like calling\n`DateTimeFormatterBuilder.optionalStart()` and\n`DateTimeFormatterBuilder.optionalEnd()`.\n\nPad modifier:: Modifies the pattern that immediately follows to be padded\nwith spaces. The pad width is determined by the number of pattern letters.\nThis is the same as calling `DateTimeFormatterBuilder.padNext(int)`.\n\nFor example, `ppH` outputs the hour-of-day padded on the left with spaces to a width of 2.\n\nAny unrecognized letter is an error. Any non-letter character, other than\n`[`, `]`, `{`, `}`, `#` and the single quote will be output directly.\nDespite this, it is recommended to use single quotes around all characters\nthat you want to output directly to ensure that future changes do not\nbreak your application.\n\n\n[[time-zones]]\n==== Time zone in date range aggregations\n\nDates can be converted from another time zone to UTC by specifying the\n`time_zone` parameter.\n\nTime zones may either be specified as an ISO 8601 UTC offset (e.g. +01:00 or\n-08:00) or as one of the time zone ids from the TZ database.\n\nThe `time_zone` parameter is also applied to rounding in date math expressions.\nAs an example, to round to the beginning of the day in the CET time zone, you\ncan do the following:\n\n[source,console,id=daterange-aggregation-timezone-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n   \"aggs\": {\n       \"range\": {\n           \"date_range\": {\n               \"field\": \"date\",\n               \"time_zone\": \"CET\",\n               \"ranges\": [\n                  { \"to\": \"2016/02/01\" }, <1>\n                  { \"from\": \"2016/02/01\", \"to\" : \"now/d\" }, <2>\n                  { \"from\": \"now/d\" }\n              ]\n          }\n      }\n   }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n<1> This date will be converted to `2016-02-01T00:00:00.000+01:00`.\n<2> `now/d` will be rounded to the beginning of the day in the CET time zone.\n\n==== Keyed Response\n\nSetting the `keyed` flag to `true` will associate a unique string key with each\nbucket and return the ranges as a hash rather than an array:\n\n[source,console,id=daterange-aggregation-keyed-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"range\": {\n      \"date_range\": {\n        \"field\": \"date\",\n        \"format\": \"MM-yyy\",\n        \"ranges\": [\n          { \"to\": \"now-10M/M\" },\n          { \"from\": \"now-10M/M\" }\n        ],\n        \"keyed\": true\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales s/now-10M\\/M/10-2015/]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"range\": {\n      \"buckets\": {\n        \"*-10-2015\": {\n          \"to\": 1.4436576E12,\n          \"to_as_string\": \"10-2015\",\n          \"doc_count\": 7\n        },\n        \"10-2015-*\": {\n          \"from\": 1.4436576E12,\n          \"from_as_string\": \"10-2015\",\n          \"doc_count\": 0\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n\nIt is also possible to customize the key for each range:\n\n[source,console,id=daterange-aggregation-keyed-multiple-keys-example]\n--------------------------------------------------\nPOST /sales/_search?size=0\n{\n  \"aggs\": {\n    \"range\": {\n      \"date_range\": {\n        \"field\": \"date\",\n        \"format\": \"MM-yyy\",\n        \"ranges\": [\n          { \"from\": \"01-2015\", \"to\": \"03-2015\", \"key\": \"quarter_01\" },\n          { \"from\": \"03-2015\", \"to\": \"06-2015\", \"key\": \"quarter_02\" }\n        ],\n        \"keyed\": true\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nResponse:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...\n  \"aggregations\": {\n    \"range\": {\n      \"buckets\": {\n        \"quarter_01\": {\n          \"from\": 1.4200704E12,\n          \"from_as_string\": \"01-2015\",\n          \"to\": 1.425168E12,\n          \"to_as_string\": \"03-2015\",\n          \"doc_count\": 5\n        },\n        \"quarter_02\": {\n          \"from\": 1.425168E12,\n          \"from_as_string\": \"03-2015\",\n          \"to\": 1.4331168E12,\n          \"to_as_string\": \"06-2015\",\n          \"doc_count\": 2\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"took\": $body.took,\"timed_out\": false,\"_shards\": $body._shards,\"hits\": $body.hits,/]\n"
}