{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.677583",
        "size": 40162,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/eql-syntax.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "eql-syntax",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[eql-syntax]]\n== EQL syntax reference\n++++\n<titleabbrev>Syntax reference</titleabbrev>\n++++\n\n[discrete]\n[[eql-basic-syntax]]\n=== Basic syntax\n\nEQL queries require an event category and a matching condition. The `where`\nkeyword connects them.\n\n[source,eql]\n----\nevent_category where condition\n----\n\nAn event category is an indexed value of the <<eql-required-fields,event\ncategory field>>. By default, the <<eql-search-api,EQL search API>> uses the\n`event.category` field from the {ecs-ref}[Elastic Common Schema (ECS)]. You can\nspecify another event category field using the API's\n<<specify-a-timestamp-or-event-category-field,`event_category_field`>>\nparameter.\n\nFor example, the following EQL query matches events with an event category of\n`process` and a `process.name` of `svchost.exe`:\n\n[source,eql]\n----\nprocess where process.name == \"svchost.exe\"\n----\n\n[discrete]\n[[eql-syntax-match-any-event-category]]\n==== Match any event category\n\nTo match events of any category, use the `any` keyword. You can also use the\n`any` keyword to search for documents without a event category field.\n\nFor example, the following EQL query matches any documents with a\n`network.protocol` field value of `http`:\n\n[source,eql]\n----\nany where network.protocol == \"http\"\n----\n\n[discrete]\n[[eql-syntax-escape-an-event-category]]\n==== Escape an event category\n\nUse enclosing double quotes (`\"`) or three enclosing double quotes (`\"\"\"`) to\nescape event categories that:\n\n* Contain a special character, such as a hyphen (`-`) or dot (`.`)\n* Contain a space\n* Start with a numeral\n\n[source,eql]\n----\n\".my.event.category\"\n\"my-event-category\"\n\"my event category\"\n\"6eventcategory\"\n\n\"\"\".my.event.category\"\"\"\n\"\"\"my-event-category\"\"\"\n\"\"\"my event category\"\"\"\n\"\"\"6eventcategory\"\"\"\n----\n\n[discrete]\n[[eql-syntax-escape-a-field-name]]\n==== Escape a field name\n\nUse enclosing backticks (+++`+++) to escape field names that:\n\n* Contain a hyphen (`-`)\n* Contain a space\n* Start with a numeral\n\n[source,eql]\n----\n`my-field`\n`my field`\n`6myfield`\n----\n\nUse double backticks (+++``+++) to escape any backticks (+++`+++) in the field\nname.\n\n[source,eql]\n----\nmy`field -> `my``field`\n----\n\n[discrete]\n[[eql-syntax-conditions]]\n=== Conditions\n\nA condition consists of one or more criteria an event must match.\nYou can specify and combine these criteria using the following operators. Most\nEQL operators are case-sensitive by default.\n\n[discrete]\n[[eql-syntax-comparison-operators]]\n==== Comparison operators\n\n[source,eql]\n----\n<   <=   ==   :   !=   >=   >\n----\n\n`<` (less than)::\nReturns `true` if the value to the left of the operator is less than the value\nto the right. Otherwise returns `false`.\n\n`<=` (less than or equal) ::\nReturns `true` if the value to the left of the operator is less than or equal to\nthe value to the right. Otherwise returns `false`.\n\n`==` (equal, case-sensitive)::\nReturns `true` if the values to the left and right of the operator are equal.\nOtherwise returns `false`. Wildcards are not supported.\n\n`:` (equal, case-insensitive)::\nReturns `true` if strings to the left and right of the operator are equal.\nOtherwise returns `false`. Can only be used to compare strings. Supports\n<<eql-syntax-wildcards,wildcards>> and <<eql-syntax-lookup-operators,list\nlookups>>.\n\n`!=` (not equal, case-sensitive)::\nReturns `true` if the values to the left and right of the operator are not\nequal. Otherwise returns `false`. Wildcards are not supported.\n\n`>=` (greater than or equal) ::\nReturns `true` if the value to the left of the operator is greater than or equal\nto the value to the right. Otherwise returns `false`. When comparing strings,\nthe operator uses a case-sensitive lexicographic order.\n\n`>` (greater than)::\nReturns `true` if the value to the left of the operator is greater than the\nvalue to the right. Otherwise returns `false`. When comparing strings,\nthe operator uses a case-sensitive lexicographic order.\n\nNOTE: `=` is not supported as an equal operator. Use `==` or `:` instead.\n\n[discrete]\n[[eql-syntax-pattern-comparison-keywords]]\n==== Pattern comparison keywords\n\n[source,eql]\n----\nmy_field like  \"VALUE*\"         // case-sensitive wildcard matching\nmy_field like~ \"value*\"         // case-insensitive wildcard matching\n\nmy_field regex  \"VALUE[^Z].?\"   // case-sensitive regex matching\nmy_field regex~ \"value[^z].?\"   // case-insensitive regex matching\n----\n\n`like` (case-sensitive)::\nReturns `true` if the string to the left of the keyword matches a\n<<eql-syntax-wildcards,wildcard pattern>> to the right. Supports\n<<eql-syntax-lookup-operators,list lookups>>. Can only be used to compare\nstrings. For case-insensitive matching, use `like~`.\n\n`regex` (case-sensitive)::\nReturns `true` if the string to the left of the keyword matches a regular\nexpression to the right. For supported regular expression syntax, see\n<<regexp-syntax>>. Supports <<eql-syntax-lookup-operators,list lookups>>. Can\nonly be used to compare strings. For case-insensitive matching, use `regex~`.\n\n[discrete]\n[[limitations-for-comparisons]]\n===== Limitations for comparisons\n\nYou cannot chain comparisons. Instead, use a\n<<eql-syntax-logical-operators,logical operator>> between comparisons. For\nexample, `foo < bar <= baz` is not supported. However, you can rewrite the\nexpression as `foo < bar and bar <= baz`, which is supported.\n\nYou also cannot compare a field to another field, even if the fields are changed\nusing a <<eql-functions,function>>.\n\n*Example* +\nThe following EQL query compares the `process.parent_name` field\nvalue to a static value, `foo`. This comparison is supported.\n\nHowever, the query also compares the `process.parent.name` field value to the\n`process.name` field. This comparison is not supported and will return an\nerror for the entire query.\n\n[source,eql]\n----\nprocess where process.parent.name == \"foo\" and process.parent.name == process.name\n----\n\nInstead, you can rewrite the query to compare both the `process.parent.name`\nand `process.name` fields to static values.\n\n[source,eql]\n----\nprocess where process.parent.name == \"foo\" and process.name == \"foo\"\n----\n\n[discrete]\n[[eql-syntax-logical-operators]]\n==== Logical operators\n\n[source,eql]\n----\nand  or  not\n----\n\n`and`::\nReturns `true` only if the condition to the left and right _both_ return `true`.\nOtherwise returns `false`.\n\n`or`::\nReturns `true` if one of the conditions to the left or right `true`.\nOtherwise returns `false`.\n\n`not`::\nReturns `true` if the condition to the right is `false`.\n\n[discrete]\n[[eql-syntax-lookup-operators]]\n==== Lookup operators\n\n[source,eql]\n----\nmy_field in (\"Value-1\", \"VALUE2\", \"VAL3\")                 // case-sensitive\nmy_field in~ (\"value-1\", \"value2\", \"val3\")                // case-insensitive\n\nmy_field not in (\"Value-1\", \"VALUE2\", \"VAL3\")             // case-sensitive\nmy_field not in~ (\"value-1\", \"value2\", \"val3\")            // case-insensitive\n\nmy_field : (\"value-1\", \"value2\", \"val3\")                  // case-insensitive\n\nmy_field like  (\"Value-*\", \"VALUE2\", \"VAL?\")              // case-sensitive\nmy_field like~ (\"value-*\", \"value2\", \"val?\")              // case-insensitive\n\nmy_field regex  (\"[vV]alue-[0-9]\", \"VALUE[^2].?\", \"VAL3\") // case-sensitive\nmy_field regex~  (\"value-[0-9]\", \"value[^2].?\", \"val3\")   // case-insensitive\n----\n\n`in` (case-sensitive)::\nReturns `true` if the value is contained in the provided list. For\ncase-insensitive matching, use `in~`.\n\n`not in` (case-sensitive)::\nReturns `true` if the value is not contained in the provided list. For\ncase-insensitive matching, use `not in~`.\n\n`:` (case-insensitive)::\nReturns `true` if the string is contained in the provided list. Can only be used\nto compare strings.\n\n`like` (case-sensitive)::\nReturns `true` if the string matches a <<eql-syntax-wildcards,wildcard pattern>>\nin the provided list. Can only be used to compare strings. For case-insensitive\nmatching, use `like~`.\n\n`regex` (case-sensitive)::\nReturns `true` if the string matches a regular expression pattern in the\nprovided list. For supported regular expression syntax, see <<regexp-syntax>>.\nCan only be used to compare strings. For case-insensitive matching, use\n`regex~`.\n\n[discrete]\n[[eql-syntax-math-operators]]\n==== Math operators\n\n[source,eql]\n----\n+  -  *  /  %\n----\n\n`+` (add)::\nAdds the values to the left and right of the operator.\n\n`-` (subtract)::\nSubtracts the value to the right of the operator from the value to the left.\n\n`*` (multiply)::\nMultiplies the values to the left and right of the operator.\n\n`/` (divide)::\nDivides the value to the left of the operator by the value to the right.\n+\n[[eql-divide-operator-float-rounding]]\n[WARNING]\n====\nIf both the dividend and divisor are integers, the divide (`\\`) operation\n_rounds down_ any returned floating point numbers to the nearest integer. To\navoid rounding, convert either the dividend or divisor to a float.\n\n*Example* +\nThe `process.args_count` field is a <<number,`long`>> integer field containing a\ncount of process arguments.\n\nA user might expect the following EQL query to only match events with a\n`process.args_count` value of `4`.\n\n[source,eql]\n----\nprocess where ( 4 / process.args_count ) == 1\n----\n\nHowever, the EQL query matches events with a `process.args_count` value of `3`\nor `4`.\n\nFor events with a `process.args_count` value of `3`, the divide operation\nreturns a float of `1.333...`, which is rounded down to `1`.\n\nTo match only events with a `process.args_count` value of `4`, convert\neither the dividend or divisor to a float.\n\nThe following EQL query changes the integer `4` to the equivalent float `4.0`.\n\n[source,eql]\n----\nprocess where ( 4.0 / process.args_count ) == 1\n----\n====\n\n`%` (modulo)::\nDivides the value to the left of the operator by the value to the right. Returns only the remainder.\n\n[discrete]\n[[eql-syntax-match-any-condition]]\n==== Match any condition\n\nTo match events solely on event category, use the `where true` condition.\n\nFor example, the following EQL query matches any `file` events:\n\n[source,eql]\n----\nfile where true\n----\n\nTo match any event, you can combine the `any` keyword with the `where true`\ncondition:\n\n[source,eql]\n----\nany where true\n----\n\n[discrete]\n[[eql-syntax-optional-fields]]\n=== Optional fields\n\nBy default, an EQL query can only contain fields that exist in the dataset\nyou're searching. A field exists in a dataset if it has an\n<<explicit-mapping,explicit>>, <<dynamic-mapping,dynamic>>, or\n<<eql-use-runtime-fields,runtime>> mapping. If an EQL query contains a field\nthat doesn't exist, it returns an error.\n\nIf you aren't sure if a field exists in a dataset, use the `?` operator to mark\nthe field as optional. If an optional field doesn't exist, the query replaces it\nwith `null` instead of returning an error.\n\n*Example* +\nIn the following query, the `user.id` field is optional.\n\n[source,eql]\n----\nnetwork where ?user.id != null\n----\n\nIf the `user.id` field exists in the dataset you're searching, the query matches\nany `network` event that contains a `user.id` value. If the `user.id` field\ndoesn't exist in the dataset, EQL interprets the query as:\n\n[source,eql]\n----\nnetwork where null != null\n----\n\nIn this case, the query matches no events.\n\n[discrete]\n[[eql-syntax-check-field-exists]]\n==== Check if a field exists\n\nTo match events containing any value for a field, compare the field to `null`\nusing the `!=` operator:\n\n[source,eql]\n----\n?my_field != null\n----\n\nTo match events that do not contain a field value, compare the field to `null`\nusing the `==` operator:\n\n[source,eql]\n----\n?my_field == null\n----\n\n[discrete]\n[[eql-syntax-strings]]\n=== Strings\n\nStrings are enclosed in double quotes (`\"`).\n\n[source,eql]\n----\n\"hello world\"\n----\n\nStrings enclosed in single quotes (`'`) are not supported.\n\n[discrete]\n[[eql-syntax-escape-characters]]\n==== Escape characters in a string\n\nWhen used within a string, special characters, such as a carriage return or\ndouble quote (`\"`), must be escaped with a preceding backslash (`\\`).\n\n[source,eql]\n----\n\"example \\r of \\\" escaped \\n characters\"\n----\n\n[options=\"header\"]\n|====\n| Escape sequence | Literal character\n|`\\n`             | Newline (linefeed)\n|`\\r`             | Carriage return\n|`\\t`             | Tab\n|`\\\\`             | Backslash (`\\`)\n|`\\\"`             | Double quote (`\"`)\n|====\n\nYou can escape Unicode characters using a hexadecimal `\\u{XXXXXXXX}` escape\nsequence. The hexadecimal value can be 2-8 characters and is case-insensitive.\nValues shorter than 8 characters are zero-padded. You can use these escape\nsequences to include non-printable or right-to-left (RTL) characters in your\nstrings. For example, you can escape a\n{wikipedia}/Right-to-left_mark[right-to-left mark (RLM)] as `\\u{200f}`,\n`\\u{200F}`, or `\\u{0000200f}`.\n\nIMPORTANT: The single quote (`'`) character is reserved for future use. You\ncannot use an escaped single quote (`\\'`) for literal strings. Use an escaped\ndouble quote (`\\\"`) instead.\n\n[discrete]\n[[eql-syntax-raw-strings]]\n==== Raw strings\n\nRaw strings treat special characters, such as backslashes (`\\`), as literal\ncharacters. Raw strings are enclosed in three double quotes (`\"\"\"`).\n\n[source,eql]\n----\n\"\"\"Raw string with a literal double quote \" and blackslash \\ included\"\"\"\n----\n\nA raw string cannot contain three consecutive double quotes (`\"\"\"`). Instead,\nuse a regular string with the `\\\"` escape sequence.\n\n[source,eql]\n----\n\"String containing \\\"\\\"\\\" three double quotes\"\n----\n\n[discrete]\n[[eql-syntax-wildcards]]\n==== Wildcards\n\nFor string comparisons using the `:` operator or `like` keyword, you can use the\n`*` and `?` wildcards to match specific patterns. The `*` wildcard matches zero\nor more characters:\n\n[source,eql]\n----\nmy_field : \"doc*\"     // Matches \"doc\", \"docs\", or \"document\" but not \"DOS\"\nmy_field : \"*doc\"     // Matches \"adoc\" or \"asciidoc\"\nmy_field : \"d*c\"      // Matches \"doc\" or \"disc\"\n\nmy_field like \"DOC*\"  // Matches \"DOC\", \"DOCS\", \"DOCs\", or \"DOCUMENT\" but not \"DOS\"\nmy_field like \"D*C\"   // Matches \"DOC\", \"DISC\", or \"DisC\"\n----\n\nThe `?` wildcard matches exactly one character:\n\n[source,eql]\n----\nmy_field : \"doc?\"     // Matches \"docs\" but not \"doc\", \"document\", or \"DOS\"\nmy_field : \"?doc\"     // Matches \"adoc\" but not \"asciidoc\"\nmy_field : \"d?c\"      // Matches \"doc\" but not \"disc\"\n\nmy_field like \"DOC?\"  // Matches \"DOCS\" or \"DOCs\" but not \"DOC\", \"DOCUMENT\", or \"DOS\"\nmy_field like \"D?c\"   // Matches \"DOC\" but not \"DISC\"\n----\n\nThe `:` operator and `like` keyword also support wildcards in\n<<eql-syntax-lookup-operators,list lookups>>:\n\n[source,eql]\n----\nmy_field : (\"doc*\", \"f*o\", \"ba?\", \"qux\")\nmy_field like (\"Doc*\", \"F*O\", \"BA?\", \"QUX\")\n----\n\n[discrete]\n[[eql-sequences]]\n=== Sequences\n\nYou can use EQL sequences to describe and match an ordered series of events.\nEach item in a sequence is an event category and event condition,\nsurrounded by square brackets (`[ ]`). Events are listed in ascending\nchronological order, with the most recent event listed last.\n\n[source,eql]\n----\nsequence\n  [ event_category_1 where condition_1 ]\n  [ event_category_2 where condition_2 ]\n  ...\n----\n\n*Example* +\nThe following EQL sequence query matches this series of ordered events:\n\n. Start with an event with:\n+\n--\n* An event category of `file`\n* A `file.extension` of `exe`\n--\n. Followed by an event with an event category of `process`\n\n[source,eql]\n----\nsequence\n  [ file where file.extension == \"exe\" ]\n  [ process where true ]\n----\n\n[discrete]\n[[eql-with-maxspan-keywords]]\n==== `with maxspan` statement\n\nYou can use `with maxspan` to constrain a sequence to a specified timespan. All\nevents in a matching sequence must occur within this duration, starting at the\nfirst event's timestamp.\n\n`maxspan` accepts <<time-units,time value>> arguments.\n\n[source,eql]\n----\nsequence with maxspan=30s\n  [ event_category_1 where condition_1 ] by field_baz\n  [ event_category_2 where condition_2 ] by field_bar\n  ...\n----\n\n*Example* +\nThe following sequence query uses a `maxspan` value of `15m` (15 minutes).\nEvents in a matching sequence must occur within 15 minutes of the first event's\ntimestamp.\n\n[source,eql]\n----\nsequence with maxspan=15m\n  [ file where file.extension == \"exe\" ]\n  [ process where true ]\n----\n\n[discrete]\n[[eql-missing-events]]\n==== Missing events\n\nUse `!` to match missing events: events in a timespan-constrained sequence that\ndo not meet a given condition.\n\n[source,eql]\n----\nsequence with maxspan=1h\n  [ event_category_1 where condition_1 ]\n  ![ event_category_2 where condition_2 ]\n  [ event_category_3 where condition_3 ]\n  ...\n----\n\nMissing event clauses can be used at the beginning, at the end, and/or in the\nmiddle of a sequence, in any combination with positive event clauses. A sequence\ncan have multiple missing event clauses, but needs to have at least one positive\nclause. <<eql-with-maxspan-keywords,`with maxspan`>> is mandatory when missing\nevent clauses are present.\n\n\n*Example* +\nThe following sequence query finds logon events that are not followed within 5\nseconds by a logoff event.\n\n[source,eql]\n----\nsequence by host.name, user.name with maxspan=5s\n  [ authentication where event.code : \"4624\" ]\n  ![ authentication where event.code : \"4647\" ]\n----\n\n[discrete]\n[[eql-by-keyword]]\n==== `by` keyword\n\nUse the `by` keyword in a sequence query to only match events that share the\nsame values, even if those values are in different fields. These shared values\nare called join keys. If a join key should be in the same field across all\nevents, use `sequence by`.\n\n[source,eql]\n----\nsequence by field_foo\n  [ event_category_1 where condition_1 ] by field_baz\n  [ event_category_2 where condition_2 ] by field_bar\n  ...\n----\n\n*Example* +\nThe following sequence query uses the `by` keyword to constrain matching events\nto:\n\n* Events with the same `user.name` value\n* `file` events with a `file.path` value equal to the following `process`\n   event's `process.executable` value.\n\n[source,eql]\n----\nsequence\n  [ file where file.extension == \"exe\" ] by user.name, file.path\n  [ process where true ] by user.name, process.executable\n----\n\nBecause the `user.name` field is shared across all events in the sequence, it\ncan be included using `sequence by`. The following sequence is equivalent to the\nprior one.\n\n[source,eql]\n----\nsequence by user.name\n  [ file where file.extension == \"exe\" ] by file.path\n  [ process where true ] by process.executable\n----\n\nYou can combine `sequence by` and `with maxspan` to constrain a sequence by both\nfield values and a timespan.\n\n[source,eql]\n----\nsequence by field_foo with maxspan=30s\n  [ event_category_1 where condition_1 ]\n  [ event_category_2 where condition_2 ]\n  ...\n----\n\n*Example* +\nThe following sequence query uses `sequence by` and `with maxspan` to only match\na sequence of events that:\n\n* Share the same `user.name` field values\n* Occur within `15m` (15 minutes) of the first matching event\n\n[source,eql]\n----\nsequence by user.name with maxspan=15m\n  [ file where file.extension == \"exe\" ]\n  [ process where true ]\n----\n\n[discrete]\n[[eql-syntax-optional-by-fields]]\n==== Optional `by` fields\n\nBy default, a join key must be a non-`null` field value. To allow `null` join\nkeys, use the `?` operator to mark the `by` field as\n<<eql-syntax-optional-fields,optional>>. This is also helpful if you aren't sure\nthe dataset you're searching contains the `by` field.\n\n*Example* +\nThe following sequence query uses `sequence by` to constrain matching events\nto:\n\n* Events with the same `process.pid` value, excluding `null` values. If the\n  `process.pid` field doesn't exist in the dataset you're searching, the query\n  returns an error.\n\n* Events with the same `process.entity_id` value, including `null` values. If\n  an event doesn't contain the `process.entity_id` field, its\n  `process.entity_id` value is considered `null`. This applies even if the\n  `process.pid` field doesn't exist in the dataset you're searching.\n\n[source,eql]\n----\nsequence by process.pid, ?process.entity_id\n  [process where process.name == \"regsvr32.exe\"]\n  [network where true]\n----\n\n[discrete]\n[[eql-until-keyword]]\n==== `until` keyword\n\nYou can use the `until` keyword to specify an expiration event for a sequence.\nIf this expiration event occurs _between_ matching events in a sequence, the\nsequence expires and is not considered a match. If the expiration event occurs\n_after_ matching events in a sequence, the sequence is still considered a\nmatch. The expiration event is not included in the results.\n\n[source,eql]\n----\nsequence\n  [ event_category_1 where condition_1 ]\n  [ event_category_2 where condition_2 ]\n  ...\nuntil [ event_category_3 where condition_3 ]\n----\n\n*Example* +\nA dataset contains the following event sequences, grouped by shared IDs:\n\n[source,txt]\n----\nA, B\nA, B, C\nA, C, B\n----\n\nThe following EQL query searches the dataset for sequences containing\nevent `A` followed by event `B`. Event `C` is used as an expiration event.\n\n[source,eql]\n----\nsequence by ID\n  A\n  B\nuntil C\n----\n\nThe query matches sequences `A, B` and `A, B, C` but not `A, C, B`.\n\n[TIP]\n====\nThe `until` keyword can be useful when searching for process sequences in\nWindows event logs.\n\nIn Windows, a process ID (PID) is unique only while a process is running. After\na process terminates, its PID can be reused.\n\nYou can search for a sequence of events with the same PID value using the `by`\nand `sequence by` keywords.\n\n*Example* +\nThe following EQL query uses the `sequence by` keyword to match a\nsequence of events that share the same `process.pid` value.\n\n[source,eql]\n----\nsequence by process.pid\n  [ process where event.type == \"start\" and process.name == \"cmd.exe\" ]\n  [ process where file.extension == \"exe\" ]\n----\n\nHowever, due to PID reuse, this can result in a matching sequence that\ncontains events across unrelated processes. To prevent false positives, you can\nuse the `until` keyword to end matching sequences before a process termination\nevent.\n\nThe following EQL query uses the `until` keyword to end sequences before\n`process` events with an `event.type` of `stop`. These events indicate a process\nhas been terminated.\n\n[source,eql]\n----\nsequence by process.pid\n  [ process where event.type == \"start\" and process.name == \"cmd.exe\" ]\n  [ process where file.extension == \"exe\" ]\nuntil [ process where event.type == \"stop\" ]\n----\n====\n\n[discrete]\n[[eql-with-runs-statement]]\n==== `with runs` statement\n\nUse a `with runs` statement to run the same event criteria successively within a\nsequence query. For example:\n\n[source,eql]\n----\nsequence\n  [ process where event.type == \"creation\" ]\n  [ library where process.name == \"regsvr32.exe\" ] with runs=3\n  [ registry where true ]\n----\n\nis equivalent to:\n\n[source,eql]\n----\nsequence\n  [ process where event.type == \"creation\" ]\n  [ library where process.name == \"regsvr32.exe\" ]\n  [ library where process.name == \"regsvr32.exe\" ]\n  [ library where process.name == \"regsvr32.exe\" ]\n  [ registry where true ]\n----\n\nThe `runs` value must be between `1` and `100` (inclusive).\n\nYou can use a `with runs` statement with the <<eql-by-keyword,`by` keyword>>.\nFor example:\n\n[source,eql]\n----\nsequence\n  [ process where event.type == \"creation\" ] by process.executable\n  [ library where process.name == \"regsvr32.exe\" ] by dll.path with runs=3\n----\n\n[discrete]\n[[eql-samples]]\n=== Samples\n\nYou can use EQL samples to describe and match a chronologically unordered series\nof events. All events in a sample share the same value for one or more fields\nthat are specified using the <<eql-by-keyword,`by` keyword>> (join keys). Each\nitem in a sample is an event category and event condition, surrounded by square\nbrackets (`[ ]`). Events are listed in the order of the filters they match.\n\n[source,eql]\n----\nsample by join_key\n  [ event_category_1 where condition_1 ]\n  [ event_category_2 where condition_2 ]\n  ...\n----\n\n*Example* + \nThe following EQL sample query returns up to 10 samples with unique values for\n`host`. Each sample consists of two events:\n\n. Start with an event with:\n+\n--\n* An event category of `file`\n* A `file.extension` of `exe`\n--\n. Followed by an event with an event category of `process`\n\n[source,eql]\n----\nsample by host\n  [ file where file.extension == \"exe\" ]\n  [ process where true ]\n----\n\nSample queries do not take into account the chronological ordering of events.\nThe `with maxspan` and `with runs` statements as well as the `until` keyword are\nnot supported. \n\n[discrete]\n[[eql-functions]]\n=== Functions\n\nYou can use EQL functions to convert data types, perform math, manipulate\nstrings, and more. For a list of supported functions, see <<eql-function-ref>>.\n\n[discrete]\n[[eql-case-insensitive-functions]]\n==== Case-insensitive functions\n\nMost EQL functions are case-sensitive by default. To make a function\ncase-insensitive, use the `~` operator after the function name:\n\n[source,eql]\n----\nstringContains(process.name,\".exe\")  // Matches \".exe\" but not \".EXE\" or \".Exe\"\nstringContains~(process.name,\".exe\") // Matches \".exe\", \".EXE\", or \".Exe\"\n----\n\n[discrete]\n[[eql-how-functions-impact-search-performance]]\n==== How functions impact search performance\n\nUsing functions in EQL queries can result in slower search speeds. If you\noften use functions to transform indexed data, you can speed up search by making\nthese changes during indexing instead. However, that often means slower index\nspeeds.\n\n*Example* +\nAn index contains the `file.path` field. `file.path` contains the full path to a\nfile, including the file extension.\n\nWhen running EQL searches, users often use the `endsWith` function with the\n`file.path` field to match file extensions:\n\n[source,eql]\n----\nfile where endsWith(file.path,\".exe\") or endsWith(file.path,\".dll\")\n----\n\nWhile this works, it can be repetitive to write and can slow search speeds. To\nspeed up search, you can do the following instead:\n\n. <<indices-put-mapping,Add a new field>>, `file.extension`, to the index. The\n  `file.extension` field will contain only the file extension from the\n  `file.path` field.\n. Use an <<ingest,ingest pipeline>> containing the <<grok-processor,`grok`>>\n  processor or another preprocessor tool to extract the file extension from the\n  `file.path` field before indexing.\n. Index the extracted file extension to the `file.extension` field.\n\nThese changes may slow indexing but allow for faster searches. Users\ncan use the `file.extension` field instead of multiple `endsWith` function\ncalls:\n\n[source,eql]\n----\nfile where file.extension in (\"exe\", \"dll\")\n----\n\nWe recommend testing and benchmarking any indexing changes before deploying them\nin production. See <<tune-for-indexing-speed>> and <<tune-for-search-speed>>.\n\n[discrete]\n[[eql-pipes]]\n=== Pipes\n\nEQL pipes filter, aggregate, and post-process events returned by\nan EQL query. You can use pipes to narrow down EQL query results or make them\nmore specific.\n\nPipes are delimited using the pipe (`|`) character.\n\n[source,eql]\n----\nevent_category where condition | pipe\n----\n\n*Example* +\nThe following EQL query uses the `tail` pipe to return only the 10 most recent\nevents matching the query.\n\n[source,eql]\n----\nauthentication where agent.id == 4624\n| tail 10\n----\n\nYou can pass the output of a pipe to another pipe. This lets you use multiple\npipes with a single query.\n\nFor a list of supported pipes, see <<eql-pipe-ref>>.\n\n[discrete]\n[[eql-syntax-limitations]]\n=== Limitations\n\nEQL has the following limitations.\n\n[discrete]\n[[eql-uses-fields-parameter]]\n==== EQL uses the `fields` parameter\n\nEQL retrieves field values using the search API's <<search-fields-param,`fields`\nparameter>>. Any limitations on the `fields` parameter also apply to EQL\nqueries. For example, if `_source` is disabled for any returned fields or at\nindex level, the values cannot be retrieved.\n\n[discrete]\n[[eql-compare-fields]]\n==== Comparing fields\n\nYou cannot use EQL comparison operators to compare a field to\nanother field. This applies even if the fields are changed using a\n<<eql-functions,function>>.\n\n[discrete]\n[[eql-text-fields]]\n==== Text fields are not supported\n\nEQL searches do not support <<text,`text`>> fields. To a search a `text` field,\nuse the EQL search API's <<eql-search-filter-query-dsl,Query DSL `filter`>>\nparameter.\n\n[discrete]\n[[eql-nested-fields]]\n==== EQL search on nested fields\n\nYou cannot use EQL to search the values of a <<nested,`nested`>> field or the\nsub-fields of a `nested` field. However, data streams and indices containing\n`nested` field mappings are otherwise supported.\n\n[discrete]\n[[eql-unsupported-syntax]]\n==== Differences from Endgame EQL syntax\n\n{es} EQL differs from the {eql-ref}/index.html[Elastic Endgame EQL syntax] as\nfollows:\n\n* In {es} EQL, most operators are case-sensitive. For example,\n`process_name == \"cmd.exe\"` is not equivalent to\n`process_name == \"Cmd.exe\"`.\n\n* In {es} EQL, functions are case-sensitive. To make a function\ncase-insensitive, use `~`, such as `endsWith~(process_name, \".exe\")`.\n\n* For case-insensitive equality comparisons, use the `:` operator. Both `*` and\n`?` are recognized wildcard characters.\n\n* The `==` and `!=` operators do not expand wildcard characters. For example,\n`process_name == \"cmd*.exe\"` interprets `*` as a literal asterisk, not a\nwildcard.\n\n* For wildcard matching, use the `like` keyword when case-sensitive and\n`like~` when case-insensitive. The `:` operator is equivalent to `like~`.\n\n* For regular expression matching, use `regex` or `regex~`.\n\n* `=` cannot be substituted for the `==` operator.\n\n* Strings enclosed in single quotes (`'`) are not supported. Enclose strings in\ndouble quotes (`\"`) instead.\n\n* `?\"` and `?'` do not indicate raw strings. Enclose raw strings in\nthree double quotes (`\"\"\"`) instead.\n\n* {es} EQL does not support:\n\n** Array functions:\n*** {eql-ref}/functions.html#arrayContains[`arrayContains`]\n*** {eql-ref}/functions.html#arrayCount[`arrayCount`]\n*** {eql-ref}/functions.html#arraySearch[`arraySearch`]\n\n** The {eql-ref}//functions.html#match[`match`] function\n\n** {eql-ref}/joins.html[Joins]\n\n** {eql-ref}/basic-syntax.html#event-relationships[Lineage-related keywords]:\n*** `child of`\n*** `descendant of`\n*** `event of`\n\n** The following {eql-ref}/pipes.html[pipes]:\n*** {eql-ref}/pipes.html#count[`count`]\n*** {eql-ref}/pipes.html#filter[`filter`]\n*** {eql-ref}/pipes.html#sort[`sort`]\n*** {eql-ref}/pipes.html#unique[`unique`]\n*** {eql-ref}/pipes.html#unique-count[`unique_count`]\n\n[discrete]\n[[eql-how-sequence-queries-handle-matches]]\n==== How sequence queries handle matches\n\n<<eql-sequences,Sequence queries>> don't find all potential matches for a\nsequence. This approach would be too slow and costly for large event data sets.\nInstead, a sequence query handles pending sequence matches as a\n{wikipedia}/Finite-state_machine[state machine]:\n\n* Each event item in the sequence query is a state in the machine.\n* Only one pending sequence can be in each state at a time.\n* If two pending sequences are in the same state at the same time, the most\nrecent sequence overwrites the older one.\n* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\nseparate state machine for each unique `by` field value.\n\n.*Example*\n[%collapsible]\n====\nA data set contains the following `process` events in ascending chronological\norder:\n\n[source,js]\n----\n{ \"index\" : { \"_id\": \"1\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n{ \"index\" : { \"_id\": \"2\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n{ \"index\" : { \"_id\": \"3\" } }\n{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n{ \"index\" : { \"_id\": \"4\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n{ \"index\" : { \"_id\": \"5\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n{ \"index\" : { \"_id\": \"6\" } }\n{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"attrib\" }, ...}\n{ \"index\" : { \"_id\": \"7\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n{ \"index\" : { \"_id\": \"8\" } }\n{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n{ \"index\" : { \"_id\": \"9\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n{ \"index\" : { \"_id\": \"10\" } }\n{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"cat\" }, ...}\n{ \"index\" : { \"_id\": \"11\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n----\n// NOTCONSOLE\n\nAn EQL sequence query searches the data set:\n\n[source,eql]\n----\nsequence by user.name\n  [process where process.name == \"attrib\"]\n  [process where process.name == \"bash\"]\n  [process where process.name == \"cat\"]\n----\n\nThe query's event items correspond to the following states:\n\n* State A:  `[process where process.name == \"attrib\"]`\n* State B:  `[process where process.name == \"bash\"]`\n* Complete: `[process where process.name == \"cat\"]`\n\nimage::images/eql/sequence-state-machine.svg[align=\"center\"]\n\nTo find matching sequences, the query uses separate state machines for each\nunique `user.name` value. Based on the data set, you can expect two state\nmachines: one for the `root` user and one for `elkbee`.\n\nimage::images/eql/separate-state-machines.svg[align=\"center\"]\n\nPending sequence matches move through each machine's states as follows:\n\n[source,txt]\n----\n{ \"index\" : { \"_id\": \"1\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n// Creates sequence [1] in state A for the \"root\" user.\n//\n// +------------------------\"root\"------------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+     +------------+  |\n// |  |    [1]    |     |           |     |            |  |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"2\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n// Creates sequence [2] in state A for \"root\", overwriting sequence [1].\n//\n// +------------------------\"root\"------------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+     +------------+  |\n// |  |    [2]    |     |           |     |            |  |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"3\" } }\n{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n// Nothing happens. The \"elkbee\" user has no pending sequence to move\n// from state A to state B.\n//\n// +-----------------------\"elkbee\"-----------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+     +------------+  |\n// |  |           |     |           |     |            |  |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"4\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n// Sequence [2] moves out of state A for \"root\".\n// State B for \"root\" now contains [2, 4].\n// State A for \"root\" is empty.\n//\n// +------------------------\"root\"------------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+ --> +-----------+     +------------+  |\n// |  |           |     |   [2, 4]  |     |            |  |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"5\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n// Nothing happens. State A is empty for \"root\".\n//\n// +------------------------\"root\"------------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+     +------------+  |\n// |  |           |     |   [2, 4]  |     |            |  |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"6\" } }\n{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"attrib\" }, ...}\n// Creates sequence [6] in state A for \"elkbee\".\n//\n// +-----------------------\"elkbee\"-----------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+     +------------+  |\n// |  |    [6]    |     |           |     |            |  |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"7\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n// Creates sequence [7] in state A for \"root\".\n// Sequence [2, 4] remains in state B for \"root\".\n//\n// +------------------------\"root\"------------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+     +------------+  |\n// |  |    [7]    |     |   [2, 4]  |     |            |  |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"8\" } }\n{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n// Sequence [6, 8] moves to state B for \"elkbee\".\n// State A for \"elkbee\" is now empty.\n//\n// +-----------------------\"elkbee\"-----------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+ --> +-----------+     +------------+  |\n// |  |           |     |   [6, 8]  |     |            |  |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"9\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n// Sequence [2, 4, 9] is complete for \"root\".\n// State B for \"root\" is now empty.\n// Sequence [7] remains in state A.\n//\n// +------------------------\"root\"------------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+ --> +------------+  |\n// |  |    [7]    |     |           |     |  [2, 4, 9] |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"10\" } }\n{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"cat\" }, ...}\n// Sequence [6, 8, 10] is complete for \"elkbee\".\n// State A and B for \"elkbee\" are now empty.\n//\n// +-----------------------\"elkbee\"-----------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+ --> +------------+  |\n// |  |           |     |           |     | [6, 8, 10] |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n\n{ \"index\" : { \"_id\": \"11\" } }\n{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n// Nothing happens.\n// The machines for \"root\" and \"elkbee\" remain the same.\n//\n// +------------------------\"root\"------------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+     +------------+  |\n// |  |    [7]    |     |           |     |  [2, 4, 9] |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n//\n// +-----------------------\"elkbee\"-----------------------+\n// |  +-----------+     +-----------+     +------------+  |\n// |  |  State A  |     |  State B  |     |  Complete  |  |\n// |  +-----------+     +-----------+     +------------+  |\n// |  |           |     |           |     | [6, 8, 10] |\n// |  +-----------+     +-----------+     +------------+  |\n// +------------------------------------------------------+\n----\n====\n"
}