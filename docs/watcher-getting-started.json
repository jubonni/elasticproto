{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.681579",
        "size": 6957,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-getting-started.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": true,
        "title": "watcher-getting-started",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[watcher-getting-started]]\n== Getting started with {watcher}\n\n[[watch-log-data]]\nTo set up a watch to start sending alerts:\n\n* <<log-add-input, Schedule the watch and define an input>>.\n* <<log-add-condition, Add a condition>> that checks to see if an alert\nneeds to be sent.\n* <<log-take-action, Configure an action>> to send an alert when the\ncondition is met.\n\n[discrete]\n[[log-add-input]]\n=== Schedule the watch and define an input\n\nA watch <<trigger-schedule,schedule>> controls how often a watch is triggered.\nThe watch <<input,input>> gets the data that you want to evaluate.\n\nTo periodically search log data and load the results into the\nwatch, you could use an <<schedule-interval,interval>> schedule and a\n<<input-search,search>> input. For example, the following Watch searches\nthe `logs` index for errors every 10 seconds:\n\n[source,console]\n------------------------------------------------------------\nPUT _watcher/watch/log_error_watch\n{\n  \"trigger\" : {\n    \"schedule\" : { \"interval\" : \"10s\" } <1>\n  },\n  \"input\" : {\n    \"search\" : {\n      \"request\" : {\n        \"indices\" : [ \"logs\" ],\n        \"body\" : {\n          \"query\" : {\n            \"match\" : { \"message\": \"error\" }\n          }\n        }\n      }\n    }\n  }\n}\n------------------------------------------------------------\n\n<1> Schedules are typically configured to run less frequently. This example sets\n    the interval to 10 seconds so you can easily see the watches being triggered.\n    Since this watch runs so frequently, don't forget to <<log-delete, delete the watch>>\n    when you're done experimenting.\n\nIf you check the watch history you'll see that the watch is being triggered every\n10 seconds. However, the search isn't returning any results so nothing is loaded\ninto the watch payload.\n\nFor example, the following request retrieves the last ten watch executions (watch\nrecords) from the watch history:\n\n[source,console]\n------------------------------------------------------------\nGET .watcher-history*/_search?pretty\n{\n  \"sort\" : [\n    { \"result.execution_time\" : \"desc\" }\n  ]\n}\n------------------------------------------------------------\n// TEST[continued]\n\n[discrete]\n[[log-add-condition]]\n=== Add a condition\n\nA <<condition,condition>> evaluates the data you've loaded into the watch and\ndetermines if any action is required. Now that you've loaded log errors into\nthe watch, you can define a condition that checks to see if any errors were\nfound.\n\nFor example, the following compare condition simply checks to see if the\nsearch input returned any hits.\n\n[source,console]\n--------------------------------------------------\nPUT _watcher/watch/log_error_watch\n{\n  \"trigger\" : { \"schedule\" : { \"interval\" : \"10s\" }},\n  \"input\" : {\n    \"search\" : {\n      \"request\" : {\n        \"indices\" : [ \"logs\" ],\n        \"body\" : {\n          \"query\" : {\n            \"match\" : { \"message\": \"error\" }\n          }\n        }\n      }\n    }\n  },\n  \"condition\" : {\n    \"compare\" : { \"ctx.payload.hits.total\" : { \"gt\" : 0 }} <1>\n  }\n}\n--------------------------------------------------\n\n<1> The <<condition-compare,compare>> condition lets you easily compare against\n    values in the execution context.\n\nFor this compare condition to evaluate to `true`, you need to add an event\nto the `logs` index that contains an error. For example, the following request\nadds a 404 error to the `logs` index:\n\n[source,console]\n--------------------------------------------------\nPOST logs/_doc\n{\n  \"timestamp\": \"2015-05-17T18:12:07.613Z\",\n  \"request\": \"GET index.html\",\n  \"status_code\": 404,\n  \"message\": \"Error: File not found\"\n}\n--------------------------------------------------\n// TEST[continued]\n\nOnce you add this event, the next time the watch executes its condition will\nevaluate to `true`. The condition result is recorded as part of the\n`watch_record` each time the watch executes, so you can verify whether or\nnot the condition was met by searching the watch history:\n\n[source,console]\n--------------------------------------------------\nGET .watcher-history*/_search?pretty\n{\n  \"query\" : {\n    \"bool\" : {\n      \"must\" : [\n        { \"match\" : { \"result.condition.met\" : true }},\n        { \"range\" : { \"result.execution_time\" : { \"gte\" : \"now-10s\" }}}\n      ]\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[discrete]\n[[log-take-action]]\n=== Configure an action\n\nRecording watch records in the watch history is nice, but the real power of\n{watcher} is being able to do something when the watch condition is met. A\nwatch's <<actions,actions>> define what to do when the watch condition\nevaluates to `true`. You can send emails, call third-party webhooks, write\ndocuments to an Elasticsearch index, or log messages to the standard\nElasticsearch log files.\n\nFor example, the following action writes a message to the Elasticsearch\nlog when an error is detected.\n\n[source,console]\n--------------------------------------------------\nPUT _watcher/watch/log_error_watch\n{\n  \"trigger\" : { \"schedule\" : { \"interval\" : \"10s\" }},\n  \"input\" : {\n    \"search\" : {\n      \"request\" : {\n        \"indices\" : [ \"logs\" ],\n        \"body\" : {\n          \"query\" : {\n            \"match\" : { \"message\": \"error\" }\n          }\n        }\n      }\n    }\n  },\n  \"condition\" : {\n    \"compare\" : { \"ctx.payload.hits.total\" : { \"gt\" : 0 }}\n  },\n  \"actions\" : {\n    \"log_error\" : {\n      \"logging\" : {\n        \"text\" : \"Found {{ctx.payload.hits.total}} errors in the logs\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n[discrete]\n[[log-delete]]\n=== Delete the Watch\n\nSince the `log_error_watch` is configured to run every 10 seconds, make sure you\ndelete it when you're done experimenting. Otherwise, the noise from this sample\nwatch will make it hard to see what else is going on in your watch history and\nlog file.\n\nTo remove the watch, use the <<watcher-api-delete-watch,delete watch API>>:\n\n[source,console]\n--------------------------------------------------\nDELETE _watcher/watch/log_error_watch\n--------------------------------------------------\n// TEST[continued]\n\n[discrete]\n[[required-security-privileges]]\n=== Required security privileges\nTo enable users to create and manipulate watches, assign them the `watcher_admin`\nsecurity role. Watcher admins can also view watches, watch history, and triggered\nwatches.\n\nTo allow users to view watches and the watch history, assign them the `watcher_user`\nsecurity role. Watcher users cannot create or manipulate watches; they are only\nallowed to execute read-only watch operations.\n\n[discrete]\n[[next-steps]]\n=== Where to go next\n\n* See <<how-watcher-works>> for more information about the\nanatomy of a watch and the watch lifecycle.\n* See <<example-watches>> for more examples of setting up\na watch.\n* See the https://github.com/elastic/examples/tree/master/Alerting[Example\nWatches] in the Elastic Examples repo for additional sample watches you can use\nas a starting point for building custom watches.\n"
}