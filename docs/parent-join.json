{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.149579",
        "size": 13512,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/parent-join.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "parent-join",
        "version": "8.15"
    },
    "doc": "[[parent-join]]\n=== Join field type\n++++\n<titleabbrev>Join</titleabbrev>\n++++\n\nThe `join` data type is a special field that creates\nparent/child relation within documents of the same index.\nThe `relations` section defines a set of possible relations within the documents,\neach relation being a parent name and a child name.\n\n// tag::multi-level-join-warning[]\nWARNING: We don't recommend using multiple levels of relations to replicate a\nrelational model. Each level of relation adds an overhead at query time in terms\nof memory and computation. For better search performance, denormalize your data\ninstead.\n// end::multi-level-join-warning[]\n\nA parent/child relation can be defined as follows:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my_id\": {\n        \"type\": \"keyword\"\n      },\n      \"my_join_field\": { <1>\n        \"type\": \"join\",\n        \"relations\": {\n          \"question\": \"answer\" <2>\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> The name for the field\n<2> Defines a single relation where `question` is parent of `answer`.\n\nTo index a document with a join, the name of the relation and the optional parent\nof the document must be provided in the `source`.\nFor instance the following example creates two `parent` documents in the `question` context:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001/_doc/1?refresh\n{\n  \"my_id\": \"1\",\n  \"text\": \"This is a question\",\n  \"my_join_field\": {\n    \"name\": \"question\" <1>\n  }\n}\n\nPUT my-index-000001/_doc/2?refresh\n{\n  \"my_id\": \"2\",\n  \"text\": \"This is another question\",\n  \"my_join_field\": {\n    \"name\": \"question\"\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n<1> This document is a `question` document.\n\nWhen indexing parent documents, you can choose to specify just the name of the relation\nas a shortcut instead of encapsulating it in the normal object notation:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001/_doc/1?refresh\n{\n  \"my_id\": \"1\",\n  \"text\": \"This is a question\",\n  \"my_join_field\": \"question\" <1>\n}\n\nPUT my-index-000001/_doc/2?refresh\n{\n  \"my_id\": \"2\",\n  \"text\": \"This is another question\",\n  \"my_join_field\": \"question\"\n}\n--------------------------------------------------\n// TEST[continued]\n\n<1> Simpler notation for a parent document just uses the relation name.\n\nWhen indexing a child, the name of the relation as well as the parent id of the document\nmust be added in the `_source`.\n\nWARNING: It is required to index the lineage of a parent in the same shard so you must\nalways route child documents using their greater parent id.\n\nFor instance the following example shows how to index two `child` documents:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001/_doc/3?routing=1&refresh <1>\n{\n  \"my_id\": \"3\",\n  \"text\": \"This is an answer\",\n  \"my_join_field\": {\n    \"name\": \"answer\", <2>\n    \"parent\": \"1\" <3>\n  }\n}\n\nPUT my-index-000001/_doc/4?routing=1&refresh\n{\n  \"my_id\": \"4\",\n  \"text\": \"This is another answer\",\n  \"my_join_field\": {\n    \"name\": \"answer\",\n    \"parent\": \"1\"\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n<1> The routing value is mandatory because parent and child documents must be indexed on the same shard\n<2> `answer` is the name of the join for this document\n<3> The parent id of this child document\n\n==== Parent-join and performance\n\nThe join field shouldn't be used like joins in a relation database. In Elasticsearch the key to good performance\nis to de-normalize your data into documents. Each join field, `has_child` or `has_parent` query adds a\nsignificant tax to your query performance. It can also trigger <<eager-global-ordinals, global ordinals>> to be built.\n\nThe only case where the join field makes sense is if your data contains a one-to-many relationship where\none entity significantly outnumbers the other entity. An example of such case is a use case with products\nand offers for these products. In the case that offers significantly outnumbers the number of products then\nit makes sense to model the product as parent document and the offer as child document.\n\n==== Parent-join restrictions\n\n* Only one `join` field mapping is allowed per index.\n* Parent and child documents must be indexed on the same shard.\n  This means that the same `routing` value needs to be provided when\n  <<docs-get,getting>>, <<docs-delete,deleting>>, or <<docs-update,updating>>\n  a child document.\n* An element can have multiple children but only one parent.\n* It is possible to add a new relation to an existing `join` field.\n* It is also possible to add a child to an existing element\n  but only if the element is already a parent.\n\n==== Searching with parent-join\n\nThe parent-join creates one field to index the name of the relation\nwithin the document (`my_parent`, `my_child`, ...).\n\nIt also creates one field per parent/child relation.\nThe name of this field is the name of the `join` field followed by `#` and the\nname of the parent in the relation.\nSo for instance for the `my_parent` -> [`my_child`, `another_child`] relation,\nthe `join` field creates an additional field named `my_join_field#my_parent`.\n\nThis field contains the parent `_id` that the document links to\nif the document is a child (`my_child` or `another_child`) and the `_id` of\ndocument if it's a parent (`my_parent`).\n\nWhen searching an index that contains a `join` field, these two fields are always\nreturned in the search response:\n\n[source,console]\n--------------------------\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\"my_id\"]\n}\n--------------------------\n// TEST[continued]\n\nWill return:\n\n[source,console-result]\n--------------------------------------------------\n{\n  ...,\n  \"hits\": {\n    \"total\": {\n      \"value\": 4,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": null,\n    \"hits\": [\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"1\",\n        \"_score\": null,\n        \"_source\": {\n          \"my_id\": \"1\",\n          \"text\": \"This is a question\",\n          \"my_join_field\": \"question\"         <1>\n        },\n        \"sort\": [\n          \"1\"\n        ]\n      },\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"2\",\n        \"_score\": null,\n        \"_source\": {\n          \"my_id\": \"2\",\n          \"text\": \"This is another question\",\n          \"my_join_field\": \"question\"          <2>\n        },\n        \"sort\": [\n          \"2\"\n        ]\n      },\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"3\",\n        \"_score\": null,\n        \"_routing\": \"1\",\n        \"_source\": {\n          \"my_id\": \"3\",\n          \"text\": \"This is an answer\",\n          \"my_join_field\": {\n            \"name\": \"answer\",                 <3>\n            \"parent\": \"1\"                     <4>\n          }\n        },\n        \"sort\": [\n          \"3\"\n        ]\n      },\n      {\n        \"_index\": \"my-index-000001\",\n        \"_id\": \"4\",\n        \"_score\": null,\n        \"_routing\": \"1\",\n        \"_source\": {\n          \"my_id\": \"4\",\n          \"text\": \"This is another answer\",\n          \"my_join_field\": {\n            \"name\": \"answer\",\n            \"parent\": \"1\"\n          }\n        },\n        \"sort\": [\n          \"4\"\n        ]\n      }\n    ]\n  }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\\.\\.\\./\"timed_out\": false, \"took\": $body.took, \"_shards\": $body._shards/]\n\n<1> This document belongs to the `question` join\n<2> This document belongs to the `question` join\n<3> This document belongs to the `answer` join\n<4> The linked parent id for the child document\n\n==== Parent-join queries and aggregations\n\nSee the <<query-dsl-has-child-query,`has_child`>> and\n<<query-dsl-has-parent-query,`has_parent`>> queries,\nthe <<search-aggregations-bucket-children-aggregation,`children`>> aggregation,\nand <<parent-child-inner-hits,inner hits>> for more information.\n\nThe value of the `join` field is accessible in aggregations\nand scripts, and may be queried with the\n<<query-dsl-parent-id-query, `parent_id` query>>:\n\n[source,console]\n----\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"parent_id\": { <1>\n      \"type\": \"answer\",\n      \"id\": \"1\"\n    }\n  },\n  \"aggs\": {\n    \"parents\": {\n      \"terms\": {\n        \"field\": \"my_join_field#question\", <2>\n        \"size\": 10\n      }\n    }\n  },\n  \"runtime_mappings\": {\n    \"parent\": {\n      \"type\": \"long\",\n      \"script\": \"\"\"\n        emit(Integer.parseInt(doc['my_join_field#question'].value)) <3>\n      \"\"\"\n    }\n  },\n  \"fields\": [\n    { \"field\": \"parent\" }\n  ]\n}\n----\n// TEST[continued]\n// TEST[s/_search/_search?filter_path=aggregations,hits.hits&sort=my_id/]\n<1> Querying the `parent id` field (also see the <<query-dsl-has-parent-query,`has_parent` query>> and the <<query-dsl-has-child-query,`has_child` query>>)\n<2> Aggregating on the `parent id` field (also see the <<search-aggregations-bucket-children-aggregation,`children`>> aggregation)\n<3> Accessing the `parent id` field in scripts. \n\n////\n[source,console-result]\n----\n{\n  \"aggregations\": {\n    \"parents\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"1\",\n          \"doc_count\": 2\n        }\n      ]\n    }\n  },\n  \"hits\": {\n    \"hits\": [\n      {\n        \"_id\": \"3\",\n        \"_index\": \"my-index-000001\",\n        \"_score\": null,\n        \"_routing\": \"1\",\n        \"_source\": $body.hits.hits.0._source,\n        \"fields\": {\n          \"parent\": [1]\n        },\n        \"sort\": [\"3\"]\n      },\n      {\n        \"_id\": \"4\",\n        \"_index\": \"my-index-000001\",\n        \"_score\": null,\n        \"_routing\": \"1\",\n        \"_source\": $body.hits.hits.1._source,\n        \"fields\": {\n          \"parent\": [1]\n        },\n        \"sort\": [\"4\"]\n      }\n    ]\n  }\n}\n----\n////\n\n==== Global ordinals\n\nThe `join` field uses <<eager-global-ordinals,global ordinals>> to speed up joins.\nGlobal ordinals need to be rebuilt after any change to a shard. The more\nparent id values are stored in a shard, the longer it takes to rebuild the\nglobal ordinals for the `join` field.\n\nGlobal ordinals, by default, are built eagerly: if the index has changed,\nglobal ordinals for the `join` field will be rebuilt as part of the refresh.\nThis can add significant time to the refresh. However most of the times this is the\nright trade-off, otherwise global ordinals are rebuilt when the first parent-join\nquery or aggregation is used. This can introduce a significant latency spike for\nyour users and usually this is worse as multiple global ordinals for the `join`\nfield may be attempt rebuilt within a single refresh interval when many writes\nare occurring.\n\nWhen the `join` field is used infrequently and writes occur frequently it may\nmake sense to disable eager loading:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my_join_field\": {\n        \"type\": \"join\",\n        \"relations\": {\n           \"question\": \"answer\"\n        },\n        \"eager_global_ordinals\": false\n      }\n    }\n  }\n}\n--------------------------------------------------\n\nThe amount of heap used by global ordinals can be checked per parent relation\nas follows:\n\n[source,console]\n--------------------------------------------------\n# Per-index\nGET _stats/fielddata?human&fields=my_join_field#question\n\n# Per-node per-index\nGET _nodes/stats/indices/fielddata?human&fields=my_join_field#question\n--------------------------------------------------\n// TEST[continued]\n\n==== Multiple children per parent\n\nIt is also possible to define multiple children for a single parent:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my_join_field\": {\n        \"type\": \"join\",\n        \"relations\": {\n          \"question\": [\"answer\", \"comment\"]  <1>\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> `question` is parent of `answer` and `comment`.\n\n==== Multiple levels of parent join\n\ninclude::parent-join.asciidoc[tag=multi-level-join-warning]\n\nMultiple levels of parent/child:\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"my_join_field\": {\n        \"type\": \"join\",\n        \"relations\": {\n          \"question\": [\"answer\", \"comment\"],  <1>\n          \"answer\": \"vote\" <2>\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n<1> `question` is parent of `answer` and `comment`\n<2> `answer` is parent of `vote`\n\nThe mapping above represents the following tree:\n\n                         question\n                          /    \\\n                         /      \\\n                      comment  answer\n                                 |\n                                 |\n                                vote\n\nIndexing a grandchild document requires a `routing` value equals\nto the grand-parent (the greater parent of the lineage):\n\n\n[source,console]\n--------------------------------------------------\nPUT my-index-000001/_doc/3?routing=1&refresh <1>\n{\n  \"text\": \"This is a vote\",\n  \"my_join_field\": {\n    \"name\": \"vote\",\n    \"parent\": \"2\" <2>\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n<1> This child document must be on the same shard than its grand-parent and parent\n<2> The parent id of this document (must points to an `answer` document)\n"
}