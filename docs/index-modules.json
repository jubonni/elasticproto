{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.405067",
        "size": 18371,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "index-modules",
        "version": "8.15"
    },
    "doc": "\n[[index-modules]]\n= Index modules\n\nIndex Modules are modules created per index and control all aspects related to\nan index.\n\n[discrete]\n[[index-modules-settings]]\n== Index settings\n\n[[index-modules-settings-description]]\n// tag::index-modules-settings-description-tag[]\nIndex level settings can be set per-index. Settings may be:\n\n_static_::\n\nThey can only be set at index creation time or on a\n<<indices-open-close,closed index>>, or by using the\n<<indices-update-settings,update-index-settings>> API with the\n`reopen` query parameter set to `true` (which automatically\ncloses and reopens impacted indices).\n\n_dynamic_::\n\nThey can be changed on a live index using the\n<<indices-update-settings,update-index-settings>> API.\n// end::index-modules-settings-description-tag[]\n\nCAUTION: You can change any documented index settings on closed indices. However, changing undocumented index settings on closed indices is unsupported and might result in errors.\n\n[discrete]\n=== Static index settings\n\nBelow is a list of all _static_ index settings that are not associated with any\nspecific index module:\n\n[[index-number-of-shards]]\n// tag::index-number-of-shards-tag[]\n`index.number_of_shards`::\nThe number of primary shards that an index should have. Defaults to `1`. This setting can only be set at index creation time. It cannot be changed on a closed index.\n+\nNOTE: The number of shards are limited to `1024` per index. This limitation is a safety limit to prevent accidental creation of indices that can destabilize a cluster due to resource allocation. The limit can be modified by specifying `export ES_JAVA_OPTS=\"-Des.index.max_number_of_shards=128\"` system property on every node that is part of the cluster.\n\n// end::index-number-of-shards-tag[]\n\n[[index-number-of-routing-shards]]\n`index.number_of_routing_shards`::\n+\n====\nInteger value used with <<index-number-of-shards,`index.number_of_shards`>> to\nroute documents to a primary shard. See <<mapping-routing-field>>.\n\n{es} uses this value when <<indices-split-index,splitting>> an index.\nFor example, a 5 shard index with `number_of_routing_shards` set to `30` (`5 x\n2 x 3`) could be split by a factor of `2` or `3`. In other words, it could be\nsplit as follows:\n\n* `5` -> `10` -> `30`  (split by 2, then by 3)\n* `5` -> `15` -> `30` (split by 3, then by 2)\n* `5` -> `30` (split by 6)\n\nThis setting's default value depends on the number of primary shards in the\nindex. The default is designed to allow you to split by factors of 2 up\nto a maximum of 1024 shards.\n\nNOTE: In {es} 7.0.0 and later versions, this setting affects how documents are\ndistributed across shards. When reindexing an older index with custom routing,\nyou must explicitly set `index.number_of_routing_shards` to maintain the same\ndocument distribution. See the\n{ref-70}/breaking-changes-7.0.html#_document_distribution_changes[related\nbreaking change].\n====\n\n[[index-codec]] `index.codec`::\n\n    The +default+ value compresses stored data with LZ4\n    compression, but this can be set to +best_compression+\n    which uses {wikipedia}/Zstd[ZSTD] for a higher\n    compression ratio, at the expense of slower stored fields read performance.\n    If you are updating the compression type, the new one will be applied\n    after segments are merged. Segment merging can be forced using\n    <<indices-forcemerge,force merge>>. Experiments with indexing log datasets\n    have shown that `best_compression` gives up to ~28% lower storage usage and\n    similar indexing throughput (sometimes a bit slower or faster depending on other used options) compared\n    to `default` while affecting get by id latencies between ~10% and ~33%. The higher get\n    by id latencies is not a concern for many use cases like logging or metrics, since\n    these don't really rely on get by id functionality (Get APIs or searching by _id).\n\n[[index-mode-setting]] `index.mode`::\n+\nThe `index.mode` setting is used to control settings applied in specific domains like ingestion of time series data or logs.\nDifferent mutually exclusive modes exist, which are used to apply settings or default values controlling indexing of documents,\nsorting and other parameters whose value affects indexing or query performance.\n+\n[source,console]\n----------------\nPUT my-index-000001\n{\n  \"settings\": {\n    \"index\":{\n      \"mode\":\"standard\" <1>\n    }\n  }\n}\n----------------\n+\n<1> This index uses the `standard` index mode\n+\nIndex mode supports the following values:\n\n`null`::: Default value (same as `standard`).\n\n`standard`::: Standard indexing with default settings.\n\n`time_series`::: Index mode optimized for storage of metrics documented in <<tsds-index-settings,TSDS Settings>>.\n\n`logsdb`::: Index mode optimized for storage of logs. It applies default sort settings on the `hostname` and `timestamp` fields and uses <<synthetic-source,synthetic `_source`>>. <<index-modules-index-sorting,Index sorting>> on different fields is still allowed.\npreview:[]\n\n[[routing-partition-size]] `index.routing_partition_size`::\n\n    The number of shards a custom <<mapping-routing-field,routing>> value can go to.\n    Defaults to 1 and can only be set at index creation time. This value must be less\n    than the `index.number_of_routing_shards` unless the `index.number_of_routing_shards` value is also 1.\n    See <<routing-index-partition>> for more details about how this setting is used.\n\n[[ccr-index-soft-deletes]]\n// tag::ccr-index-soft-deletes-tag[]\n`index.soft_deletes.enabled`::\ndeprecated:[7.6.0, Creating indices with soft-deletes disabled is deprecated and will be removed in future Elasticsearch versions.]\nIndicates whether soft deletes are enabled on the index. Soft deletes can only\nbe configured at index creation and only on indices created on or after\n{es} 6.5.0. Defaults to `true`.\n// end::ccr-index-soft-deletes-tag[]\n\n[[ccr-index-soft-deletes-retention-period]]\n//tag::ccr-index-soft-deletes-retention-tag[]\n`index.soft_deletes.retention_lease.period`::\nThe maximum period to retain a shard history retention lease before it is\nconsidered expired. Shard history retention leases ensure that soft deletes are\nretained during merges on the Lucene index. If a soft delete is merged away\nbefore it can be replicated to a follower the following process will fail due\nto incomplete history on the leader. Defaults to `12h`.\n//end::ccr-index-soft-deletes-retention-tag[]\n\n[[load-fixed-bitset-filters-eagerly]] `index.load_fixed_bitset_filters_eagerly`::\n\n    Indicates whether <<query-filter-context, cached filters>> are pre-loaded for\n    nested queries. Possible values are `true` (default) and `false`.\n\n[[index-shard-check-on-startup]] `index.shard.check_on_startup`::\n+\n====\nWARNING: Expert users only. This setting enables some very expensive processing\nat shard startup and is only ever useful while diagnosing a problem in your\ncluster. If you do use it, you should do so only temporarily and remove it\nonce it is no longer needed.\n\n{es} automatically performs integrity checks on the contents of shards at\nvarious points during their lifecycle. For instance, it verifies the checksum\nof every file transferred when recovering a replica or taking a snapshot. It\nalso verifies the integrity of many important files when opening a shard, which\nhappens when starting up a node and when finishing a shard recovery or\nrelocation. You can therefore manually verify the integrity of a whole shard\nwhile it is running by taking a snapshot of it into a fresh repository or by\nrecovering it onto a fresh node.\n\nThis setting determines whether {es} performs additional integrity checks while\nopening a shard. If these checks detect corruption then they will prevent the\nshard from being opened. It accepts the following values:\n\n`false`::: Don't perform additional checks for corruption when opening a shard.\nThis is the default and recommended behaviour.\n\n`checksum`::: Verify that the checksum of every file in the shard matches its\ncontents. This will detect cases where the data read from disk differ from the\ndata that {es} originally wrote, for instance due to undetected disk corruption\nor other hardware failures. These checks require reading the entire shard from\ndisk which takes substantial time and IO bandwidth and may affect cluster\nperformance by evicting important data from your filesystem cache.\n\n`true`::: Performs the same checks as `checksum` and also checks for logical\ninconsistencies in the shard, which could for instance be caused by the data\nbeing corrupted while it was being written due to faulty RAM or other hardware\nfailures. These checks require reading the entire shard from disk which takes\nsubstantial time and IO bandwidth, and then performing various checks on the\ncontents of the shard which take substantial time, CPU and memory.\n====\n\n[discrete]\n[[dynamic-index-settings]]\n=== Dynamic index settings\n\nBelow is a list of all _dynamic_ index settings that are not associated with any\nspecific index module:\n\n[[dynamic-index-number-of-replicas]]\n`index.number_of_replicas`::\n\n    The number of replicas each primary shard has. Defaults to 1.\n\n    WARNING: Configuring it to 0 may lead to temporary availability loss\n    during node restarts or permanent data loss in case of data corruption.\n\n[[dynamic-index-auto-expand-replicas]]\n`index.auto_expand_replicas`::\nAuto-expand the number of replicas based on the number of data nodes in the\ncluster. Set to a dash delimited lower and upper bound (e.g. `0-5`) or use `all`\nfor the upper bound (e.g. `0-all`). Defaults to `false` (i.e. disabled). Note\nthat the auto-expanded number of replicas only takes\n<<shard-allocation-filtering,allocation filtering>> rules into account, but\nignores other allocation rules such as <<allocation-total-shards,total shards\nper node>>, and this can lead to the cluster health becoming `YELLOW` if the\napplicable rules prevent all the replicas from being allocated.\n+\nIf the upper bound is `all` then <<shard-allocation-awareness,shard allocation\nawareness>> and\n<<cluster-routing-allocation-same-shard-host,`cluster.routing.allocation.same_shard.host`>>\nare ignored for this index.\n\n[[dynamic-index-search-idle-after]]\n`index.search.idle.after`::\n    How long a shard can not receive a search or get request until it's considered\n    search idle. (default is `30s`)\n\n[[index-refresh-interval-setting]]\n`index.refresh_interval`::\n\n    How often to perform a refresh operation, which makes recent changes to the\n    index visible to search. Defaults to `1s`. Can be set to `-1` to disable\n    refresh. If this setting is not explicitly set, shards that haven't seen\n    search traffic for at least `index.search.idle.after` seconds will not receive\n    background refreshes until they receive a search request. Searches that hit an\n    idle shard where a refresh is pending will trigger a refresh as part of the\n    search operation for that shard only. This behavior aims to automatically optimize\n    bulk indexing in the default case when no searches are performed. In order to opt\n    out of this behavior an explicit value of `1s` should set as the refresh\n    interval.\n\n[[index-max-result-window]]\n`index.max_result_window`::\n\n    The maximum value of `from + size` for searches to this index. Defaults to\n    `10000`. Search requests take heap memory and time proportional to\n    `from + size` and this limits that memory. See\n    <<scroll-search-results,Scroll>> or <<search-after,Search After>> for a more efficient alternative\n    to raising this.\n\n`index.max_inner_result_window`::\n\n    The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. Defaults to\n    `100`. Inner hits and top hits aggregation take heap memory and time proportional to `from + size` and this limits that memory.\n\n`index.max_rescore_window`::\n\n    The maximum value of `window_size` for `rescore` requests in searches of this index.\n    Defaults to `index.max_result_window` which defaults to `10000`. Search\n    requests take heap memory and time proportional to\n    `max(window_size, from + size)` and this limits that memory.\n\n`index.max_docvalue_fields_search`::\n\n    The maximum number of `docvalue_fields` that are allowed in a query.\n    Defaults to `100`. Doc-value fields are costly since they might incur\n    a per-field per-document seek.\n\n`index.max_script_fields`::\n\n    The maximum number of `script_fields` that are allowed in a query.\n    Defaults to `32`.\n\n[[index-max-ngram-diff]]\n`index.max_ngram_diff`::\n\n    The maximum allowed difference between min_gram and max_gram for NGramTokenizer and NGramTokenFilter.\n    Defaults to `1`.\n\n[[index-max-shingle-diff]]\n`index.max_shingle_diff`::\n\n    The maximum allowed difference between max_shingle_size and min_shingle_size\n    for the <<analysis-shingle-tokenfilter,`shingle` token filter>>. Defaults to\n    `3`.\n\n`index.max_refresh_listeners`::\n\n    Maximum number of refresh listeners available on each shard of the index.\n    These listeners are used to implement <<docs-refresh,`refresh=wait_for`>>.\n\n `index.analyze.max_token_count`::\n\n    The maximum number of tokens that can be produced using _analyze API.\n    Defaults to `10000`.\n\n[[index-max-analyzed-offset]]\n `index.highlight.max_analyzed_offset`::\n\n     The maximum number of characters that will be analyzed for a highlight request.\n     This setting is only applicable when highlighting is requested on a text that was indexed without offsets or term vectors.\n     Defaults to `1000000`.\n\n[[index-max-terms-count]]\n `index.max_terms_count`::\n\n    The maximum number of terms that can be used in Terms Query.\n    Defaults to `65536`.\n\n[[index-max-regex-length]]\n `index.max_regex_length`::\n\n    The maximum length of value that can be used in `regexp` or `prefix` query.\n    Defaults to `1000`.\n\n[[index-query-default-field]]\n`index.query.default_field`::\n+\n--\n(string or array of strings)\nWildcard (`*`) patterns matching one or more fields. The following query types\nsearch these matching fields by default:\n\n* <<query-dsl-mlt-query>>\n* <<query-dsl-multi-match-query>>\n* <<query-dsl-query-string-query>>\n* <<query-dsl-simple-query-string-query>>\n\nDefaults to `*`, which matches all fields eligible for\n<<term-level-queries,term-level queries>>, excluding metadata fields.\n--\n\n[[index-routing-allocation-enable-setting]]\n `index.routing.allocation.enable`::\n\n    Controls shard allocation for this index. It can be set to:\n    * `all` (default) - Allows shard allocation for all shards.\n    * `primaries` - Allows shard allocation only for primary shards.\n    * `new_primaries` - Allows shard allocation only for newly-created primary shards.\n    * `none` - No shard allocation is allowed.\n\n `index.routing.rebalance.enable`::\n\n    Enables shard rebalancing for this index. It can be set to:\n    * `all` (default) - Allows shard rebalancing for all shards.\n    * `primaries` - Allows shard rebalancing only for primary shards.\n    * `replicas` - Allows shard rebalancing only for replica shards.\n    * `none` - No shard rebalancing is allowed.\n\n `index.gc_deletes`::\n\n    The length of time that a <<delete-versioning,deleted document's version number>> remains available for <<index-versioning,further versioned operations>>.\n    Defaults to `60s`.\n\n[[index-default-pipeline]]\n `index.default_pipeline`::\n\n    Default <<ingest,ingest pipeline>> for the index. Index requests will fail\n    if the default pipeline is set and the pipeline does not exist. The default may be\n    overridden using the `pipeline` parameter. The special pipeline name `_none` indicates\n    no default ingest pipeline will run.\n\n[[index-final-pipeline]]\n`index.final_pipeline`::\nFinal <<ingest,ingest pipeline>> for the index. Indexing requests\nwill fail if the final pipeline is set and the pipeline does not exist.\nThe final pipeline always runs after the request pipeline (if specified) and\nthe default pipeline (if it exists). The special pipeline name `_none`\nindicates no final ingest pipeline will run.\n+\nNOTE: You can't use a final pipeline to change the `_index` field. If the\npipeline attempts to change the `_index` field, the indexing request will fail.\n\n[[index-hidden]] `index.hidden`::\n\n    Indicates whether the index should be hidden by default. Hidden indices are not\n    returned by default when using a wildcard expression. This behavior is controlled\n    per request through the use of the `expand_wildcards` parameter. Possible values are\n    `true` and `false` (default).\n\n[discrete]\n=== Settings in other index modules\n\nOther index settings are available in index modules:\n\n<<analysis,Analysis>>::\n\n    Settings to define analyzers, tokenizers, token filters and character\n    filters.\n\n<<index-modules-allocation,Index shard allocation>>::\n\n    Control over where, when, and how shards are allocated to nodes.\n\n<<index-modules-mapper,Mapping>>::\n\n    Enable or disable dynamic mapping for an index.\n\n<<index-modules-merge,Merging>>::\n\n    Control over how shards are merged by the background merge process.\n\n<<index-modules-similarity,Similarities>>::\n\n    Configure custom similarity settings to customize how search results are\n    scored.\n\n<<index-modules-slowlog,Slowlog>>::\n\n    Control over how slow queries and fetch requests are logged.\n\n<<index-modules-store,Store>>::\n\n    Configure the type of filesystem used to access shard data.\n\n<<index-modules-translog,Translog>>::\n\n    Control over the transaction log and background flush operations.\n\n<<index-modules-history-retention,History retention>>::\n\n    Control over the retention of a history of operations in the index.\n\n<<index-modules-indexing-pressure,Indexing pressure>>::\n\n    Configure indexing back pressure limits.\n\n[discrete]\n[[x-pack-index-settings]]\n=== [xpack]#{xpack} index settings#\n\n<<ilm-settings,{ilm-cap}>>::\n\n    Specify the lifecycle policy and rollover alias for an index.\n\ninclude::index-modules/analysis.asciidoc[]\n\ninclude::index-modules/allocation.asciidoc[]\n\ninclude::index-modules/blocks.asciidoc[]\n\ninclude::index-modules/mapper.asciidoc[]\n\ninclude::index-modules/merge.asciidoc[]\n\ninclude::index-modules/similarity.asciidoc[]\n\ninclude::index-modules/slowlog.asciidoc[]\n\ninclude::index-modules/store.asciidoc[]\n\ninclude::index-modules/translog.asciidoc[]\n\ninclude::index-modules/history-retention.asciidoc[]\n\ninclude::index-modules/index-sorting.asciidoc[]\n\ninclude::index-modules/indexing-pressure.asciidoc[]\n"
}