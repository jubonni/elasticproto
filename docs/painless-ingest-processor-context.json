{
    "meta": {
        "timestamp": "2024-11-01T03:02:53.108580",
        "size": 5657,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-ingest-processor-context.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-ingest-processor-context",
        "version": "8.15"
    },
    "doc": "[[painless-ingest-processor-context]]\n=== Ingest processor context\n\nUse a Painless script in an {ref}/script-processor.html[ingest processor]\nto modify documents upon insertion.\n\n*Variables*\n\n`params` (`Map`, read-only)::\n        User-defined parameters passed in as part of the query.\n\n{ref}/mapping-index-field.html[`ctx['_index']`] (`String`)::\n        The name of the index.\n\n`ctx` (`Map`)::\n        Contains extracted JSON in a `Map` and `List` structure for the fields\n        that are part of the document.\n\n*Side Effects*\n\n{ref}/mapping-index-field.html[`ctx['_index']`]::\n        Modify this to change the destination index for the current document.\n\n`ctx` (`Map`)::\n        Modify the values in the `Map/List` structure to add, modify, or delete\n        the fields of a document.\n\n*Return*\n\nvoid::\n        No expected return value.\n\n*API*\n\nBoth the standard <<painless-api-reference-shared, Painless API>> and\n<<painless-api-reference-ingest, Specialized Ingest API>> are available.\n\n*Example*\n\nTo run this example, first follow the steps in\n<<painless-context-examples, context examples>>.\n\nThe seat data contains:\n\n* A date in the format `YYYY-MM-DD` where the second digit of both month and day\n  is optional.\n* A time in the format HH:MM* where the second digit of both hours and minutes\n  is optional. The star (*) represents either the `String` `AM` or `PM`.\n\nThe following ingest script processes the date and time `Strings` and stores the\nresult in a `datetime` field.\n\n[source,Painless]\n----\nString[] dateSplit = ctx.date.splitOnToken(\"-\");                     <1>\nString year = dateSplit[0].trim();\nString month = dateSplit[1].trim();\n\nif (month.length() == 1) {                                           <2>\n    month = \"0\" + month;\n}\n\nString day = dateSplit[2].trim();\n\nif (day.length() == 1) {                                             <3>\n    day = \"0\" + day;\n}\n\nboolean pm = ctx.time.substring(ctx.time.length() - 2).equals(\"PM\"); <4>\nString[] timeSplit = ctx.time.substring(0,\n        ctx.time.length() - 2).splitOnToken(\":\");                    <5>\nint hours = Integer.parseInt(timeSplit[0].trim());\nint minutes = Integer.parseInt(timeSplit[1].trim());\n\nif (pm) {                                                            <6>\n    hours += 12;\n}\n\nString dts = year + \"-\" + month + \"-\" + day + \"T\" +\n        (hours < 10 ? \"0\" + hours : \"\" + hours) + \":\" +\n        (minutes < 10 ? \"0\" + minutes : \"\" + minutes) +\n        \":00+08:00\";                                                 <7>\n\nZonedDateTime dt = ZonedDateTime.parse(\n         dts, DateTimeFormatter.ISO_OFFSET_DATE_TIME);               <8>\nctx.datetime = dt.getLong(ChronoField.INSTANT_SECONDS)*1000L;        <9>\n----\n<1> Uses the `splitOnToken` function to separate the date `String` from the\n    seat data into year, month, and day `Strings`.\n    Note::\n    * The use of the `ctx` ingest processor context variable to retrieve the\n      data from the `date` field.\n<2> Appends the <<string-literals, string literal>> `\"0\"` value to a single\n    digit month since the format of the seat data allows for this case.\n<3> Appends the <<string-literals, string literal>> `\"0\"` value to a single\n    digit day since the format of the seat data allows for this case.\n<4> Sets the <<primitive-types, `boolean type`>>\n     <<painless-variables, variable>> to `true` if the time `String` is a time\n     in the afternoon or evening.\n     Note::\n     * The use of the `ctx` ingest processor context variable to retrieve the\n       data from the `time` field.\n<5> Uses the `splitOnToken` function to separate the time `String` from the\n     seat data into hours and minutes `Strings`.\n     Note::\n     * The use of the `substring` method to remove the `AM` or `PM` portion of\n       the time `String`.\n     * The use of the `ctx` ingest processor context variable to retrieve the\n       data from the `date` field.\n<6> If the time `String` is an afternoon or evening value adds the\n     <<integer-literals, integer literal>> `12` to the existing hours to move to\n     a 24-hour based time.\n<7> Builds a new time `String` that is parsable using existing API methods.\n<8> Creates a `ZonedDateTime` <<reference-types, reference type>> value by using\n     the API method `parse` to parse the new time `String`.\n<9> Sets the datetime field `datetime` to the number of milliseconds retrieved\n     from the API method `getLong`.\n     Note::\n     * The use of the `ctx` ingest processor context variable to set the field\n       `datetime`. Manipulate each document's fields with the `ctx` variable as\n       each document is indexed.\n\nSubmit the following request:\n\n[source,console]\n----\nPUT /_ingest/pipeline/seats\n{\n  \"description\": \"update datetime for seats\",\n  \"processors\": [\n    {\n      \"script\": {\n        \"source\": \"String[] dateSplit = ctx.date.splitOnToken('-'); String year = dateSplit[0].trim(); String month = dateSplit[1].trim(); if (month.length() == 1) { month = '0' + month; } String day = dateSplit[2].trim(); if (day.length() == 1) { day = '0' + day; } boolean pm = ctx.time.substring(ctx.time.length() - 2).equals('PM'); String[] timeSplit = ctx.time.substring(0, ctx.time.length() - 2).splitOnToken(':'); int hours = Integer.parseInt(timeSplit[0].trim()); int minutes = Integer.parseInt(timeSplit[1].trim()); if (pm) { hours += 12; } String dts = year + '-' + month + '-' + day + 'T' + (hours < 10 ? '0' + hours : '' + hours) + ':' + (minutes < 10 ? '0' + minutes : '' + minutes) + ':00+08:00'; ZonedDateTime dt = ZonedDateTime.parse(dts, DateTimeFormatter.ISO_OFFSET_DATE_TIME); ctx.datetime = dt.getLong(ChronoField.INSTANT_SECONDS)*1000L;\"\n      }\n    }\n  ]\n}\n----\n"
}