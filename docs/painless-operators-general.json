{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.861067",
        "size": 12654,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-operators-general.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "painless-operators-general",
        "version": "8.15"
    },
    "doc": "[[painless-operators-general]]\n=== Operators: General\n\n[[precedence-operator]]\n==== Precedence\n\nUse the `precedence operator '()'` to guarantee the order of evaluation for an\nexpression. An expression encapsulated by the precedence operator (enclosed in\nparentheses) overrides existing precedence relationships between operators and\nis evaluated prior to other expressions in inward-to-outward order.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nprecedence: '(' expression ')';\n----\n\n*Examples*\n\n* Precedence with numeric operators.\n+\n[source,Painless]\n----\nint x = (5+4)*6;   <1>\nint y = 12/(x-50); <2>\n----\n+\n<1> declare `int x`;\n    add `int 5` and `int 4` -> `int 9`;\n    multiply `int 9` and `int 6` -> `int 54`;\n    store `int 54` to `x`;\n    (note the add is evaluated before the multiply due to the precedence\n            operator)\n<2> declare `int y`;\n    load from `x` -> `int 54`;\n    subtract `int 50` from `int 54` -> `int 4`;\n    divide `int 12` by `int 4` -> `int 3`;\n    store `int 3` to `y`;\n    (note the subtract is evaluated before the divide due to the precedence\n            operator)\n\n[[function-call-operator]]\n==== Function Call\n\nUse the `function call operator ()` to call an existing function. A\n<<painless-functions, function call>> is defined within a script.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nfunction_call: ID '(' ( expression (',' expression)* )? ')'';\n----\n\n*Examples*\n\n* A function call.\n+\n[source,Painless]\n----\nint add(int x, int y) { <1>\n      return x + y;\n  }\n\nint z = add(1, 2); <2>\n----\n+\n<1> define function `add` that returns `int` and has parameters (`int x`,\n            `int y`)\n<2> declare `int z`;\n    call `add` with arguments (`int 1`, `int 2`) -> `int 3`;\n    store `int 3` to `z`\n\n[[cast-operator]]\n==== Cast\n\nAn explicit cast converts the value of an original type to the equivalent value\nof a target type forcefully as an operation. Use the `cast operator '()'` to\nspecify an explicit cast. Refer to <<painless-casting, casting>> for more\ninformation.\n\n[[conditional-operator]]\n==== Conditional\n\nA conditional consists of three expressions. The first expression is evaluated\nwith an expected boolean result type. If the first expression evaluates to true\nthen the second expression will be evaluated. If the first expression evaluates\nto false then the third expression will be evaluated. The second and third\nexpressions will be <<promotion, promoted>> if the evaluated values are not the\nsame type. Use the `conditional operator '? :'` as a shortcut to avoid the need\nfor a full if/else branch in certain expressions.\n\n*Errors*\n\n* If the first expression does not evaluate to a boolean type value.\n* If the values for the second and third expressions cannot be promoted.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nconditional: expression '?' expression ':' expression;\n----\n\n*Promotion*\n\n[cols=\"<1,^1,^1,^1,^1,^1,^1,^1,^1,^1\"]\n|====\n|           | byte   | short  | char   | int    | long   | float  | double | Reference | def\n| byte      | int    | int    | int    | int    | long   | float  | double | -         | def\n| short     | int    | int    | int    | int    | long   | float  | double | -         | def\n| char      | int    | int    | int    | int    | long   | float  | double | -         | def\n| int       | int    | int    | int    | int    | long   | float  | double | -         | def\n| long      | long   | long   | long   | long   | long   | float  | double | -         | def\n| float     | float  | float  | float  | float  | float  | float  | double | -         | def\n| double    | double | double | double | double | double | double | double | -         | def\n| Reference | -      | -      | -      | -      | -      | -      | -      | Object @  | def\n| def       | def    | def    | def    | def    | def    | def    | def    | def       | def\n|====\n\n@ If the two reference type values are the same then this promotion will not\noccur.\n\n*Examples*\n\n* Evaluation of conditionals.\n+\n[source,Painless]\n----\nboolean b = true;        <1>\nint x = b ? 1 : 2;       <2>\nList y = x > 1 ? new ArrayList() : null; <3>\ndef z = x < 2 ? x : 2.0; <4>\n----\n+\n<1> declare `boolean b`;\n    store `boolean true` to `b`\n<2> declare `int x`;\n    load from `b` -> `boolean true`\n    evaluate 1st expression: `int 1` -> `int 1`;\n    store `int 1` to `x`\n<3> declare `List y`;\n    load from `x` -> `int 1`;\n    `int 1` greater than `int 1` -> `boolean false`;\n    evaluate 2nd expression: `null` -> `null`;\n    store `null` to `y`;\n<4> declare `def z`;\n    load from `x` -> `int 1`;\n    `int 1` less than `int 2` -> `boolean true`;\n    evaluate 1st expression: load from `x` -> `int 1`;\n    promote `int 1` and `double 2.0`: result `double`;\n    implicit cast `int 1` to `double 1.0` -> `double 1.0`;\n    implicit cast `double 1.0` to `def` -> `def`;\n    store `def` to `z`;\n\n[[assignment-operator]]\n==== Assignment\n\nUse the `assignment operator '='` to store a value in a variable or reference\ntype member field for use in subsequent operations. Any operation that produces\na value can be assigned to any variable/field as long as the\n<<painless-types, types>> are the same or the resultant type can be\n<<painless-casting, implicitly cast>> to the variable/field type.\n\nSee <<variable-assignment, variable assignment>> for examples using variables.\n\n*Errors*\n\n* If the type of value is unable to match the type of variable or field.\n\n*Grammar*\n\n[source,ANTLR4]\n----\nassignment: field '=' expression\n----\n\n*Examples*\n\nThe examples use the following reference type definition:\n\n[source,Painless]\n----\nname:\n  Example\n\nnon-static member fields:\n  * int x\n  * def y\n  * List z\n----\n\n* Field assignments of different type values.\n+\n[source,Painless]\n----\nExample example = new Example(); <1>\nexample.x = 1;                   <2>\nexample.y = 2.0;                 <3>\nexample.z = new ArrayList();     <4>\n----\n+\n<1> declare `Example example`;\n    allocate `Example` instance -> `Example reference`;\n    store `Example reference` to `example`\n<2> load from `example` -> `Example reference`;\n    store `int 1` to `x` of `Example reference`\n<3> load from `example` -> `Example reference`;\n    implicit cast `double 2.0` to `def` -> `def`;\n    store `def` to `y` of `Example reference`\n<4> load from `example` -> `Example reference`;\n    allocate `ArrayList` instance -> `ArrayList reference`;\n    implicit cast `ArrayList reference` to `List reference` -> `List reference`;\n    store `List reference` to `z` of `Example reference`\n+\n* A field assignment from a field access.\n+\n[source,Painless]\n----\nExample example = new Example(); <1>\nexample.x = 1;                   <2>\nexample.y = example.x;           <3>\n----\n+\n<1> declare `Example example`;\n    allocate `Example` instance -> `Example reference`;\n    store `Example reference` to `example`\n<2> load from `example` -> `Example reference`;\n    store `int 1` to `x` of `Example reference`\n<3> load from `example` -> `Example reference @0`;\n    load from `example` -> `Example reference @1`;\n    load from `x` of `Example reference @1` -> `int 1`;\n    implicit cast `int 1` to `def` -> `def`;\n    store `def` to `y` of `Example reference @0`;\n    (note `Example reference @0` and `Example reference @1` are the same)\n\n[[compound-assignment-operator]]\n==== Compound Assignment\n\nUse the `compound assignment operator '$='` as a shortcut for an assignment\nwhere a binary operation would occur between the variable/field as the\nleft-hand side expression and a separate right-hand side expression.\n\nA compound assignment is equivalent to the expression below where V is the\nvariable/field and T is the type of variable/member.\n\n[source,Painless]\n----\nV = (T)(V op expression);\n----\n\n*Operators*\n\nThe table below shows the available operators for use in a compound assignment.\nEach operator follows the casting/promotion rules according to their regular\ndefinition. For numeric operations there is an extra implicit cast when\nnecessary to return the promoted numeric type value to the original numeric type\nvalue of the variable/field and can result in data loss.\n\n|====\n|Operator|Compound Symbol\n|Multiplication|*=\n|Division|/=\n|Remainder|%=\n|Addition|+=\n|Subtraction|-=\n|Left Shift|+++<<=+++\n|Right Shift|>>=\n|Unsigned Right Shift|>>>=\n|Bitwise And|&=\n|Boolean And|&=\n|Bitwise Xor|^=\n|Boolean Xor|^=\n|Bitwise Or|\\|=\n|Boolean Or|\\|=\n|String Concatenation|+=\n|====\n\n*Errors*\n\n* If the type of value is unable to match the type of variable or field.\n\n*Grammar*\n\n[source,ANTLR4]\n----\ncompound_assignment: ( ID | field ) '$=' expression;\n----\n\nNote the use of the `$=` represents the use of any of the possible binary\noperators.\n\n*Examples*\n\n* Compound assignment for each numeric operator.\n+\n[source,Painless]\n----\nint i = 10; <1>\ni *= 2;     <2>\ni /= 5;     <3>\ni %= 3;     <4>\ni += 5;     <5>\ni -= 5;     <6>\ni <<= 2;    <7>\ni >>= 1;    <8>\ni >>>= 1;   <9>\ni &= 15;    <10>\ni ^= 12;    <11>\ni |= 2;     <12>\n----\n+\n<1> declare `int i`;\n    store `int 10` to `i`\n<2> load from `i` -> `int 10`;\n    multiply `int 10` and `int 2` -> `int 20`;\n    store `int 20` to `i`;\n    (note this is equivalent to `i = i*2`)\n<3> load from `i` -> `int 20`;\n    divide `int 20` by `int 5` -> `int 4`;\n    store `int 4` to `i`;\n    (note this is equivalent to `i = i/5`)\n<4> load from `i` -> `int 4`;\n    remainder `int 4` by `int 3` -> `int 1`;\n    store `int 1` to `i`;\n    (note this is equivalent to `i = i%3`)\n<5> load from `i` -> `int 1`;\n    add `int 1` and `int 5` -> `int 6`;\n    store `int 6` to `i`;\n    (note this is equivalent to `i = i+5`)\n<6> load from `i` -> `int 6`;\n    subtract `int 5` from `int 6` -> `int 1`;\n    store `int 1` to `i`;\n    (note this is equivalent to `i = i-5`)\n<7> load from `i` -> `int 1`;\n    left shift `int 1` by `int 2` -> `int 4`;\n    store `int 4` to `i`;\n    (note this is equivalent to `i = i<<2`)\n<8> load from `i` -> `int 4`;\n    right shift `int 4` by `int 1` -> `int 2`;\n    store `int 2` to `i`;\n    (note this is equivalent to `i = i>>1`)\n<9> load from `i` -> `int 2`;\n    unsigned right shift `int 2` by `int 1` -> `int 1`;\n    store `int 1` to `i`;\n    (note this is equivalent to `i = i>>>1`)\n<10> load from `i` -> `int 1`;\n     bitwise and `int 1` and `int 15` -> `int 1`;\n     store `int 1` to `i`;\n     (note this is equivalent to `i = i&2`)\n<11> load from `i` -> `int 1`;\n     bitwise xor `int 1` and `int 12` -> `int 13`;\n     store `int 13` to `i`;\n     (note this is equivalent to `i = i^2`)\n<12> load from `i` -> `int 13`;\n     bitwise or `int 13` and `int 2` -> `int 15`;\n     store `int 15` to `i`;\n     (note this is equivalent to `i = i|2`)\n+\n* Compound assignment for each boolean operator.\n+\n[source,Painless]\n----\nboolean b = true; <1>\nb &= false;       <2>\nb ^= false;       <3>\nb |= true;        <4>\n----\n+\n<1> declare `boolean b`;\n    store `boolean true` in `b`;\n<2> load from `b` -> `boolean true`;\n    boolean and `boolean true` and `boolean false` -> `boolean false`;\n    store `boolean false` to `b`;\n    (note this is equivalent to `b = b && false`)\n<3> load from `b` -> `boolean false`;\n    boolean xor `boolean false` and `boolean false` -> `boolean false`;\n    store `boolean false` to `b`;\n    (note this is equivalent to `b = b ^ false`)\n<4> load from `b` -> `boolean true`;\n    boolean or `boolean false` and `boolean true` -> `boolean true`;\n    store `boolean true` to `b`;\n    (note this is equivalent to `b = b || true`)\n+\n* A compound assignment with the string concatenation operator.\n+\n[source,Painless]\n----\nString s = 'compound'; <1>\ns += ' assignment';    <2>\n----\n<1> declare `String s`;\n    store `String 'compound'` to `s`;\n<2> load from `s` -> `String 'compound'`;\n    string concat `String 'compound'` and `String ' assignment''`\n            -> `String 'compound assignment'`;\n    store `String 'compound assignment'` to `s`;\n    (note this is equivalent to `s = s + ' assignment'`)\n+\n* A compound assignment with the `def` type.\n+\n[source,Painless]\n----\ndef x = 1; <1>\nx += 2;    <2>\n----\n<1> declare `def x`;\n    implicit cast `int 1` to `def`;\n    store `def` to `x`;\n<2> load from `x` -> `def`;\n    implicit cast `def` to `int 1` -> `int 1`;\n    add `int 1` and `int 2` -> `int 3`;\n    implicit cast `int 3` to `def` -> `def`;\n    store `def` to `x`;\n    (note this is equivalent to `x = x+2`)\n+\n* A compound assignment with an extra implicit cast.\n+\n[source,Painless]\n----\nbyte b = 1; <1>\nb += 2;     <2>\n----\n<1> declare `byte b`;\n    store `byte 1` to `x`;\n<2> load from `x` -> `byte 1`;\n    implicit cast `byte 1 to `int 1` -> `int 1`;\n    add `int 1` and `int 2` -> `int 3`;\n    implicit cast `int 3` to `byte 3` -> `byte 3`;\n    store `byte 3` to `b`;\n    (note this is equivalent to `b = b+2`)\n"
}