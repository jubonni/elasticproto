{
    "meta": {
        "timestamp": "2024-11-01T03:07:10.143278",
        "size": 12225,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-script-score-query.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "query-dsl-script-score-query",
        "version": "8.15"
    },
    "doc": "[[query-dsl-script-score-query]]\n=== Script score query\n++++\n<titleabbrev>Script score</titleabbrev>\n++++\n\nUses a <<modules-scripting,script>> to provide a custom score for returned\ndocuments.\n\nThe `script_score` query is useful if, for example, a scoring function is expensive and you only need to calculate the score of a filtered set of documents.\n\n\n[[script-score-query-ex-request]]\n==== Example request\nThe following `script_score` query assigns each returned document a score equal to the `my-int` field value divided by `10`.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"script_score\": {\n      \"query\": {\n        \"match\": { \"message\": \"elasticsearch\" }\n      },\n      \"script\": {\n        \"source\": \"doc['my-int'].value / 10 \"\n      }\n    }\n  }\n}\n--------------------------------------------------\n\n\n[[script-score-top-level-params]]\n==== Top-level parameters for `script_score`\n`query`::\n(Required, query object) Query used to return documents.\n\n`script`::\n+\n--\n(Required, <<modules-scripting-using,script object>>) Script used to compute the score of documents returned by the `query`.\n\nIMPORTANT: Final relevance scores from the `script_score` query cannot be\nnegative. To support certain search optimizations, Lucene requires\nscores be positive or `0`.\n--\n\n`min_score`::\n(Optional, float) Documents with a score lower\nthan this floating point number are excluded from the search results.\n\n`boost`::\n(Optional, float) Documents' scores produced by `script` are\nmultiplied by `boost` to produce final documents' scores. Defaults to `1.0`.\n\n[[script-score-query-notes]]\n==== Notes\n\n[[script-score-access-scores]]\n===== Use relevance scores in a script\n\nWithin a script, you can\n{ref}/modules-scripting-fields.html#scripting-score[access]\nthe `_score` variable which represents the current relevance score of a\ndocument.\n\n[[script-score-access-term-statistics]]\n===== Use term statistics in a script\n\nWithin a script, you can\n{ref}/modules-scripting-fields.html#scripting-term-statistics[access]\nthe `_termStats` variable which provides statistical information about the terms used in the child query of the `script_score` query.\n\n[[script-score-predefined-functions]]\n===== Predefined functions\nYou can use any of the available {painless}/painless-contexts.html[painless\nfunctions] in your `script`. You can also use the following predefined functions\nto customize scoring:\n\n* <<script-score-saturation>>\n* <<script-score-sigmoid>>\n* <<random-score-function>>\n* <<decay-functions-numeric-fields>>\n* <<decay-functions-geo-fields>>\n* <<decay-functions-date-fields>>\n* <<script-score-functions-vector-fields>>\n\nWe suggest using these predefined functions instead of writing your own.\nThese functions take advantage of efficiencies from {es}' internal mechanisms.\n\n[[script-score-saturation]]\n====== Saturation\n`saturation(value,k) = value/(k + value)`\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"saturation(doc['my-int'].value, 1)\"\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n[[script-score-sigmoid]]\n====== Sigmoid\n`sigmoid(value, k, a) = value^a/ (k^a + value^a)`\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"sigmoid(doc['my-int'].value, 2, 1)\"\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n[[random-score-function]]\n====== Random score function\n`random_score` function generates scores that are uniformly distributed\nfrom 0 up to but not including 1.\n\n`randomScore` function has the following syntax:\n`randomScore(<seed>, <fieldName>)`.\nIt has a required parameter - `seed` as an integer value,\nand an optional parameter - `fieldName` as a string value.\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"randomScore(100, '_seq_no')\"\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nIf the `fieldName` parameter is omitted, the internal Lucene\ndocument ids will be used as a source of randomness. This is very efficient,\nbut unfortunately not reproducible since documents might be renumbered\nby merges.\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"randomScore(100)\"\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nNote that documents that are within the same shard and have the\nsame value for field will get the same score, so it is usually desirable\nto use a field that has unique values for all documents across a shard.\nA good default choice might be to use the `_seq_no`\nfield, whose only drawback is that scores will change if the document is\nupdated since update operations also update the value of the `_seq_no` field.\n\n[[decay-functions-numeric-fields]]\n====== Decay functions for numeric fields\nYou can read more about decay functions\n{ref}/query-dsl-function-score-query.html#function-decay[here].\n\n* `double decayNumericLinear(double origin, double scale, double offset, double decay, double docValue)`\n* `double decayNumericExp(double origin, double scale, double offset, double decay, double docValue)`\n* `double decayNumericGauss(double origin, double scale, double offset, double decay, double docValue)`\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"decayNumericLinear(params.origin, params.scale, params.offset, params.decay, doc['dval'].value)\",\n    \"params\": { <1>\n        \"origin\": 20,\n        \"scale\": 10,\n        \"decay\" : 0.5,\n        \"offset\" : 0\n    }\n}\n--------------------------------------------------\n// NOTCONSOLE\n<1> Using `params` allows to compile the script only once, even if params change.\n\n[[decay-functions-geo-fields]]\n====== Decay functions for geo fields\n\n* `double decayGeoLinear(String originStr, String scaleStr, String offsetStr, double decay, GeoPoint docValue)`\n\n* `double decayGeoExp(String originStr, String scaleStr, String offsetStr, double decay, GeoPoint docValue)`\n\n* `double decayGeoGauss(String originStr, String scaleStr, String offsetStr, double decay, GeoPoint docValue)`\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"decayGeoExp(params.origin, params.scale, params.offset, params.decay, doc['location'].value)\",\n    \"params\": {\n        \"origin\": \"40, -70.12\",\n        \"scale\": \"200km\",\n        \"offset\": \"0km\",\n        \"decay\" : 0.2\n    }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n[[decay-functions-date-fields]]\n====== Decay functions for date fields\n\n* `double decayDateLinear(String originStr, String scaleStr, String offsetStr, double decay, JodaCompatibleZonedDateTime docValueDate)`\n\n* `double decayDateExp(String originStr, String scaleStr, String offsetStr, double decay, JodaCompatibleZonedDateTime docValueDate)`\n\n* `double decayDateGauss(String originStr, String scaleStr, String offsetStr, double decay, JodaCompatibleZonedDateTime docValueDate)`\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"decayDateGauss(params.origin, params.scale, params.offset, params.decay, doc['date'].value)\",\n    \"params\": {\n        \"origin\": \"2008-01-01T01:00:00Z\",\n        \"scale\": \"1h\",\n        \"offset\" : \"0\",\n        \"decay\" : 0.5\n    }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nNOTE: Decay functions on dates are limited to dates in the default format\nand default time zone. Also calculations with `now` are not supported.\n\n[[script-score-functions-vector-fields]]\n====== Functions for vector fields\n<<vector-functions, Functions for vector fields>> are accessible through\n`script_score` query.\n\n===== Allow expensive queries\nScript score queries will not be executed if <<query-dsl-allow-expensive-queries, `search.allow_expensive_queries`>>\nis set to false.\n\n[[script-score-faster-alt]]\n===== Faster alternatives\nThe `script_score` query calculates the score for\nevery matching document, or hit. There are faster alternative query types that\ncan efficiently skip non-competitive hits:\n\n* If you want to boost documents on some static fields, use the\n <<query-dsl-rank-feature-query, `rank_feature`>> query.\n * If you want to boost documents closer to a date or geographic point, use the\n <<query-dsl-distance-feature-query, `distance_feature`>> query.\n\n[[script-score-function-score-transition]]\n===== Transition from the function score query\nWe recommend using the `script_score` query instead of\n<<query-dsl-function-score-query, `function_score`>> query for the simplicity\nof the `script_score` query.\n\nYou can implement the following functions of the `function_score` query using\nthe `script_score` query:\n\n* <<script-score>>\n* <<weight>>\n* <<random-score>>\n* <<field-value-factor>>\n* <<decay-functions>>\n\n[[script-score]]\n====== `script_score`\nWhat you used in `script_score` of the Function Score query, you\ncan copy into the Script Score query. No changes here.\n\n[[weight]]\n====== `weight`\n`weight` function can be implemented in the Script Score query through\nthe following script:\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"params.weight * _score\",\n    \"params\": {\n        \"weight\": 2\n    }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n[[random-score]]\n====== `random_score`\n\nUse `randomScore` function\nas described in <<random-score-function, random score function>>.\n\n[[field-value-factor]]\n====== `field_value_factor`\n`field_value_factor` function can be easily implemented through script:\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"Math.log10(doc['field'].value * params.factor)\",\n    \"params\" : {\n        \"factor\" : 5\n    }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n\nFor checking if a document has a missing value, you can use\n`doc['field'].size() == 0`. For example, this script will use\na value `1` if a document doesn't have a field `field`:\n\n[source,js]\n--------------------------------------------------\n\"script\" : {\n    \"source\" : \"Math.log10((doc['field'].size() == 0 ? 1 : doc['field'].value()) * params.factor)\",\n    \"params\" : {\n        \"factor\" : 5\n    }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\nThis table lists how `field_value_factor` modifiers can be implemented\nthrough a script:\n\n[cols=\"<,<\",options=\"header\",]\n|=======================================================================\n| Modifier | Implementation in Script Score\n\n| `none` | -\n| `log` |  `Math.log10(doc['f'].value)`\n| `log1p` | `Math.log10(doc['f'].value + 1)`\n| `log2p` | `Math.log10(doc['f'].value + 2)`\n| `ln` | `Math.log(doc['f'].value)`\n| `ln1p` | `Math.log(doc['f'].value + 1)`\n| `ln2p` | `Math.log(doc['f'].value + 2)`\n| `square` | `Math.pow(doc['f'].value, 2)`\n| `sqrt` | `Math.sqrt(doc['f'].value)`\n| `reciprocal` | `1.0 / doc['f'].value`\n|=======================================================================\n\n[[decay-functions]]\n====== `decay` functions\nThe `script_score` query has equivalent <<decay-functions-numeric-fields, decay\nfunctions>> that can be used in scripts.\n\ninclude::{es-ref-dir}/vectors/vector-functions.asciidoc[]\n\n[[score-explanation]]\n===== Explain request\nUsing an <<search-explain, explain request>> provides an explanation of how the parts of a score were computed. The `script_score` query can add its own explanation by setting the `explanation` parameter:\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_explain/0\n{\n  \"query\": {\n    \"script_score\": {\n      \"query\": {\n        \"match\": { \"message\": \"elasticsearch\" }\n      },\n      \"script\": {\n        \"source\": \"\"\"\n          long count = doc['count'].value;\n          double normalizedCount = count / 10;\n          if (explanation != null) {\n            explanation.set('normalized count = count / 10 = ' + count + ' / 10 = ' + normalizedCount);\n          }\n          return normalizedCount;\n        \"\"\"\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nNote that the `explanation` will be null when using in a normal `_search` request, so having a conditional guard is best practice.\n"
}