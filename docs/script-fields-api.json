{
    "meta": {
        "timestamp": "2024-11-01T03:07:08.711280",
        "size": 5468,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/script-fields-api.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "script-fields-api",
        "version": "8.15"
    },
    "doc": "[[script-fields-api]]\n== Access fields in a document with the `field` API\n++++\n<titleabbrev>Access fields in a document</titleabbrev>\n++++\n\nbeta::[\"The `field` API is still in development and should be considered a beta feature. The API is subject to change and this iteration is likely not the final state. For feature status, refer to {es-issue}78920[#78920].\"]\n\nUse the `field` API to access document fields:\n\n[source,painless]\n----\nfield('my_field').get(<default_value>)\n----\n\nThis API fundamentally changes how you access documents in Painless. Previously,\nyou had to access the `doc` map with the field name that you wanted to access:\n\n[source,painless]\n----\ndoc['my_field'].value\n----\n\nAccessing document fields this way didn't handle missing values or missing\nmappings, which meant that to write robust Painless scripts, you needed to\ninclude logic to check that both fields and values exist.\n\nInstead, use the `field` API, which is the preferred approach to access\ndocuments in Painless. The `field` API handles missing values, and will evolve\nto abstract access to `_source` and `doc_values`.\n\nNOTE: Some fields aren't yet compatible with the `fields` API, such as `text` or\n`geo` fields. Continue using `doc` to access field types that the `field` API\ndoesn't support.\n\nThe `field` API returns a `Field` object that iterates over fields with \nmultiple values, providing access to the underlying value through the\n`get(<default_value>)` method, as well as type conversion and helper methods. \n\nThe `field` API returns the default value that you specify, regardless of\nwhether the field exists or has any values for the current document.\nThis means that the `field` API can handle missing values without requiring \nadditional logic. For a reference type such as `keyword`, the default \nvalue can be `null`. For a primitive type such as `boolean` or `long`, the\ndefault value must be a matching primitive type, such as `false` or `1`. \n\n[discrete]\n=== Convenient, simpler access\nInstead of explicitly calling the `field` API with the `get()` method, you can\ninclude the `$` shortcut. Just include the `$` symbol, field name, and a default\nvalue, in case the field doesn't have a value:\n\n[source,painless]\n----\n$(\u2018field\u2019, <default_value>)\n----\n\nWith these enhanced capabilities and simplified syntax, you can write scripts\nthat are shorter, less complex, and easier to read. For example, the following\nscript uses the outdated syntax to determine the difference in milliseconds\nbetween two complex `datetime` values from an indexed document:\n\n[source,painless]\n----\nif (doc.containsKey('start') && doc.containsKey('end')) {\n   if (doc['start'].size() > 0 && doc['end'].size() > 0) {\n       ZonedDateTime start = doc['start'].value;\n       ZonedDateTime end = doc['end'].value;\n       return ChronoUnit.MILLIS.between(start, end);\n   } else {\n       return -1;\n   }\n} else {\n   return -1;\n}\n----\n\nUsing the `field` API, you can write this same script much more succinctly,\nwithout requiring additional logic to determine whether fields exist before\noperating on them:\n\n[source,painless]\n----\nZonedDateTime start = field('start').get(null);\nZonedDateTime end = field('end').get(null);\nreturn start == null || end == null ? -1 : ChronoUnit.MILLIS.between(start, end)\n----\n\n[discrete]\n=== Supported mapped field types\nThe following table indicates the mapped field types that the `field` API\nsupports. For each supported type, values are listed that are returned by the\n`field` API (from the `get` and `as<Type>` methods) and the `doc` map (from the\n`getValue` and `get` methods). \n\nNOTE: The `fields` API currently doesn't support some fields, but you can still\naccess those fields through the `doc` map. For the most current list of\nsupported fields, refer to {es-issue}79105[#79105].\n\n[cols=\"1,1,1,1,1\",options=\"header\",]\n|========\n|Mapped field type\n2+|Returned type from `field`\n2+|Returned type from `doc`\nh|              h|`get`      h|`as<Type>`    h|`getValue` h|`get`\n |`binary`        |`ByteBuffer` |-             |`BytesRef`  |`BytesRef`\n |`boolean`       |`boolean`    |-             |`boolean`   |`Boolean`\n |`keyword`       |`String`     |-             |`String`    |`String`\n |`long`          |`long`       |-             |`long`      |`Long`\n |`integer`       |`int`        |-             |`long`      |`Long`\n |`short`         |`short`      |-             |`long`      |`Long`\n |`byte`          |`byte`       |-             |`long`      |`Long`\n |`double`        |`double`     |-             |`double`    |`Double`\n |`scaled_float`  |`double`     |-             |`double`    |`Double`\n |`half_float`    |`float`      |-             |`double`    |`Double`\n |`unsigned_long` |`long`       |`BigInteger`  |`long`      |`Long`\n |`date`          |`ZonedDateTime` |-          |`ZonedDateTime` |`ZonedDateTime`\n |`date_nanos`    |`ZonedDateTime` |-          |`ZonedDateTime` |`ZonedDateTime`\n |`ip`            |`IpAddress`     |`String`  |`String`    |`String`\n |`_version`      |`long`       |-             |`long`      |`Long`\n |`_seq_no`       |`long`       |-             |`long`      |`Long`\n |`version`       |`Version`    |`String`      |`String`    |`String`\n |`murmur3`       |`long`       |-             |`long`      |`Long`\n |`constant_keyword` |`String`  |-             |`String`    |`String`\n |`wildcard`      |`String`     |-             |`String`    |`String`\n |`flattened`     |`String`     |-             |`String`    |`String`\n|========"
}