{
    "meta": {
        "size": 3056,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/esql-inlinestats-by.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "esql-inlinestats-by",
        "version": "8.15"
    },
    "doc": "[discrete]\n[[esql-inlinestats-by]]\n=== `INLINESTATS ... BY`\n\nexperimental::[\"INLINESTATS is highly experimental and only available in SNAPSHOT versions.\"]\n\nThe `INLINESTATS` command calculates an aggregate result and adds new columns\nwith the result to the stream of input data.\n\n**Syntax**\n\n[source,esql]\n----\nINLINESTATS [column1 =] expression1[, ..., [columnN =] expressionN]\n[BY grouping_expression1[, ..., grouping_expressionN]]\n----\n\n*Parameters*\n\n`columnX`::\nThe name by which the aggregated value is returned. If omitted, the name is\nequal to the corresponding expression (`expressionX`). If multiple columns\nhave the same name, all but the rightmost column with this name will be ignored.\n\n`expressionX`::\nAn expression that computes an aggregated value. If its name coincides with one\nof the computed columns, that column will be ignored.\n\n`grouping_expressionX`::\nAn expression that outputs the values to group by.\n\nNOTE: Individual `null` values are skipped when computing aggregations.\n\n*Description*\n\nThe `INLINESTATS` command calculates an aggregate result and merges that result\nback into the stream of input data. Without the optional `BY` clause this will\nproduce a single result which is appended to each row. With a `BY` clause this\nwill produce one result per grouping and merge the result into the stream based on\nmatching group keys.\n\nAll of the <<esql-agg-functions,aggregation functions>> are supported.\n\n*Examples*\n\nFind the employees that speak the most languages (it's a tie!):\n\n[source.merge.styled,esql]\n----\ninclude::{esql-specs}/inlinestats.csv-spec[tag=max-languages]\n----\n[%header.monospaced.styled,format=dsv,separator=|]\n|===\ninclude::{esql-specs}/inlinestats.csv-spec[tag=max-languages-result]\n|===\n\nFind the longest tenured employee who's last name starts with each letter of the alphabet:\n\n[source.merge.styled,esql]\n----\ninclude::{esql-specs}/inlinestats.csv-spec[tag=longest-tenured-by-first]\n----\n[%header.monospaced.styled,format=dsv,separator=|]\n|===\ninclude::{esql-specs}/inlinestats.csv-spec[tag=longest-tenured-by-first-result]\n|===\n\nFind the northern and southern most airports:\n\n[source.merge.styled,esql]\n----\ninclude::{esql-specs}/inlinestats.csv-spec[tag=extreme-airports]\n----\n[%header.monospaced.styled,format=dsv,separator=|]\n|===\ninclude::{esql-specs}/inlinestats.csv-spec[tag=extreme-airports-result]\n|===\n\nNOTE: Our test data doesn't have many \"small\" airports.\n\nIf a `BY` field is multivalued then `INLINESTATS` will put the row in *each*\nbucket like <<esql-stats-by>>:\n\n[source.merge.styled,esql]\n----\ninclude::{esql-specs}/inlinestats.csv-spec[tag=mv-group]\n----\n[%header.monospaced.styled,format=dsv,separator=|]\n|===\ninclude::{esql-specs}/inlinestats.csv-spec[tag=mv-group-result]\n|===\n\nTo treat each group key as its own row use <<esql-mv_expand>> before `INLINESTATS`:\n\n[source.merge.styled,esql]\n----\ninclude::{esql-specs}/inlinestats.csv-spec[tag=mv-expand]\n----\n[%header.monospaced.styled,format=dsv,separator=|]\n|===\ninclude::{esql-specs}/inlinestats.csv-spec[tag=mv-expand-result]\n|===\n"
}