{
    "meta": {
        "size": 11135,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html",
        "type": "documentation",
        "role": [
            "child_attributes"
        ],
        "has_code": true,
        "title": "search-multi-search",
        "version": "8.15"
    },
    "doc": "[[search-multi-search]]\n=== Multi search API\n++++\n<titleabbrev>Multi search</titleabbrev>\n++++\n\nExecutes several searches with a single API request.\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_msearch\n{ }\n{\"query\" : {\"match\" : { \"message\": \"this is a test\"}}}\n{\"index\": \"my-index-000002\"}\n{\"query\" : {\"match_all\" : {}}}\n--------------------------------------------------\n// TEST[setup:my_index]\n\n[[search-multi-search-api-request]]\n==== {api-request-title}\n\n`GET /<target>/_msearch`\n\n[[search-multi-search-api-prereqs]]\n==== {api-prereq-title}\n\n* If the {es} {security-features} are enabled, you must have the `read`\n<<privileges-list-indices,index privilege>> for the target data stream, index,\nor alias. For cross-cluster search, see <<remote-clusters>>.\n\n[[search-multi-search-api-desc]]\n==== {api-description-title}\n\nThe multi search API executes several searches from a single API request.\nThe format of the request is similar to the bulk API format and makes use\nof the newline delimited JSON (NDJSON) format.\n\nThe structure is as follows:\n\n[source,js]\n--------------------------------------------------\nheader\\n\nbody\\n\nheader\\n\nbody\\n\n--------------------------------------------------\n// NOTCONSOLE\n\nThis structure is specifically optimized to reduce parsing if a specific search\nends up redirected to another node.\n\n[IMPORTANT]\n====\nThe final line of data must end with a newline character `\\n`. Each newline\ncharacter may be preceded by a carriage return `\\r`. When sending requests to\nthis endpoint the `Content-Type` header should be set to `application/x-ndjson`.\n====\n\n[[search-multi-search-api-path-params]]\n==== {api-path-parms-title}\n\n`<target>`::\n(Optional, string)\nComma-separated list of data streams, indices, and aliases to search.\n+\nThis list acts as a fallback if a search in the request body does not specify an\n`index` target.\n+\nWildcard (`*`) expressions are supported. To search all data streams and indices\nin a cluster, omit this parameter or use `_all` or `*`.\n\n[[search-multi-search-api-query-params]]\n==== {api-query-parms-title}\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=allow-no-indices]\n\n`ccs_minimize_roundtrips`::\n(Optional, Boolean)\nIf `true`, network roundtrips between the coordinating node and remote clusters\nare minimized for {ccs} requests. Defaults to `true`. See\n<<ccs-network-delays>>.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=expand-wildcards]\n+\nDefaults to `open`.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=ignore_throttled]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=index-ignore-unavailable]\n\n`max_concurrent_searches`::\n(Optional, integer)\nMaximum number of concurrent searches the multi search API can execute. Defaults\nto +max(1, (# of <<data-node,data nodes>> * min(<<search-threadpool,search thread pool size>>, 10)))+.\n\n`max_concurrent_shard_requests`::\n+\n--\n(Optional, integer)\nMaximum number of concurrent shard requests that each sub-search request\nexecutes per node. Defaults to `5`.\n\nYou can use this parameter to prevent a request from overloading a cluster. For\nexample, a default request hits all data streams and indices in a cluster. This\ncould cause shard request rejections if the number of shards per node is high.\n\nIn certain scenarios, parallelism isn't achieved through concurrent requests. In\nthose cases, a low value in this parameter could result in poor performance.\nFor example, in an environment where a very low number of concurrent search\nrequests are expected, a higher value in this parameter may improve performance.\n--\n\n`pre_filter_shard_size`::\n(Optional, integer)\nDefines a threshold that enforces a pre-filter roundtrip to prefilter search\nshards based on query rewriting if the number of shards the search request\nexpands to exceeds the threshold. This filter roundtrip can limit the number of\nshards significantly if for instance a shard can not match any documents based\non its rewrite method i.e., if date filters are mandatory to match but the\nshard bounds and the query are disjoint.\nWhen unspecified, the pre-filter phase is executed if any of these\nconditions is met:\n  - The request targets more than `128` shards.\n  - The request targets one or more read-only index.\n  - The primary sort of the query targets an indexed field.\n\n`rest_total_hits_as_int`::\n(Optional, Boolean)\nIf `true`, `hits.total` are returned as an integer in the\nresponse. Defaults to `false`, which returns an object.\n\n`routing`::\n(Optional, string)\nCustom <<mapping-routing-field,routing value>> used to route search operations\nto a specific shard.\n\n`search_type`::\n+\n--\n(Optional, string)\nIndicates whether global term and document frequencies should be used when\nscoring returned documents.\n\nOptions are:\n\n`query_then_fetch`::\n(default)\nDocuments are scored using local term and document frequencies for the shard.\nThis is usually faster but less accurate.\n\n`dfs_query_then_fetch`::\nDocuments are scored using global term and document frequencies across all\nshards. This is usually slower but more accurate.\n--\n\n`typed_keys`::\n(Optional, Boolean)\nSpecifies whether aggregation and suggester names should be prefixed by their\nrespective types in the response.\n\n[role=\"child_attributes\"]\n[[search-multi-search-api-request-body]]\n==== {api-request-body-title}\n\nThe request body contains a newline-delimited list of search `<header>` and\nsearch `<body>` objects.\n\n// tag::header-params[]\n`<header>`::\n(Required, object)\nParameters used to limit or change the search.\n+\nThis object is required for each search body but can be empty (`{}`) or a blank\nline.\n+\n.Properties of `<header>` objects\n[%collapsible%open]\n====\n`allow_no_indices`::\n(Optional, Boolean)\nIf `true`, the request does *not* return an error if a wildcard expression or\n`_all` value retrieves only missing or closed indices.\n+\nThis parameter also applies to <<aliases,aliases>> that point to a missing\nor index.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=expand-wildcards]\n+\nDefaults to `open`.\n\n`ignore_unavailable`::\n(Optional, Boolean) If `true`, documents from missing or closed indices are not\nincluded in the response. Defaults to `false`.\n\n`index`::\n(Optional, string or array of strings)\nData streams, indices, and aliases to search. Supports wildcards (`*`). Specify\nmultiple targets as an array.\n+\nIf this parameter is not specified, the `<target>` request path parameter\nis used as a fallback.\n\n`preference`::\n(Optional, string)\nNode or shard used to perform the search. Random by default.\n\n`request_cache`::\n(Optional, Boolean)\nIf `true`, the request cache can be used for this search. Defaults to\nindex-level settings. See <<shard-request-cache>>.\n\n`routing`::\n(Optional, string)\nCustom <<mapping-routing-field,routing value>> used to route search operations\nto a specific shard.\n\n`search_type`::\n+\n--\n(Optional, string)\nIndicates whether global term and document frequencies should be used when\nscoring returned documents.\n\nOptions are:\n\n`query_then_fetch`:::\n(default)\nDocuments are scored using local term and document frequencies for the shard.\nThis is usually faster but less accurate.\n\n`dfs_query_then_fetch`:::\nDocuments are scored using global term and document frequencies across all\nshards. This is usually slower but more accurate.\n--\n====\n// end::header-params[]\n\n`<body>`::\n(Optional, object)\nContains parameters for a search request:\n+\n.Properties of `<body>` objects\n[%collapsible%open]\n====\n`aggregations`::\n(Optional, <<search-aggregations,aggregation object>>)\nAggregations you wish to run during the search. See <<search-aggregations>>.\n\n`query`::\n(Optional, <<query-dsl,Query DSL object>>) Query you wish to run during the\nsearch. Hits matching this query are returned in the response.\n\n`from`::\n(Optional, integer)\nStarting offset for returned hits. Defaults to `0`.\n\n`size`::\n(Optional, integer)\nNumber of hits to return. Defaults to `10`.\n====\n\n[[search-multi-search-api-response-body]]\n==== {api-response-body-title}\n\n`responses`::\n  (array) Includes the search response and status code for each search request\n  matching its order in the original multi search request. If there was a\n  complete failure for a specific search request, an object with `error` message\n  and corresponding status code will be returned in place of the actual search\n  response.\n\n\n[[search-multi-search-api-example]]\n==== {api-examples-title}\n\nThe header includes the data streams, indices, and aliases to search. The header\nalso indicates the `search_type`, `preference`, and `routing`. The body includes\nthe typical search body request (including the `query`, `aggregations`, `from`,\n`size`, and so on).\n\n[source,js]\n--------------------------------------------------\n$ cat requests\n{\"index\" : \"test\"}\n{\"query\" : {\"match_all\" : {}}, \"from\" : 0, \"size\" : 10}\n{\"index\" : \"test\", \"search_type\" : \"dfs_query_then_fetch\"}\n{\"query\" : {\"match_all\" : {}}}\n{}\n{\"query\" : {\"match_all\" : {}}}\n\n{\"query\" : {\"match_all\" : {}}}\n{\"search_type\" : \"dfs_query_then_fetch\"}\n{\"query\" : {\"match_all\" : {}}}\n--------------------------------------------------\n// NOTCONSOLE\n\n[source,js]\n--------------------------------------------------\n$ curl -H \"Content-Type: application/x-ndjson\" -XGET localhost:9200/_msearch --data-binary \"@requests\"; echo\n--------------------------------------------------\n// NOTCONSOLE\n\nNote, the above includes an example of an empty header (can also be just\nwithout any content) which is supported as well.\n\n\nThe endpoint also allows you to search against data streams, indices, and\naliases in the request path. In this case, it will be used as the default target\nunless explicitly specified in the header's `index` parameter. For example:\n\n[source,console]\n--------------------------------------------------\nGET my-index-000001/_msearch\n{}\n{\"query\" : {\"match_all\" : {}}, \"from\" : 0, \"size\" : 10}\n{}\n{\"query\" : {\"match_all\" : {}}}\n{\"index\" : \"my-index-000002\"}\n{\"query\" : {\"match_all\" : {}}}\n--------------------------------------------------\n// TEST[setup:my_index]\n\nThe above will execute the search against the `my-index-000001` index for all the\nrequests that don't define an `index` target in the request body. The last\nsearch will be executed against the `my-index-000002` index.\n\nThe `search_type` can be set in a similar manner to globally apply to\nall search requests.\n\n\n[[msearch-security]]\n==== Security\n\nSee <<api-url-access-control>>\n\n\n[[multi-search-partial-responses]]\n==== Partial responses\n\nTo ensure fast responses, the multi search API will respond with partial results\nif one or more shards fail. See <<shard-failures, Shard failures>> for more\ninformation.\n\n\n[[msearch-cancellation]]\n==== Search Cancellation\n\nMulti searches can be cancelled using standard <<task-cancellation,task cancellation>>\nmechanism and are also automatically cancelled when the http connection used to\nperform the request is closed by the client. It is fundamental that the http\nclient sending requests closes connections whenever requests time out or are\naborted. Cancelling an msearch request will also cancel all of the corresponding\nsub search requests.\n"
}