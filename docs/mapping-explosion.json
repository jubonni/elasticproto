{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.590069",
        "size": 7421,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-explosion.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "mapping-explosion",
        "version": "8.15"
    },
    "doc": "[[mapping-explosion]]\n=== Mapping explosion\n\n{es}'s search and {kibana-ref}/discover.html[{kib}'s discover] Javascript rendering are\ndependent on the search's backing indices total amount of\n<<mapping-types,mapped fields>>, of all mapping depths. When this total\namount is too high or is exponentially climbing, we refer to it as\nexperiencing mapping explosion. Field counts going this high are uncommon\nand usually suggest an upstream document formatting issue as\nlink:https://www.elastic.co/blog/found-crash-elasticsearch#mapping-explosion[shown in this blog].\n\nMapping explosion may surface as the following performance symptoms:\n\n* <<cat-nodes,CAT nodes>> reporting high heap or CPU on the main node\nand/or nodes hosting the indices shards. This may potentially\nescalate to temporary node unresponsiveness and/or main overwhelm.\n\n* <<cat-tasks,CAT tasks>> reporting long search durations only related to\nthis index or indices, even on simple searches.\n\n* <<cat-tasks,CAT tasks>> reporting long index durations only related to\nthis index or indices. This usually relates to <<cluster-pending,pending tasks>>\nreporting that the coordinating node is waiting for all other nodes to\nconfirm they are on mapping update request.\n\n* Discover's **Fields for wildcard** page-loading API command or {kibana-ref}/console-kibana.html[Dev Tools] page-refreshing Autocomplete API commands are taking a long time (more than 10 seconds) or\ntiming out in the browser's Developer Tools Network tab. For more \ninformation, refer to our https://www.elastic.co/blog/troubleshooting-guide-common-issues-kibana-discover-load[walkthrough on troubleshooting Discover].\n\n* Discover's **Available fields** taking a long time to compile Javascript in the browser's Developer Tools Performance tab. This may potentially escalate to temporary browser page unresponsiveness.\n\n* Kibana's {kibana-ref}/alerting-getting-started.html[alerting] or {security-guide}/detection-engine-overview.html[security rules] may error `The content length (X) is bigger than the maximum allowed string (Y)` where `X` is attempted payload and `Y` is {kib}'s {kibana-ref}/settings.html#server-maxPayload[`server-maxPayload`].\n\n* Long {es} start-up durations.\n\n[discrete]\n[[prevent]]\n==== Prevent or prepare\n\n<<mapping,Mappings>> cannot be field-reduced once initialized.\n{es} indices default to <<dynamic-mapping,dynamic mappings>> which\ndoesn't normally cause problems unless it's combined with overriding\n<<mapping-settings-limit,`index.mapping.total_fields.limit`>>. The\ndefault `1000` limit is considered generous, though overriding to `10000`\ndoesn't cause noticeable impact depending on use case. However, to give\na bad example, overriding to `100000` and this limit being hit\nby mapping totals would usually have strong performance implications.\n\nIf your index mapped fields expect to contain a large, arbitrary set of\nkeys, you may instead consider:\n\n* Setting <<mapping-settings-limit,`index.mapping.total_fields.ignore_dynamic_beyond_limit`>> to `true`.\nInstead of rejecting documents that exceed the field limit, this will ignore dynamic fields once the limit is reached.\n\n* Using the <<flattened,flattened>> data type. Please note,\nhowever, that flattened objects is link:https://github.com/elastic/kibana/issues/25820[not fully supported in {kib}] yet. For example, this could apply to sub-mappings like { `host.name` ,\n`host.os`, `host.version` }. Desired fields are still accessed by\n<<runtime-search-request,runtime fields>>.\n\n* Disable <<dynamic-mapping,dynamic mappings>>.\nThis cannot effect current index mapping, but can apply going forward via an <<index-templates,index template>>.\n\nModifying to the <<nested,nested>> data type would not resolve the core\nissue.\n\n[discrete]\n[[check]]\n==== Check for issue\n\nTo confirm the field totals of an index to check for mapping explosion:\n\n* Check {es} cluster logs for errors `Limit of total fields [X] in index [Y] has been exceeded` where `X` is the value of  `index.mapping.total_fields.limit` and `Y` is your index. The correlated ingesting source log error would be `Limit of total fields [X] has been exceeded while adding new fields [Z]` where `Z` is attempted new fields.\n\n* For top-level fields, poll <<search-field-caps,field capabilities>> for `fields=*`.\n\n* Search the output of <<indices-get-mapping,get mapping>> for `\"type\"`.\n\n* If you're inclined to use the link:https://stedolan.github.io/jq[third-party tool JQ], you can process the <<indices-get-mapping,get mapping>> `mapping.json` output.\n+\n[source, sh]\n----\n$ cat mapping.json | jq -c 'to_entries[]| .key as $index| [.value.mappings| to_entries[]|select(.key==\"properties\") | {(.key):([.value|..|.type?|select(.!=null)]|length)}]| map(to_entries)| flatten| from_entries| ([to_entries[].value]|add)| {index: $index, field_count: .}'\n----\n\nYou can use <<indices-disk-usage,analyze index disk usage>> to find fields which are never or rarely populated as easy wins.\n\n[discrete]\n[[complex]]\n==== Complex explosions\n\nMapping explosions also covers when an individual index field totals are within limits but combined indices fields totals are very high. It's very common for symptoms to first be noticed on a {kibana-ref}/data-views.html[data view] and be traced back to an individual index or a subset of indices via the\n<<indices-resolve-index-api,resolve index API>>.\n\nHowever, though less common, it is possible to only experience mapping explosions on the combination of backing indices. For example, if a <<data-streams,data stream>>'s backing indices are all at field total limit but each contain unique fields from one another.\n\nThis situation most easily surfaces by adding a {kibana-ref}/data-views.html[data view] and checking its **Fields** tab for its total fields count. This statistic does tells you overall fields and not only where <<mapping-index,`index:true`>>, but serves as a good baseline.\n\nIf your issue only surfaces via a {kibana-ref}/data-views.html[data view], you may consider this menu's **Field filters** if you're not using <<mapping-types,multi-fields>>. Alternatively, you may consider a more targeted index pattern or using a negative pattern to filter-out problematic indices. For example, if `logs-*` has too high a field count because of problematic backing indices `logs-lotsOfFields-*`, then you could update to either `logs-*,-logs-lotsOfFields-*` or `logs-iMeantThisAnyway-*`.\n\n\n[discrete]\n[[resolve]]\n==== Resolve\n\nMapping explosion is not easily resolved, so it is better prevented via the above. Encountering it usually indicates unexpected upstream data changes or planning failures. If encountered, we recommend reviewing your data architecture. The following options are additional to the ones discussed earlier on this page; they should be applied as best use-case applicable:\n\n* Disable <<dynamic-mapping,dynamic mappings>>.\n\n* <<docs-reindex,Reindex>> into an index with a corrected mapping,\neither via <<index-templates,index template>> or <<explicit-mapping,explicitly set>>.\n\n* If index is unneeded and/or historical, consider <<indices-delete-index,deleting>>.\n\n* {logstash-ref}/plugins-inputs-elasticsearch.html[Export] and {logstash-ref}/plugins-outputs-elasticsearch.html[re-import] data into a mapping-corrected index after {logstash-ref}/plugins-filters-prune.html[pruning]\nproblematic fields via Logstash.\n\n<<indices-split-index,Splitting index>> would not resolve the core issue.\n"
}