{
    "meta": {
        "timestamp": "2024-11-01T03:07:10.515282",
        "size": 8030,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html",
        "type": "documentation",
        "role": [],
        "has_code": false,
        "title": "docs-update",
        "version": "8.15"
    },
    "doc": "[[docs-update]]\n=== Update API\n++++\n<titleabbrev>Update</titleabbrev>\n++++\n\nUpdates a document using the specified script.\n\n[[docs-update-api-request]]\n==== {api-request-title}\n\n`POST /<index>/_update/<_id>`\n\n[[docs-update-api-prereqs]]\n==== {api-prereq-title}\n\n* If the {es} {security-features} are enabled, you must have the `index` or\n`write` <<privileges-list-indices,index privilege>> for the target index or\nindex alias.\n\n[[update-api-desc]]\n==== {api-description-title}\n\nEnables you to script document updates. The script can update, delete, or skip\nmodifying the document. The update API also supports passing a partial document,\nwhich is merged into the existing document. To fully replace an existing\ndocument, use the <<docs-index_,`index` API>>.\n\nThis operation:\n\n. Gets the document (collocated with the shard) from the index.\n. Runs the specified script.\n. Indexes the result.\n\nThe document must still be reindexed, but using `update` removes some network\nroundtrips and reduces chances of version conflicts between the GET and the\nindex operation.\n\nThe `_source` field must be enabled to use `update`. In addition to `_source`,\nyou can access the following variables through the `ctx` map: `_index`,\n`_type`, `_id`, `_version`, `_routing`, and `_now` (the current timestamp).\n\n[[docs-update-api-path-params]]\n==== {api-path-parms-title}\n\n`<index>`::\n(Required, string) Name of the target index. By default, the index is created\nautomatically if it doesn't exist. For more information, see <<index-creation>>.\n\n`<_id>`::\n(Required, string) Unique identifier for the document to be updated.\n\n[[docs-update-api-query-params]]\n==== {api-query-parms-title}\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=if_seq_no]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=if_primary_term]\n\n`lang`::\n(Optional, string) The script language. Default: `painless`.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=require-alias]\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=refresh]\n\n`retry_on_conflict`::\n(Optional, integer) Specify how many times should the operation be retried when\n a conflict occurs. Default: 0.\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=routing]\n\n`_source`::\n(Optional, list) Set to `false` to disable source retrieval (default: `true`).\nYou can also specify a comma-separated list of the fields you want to retrieve.\n\n`_source_excludes`::\n(Optional, list) Specify the source fields you want to exclude.\n\n`_source_includes`::\n(Optional, list) Specify the source fields you want to retrieve.\n\n`timeout`::\n+\n--\n(Optional, <<time-units, time units>>)\nPeriod to wait for the following operations:\n\n* <<dynamic-mapping,Dynamic mapping>> updates\n* <<index-wait-for-active-shards,Waiting for active shards>>\n\nDefaults to `1m` (one minute). This guarantees {es} waits for at least the\ntimeout before failing. The actual wait time could be longer, particularly when\nmultiple waits occur.\n--\n\ninclude::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=wait_for_active_shards]\n\n[[update-api-example]]\n==== {api-examples-title}\n\nFirst, let's index a simple doc:\n\n[source,console]\n----\nPUT test/_doc/1\n{\n  \"counter\" : 1,\n  \"tags\" : [\"red\"]\n}\n----\n// TESTSETUP\n\nTo increment the counter, you can submit an update request with the\nfollowing script:\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"script\" : {\n    \"source\": \"ctx._source.counter += params.count\",\n    \"lang\": \"painless\",\n    \"params\" : {\n      \"count\" : 4\n    }\n  }\n}\n----\n\nSimilarly, you could use and update script to add a tag to the list of tags\n(this is just a list, so the tag is added even it exists):\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"script\": {\n    \"source\": \"ctx._source.tags.add(params.tag)\",\n    \"lang\": \"painless\",\n    \"params\": {\n      \"tag\": \"blue\"\n    }\n  }\n}\n----\n\nYou could also remove a tag from the list of tags. The Painless\nfunction to `remove` a tag takes the array index of the element\nyou want to remove. To avoid a possible runtime error, you first need to\nmake sure the tag exists. If the list contains duplicates of the tag, this\nscript just removes one occurrence.\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"script\": {\n    \"source\": \"if (ctx._source.tags.contains(params.tag)) { ctx._source.tags.remove(ctx._source.tags.indexOf(params.tag)) }\",\n    \"lang\": \"painless\",\n    \"params\": {\n      \"tag\": \"blue\"\n    }\n  }\n}\n----\n\nYou can also add and remove fields from a document. For example, this script\nadds the field `new_field`:\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"script\" : \"ctx._source.new_field = 'value_of_new_field'\"\n}\n----\n\nConversely, this script removes the field `new_field`:\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"script\" : \"ctx._source.remove('new_field')\"\n}\n----\n// TEST[continued]\n\nThe following script removes a subfield from an object field:\n\n////\n[source,console]\n----\nPUT test/_doc/1?refresh\n{\n  \"my-object\": {\n    \"my-subfield\": true\n  }\n}\n----\n////\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"script\": \"ctx._source['my-object'].remove('my-subfield')\"\n}\n----\n// TEST[continued]\n\nInstead of updating the document, you can also change the operation that is\nexecuted from within the script. For example, this request deletes the doc if\nthe `tags` field contains `green`, otherwise it does nothing (`noop`):\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"script\": {\n    \"source\": \"if (ctx._source.tags.contains(params.tag)) { ctx.op = 'delete' } else { ctx.op = 'noop' }\",\n    \"lang\": \"painless\",\n    \"params\": {\n      \"tag\": \"green\"\n    }\n  }\n}\n----\n\n[discrete]\n===== Update part of a document\n\nThe following partial update adds a new field to the\nexisting document:\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"doc\": {\n    \"name\": \"new_name\"\n  }\n}\n----\n\nIf both `doc` and `script` are specified, then `doc` is ignored. If you\nspecify a scripted update, include the fields you want to update in the script.\n\n[discrete]\n===== Detect noop updates\n\nBy default updates that don't change anything detect that they don't change\nanything and return `\"result\": \"noop\"`:\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"doc\": {\n    \"name\": \"new_name\"\n  }\n}\n----\n// TEST[continued]\n\nIf the value of `name` is already `new_name`, the update\nrequest is ignored and the `result` element in the response returns `noop`:\n\n[source,console-result]\n----\n{\n   \"_shards\": {\n        \"total\": 0,\n        \"successful\": 0,\n        \"failed\": 0\n   },\n   \"_index\": \"test\",\n   \"_id\": \"1\",\n   \"_version\": 2,\n   \"_primary_term\": 1,\n   \"_seq_no\": 1,\n   \"result\": \"noop\"\n}\n----\n\nYou can disable this behavior by setting `\"detect_noop\": false`:\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"doc\": {\n    \"name\": \"new_name\"\n  },\n  \"detect_noop\": false\n}\n----\n\n[[upserts]]\n[discrete]\n===== Upsert\n\nIf the document does not already exist, the contents of the `upsert` element\nare inserted as a new document. If the document exists, the\n`script` is executed:\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"script\": {\n    \"source\": \"ctx._source.counter += params.count\",\n    \"lang\": \"painless\",\n    \"params\": {\n      \"count\": 4\n    }\n  },\n  \"upsert\": {\n    \"counter\": 1\n  }\n}\n----\n\n[discrete]\n[[scripted_upsert]]\n===== Scripted upsert\n\nTo run the script whether or not the document exists, set `scripted_upsert` to\n`true`:\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"scripted_upsert\": true,\n  \"script\": {\n    \"source\": \"\"\"\n      if ( ctx.op == 'create' ) {\n        ctx._source.counter = params.count\n      } else {\n        ctx._source.counter += params.count\n      }\n    \"\"\",\n    \"params\": {\n      \"count\": 4\n    }\n  },\n  \"upsert\": {}\n}\n----\n\n[discrete]\n[[doc_as_upsert]]\n===== Doc as upsert\n\nInstead of sending a partial `doc` plus an `upsert` doc, you can set\n`doc_as_upsert` to `true` to use the contents of `doc` as the `upsert`\nvalue:\n\n[source,console]\n----\nPOST test/_update/1\n{\n  \"doc\": {\n    \"name\": \"new_name\"\n  },\n  \"doc_as_upsert\": true\n}\n----\n\n[NOTE]\n====\nUsing <<ingest,ingest pipelines>> with `doc_as_upsert` is not supported.\n====\n"
}