{
    "meta": {
        "timestamp": "2024-11-01T02:49:25.886069",
        "size": 11110,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/painless-walkthrough.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "painless-walkthrough",
        "version": "8.15"
    },
    "doc": "[[painless-walkthrough]]\n=== A Brief Painless Walkthrough\n\nTo illustrate how Painless works, let's load some hockey stats into an Elasticsearch index:\n\n[source,console]\n----------------------------------------------------------------\nPUT hockey/_bulk?refresh\n{\"index\":{\"_id\":1}}\n{\"first\":\"johnny\",\"last\":\"gaudreau\",\"goals\":[9,27,1],\"assists\":[17,46,0],\"gp\":[26,82,1],\"born\":\"1993/08/13\"}\n{\"index\":{\"_id\":2}}\n{\"first\":\"sean\",\"last\":\"monohan\",\"goals\":[7,54,26],\"assists\":[11,26,13],\"gp\":[26,82,82],\"born\":\"1994/10/12\"}\n{\"index\":{\"_id\":3}}\n{\"first\":\"jiri\",\"last\":\"hudler\",\"goals\":[5,34,36],\"assists\":[11,62,42],\"gp\":[24,80,79],\"born\":\"1984/01/04\"}\n{\"index\":{\"_id\":4}}\n{\"first\":\"micheal\",\"last\":\"frolik\",\"goals\":[4,6,15],\"assists\":[8,23,15],\"gp\":[26,82,82],\"born\":\"1988/02/17\"}\n{\"index\":{\"_id\":5}}\n{\"first\":\"sam\",\"last\":\"bennett\",\"goals\":[5,0,0],\"assists\":[8,1,0],\"gp\":[26,1,0],\"born\":\"1996/06/20\"}\n{\"index\":{\"_id\":6}}\n{\"first\":\"dennis\",\"last\":\"wideman\",\"goals\":[0,26,15],\"assists\":[11,30,24],\"gp\":[26,81,82],\"born\":\"1983/03/20\"}\n{\"index\":{\"_id\":7}}\n{\"first\":\"david\",\"last\":\"jones\",\"goals\":[7,19,5],\"assists\":[3,17,4],\"gp\":[26,45,34],\"born\":\"1984/08/10\"}\n{\"index\":{\"_id\":8}}\n{\"first\":\"tj\",\"last\":\"brodie\",\"goals\":[2,14,7],\"assists\":[8,42,30],\"gp\":[26,82,82],\"born\":\"1990/06/07\"}\n{\"index\":{\"_id\":39}}\n{\"first\":\"mark\",\"last\":\"giordano\",\"goals\":[6,30,15],\"assists\":[3,30,24],\"gp\":[26,60,63],\"born\":\"1983/10/03\"}\n{\"index\":{\"_id\":10}}\n{\"first\":\"mikael\",\"last\":\"backlund\",\"goals\":[3,15,13],\"assists\":[6,24,18],\"gp\":[26,82,82],\"born\":\"1989/03/17\"}\n{\"index\":{\"_id\":11}}\n{\"first\":\"joe\",\"last\":\"colborne\",\"goals\":[3,18,13],\"assists\":[6,20,24],\"gp\":[26,67,82],\"born\":\"1990/01/30\"}\n----------------------------------------------------------------\n// TESTSETUP\n\n[discrete]\n==== Accessing Doc Values from Painless\n\nDocument values can be accessed from a `Map` named `doc`.\n\nFor example, the following script calculates a player's total goals. This example uses a strongly typed `int` and a `for` loop.\n\n[source,console]\n----------------------------------------------------------------\nGET hockey/_search\n{\n  \"query\": {\n    \"function_score\": {\n      \"script_score\": {\n        \"script\": {\n          \"lang\": \"painless\",\n          \"source\": \"\"\"\n            int total = 0;\n            for (int i = 0; i < doc['goals'].length; ++i) {\n              total += doc['goals'][i];\n            }\n            return total;\n          \"\"\"\n        }\n      }\n    }\n  }\n}\n----------------------------------------------------------------\n\nAlternatively, you could do the same thing using a script field instead of a function score:\n\n[source,console]\n----------------------------------------------------------------\nGET hockey/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"script_fields\": {\n    \"total_goals\": {\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"\"\"\n          int total = 0;\n          for (int i = 0; i < doc['goals'].length; ++i) {\n            total += doc['goals'][i];\n          }\n          return total;\n        \"\"\"\n      }\n    }\n  }\n}\n----------------------------------------------------------------\n\nThe following example uses a Painless script to sort the players by their combined first and last names. The names are accessed using\n`doc['first'].value` and `doc['last'].value`.\n\n[source,console]\n----------------------------------------------------------------\nGET hockey/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": {\n    \"_script\": {\n      \"type\": \"string\",\n      \"order\": \"asc\",\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"doc['first.keyword'].value + ' ' + doc['last.keyword'].value\"\n      }\n    }\n  }\n}\n----------------------------------------------------------------\n\n[discrete]\n==== Missing keys\n\n`doc['myfield'].value` throws an exception if\nthe field is missing in a document.\n\nFor more dynamic index mappings, you may consider writing a catch equation\n\n```\nif (!doc.containsKey('myfield') || doc['myfield'].empty) { return \"unavailable\" } else { return doc['myfield'].value }\n```\n\n[discrete]\n==== Missing values\n\nTo check if a document is missing a value, you can call\n`doc['myfield'].size() == 0`.\n\n[discrete]\n==== Updating Fields with Painless\n\nYou can also easily update fields. You access the original source for a field as `ctx._source.<field-name>`.\n\nFirst, let's look at the source data for a player by submitting the following request:\n\n[source,console]\n----------------------------------------------------------------\nGET hockey/_search\n{\n  \"query\": {\n    \"term\": {\n      \"_id\": 1\n    }\n  }\n}\n----------------------------------------------------------------\n\nTo change player 1's last name to `hockey`, simply set `ctx._source.last` to the new value:\n\n[source,console]\n----------------------------------------------------------------\nPOST hockey/_update/1\n{\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"ctx._source.last = params.last\",\n    \"params\": {\n      \"last\": \"hockey\"\n    }\n  }\n}\n----------------------------------------------------------------\n\nYou can also add fields to a document. For example, this script adds a new field that contains\nthe player's nickname,  _hockey_.\n\n[source,console]\n----------------------------------------------------------------\nPOST hockey/_update/1\n{\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"\"\"\n      ctx._source.last = params.last;\n      ctx._source.nick = params.nick\n    \"\"\",\n    \"params\": {\n      \"last\": \"gaudreau\",\n      \"nick\": \"hockey\"\n    }\n  }\n}\n----------------------------------------------------------------\n\n[discrete]\n[[modules-scripting-painless-dates]]\n==== Dates\n\nDate fields are exposed as\n`ZonedDateTime`, so they support methods like `getYear`, `getDayOfWeek`\nor e.g. getting milliseconds since epoch with `getMillis`. To use these\nin a script, leave out the `get` prefix and continue with lowercasing the\nrest of the method name. For example, the following returns every hockey\nplayer's birth year:\n\n[source,console]\n----------------------------------------------------------------\nGET hockey/_search\n{\n  \"script_fields\": {\n    \"birth_year\": {\n      \"script\": {\n        \"source\": \"doc.born.value.year\"\n      }\n    }\n  }\n}\n----------------------------------------------------------------\n\n[discrete]\n[[modules-scripting-painless-regex]]\n==== Regular expressions\n\nNOTE: Regexes are enabled by default as the Setting `script.painless.regex.enabled` \nhas a new option, `limited`, the default. This defaults to using regular expressions \nbut limiting the complexity of the regular expressions. Innocuous looking regexes \ncan have staggering performance and stack depth behavior. But still, they remain an \namazingly powerful tool. In addition, to `limited`, the setting can be set to `true`, \nas before, which enables regular expressions without limiting them.To enable them \nyourself set `script.painless.regex.enabled: true` in `elasticsearch.yml`.\n\nPainless's native support for regular expressions has syntax constructs:\n\n* `/pattern/`: Pattern literals create patterns. This is the only way to create\na pattern in painless. The pattern inside the ++/++'s are just\nhttps://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html[Java regular expressions].\nSee <<pattern-flags>> for more.\n* `=~`: The find operator return a `boolean`, `true` if a subsequence of the\ntext matches, `false` otherwise.\n* `==~`: The match operator returns a `boolean`, `true` if the text matches,\n`false` if it doesn't.\n\nUsing the find operator (`=~`) you can update all hockey players with \"b\" in\ntheir last name:\n\n[source,console]\n----------------------------------------------------------------\nPOST hockey/_update_by_query\n{\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"\"\"\n      if (ctx._source.last =~ /b/) {\n        ctx._source.last += \"matched\";\n      } else {\n        ctx.op = \"noop\";\n      }\n    \"\"\"\n  }\n}\n----------------------------------------------------------------\n\nUsing the match operator (`==~`) you can update all the hockey players whose\nnames start with a consonant and end with a vowel:\n\n[source,console]\n----------------------------------------------------------------\nPOST hockey/_update_by_query\n{\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"\"\"\n      if (ctx._source.last ==~ /[^aeiou].*[aeiou]/) {\n        ctx._source.last += \"matched\";\n      } else {\n        ctx.op = \"noop\";\n      }\n    \"\"\"\n  }\n}\n----------------------------------------------------------------\n\nYou can use the `Pattern.matcher` directly to get a `Matcher` instance and\nremove all of the vowels in all of their last names:\n\n[source,console]\n----------------------------------------------------------------\nPOST hockey/_update_by_query\n{\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"ctx._source.last = /[aeiou]/.matcher(ctx._source.last).replaceAll('')\"\n  }\n}\n----------------------------------------------------------------\n\n`Matcher.replaceAll` is just a call to Java's `Matcher`'s\nhttps://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#replaceAll-java.lang.String-[replaceAll]\nmethod so it supports `$1` and `\\1` for replacements:\n\n[source,console]\n----------------------------------------------------------------\nPOST hockey/_update_by_query\n{\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"ctx._source.last = /n([aeiou])/.matcher(ctx._source.last).replaceAll('$1')\"\n  }\n}\n----------------------------------------------------------------\n\nIf you need more control over replacements you can call `replaceAll` on a\n`CharSequence` with a `Function<Matcher, String>` that builds the replacement.\nThis does not support `$1` or `\\1` to access replacements because you already\nhave a reference to the matcher and can get them with `m.group(1)`.\n\nIMPORTANT: Calling `Matcher.find` inside of the function that builds the\nreplacement is rude and will likely break the replacement process.\n\nThis will make all of the vowels in the hockey player's last names upper case:\n\n[source,console]\n----------------------------------------------------------------\nPOST hockey/_update_by_query\n{\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"\"\"\n      ctx._source.last = ctx._source.last.replaceAll(/[aeiou]/, m ->\n        m.group().toUpperCase(Locale.ROOT))\n    \"\"\"\n  }\n}\n----------------------------------------------------------------\n\nOr you can use the `CharSequence.replaceFirst` to make the first vowel in their\nlast names upper case:\n\n[source,console]\n----------------------------------------------------------------\nPOST hockey/_update_by_query\n{\n  \"script\": {\n    \"lang\": \"painless\",\n    \"source\": \"\"\"\n      ctx._source.last = ctx._source.last.replaceFirst(/[aeiou]/, m ->\n        m.group().toUpperCase(Locale.ROOT))\n    \"\"\"\n  }\n}\n----------------------------------------------------------------\n\nNote: all of the `_update_by_query` examples above could really do with a\n`query` to limit the data that they pull back. While you *could* use a\n{ref}/query-dsl-script-query.html[script query] it wouldn't be as efficient\nas using any other query because script queries aren't able to use the inverted\nindex to limit the documents that they have to check.\n"
}