{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.212591",
        "size": 9210,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-functions-conditional.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "sql-functions-conditional",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[sql-functions-conditional]]\n=== Conditional Functions And Expressions\n\nFunctions that return one of their arguments by evaluating in an if-else manner.\n\n[[sql-functions-conditional-case]]\n==== `CASE`\n\n.Synopsis:\n[source, sql]\n----\nCASE WHEN condition THEN result\n    [WHEN ...]\n    [ELSE default_result]\nEND\n----\n\n*Input*:\n\nOne or multiple _WHEN *condition* THEN *result_* clauses are used and the expression can optionally have\nan _ELSE *default_result_* clause. Every *condition* should be a boolean expression.\n\n*Output*: one of the *result* expressions if the corresponding _WHEN *condition_* evaluates to `true` or\nthe *default_result* if all _WHEN *condition_* clauses evaluate to `false`. If the optional _ELSE *default_result_*\nclause is missing and all _WHEN *condition_* clauses evaluate to `false` then `null` is returned.\n\n*Description*: The CASE expression is a generic conditional expression which simulates if/else statements of other programming languages\nIf the condition\u2019s result is true, the value of the result expression that follows the condition will be the returned\nthe subsequent when clauses will be skipped and not processed.\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[case]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[caseReturnNull]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[caseWithElse]\n----\n\n\nAs a variant, a case expression can be expressed with a syntax similar to *switch-case* of other programming languages:\n[source, sql]\n----\nCASE expression\n     WHEN value1 THEN result1\n    [WHEN value2 THEN result2]\n    [WHEN ...]\n    [ELSE default_result]\nEND\n----\n\nIn this case it's transformed internally to:\n[source, sql]\n----\nCASE WHEN expression = value1 THEN result1\n    [WHEN expression = value2 THEN result2]\n    [WHEN ...]\n    [ELSE default_result]\nEND\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[caseWithOperand]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[caseWithOperandAndElse]\n----\n\n[NOTE]\n===============================\nAll result expressions must be of compatible data types. More specifically all result\nexpressions should have a compatible data type with the 1st _non-null_ result expression.\nE.g.:\n\nfor the following query:\n\n[source, sql]\n----\nCASE WHEN a = 1 THEN null\n     WHEN a > 2 THEN 10\n     WHEN a > 5 THEN 'foo'\nEND\n----\n\nan error message would be returned, mentioning that *'foo'* is of data type *keyword*,\nwhich does not match the expected data type *integer* (based on result *10*).\n===============================\n\n[[sql-functions-conditional-case-groupby-custom-buckets]]\n===== Conditional bucketing\n\nCASE can be used as a GROUP BY key in a query to facilitate custom bucketing\nand assign descriptive names to those buckets. If, for example, the values\nfor a key are too many or, simply, ranges of those values are more\ninteresting than every single value, CASE can create custom buckets as in the\nfollowing example:\n\n[source, sql]\n----\nSELECT count(*) AS count,\n  CASE WHEN NVL(languages, 0) = 0 THEN 'zero'\n    WHEN languages = 1 THEN 'one'\n    WHEN languages = 2 THEN 'bilingual'\n    WHEN languages = 3 THEN 'trilingual'\n    ELSE 'multilingual'\n  END as lang_skills\nFROM employees\nGROUP BY lang_skills\nORDER BY lang_skills;\n----\nWith this query, one can create normal grouping buckets for values _0, 1, 2, 3_ with\ndescriptive names, and every value _>= 4_ falls into the _multilingual_ bucket.\n\n[[sql-functions-conditional-coalesce]]\n==== `COALESCE`\n\n.Synopsis:\n[source, sql]\n----\nCOALESCE(\n    expression, <1>\n    expression, <2>\n    ...)\n----\n\n*Input*:\n\n<1> 1st expression\n\n<2> 2nd expression\n\n...\n\n**N**th expression\n\nCOALESCE can take an arbitrary number of arguments.\n\n*Output*: one of the expressions or `null`\n\n*Description*: Returns the first of its arguments that is not null.\nIf all arguments are null, then it returns `null`.\n\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[coalesceReturnNonNull]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[coalesceReturnNull]\n----\n\n[[sql-functions-conditional-greatest]]\n==== `GREATEST`\n\n.Synopsis:\n[source, sql]\n----\nGREATEST(\n    expression, <1>\n    expression, <2>\n    ...)\n----\n\n*Input*:\n\n<1> 1st expression\n\n<2> 2nd expression\n\n...\n\n**N**th expression\n\nGREATEST can take an arbitrary number of arguments and\nall of them must be of the same data type.\n\n*Output*: one of the expressions or `null`\n\n*Description*: Returns the argument that has the largest value which is not null.\nIf all arguments are null, then it returns `null`.\n\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[greatestReturnNonNull]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[greatestReturnNull]\n----\n\n[[sql-functions-conditional-ifnull]]\n==== `IFNULL`\n\n.Synopsis:\n[source, sql]\n----\nIFNULL(\n    expression, <1>\n    expression) <2>\n----\n\n*Input*:\n\n<1> 1st expression\n\n<2> 2nd expression\n\n\n*Output*: 2nd expression if 1st expression is null, otherwise 1st expression.\n\n*Description*: Variant of <<sql-functions-conditional-coalesce>> with only two arguments.\nReturns the first of its arguments that is not null.\nIf all arguments are null, then it returns `null`.\n\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[ifNullReturnFirst]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[ifNullReturnSecond]\n----\n\n[[sql-functions-conditional-iif]]\n==== `IIF`\n\n.Synopsis:\n[source, sql]\n----\nIIF(\n    expression,   <1>\n    expression,   <2>\n    [expression]) <3>\n----\n\n*Input*:\n\n<1> boolean condition to check\n\n<2> return value if the boolean condition evaluates to `true`\n\n<3> return value if the boolean condition evaluates `false`; optional\n\n*Output*: 2nd expression if 1st expression (condition) evaluates to `true`. If it evaluates to `false`\nreturn 3rd expression. If 3rd expression is not provided return `null`.\n\n*Description*: Conditional function that implements the standard _IF <condition> THEN <result1> ELSE <result2>_\nlogic of programming languages. If the 3rd expression is not provided and the condition evaluates to `false`,\n`null` is returned.\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[iifWithDefaultValue]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[iifWithoutDefaultValue]\n----\n\n[TIP]\n=================\n*IIF* functions can be combined to implement more complex logic simulating the <<sql-functions-conditional-case>>\nexpression. E.g.:\n\n[source, sql]\n----\nIIF(a = 1, 'one', IIF(a = 2, 'two', IIF(a = 3, 'three', 'many')))\n----\n=================\n\n\n[[sql-functions-conditional-isnull]]\n==== `ISNULL`\n\n.Synopsis:\n[source, sql]\n----\nISNULL(\n    expression, <1>\n    expression) <2>\n----\n\n*Input*:\n\n<1> 1st expression\n\n<2> 2nd expression\n\n\n*Output*: 2nd expression if 1st expression is null, otherwise 1st expression.\n\n*Description*: Variant of <<sql-functions-conditional-coalesce>> with only two arguments.\nReturns the first of its arguments that is not null.\nIf all arguments are null, then it returns `null`.\n\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[isNullReturnFirst]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[isNullReturnSecond]\n----\n\n\n[[sql-functions-conditional-least]]\n==== `LEAST`\n\n.Synopsis:\n[source, sql]\n----\nLEAST(\n    expression, <1>\n    expression, <2>\n    ...)\n----\n\n*Input*:\n\n<1> 1st expression\n\n<2> 2nd expression\n\n...\n\n**N**th expression\n\nLEAST can take an arbitrary number of arguments and\nall of them must be of the same data type.\n\n*Output*: one of the expressions or `null`\n\n*Description*: Returns the argument that has the smallest value which is not null.\nIf all arguments are null, then it returns `null`.\n\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[leastReturnNonNull]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[leastReturnNull]\n----\n\n\n[[sql-functions-conditional-nullif]]\n==== `NULLIF`\n\n.Synopsis:\n[source, sql]\n----\nNULLIF(\n    expression, <1>\n    expression) <2>\n----\n\n*Input*:\n\n<1> 1st expression\n\n<2> 2nd expression\n\n\n*Output*: `null` if the 2 expressions are equal, otherwise the 1st expression.\n\n*Description*: Returns `null` when the two input expressions are equal and\nif not, it returns the 1st expression.\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[nullIfReturnFirst]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[nullIfReturnNull]\n----\n\n\n[[sql-functions-conditional-nvl]]\n==== `NVL`\n\n.Synopsis:\n[source, sql]\n----\nNVL(\n    expression, <1>\n    expression) <2>\n----\n\n*Input*:\n\n<1> 1st expression\n\n<2> 2nd expression\n\n\n*Output*: 2nd expression if 1st expression is null, otherwise 1st expression.\n\n*Description*: Variant of <<sql-functions-conditional-coalesce>> with only two arguments.\nReturns the first of its arguments that is not null.\nIf all arguments are null, then it returns `null`.\n\n\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[nvlReturnFirst]\n----\n\n[source, sql]\n----\ninclude-tagged::{sql-specs}/docs/docs.csv-spec[nvlReturnSecond]\n----\n\n\n"
}