{
    "meta": {
        "size": 17300,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "sort-search-results",
        "version": "8.15"
    },
    "doc": "[[sort-search-results]]\n=== Sort search results\n\nAllows you to add one or more sorts on specific fields. Each sort can be\nreversed as well. The sort is defined on a per field level, with special\nfield name for `_score` to sort by score, and `_doc` to sort by index order.\n\nAssuming the following index mapping:\n\n[source,console]\n--------------------------------------------------\nPUT /my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"post_date\": { \"type\": \"date\" },\n      \"user\": {\n        \"type\": \"keyword\"\n      },\n      \"name\": {\n        \"type\": \"keyword\"\n      },\n      \"age\": { \"type\": \"integer\" }\n    }\n  }\n}\n--------------------------------------------------\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"sort\" : [\n    { \"post_date\" : {\"order\" : \"asc\", \"format\": \"strict_date_optional_time_nanos\"}},\n    \"user\",\n    { \"name\" : \"desc\" },\n    { \"age\" : \"desc\" },\n    \"_score\"\n  ],\n  \"query\" : {\n    \"term\" : { \"user\" : \"kimchy\" }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nNOTE: `_doc` has no real use-case besides being the most efficient sort order.\nSo if you don't care about the order in which documents are returned, then you\nshould sort by `_doc`. This especially helps when <<scroll-search-results,scrolling>>.\n\n[discrete]\n==== Sort values\n\nThe search response includes `sort` values for each document. Use the `format`\nparameter to specify a <<built-in-date-formats,date format>> for the `sort`\nvalues of <<date,`date`>> and <<date_nanos,`date_nanos`>> fields. The following\nsearch returns `sort` values for the `post_date` field in the\n`strict_date_optional_time_nanos` format.\n\n[source,console]\n--------------------------------------------------\nGET /my-index-000001/_search\n{\n  \"sort\" : [\n    { \"post_date\" : {\"format\": \"strict_date_optional_time_nanos\"}}\n  ],\n  \"query\" : {\n    \"term\" : { \"user\" : \"kimchy\" }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\n[discrete]\n==== Sort order\n\nThe `order` option can have the following values:\n\n[horizontal]\n`asc`:: Sort in ascending order\n`desc`:: Sort in descending order\n\nThe order defaults to `desc` when sorting on the `_score`, and defaults\nto `asc` when sorting on anything else.\n\n[discrete]\n==== Sort mode option\n\nElasticsearch supports sorting by array or multi-valued fields. The `mode` option\ncontrols what array value is picked for sorting the document it belongs\nto. The `mode` option can have the following values:\n\n[horizontal]\n`min`:: Pick the lowest value.\n`max`:: Pick the highest value.\n`sum`:: Use the sum of all values as sort value. Only applicable for\n        number based array fields.\n`avg`:: Use the average of all values as sort value. Only applicable\n        for number based array fields.\n`median`:: Use the median of all values as sort value. Only applicable\n           for number based array fields.\n\nThe default sort mode in the ascending sort order is `min` -- the lowest value\nis picked. The default sort mode in the descending order is `max` --\nthe highest value is picked.\n\n[discrete]\n===== Sort mode example usage\n\nIn the example below the field price has multiple prices per document.\nIn this case the result hits will be sorted by price ascending based on\nthe average price per document.\n\n[source,console]\n--------------------------------------------------\nPUT /my-index-000001/_doc/1?refresh\n{\n   \"product\": \"chocolate\",\n   \"price\": [20, 4]\n}\n\nPOST /_search\n{\n   \"query\" : {\n      \"term\" : { \"product\" : \"chocolate\" }\n   },\n   \"sort\" : [\n      {\"price\" : {\"order\" : \"asc\", \"mode\" : \"avg\"}}\n   ]\n}\n--------------------------------------------------\n\n[discrete]\n==== Sorting numeric fields\n\nFor numeric fields it is also possible to cast the values from one type\nto another using the `numeric_type` option.\nThis option accepts the following values: [`\"double\", \"long\", \"date\", \"date_nanos\"`]\nand can be useful for searches across multiple data streams or indices where the sort field is mapped differently.\n\nConsider for instance these two indices:\n\n[source,console]\n--------------------------------------------------\nPUT /index_double\n{\n  \"mappings\": {\n    \"properties\": {\n      \"field\": { \"type\": \"double\" }\n    }\n  }\n}\n--------------------------------------------------\n\n[source,console]\n--------------------------------------------------\nPUT /index_long\n{\n  \"mappings\": {\n    \"properties\": {\n      \"field\": { \"type\": \"long\" }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nSince `field` is mapped as a `double` in the first index and as a `long`\nin the second index, it is not possible to use this field to sort requests\nthat query both indices by default. However you can force the type to one\nor the other with the `numeric_type` option in order to force a specific\ntype for all indices:\n\n[source,console]\n--------------------------------------------------\nPOST /index_long,index_double/_search\n{\n   \"sort\" : [\n      {\n        \"field\" : {\n            \"numeric_type\" : \"double\"\n        }\n      }\n   ]\n}\n--------------------------------------------------\n// TEST[continued]\n\nIn the example above, values for the `index_long` index are casted to\na double in order to be compatible with the values produced by the\n`index_double` index.\nIt is also possible to transform a floating point field into a `long`\nbut note that in this case floating points are replaced by the largest\nvalue that is less than or equal (greater than or equal if the value\nis negative) to the argument and is equal to a mathematical integer.\n\nThis option can also be used to convert a `date` field that uses millisecond\nresolution to a `date_nanos` field with nanosecond resolution.\nConsider for instance these two indices:\n\n[source,console]\n--------------------------------------------------\nPUT /index_double\n{\n  \"mappings\": {\n    \"properties\": {\n      \"field\": { \"type\": \"date\" }\n    }\n  }\n}\n--------------------------------------------------\n\n[source,console]\n--------------------------------------------------\nPUT /index_long\n{\n  \"mappings\": {\n    \"properties\": {\n      \"field\": { \"type\": \"date_nanos\" }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[continued]\n\nValues in these indices are stored with different resolutions so sorting on these\nfields will always sort the `date` before the `date_nanos` (ascending order).\nWith the `numeric_type` type option it is possible to set a single resolution for\nthe sort, setting to `date` will convert the `date_nanos` to the millisecond resolution\nwhile `date_nanos` will convert the values in the `date` field to the nanoseconds resolution:\n\n[source,console]\n--------------------------------------------------\nPOST /index_long,index_double/_search\n{\n   \"sort\" : [\n      {\n        \"field\" : {\n            \"numeric_type\" : \"date_nanos\"\n        }\n      }\n   ]\n}\n--------------------------------------------------\n// TEST[continued]\n\n[WARNING]\nTo avoid overflow, the conversion to `date_nanos` cannot be applied on dates before\n1970 and after 2262 as nanoseconds are represented as longs.\n\n[discrete]\n[[nested-sorting]]\n==== Sorting within nested objects.\n\nElasticsearch also supports sorting by\nfields that are inside one or more nested objects. The sorting by nested\nfield support has a `nested` sort option with the following properties:\n\n`path`::\n    Defines on which nested object to sort. The actual\n    sort field must be a direct field inside this nested object.\n    When sorting by nested field, this field is mandatory.\n\n`filter`::\n    A filter that the inner objects inside the nested path\n    should match with in order for its field values to be taken into account\n    by sorting. Common case is to repeat the query / filter inside the\n    nested filter or query. By default no `filter` is active.\n`max_children`::\n    The maximum number of children to consider per root document\n    when picking the sort value. Defaults to unlimited.\n`nested`::\n    Same as top-level `nested` but applies to another nested path within the\n    current nested object.\n\nNOTE: Elasticsearch will throw an error if a nested field is defined in a sort without\na `nested` context.\n\n[discrete]\n===== Nested sorting examples\n\nIn the below example `offer` is a field of type `nested`.\nThe nested `path` needs to be specified; otherwise, Elasticsearch doesn't know on what nested level sort values need to be captured.\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n   \"query\" : {\n      \"term\" : { \"product\" : \"chocolate\" }\n   },\n   \"sort\" : [\n       {\n          \"offer.price\" : {\n             \"mode\" :  \"avg\",\n             \"order\" : \"asc\",\n             \"nested\": {\n                \"path\": \"offer\",\n                \"filter\": {\n                   \"term\" : { \"offer.color\" : \"blue\" }\n                }\n             }\n          }\n       }\n    ]\n}\n--------------------------------------------------\n\nIn the below example `parent` and `child` fields are of type `nested`.\nThe `nested.path` needs to be specified at each level; otherwise, Elasticsearch doesn't know on what nested level sort values need to be captured.\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n   \"query\": {\n      \"nested\": {\n         \"path\": \"parent\",\n         \"query\": {\n            \"bool\": {\n                \"must\": {\"range\": {\"parent.age\": {\"gte\": 21}}},\n                \"filter\": {\n                    \"nested\": {\n                        \"path\": \"parent.child\",\n                        \"query\": {\"match\": {\"parent.child.name\": \"matt\"}}\n                    }\n                }\n            }\n         }\n      }\n   },\n   \"sort\" : [\n      {\n         \"parent.child.age\" : {\n            \"mode\" :  \"min\",\n            \"order\" : \"asc\",\n            \"nested\": {\n               \"path\": \"parent\",\n               \"filter\": {\n                  \"range\": {\"parent.age\": {\"gte\": 21}}\n               },\n               \"nested\": {\n                  \"path\": \"parent.child\",\n                  \"filter\": {\n                     \"match\": {\"parent.child.name\": \"matt\"}\n                  }\n               }\n            }\n         }\n      }\n   ]\n}\n--------------------------------------------------\n\nNested sorting is also supported when sorting by\nscripts and sorting by geo distance.\n\n[discrete]\n==== Missing values\n\nThe `missing` parameter specifies how docs which are missing\nthe sort field should be treated: The `missing` value can be\nset to `_last`, `_first`, or a custom value (that\nwill be used for missing docs as the sort value).\nThe default is `_last`.\n\nFor example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"sort\" : [\n    { \"price\" : {\"missing\" : \"_last\"} }\n  ],\n  \"query\" : {\n    \"term\" : { \"product\" : \"chocolate\" }\n  }\n}\n--------------------------------------------------\n\nNOTE: If a nested inner object doesn't match with\nthe `nested.filter` then a missing value is used.\n\n[discrete]\n==== Ignoring unmapped fields\n\nBy default, the search request will fail if there is no mapping\nassociated with a field. The `unmapped_type` option allows you to ignore\nfields that have no mapping and not sort by them. The value of this\nparameter is used to determine what sort values to emit. Here is an\nexample of how it can be used:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"sort\" : [\n    { \"price\" : {\"unmapped_type\" : \"long\"} }\n  ],\n  \"query\" : {\n    \"term\" : { \"product\" : \"chocolate\" }\n  }\n}\n--------------------------------------------------\n\nIf any of the indices that are queried doesn't have a mapping for `price`\nthen Elasticsearch will handle it as if there was a mapping of type\n`long`, with all documents in this index having no value for this field.\n\n[discrete]\n[[geo-sorting]]\n==== Geo distance sorting\n\nAllow to sort by `_geo_distance`. Here is an example, assuming `pin.location` is a field of type `geo_point`:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"sort\" : [\n    {\n      \"_geo_distance\" : {\n          \"pin.location\" : [-70, 40],\n          \"order\" : \"asc\",\n          \"unit\" : \"km\",\n          \"mode\" : \"min\",\n          \"distance_type\" : \"arc\",\n          \"ignore_unmapped\": true\n      }\n    }\n  ],\n  \"query\" : {\n    \"term\" : { \"user\" : \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\n\n\n`distance_type`::\n\n    How to compute the distance. Can either be `arc` (default), or `plane` (faster, but inaccurate on long distances and close to the poles).\n\n`mode`::\n\n    What to do in case a field has several geo points. By default, the shortest\n    distance is taken into account when sorting in ascending order and the\n    longest distance when sorting in descending order. Supported values are\n    `min`, `max`, `median` and `avg`.\n\n`unit`::\n\n    The unit to use when computing sort values. The default is `m` (meters).\n\n\n`ignore_unmapped`::\n\n    Indicates if the unmapped field should be treated as a missing value. Setting it to `true` is equivalent to specifying\n    an `unmapped_type` in the field sort. The default is `false` (unmapped field cause the search to fail).\n\nNOTE: geo distance sorting does not support configurable missing values: the\ndistance will always be considered equal to +Infinity+ when a document does not\nhave values for the field that is used for distance computation.\n\nThe following formats are supported in providing the coordinates:\n\n[discrete]\n===== Lat lon as properties\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"sort\" : [\n    {\n      \"_geo_distance\" : {\n        \"pin.location\" : {\n          \"lat\" : 40,\n          \"lon\" : -70\n        },\n        \"order\" : \"asc\",\n        \"unit\" : \"km\"\n      }\n    }\n  ],\n  \"query\" : {\n    \"term\" : { \"user\" : \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\n[discrete]\n===== Lat lon as WKT string\n\nFormat in https://docs.opengeospatial.org/is/12-063r5/12-063r5.html[Well-Known Text].\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"sort\": [\n    {\n      \"_geo_distance\": {\n        \"pin.location\": \"POINT (-70 40)\",\n        \"order\": \"asc\",\n        \"unit\": \"km\"\n      }\n    }\n  ],\n  \"query\": {\n    \"term\": { \"user\": \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\n[discrete]\n===== Geohash\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"sort\": [\n    {\n      \"_geo_distance\": {\n        \"pin.location\": \"drm3btev3e86\",\n        \"order\": \"asc\",\n        \"unit\": \"km\"\n      }\n    }\n  ],\n  \"query\": {\n    \"term\": { \"user\": \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\n[discrete]\n===== Lat lon as array\n\nFormat in `[lon, lat]`, note, the order of lon/lat here in order to\nconform with http://geojson.org/[GeoJSON].\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"sort\": [\n    {\n      \"_geo_distance\": {\n        \"pin.location\": [ -70, 40 ],\n        \"order\": \"asc\",\n        \"unit\": \"km\"\n      }\n    }\n  ],\n  \"query\": {\n    \"term\": { \"user\": \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\n[discrete]\n==== Multiple reference points\n\nMultiple geo points can be passed as an array containing any `geo_point` format, for example\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"sort\": [\n    {\n      \"_geo_distance\": {\n        \"pin.location\": [ [ -70, 40 ], [ -71, 42 ] ],\n        \"order\": \"asc\",\n        \"unit\": \"km\"\n      }\n    }\n  ],\n  \"query\": {\n    \"term\": { \"user\": \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\nand so forth.\n\nThe final distance for a document will then be `min`/`max`/`avg` (defined via `mode`) distance of all points contained in the document to all points given in the sort request.\n\n\n[discrete]\n[[script-based-sorting]]\n==== Script based sorting\n\nAllow to sort based on custom scripts, here is an example:\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"query\": {\n    \"term\": { \"user\": \"kimchy\" }\n  },\n  \"sort\": {\n    \"_script\": {\n      \"type\": \"number\",\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"doc['field_name'].value * params.factor\",\n        \"params\": {\n          \"factor\": 1.1\n        }\n      },\n      \"order\": \"asc\"\n    }\n  }\n}\n--------------------------------------------------\n\n[discrete]\n==== Track scores\n\nWhen sorting on a field, scores are not computed. By setting\n`track_scores` to true, scores will still be computed and tracked.\n\n[source,console]\n--------------------------------------------------\nGET /_search\n{\n  \"track_scores\": true,\n  \"sort\" : [\n    { \"post_date\" : {\"order\" : \"desc\"} },\n    { \"name\" : \"desc\" },\n    { \"age\" : \"desc\" }\n  ],\n  \"query\" : {\n    \"term\" : { \"user\" : \"kimchy\" }\n  }\n}\n--------------------------------------------------\n\n[discrete]\n==== Memory considerations\n\nWhen sorting, the relevant sorted field values are loaded into memory.\nThis means that per shard, there should be enough memory to contain\nthem. For string based types, the field sorted on should not be analyzed\n/ tokenized. For numeric types, if possible, it is recommended to\nexplicitly set the type to narrower types (like `short`, `integer` and\n`float`).\n"
}