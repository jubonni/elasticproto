{
    "meta": {
        "timestamp": "2024-11-01T03:02:52.991580",
        "size": 21196,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-movfn-aggregation.html",
        "type": "documentation",
        "role": [],
        "has_code": true,
        "title": "search-aggregations-pipeline-movfn-aggregation",
        "version": "8.15"
    },
    "doc": "[[search-aggregations-pipeline-movfn-aggregation]]\n=== Moving function aggregation\n++++\n<titleabbrev>Moving function</titleabbrev>\n++++\n\nGiven an ordered series of data, the Moving Function aggregation will slide a window across the data and allow the user to specify a custom\nscript that is executed on each window of data. For convenience, a number of common functions are predefined such as min/max, moving averages,\netc.\n\n==== Syntax\n\nA `moving_fn` aggregation looks like this in isolation:\n\n[source,js]\n--------------------------------------------------\n{\n  \"moving_fn\": {\n    \"buckets_path\": \"the_sum\",\n    \"window\": 10,\n    \"script\": \"MovingFunctions.min(values)\"\n  }\n}\n--------------------------------------------------\n// NOTCONSOLE\n\n[[moving-fn-params]]\n.`moving_fn` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description |Required |Default Value\n|`buckets_path` |Path to the metric of interest (see <<buckets-path-syntax, `buckets_path` Syntax>> for more details |Required |\n|`window` |The size of window to \"slide\" across the histogram. |Required |\n|`script` |The script that should be executed on each window of data |Required |\n|`gap_policy` |The policy to apply when gaps are found in the data. See <<gap-policy>>. |Optional |`skip`\n|`shift` |<<shift-parameter, Shift>> of window position. |Optional | 0\n|===\n\n`moving_fn` aggregations must be embedded inside of a `histogram` or `date_histogram` aggregation. They can be\nembedded like any other metric aggregation:\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {                  <1>\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }   <2>\n        },\n        \"the_movfn\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",  <3>\n            \"window\": 10,\n            \"script\": \"MovingFunctions.unweightedAvg(values)\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n<1> A `date_histogram` named \"my_date_histo\" is constructed on the \"timestamp\" field, with one-month intervals\n<2> A `sum` metric is used to calculate the sum of a field. This could be any numeric metric (sum, min, max, etc)\n<3> Finally, we specify a `moving_fn` aggregation which uses \"the_sum\" metric as its input.\n\nMoving averages are built by first specifying a `histogram` or `date_histogram` over a field. You can then optionally\nadd numeric metrics, such as a `sum`, inside of that histogram. Finally, the `moving_fn` is embedded inside the histogram.\nThe `buckets_path` parameter is then used to \"point\" at one of the sibling metrics inside of the histogram (see\n<<buckets-path-syntax>> for a description of the syntax for `buckets_path`.\n\nAn example response from the above aggregation may look like:\n\n[source,console-result]\n--------------------------------------------------\n{\n   \"took\": 11,\n   \"timed_out\": false,\n   \"_shards\": ...,\n   \"hits\": ...,\n   \"aggregations\": {\n      \"my_date_histo\": {\n         \"buckets\": [\n             {\n                 \"key_as_string\": \"2015/01/01 00:00:00\",\n                 \"key\": 1420070400000,\n                 \"doc_count\": 3,\n                 \"the_sum\": {\n                    \"value\": 550.0\n                 },\n                 \"the_movfn\": {\n                    \"value\": null\n                 }\n             },\n             {\n                 \"key_as_string\": \"2015/02/01 00:00:00\",\n                 \"key\": 1422748800000,\n                 \"doc_count\": 2,\n                 \"the_sum\": {\n                    \"value\": 60.0\n                 },\n                 \"the_movfn\": {\n                    \"value\": 550.0\n                 }\n             },\n             {\n                 \"key_as_string\": \"2015/03/01 00:00:00\",\n                 \"key\": 1425168000000,\n                 \"doc_count\": 2,\n                 \"the_sum\": {\n                    \"value\": 375.0\n                 },\n                 \"the_movfn\": {\n                    \"value\": 305.0\n                 }\n             }\n         ]\n      }\n   }\n}\n--------------------------------------------------\n// TESTRESPONSE[s/\"took\": 11/\"took\": $body.took/]\n// TESTRESPONSE[s/\"_shards\": \\.\\.\\./\"_shards\": $body._shards/]\n// TESTRESPONSE[s/\"hits\": \\.\\.\\./\"hits\": $body.hits/]\n\n\n==== Custom user scripting\n\nThe Moving Function aggregation allows the user to specify any arbitrary script to define custom logic. The script is invoked each time a\nnew window of data is collected. These values are provided to the script in the `values` variable. The script should then perform some\nkind of calculation and emit a single `double` as the result. Emitting `null` is not permitted, although `NaN` and +/- `Inf` are allowed.\n\nFor example, this script will simply return the first value from the window, or `NaN` if no values are available:\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_movavg\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"return values.length > 0 ? values[0] : Double.NaN\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n[[shift-parameter]]\n==== shift parameter\n\nBy default (with `shift = 0`), the window that is offered for calculation is the last `n` values excluding the current bucket.\nIncreasing `shift` by 1 moves starting window position by `1` to the right.\n\n- To include current bucket to the window, use `shift = 1`.\n- For center alignment (`n / 2` values before and after the current bucket), use `shift = window / 2`.\n- For right alignment (`n` values after the current bucket), use `shift = window`.\n\nIf either of window edges moves outside the borders of data series, the window shrinks to include available values only.\n\n==== Pre-built Functions\n\nFor convenience, a number of functions have been prebuilt and are available inside the `moving_fn` script context:\n\n- `max()`\n- `min()`\n- `sum()`\n- `stdDev()`\n- `unweightedAvg()`\n- `linearWeightedAvg()`\n- `ewma()`\n- `holt()`\n- `holtWinters()`\n\nThe functions are available from the `MovingFunctions` namespace. E.g. `MovingFunctions.max()`\n\n===== max Function\n\nThis function accepts a collection of doubles and returns the maximum value in that window. `null` and `NaN` values are ignored; the maximum\nis only calculated over the real values. If the window is empty, or all values are `null`/`NaN`, `NaN` is returned as the result.\n\n[[max-params]]\n.`max(double[] values)` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description\n|`values` |The window of values to find the maximum\n|===\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_moving_max\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"MovingFunctions.max(values)\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n===== min Function\n\nThis function accepts a collection of doubles and returns the minimum value in that window.  `null` and `NaN` values are ignored; the minimum\nis only calculated over the real values. If the window is empty, or all values are `null`/`NaN`, `NaN` is returned as the result.\n\n[[min-params]]\n.`min(double[] values)` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description\n|`values` |The window of values to find the minimum\n|===\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_moving_min\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"MovingFunctions.min(values)\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n===== sum Function\n\nThis function accepts a collection of doubles and returns the sum of the values in that window.  `null` and `NaN` values are ignored;\nthe sum is only calculated over the real values. If the window is empty, or all values are `null`/`NaN`, `0.0` is returned as the result.\n\n[[sum-params]]\n.`sum(double[] values)` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description\n|`values` |The window of values to find the sum of\n|===\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_moving_sum\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"MovingFunctions.sum(values)\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n===== stdDev Function\n\nThis function accepts a collection of doubles and average, then returns the standard deviation of the values in that window.\n`null` and `NaN` values are ignored; the sum is only calculated over the real values. If the window is empty, or all values are\n`null`/`NaN`, `0.0` is returned as the result.\n\n[[stddev-params]]\n.`stdDev(double[] values)` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description\n|`values` |The window of values to find the standard deviation of\n|`avg` |The average of the window\n|===\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_moving_sum\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"MovingFunctions.stdDev(values, MovingFunctions.unweightedAvg(values))\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nThe `avg` parameter must be provided to the standard deviation function because different styles of averages can be computed on the window\n(simple, linearly weighted, etc). The various moving averages that are detailed below can be used to calculate the average for the\nstandard deviation function.\n\n===== unweightedAvg Function\n\nThe `unweightedAvg` function calculates the sum of all values in the window, then divides by the size of the window. It is effectively\na simple arithmetic mean of the window. The simple moving average does not perform any time-dependent weighting, which means\nthe values from a `simple` moving average tend to \"lag\" behind the real data.\n\n`null` and `NaN` values are ignored; the average is only calculated over the real values. If the window is empty, or all values are\n`null`/`NaN`, `NaN` is returned as the result. This means that the count used in the average calculation is count of non-`null`,non-`NaN`\nvalues.\n\n[[unweightedavg-params]]\n.`unweightedAvg(double[] values)` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description\n|`values` |The window of values to find the sum of\n|===\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_movavg\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"MovingFunctions.unweightedAvg(values)\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n==== linearWeightedAvg Function\n\nThe `linearWeightedAvg` function assigns a linear weighting to points in the series, such that \"older\" datapoints (e.g. those at\nthe beginning of the window) contribute a linearly less amount to the total average. The linear weighting helps reduce\nthe \"lag\" behind the data's mean, since older points have less influence.\n\nIf the window is empty, or all values are `null`/`NaN`, `NaN` is returned as the result.\n\n[[linearweightedavg-params]]\n.`linearWeightedAvg(double[] values)` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description\n|`values` |The window of values to find the sum of\n|===\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_movavg\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"MovingFunctions.linearWeightedAvg(values)\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n==== ewma Function\n\nThe `ewma` function (aka \"single-exponential\") is similar to the `linearMovAvg` function,\nexcept older data-points become exponentially less important,\nrather than linearly less important. The speed at which the importance decays can be controlled with an `alpha`\nsetting. Small values make the weight decay slowly, which provides greater smoothing and takes into account a larger\nportion of the window. Larger values make the weight decay quickly, which reduces the impact of older values on the\nmoving average. This tends to make the moving average track the data more closely but with less smoothing.\n\n`null` and `NaN` values are ignored; the average is only calculated over the real values. If the window is empty, or all values are\n`null`/`NaN`, `NaN` is returned as the result. This means that the count used in the average calculation is count of non-`null`,non-`NaN`\nvalues.\n\n[[ewma-params]]\n.`ewma(double[] values, double alpha)` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description\n|`values` |The window of values to find the sum of\n|`alpha` |Exponential decay\n|===\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_movavg\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"MovingFunctions.ewma(values, 0.3)\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n\n==== holt Function\n\nThe `holt` function (aka \"double exponential\") incorporates a second exponential term which\ntracks the data's trend. Single exponential does not perform well when the data has an underlying linear trend. The\ndouble exponential model calculates two values internally: a \"level\" and a \"trend\".\n\nThe level calculation is similar to `ewma`, and is an exponentially weighted view of the data. The difference is\nthat the previously smoothed value is used instead of the raw value, which allows it to stay close to the original series.\nThe trend calculation looks at the difference between the current and last value (e.g. the slope, or trend, of the\nsmoothed data). The trend value is also exponentially weighted.\n\nValues are produced by multiplying the level and trend components.\n\n`null` and `NaN` values are ignored; the average is only calculated over the real values. If the window is empty, or all values are\n`null`/`NaN`, `NaN` is returned as the result. This means that the count used in the average calculation is count of non-`null`,non-`NaN`\nvalues.\n\n[[holt-params]]\n.`holt(double[] values, double alpha)` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description\n|`values` |The window of values to find the sum of\n|`alpha` |Level decay value\n|`beta` |Trend decay value\n|===\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_movavg\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"MovingFunctions.holt(values, 0.3, 0.1)\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\nIn practice, the `alpha` value behaves very similarly in `holtMovAvg` as `ewmaMovAvg`: small values produce more smoothing\nand more lag, while larger values produce closer tracking and less lag. The value of `beta` is often difficult\nto see. Small values emphasize long-term trends (such as a constant linear trend in the whole series), while larger\nvalues emphasize short-term trends.\n\n==== holtWinters Function\n\nThe `holtWinters` function (aka \"triple exponential\") incorporates a third exponential term which\ntracks the seasonal aspect of your data. This aggregation therefore smooths based on three components: \"level\", \"trend\"\nand \"seasonality\".\n\nThe level and trend calculation is identical to `holt` The seasonal calculation looks at the difference between\nthe current point, and the point one period earlier.\n\nHolt-Winters requires a little more handholding than the other moving averages. You need to specify the \"periodicity\"\nof your data: e.g. if your data has cyclic trends every 7 days, you would set `period = 7`. Similarly if there was\na monthly trend, you would set it to `30`. There is currently no periodicity detection, although that is planned\nfor future enhancements.\n\n`null` and `NaN` values are ignored; the average is only calculated over the real values. If the window is empty, or all values are\n`null`/`NaN`, `NaN` is returned as the result. This means that the count used in the average calculation is count of non-`null`,non-`NaN`\nvalues.\n\n[[holtwinters-params]]\n.`holtWinters(double[] values, double alpha)` Parameters\n[options=\"header\"]\n|===\n|Parameter Name |Description\n|`values` |The window of values to find the sum of\n|`alpha` |Level decay value\n|`beta` |Trend decay value\n|`gamma` |Seasonality decay value\n|`period` |The periodicity of the data\n|`multiplicative` |True if you wish to use multiplicative holt-winters, false to use additive\n|===\n\n[source,console]\n--------------------------------------------------\nPOST /_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"my_date_histo\": {\n      \"date_histogram\": {\n        \"field\": \"date\",\n        \"calendar_interval\": \"1M\"\n      },\n      \"aggs\": {\n        \"the_sum\": {\n          \"sum\": { \"field\": \"price\" }\n        },\n        \"the_movavg\": {\n          \"moving_fn\": {\n            \"buckets_path\": \"the_sum\",\n            \"window\": 10,\n            \"script\": \"if (values.length > 5*2) {MovingFunctions.holtWinters(values, 0.3, 0.1, 0.1, 5, false)}\"\n          }\n        }\n      }\n    }\n  }\n}\n--------------------------------------------------\n// TEST[setup:sales]\n\n[WARNING]\n======\nMultiplicative Holt-Winters works by dividing each data point by the seasonal value. This is problematic if any of\nyour data is zero, or if there are gaps in the data (since this results in a divid-by-zero). To combat this, the\n`mult` Holt-Winters pads all values by a very small amount (1*10^-10^) so that all values are non-zero. This affects\nthe result, but only minimally. If your data is non-zero, or you prefer to see `NaN` when zero's are encountered,\nyou can disable this behavior with `pad: false`\n======\n\n===== \"Cold Start\"\n\nUnfortunately, due to the nature of Holt-Winters, it requires two periods of data to \"bootstrap\" the algorithm. This\nmeans that your `window` must always be *at least* twice the size of your period. An exception will be thrown if it\nisn't. It also means that Holt-Winters will not emit a value for the first `2 * period` buckets; the current algorithm\ndoes not backcast.\n\nYou'll notice in the above example we have an `if ()` statement checking the size of values. This is checking to make sure\nwe have two periods worth of data (`5 * 2`, where 5 is the period specified in the `holtWintersMovAvg` function) before calling\nthe holt-winters function.\n"
}