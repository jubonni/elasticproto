{
    "meta": {
        "timestamp": "2024-11-01T03:07:10.455288",
        "size": 9914,
        "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/transform-scale.html",
        "type": "documentation",
        "role": [
            "xpack"
        ],
        "has_code": false,
        "title": "transform-scale",
        "version": "8.15"
    },
    "doc": "[role=\"xpack\"]\n[[transform-scale]]\n= Working with {transforms} at scale\n++++\n<titleabbrev>{transforms-cap} at scale</titleabbrev>\n++++\n\n{transforms-cap} convert existing {es} indices into summarized indices, which \nprovide opportunities for new insights and analytics. The search and index \noperations performed by {transforms} use standard {es} features so similar \nconsiderations for working with {es} at scale are often applicable to \n{transforms}. If you experience performance issues, start by identifying the \nbottleneck areas (search, indexing, processing, or storage) then review the \nrelevant considerations in this guide to improve performance. It also helps to \nunderstand how {transforms} work as different considerations apply depending on \nwhether or not your transform is running in continuous mode or in batch.\n\nIn this guide, you'll learn how to:\n\n* Understand the impact of configuration options on the performance of \n  {transforms}.\n\n**Prerequisites:**\n\nThese guildelines assume you have a {transform} you want to tune, and you\u2019re \nalready familiar with: \n\n* <<transform-overview,How {transforms} work>>.\n* <<transform-setup,How to set up {transforms}>>.\n* <<transform-checkpoints,How {transform} checkpoints work in continuous mode>>.\n\nThe following considerations are not sequential \u2013 the numbers help to navigate \nbetween the list items; you can take action on one or more of them in any order. \nMost of the recommendations apply to both continuous and batch {transforms}. If \na list item only applies to one {transform} type, this exception is highlighted \nin the description.\n\nThe keywords in parenthesis at the end of each recommendation title indicates \nthe bottleneck area that may be improved by following the given recommendation.\n\n[discrete]\n[[measure-performance]]\n== Measure {transforms} performance\n\nIn order to optimize {transform} performance, start by identifying the areas \nwhere most work is being done. The **Stats** interface of the \n**{transforms-cap}** page in {kib} contains information that covers three main \nareas: indexing, searching, and processing time (alternatively, you can use the \n<<get-transform-stats, {transforms} stats API>>). If, for example, the results \nshow that the highest proportion of time is spent on search, then prioritize \nefforts on optimizing the search query of the {transform}. {transforms-cap} also \nhas https://esrally.readthedocs.io[Rally support] that makes it possible to run \nperformance checks on {transforms} configurations if it is required. If you \noptimized the crucial factors and you still experience performance issues, you \nmay also want to consider improving your hardware.\n\n\n[discrete]\n[[frequency]]\n== 1. Optimize `frequency` (index)\n\nIn a {ctransform}, the `frequency` configuration option sets the interval \nbetween checks for changes in the source indices. If changes are detected, then \nthe source data is searched and the changes are applied to the destination \nindex. Depending on your use case, you may wish to reduce the frequency at which \nchanges are applied. By setting `frequency` to a higher value (maximum is one \nhour), the workload can be spread over time at the cost of less up-to-date data.\n\n\n[discrete]\n[[increase-shards-dest-index]]\n== 2. Increase the number of shards of the destination index (index)\n\nDepending on the size of the destination index, you may consider increasing its \nshard count. {transforms-cap} use one shard by default when creating the \ndestination index. To override the index settings, create the destination index \nbefore starting the {transform}. For more information about how the number of \nshards affects scalability and resilience, refer to <<scalability>>\n\nTIP: Use the <<preview-transform>> to check the settings that the {transform} \nwould use to create the destination index. You can copy and adjust these in \norder to create the destination index prior to starting the {transform}.\n\n\n[discrete]\n[[search-queries]]\n== 3. Profile and optimize your search queries (search)\n\nIf you have defined a {transform} source index `query`, ensure it is as \nefficient as possible. Use the **Search Profiler** under **Dev Tools** in {kib} \nto get detailed timing information about the execution of individual components \nin the search request. Alternatively, you can use the <<search-profile>>. The \nresults give you insight into how search requests are executed at a low level so \nthat you can understand why certain requests are slow, and take steps to improve \nthem.\n\n{transforms-cap} execute standard {es} search requests. There are different ways \nto write {es} queries, and some of them are more efficient than others. Consult \n<<tune-for-search-speed>> to learn more about {es} performance tuning.\n\n\n[discrete]\n[[limit-source-query]]\n== 4. Limit the scope of the source query (search)\n\nImagine your {ctransform} is configured to group by `IP` and calculate the sum \nof `bytes_sent`. For each checkpoint, a {ctransform} detects changes in the \nsource data since the previous checkpoint, identifying the IPs for which new \ndata has been ingested. Then it performs a second search, filtered for this \ngroup of IPs, in order to calculate the total `bytes_sent`. If this second \nsearch matches many shards, then this could be resource intensive. Consider \nlimiting the scope that the source index pattern and query will match.\n\nTo limit which historical indices are accessed, exclude certain tiers (for\nexample `\"must_not\": { \"terms\": { \"_tier\": [ \"data_frozen\", \"data_cold\" ] } }`\nand/or use an absolute time value as a date range filter in your source query\n(for example, greater than 2024-01-01T00:00:00). If you use a relative time\nvalue (for example, gte now-30d/d) then ensure date rounding is applied to take\nadvantage of query caching and ensure that the relative time is much larger than\nthe largest of `frequency` or `time.sync.delay` or the date histogram bucket,\notherwise data may be missed. Do not use date filters which are less than a date\nvalue (for example, `lt`: less than  or `lte`: less than or equal to) as this\nconflicts with the logic applied at each checkpoint execution and data may be\nmissed.\n\nConsider using <<api-date-math-index-names,date math>> in your index names to \nreduce the number of indices to resolve in your queries. Add a date pattern \n- for example, `yyyy-MM-dd` - to your index names and use it to limit your query \nto a specific date. The example below queries indices only from yesterday and \ntoday: \n\n[source,js]\n----------------------------------\n  \"source\": {\n    \"index\": [\n        \"<mydata-{now/d-1d{yyyy-MM-dd}}*>\", \n        \"<mydata-{now/d{yyyy-MM-dd}}*>\"\n    ]\n  },\n----------------------------------\n// NOTCONSOLE\n\n\n[discrete]\n[[optimize-shading-strategy]]\n== 5. Optimize the sharding strategy for the source index (search)\n\nThere is no one-size-fits-all sharding strategy. A strategy that works in one \nenvironment may not scale in another. A good sharding strategy must account for \nyour infrastructure, use case, and performance expectations.\n\nToo few shards may mean that the benefits of distributing the workload cannot be \nrealised; however too many shards may impact your cluster health. To learn more \nabout sizing your shards, read this <<size-your-shards,guide>>.\n\n\n[discrete]\n[[tune-max-page-search-size]]\n== 6. Tune `max_page_search_size` (search)\n\nThe `max_page_search_size` {transform} configuration option defines the number \nof buckets that are returned for each search request. The default value is 500. \nIf you increase this value, you get better throughput at the cost of higher \nlatency and memory usage.\n\nThe ideal value of this parameter is highly dependent on your use case. If your \n{transform} executes memory-intensive aggregations \u2013 for example, cardinality or \npercentiles \u2013 then increasing `max_page_search_size` requires more available \nmemory. If memory limits are exceeded, a circuit breaker exception occurs.\n\n\n[discrete]\n[[indexed-fields-in-source]]\n== 7. Use indexed fields in your source indices (search)\n\nRuntime fields and scripted fields are not indexed fields; their values are only \nextracted or computed at search time. While these fields provide flexibility in \nhow you access your data, they increase performance costs at search time. If \n{transform} performance using runtime fields or scripted fields is a concern, \nyou may wish to consider using indexed fields instead. For performance reasons, \nwe do not recommend using a runtime field as the time field that synchronizes a \n{ctransform}. \n\n\n[discrete]\n[[index-sorting-group-by-ordering]]\n== 8. Use index sorting (search, process)\n\nIndex sorting enables you to store documents on disk in a specific order which\ncan improve query efficiency. The ideal sorting logic depends on your use case,\nbut the rule of thumb may be to sort the fields in descending order (high to low\ncardinality) starting with the time-based fields. Index sorting\ncan be defined only once at index creation. If you don't already have index\nsorting on the index that you want to use as a source, consider reindexing it to\na new, sorted index.\n\n\n[discrete]\n[[disable-source-dest]]\n== 9. Disable the `_source` field on the destination index (storage)\n\nThe <<mapping-source-field>> contains the original JSON document body that was \npassed at index time. The `_source` field itself is not indexed (and thus is not \nsearchable), but it is still stored in the index and incurs a storage overhead. \nConsider disabling `_source` to save storage space if you have a large \ndestination index. Disabling `_source` is only possible during index creation.\n\nNOTE: When the `_source` field is disabled, a number of features are not \nsupported. Consult <<disable-source-field>> to understand the consequences \nbefore disabling it.\n\n\n[discrete]\n== Further reading\n\n* <<tune-for-search-speed>>\n* <<tune-for-indexing-speed>>\n* <<size-your-shards>>\n* <<ilm-index-lifecycle>>\n"
}